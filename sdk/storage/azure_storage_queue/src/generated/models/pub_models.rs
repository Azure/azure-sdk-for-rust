// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    xml_helpers::{CorsCorsRule, Queue_itemsQueue},
    GeoReplicationStatusType,
};
use azure_core::{fmt::SafeDebug, time::OffsetDateTime};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Represents an access policy.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct AccessPolicy {
    /// The date-time the policy expires.
    #[serde(
        default,
        rename = "Expiry",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub expiry: Option<OffsetDateTime>,

    /// The permissions for acl the policy.
    #[serde(rename = "Permission", skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,

    /// The date-time the policy is active.
    #[serde(
        default,
        rename = "Start",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start: Option<OffsetDateTime>,
}

/// CORS is an HTTP feature that enables a web application running under one domain to access resources in another domain.
/// Web browsers implement a security restriction known as same-origin policy that prevents a web page from calling APIs in
/// a different domain; CORS provides a secure way to allow one domain (the origin domain) to call APIs in another domain
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct CorsRule {
    /// The allowed headers.
    #[serde(rename = "AllowedHeaders", skip_serializing_if = "Option::is_none")]
    pub allowed_headers: Option<String>,

    /// The allowed methods.
    #[serde(rename = "AllowedMethods", skip_serializing_if = "Option::is_none")]
    pub allowed_methods: Option<String>,

    /// The allowed origins.
    #[serde(rename = "AllowedOrigins", skip_serializing_if = "Option::is_none")]
    pub allowed_origins: Option<String>,

    /// The exposed headers.
    #[serde(rename = "ExposedHeaders", skip_serializing_if = "Option::is_none")]
    pub exposed_headers: Option<String>,

    /// The maximum age in seconds.
    #[serde(rename = "MaxAgeInSeconds", skip_serializing_if = "Option::is_none")]
    pub max_age_in_seconds: Option<i32>,
}

/// Geo-Replication information for the Secondary Storage Service
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct GeoReplication {
    /// A GMT date/time value, to the second. All primary writes preceding this value are guaranteed to be available for read
    /// operations at the secondary. Primary writes after this point in time may or may not be available for reads.
    #[serde(
        default,
        rename = "LastSyncTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub last_sync_time: Option<OffsetDateTime>,

    /// The status of the secondary location
    #[serde(rename = "Status", skip_serializing_if = "Option::is_none")]
    pub status: Option<GeoReplicationStatusType>,
}

/// List wrapper for PeekedMessageItem array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "QueueMessagesList")]
pub struct ListOfPeekedMessage {
    /// The list of peeked messages.
    #[serde(rename = "QueueMessage", skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PeekedMessage>>,
}

/// List wrapper for DequeuedMessageItem array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "QueueMessagesList")]
pub struct ListOfReceivedMessage {
    /// The list of dequeued messages.
    #[serde(rename = "QueueMessage", skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ReceivedMessage>>,
}

/// List wrapper for EnqueuedMessage array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "QueueMessagesList")]
pub struct ListOfSentMessage {
    /// The list of enqueued messages.
    #[serde(rename = "QueueMessage", skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<SentMessage>>,
}

/// Represents an array of signed identifiers
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[serde(rename = "SignedIdentifiers")]
pub struct ListOfSignedIdentifier {
    /// The list of signed identifiers.
    #[serde(rename = "SignedIdentifier", skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<SignedIdentifier>>,
}

/// The list queue segment response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "EnumerationResults")]
pub struct ListQueuesResponse {
    /// The marker of the queues.
    #[serde(rename = "Marker", skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,

    /// The max results of the queues.
    #[serde(rename = "MaxResults", skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i32>,

    /// The next marker of the queues.
    #[serde(rename = "NextMarker", skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,

    /// The prefix of the queues.
    #[serde(rename = "Prefix", skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,

    /// The queue segment.
    #[serde(
        default,
        deserialize_with = "Queue_itemsQueue::unwrap",
        rename = "Queues",
        serialize_with = "Queue_itemsQueue::wrap"
    )]
    pub queue_items: Vec<QueueItem>,

    /// The service endpoint.
    #[serde(rename = "@ServiceEndpoint", skip_serializing_if = "Option::is_none")]
    pub service_endpoint: Option<String>,
}

/// Azure Analytics Logging settings.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct Logging {
    /// Whether delete operation is logged.
    #[serde(rename = "Delete", skip_serializing_if = "Option::is_none")]
    pub delete: Option<bool>,

    /// Whether read operation is logged.
    #[serde(rename = "Read", skip_serializing_if = "Option::is_none")]
    pub read: Option<bool>,

    /// The retention policy of the logs.
    #[serde(rename = "RetentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicy>,

    /// The version of the logging properties.
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

    /// Whether write operation is logged.
    #[serde(rename = "Write", skip_serializing_if = "Option::is_none")]
    pub write: Option<bool>,
}

/// The metrics properties.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct Metrics {
    /// Whether it is enabled.
    #[serde(rename = "Enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    /// Whether to include API in the metrics.
    #[serde(rename = "IncludeAPIs", skip_serializing_if = "Option::is_none")]
    pub include_apis: Option<bool>,

    /// The retention policy of the metrics.
    #[serde(rename = "RetentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicy>,

    /// The version of the metrics properties.
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The object returned in the QueueMessageList array when calling Peek Messages on
/// a Queue
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct PeekedMessage {
    /// The number of times the message has been dequeued.
    #[serde(rename = "DequeueCount", skip_serializing_if = "Option::is_none")]
    pub dequeue_count: Option<i64>,

    /// The time that the Message will expire and be automatically deleted.
    #[serde(
        default,
        rename = "ExpirationTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub expiration_time: Option<OffsetDateTime>,

    /// The time the Message was inserted into the Queue.
    #[serde(
        default,
        rename = "InsertionTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub insertion_time: Option<OffsetDateTime>,

    /// The Id of the Message.
    #[serde(rename = "MessageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// The content of the Message.
    #[serde(rename = "MessageText", skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,
}

/// Contains results for `QueueClient::get_metadata()`
#[derive(SafeDebug)]
pub struct QueueClientGetMetadataResult;

/// Contains results for `QueueClient::set_access_policy()`
#[derive(SafeDebug)]
pub struct QueueClientSetAccessPolicyResult;

/// An Azure Storage Queue.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "Queue")]
pub struct QueueItem {
    /// The metadata of the container.
    #[serde(rename = "Metadata", skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,

    /// The name of the queue.
    #[serde(rename = "Name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// A Message object which can be stored in a Queue
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct QueueMessage {
    /// The content of the message
    #[serde(rename = "MessageText", skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,
}

/// The object returned in the QueueMessageList array when calling Get Messages on
/// a Queue.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ReceivedMessage {
    /// The number of times the message has been dequeued.
    #[serde(rename = "DequeueCount", skip_serializing_if = "Option::is_none")]
    pub dequeue_count: Option<i64>,

    /// The time that the Message will expire and be automatically deleted.
    #[serde(
        default,
        rename = "ExpirationTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub expiration_time: Option<OffsetDateTime>,

    /// The time the Message was inserted into the Queue.
    #[serde(
        default,
        rename = "InsertionTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub insertion_time: Option<OffsetDateTime>,

    /// The Id of the Message.
    #[serde(rename = "MessageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// The content of the message
    #[serde(rename = "MessageText", skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,

    /// This value is required to delete the Message. If deletion fails using this
    /// PopReceipt then the message has been dequeued by another client.
    #[serde(rename = "PopReceipt", skip_serializing_if = "Option::is_none")]
    pub pop_receipt: Option<String>,

    /// The time that the message will again become visible in the Queue.
    #[serde(
        default,
        rename = "TimeNextVisible",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub time_next_visible: Option<OffsetDateTime>,
}

/// The retention policy.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct RetentionPolicy {
    /// The number of days to retain the logs.
    #[serde(rename = "Days", skip_serializing_if = "Option::is_none")]
    pub days: Option<i32>,

    /// Whether to enable the retention policy.
    #[serde(rename = "Enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The object returned in the QueueMessageList array when calling Put Message on a
/// Queue
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct SentMessage {
    /// The time that the Message will expire and be automatically deleted.
    #[serde(
        default,
        rename = "ExpirationTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub expiration_time: Option<OffsetDateTime>,

    /// The time the Message was inserted into the Queue.
    #[serde(
        default,
        rename = "InsertionTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub insertion_time: Option<OffsetDateTime>,

    /// The Id of the Message.
    #[serde(rename = "MessageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// This value is required to delete the Message. If deletion fails using this
    /// PopReceipt then the message has been dequeued by another client.
    #[serde(rename = "PopReceipt", skip_serializing_if = "Option::is_none")]
    pub pop_receipt: Option<String>,

    /// The time that the message will again become visible in the Queue.
    #[serde(
        default,
        rename = "TimeNextVisible",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub time_next_visible: Option<OffsetDateTime>,
}

/// The signed identifier.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SignedIdentifier {
    /// The access policy for the signed identifier.
    #[serde(rename = "AccessPolicy", skip_serializing_if = "Option::is_none")]
    pub access_policy: Option<AccessPolicy>,

    /// The unique ID for the signed identifier.
    #[serde(rename = "Id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// The service properties.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct StorageServiceProperties {
    /// The CORS properties.
    #[serde(
        default,
        deserialize_with = "CorsCorsRule::unwrap",
        rename = "Cors",
        serialize_with = "CorsCorsRule::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub cors: Option<Vec<CorsRule>>,

    /// The hour metrics properties.
    #[serde(rename = "HourMetrics", skip_serializing_if = "Option::is_none")]
    pub hour_metrics: Option<Metrics>,

    /// The logging properties.
    #[serde(rename = "Logging", skip_serializing_if = "Option::is_none")]
    pub logging: Option<Logging>,

    /// The minute metrics properties.
    #[serde(rename = "MinuteMetrics", skip_serializing_if = "Option::is_none")]
    pub minute_metrics: Option<Metrics>,
}

/// Stats for the storage service.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct StorageServiceStats {
    /// The geo replication stats.
    #[serde(rename = "GeoReplication", skip_serializing_if = "Option::is_none")]
    pub geo_replication: Option<GeoReplication>,
}
