// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::GeoReplicationStatusType;
use azure_core::fmt::SafeDebug;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use time::OffsetDateTime;

/// An Access policy
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct AccessPolicy {
    /// the date-time the policy expires
    #[serde(
        default,
        rename = "Expiry",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub expiry: Option<OffsetDateTime>,

    /// the permissions for the acl policy
    #[serde(rename = "Permission", skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,

    /// the date-time the policy is active
    #[serde(
        default,
        rename = "Start",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub start: Option<OffsetDateTime>,
}

/// CORS is an HTTP feature that enables a web application running under one domain
/// to access resources in another domain. Web browsers implement a security
/// restriction known as same-origin policy that prevents a web page from calling
/// APIs in a different domain; CORS provides a secure way to allow one domain (the
/// origin domain) to call APIs in another domain
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct CorsRule {
    /// the request headers that the origin domain may specify on the CORS request.
    #[serde(rename = "AllowedHeaders", skip_serializing_if = "Option::is_none")]
    pub allowed_headers: Option<String>,

    /// The methods (HTTP request verbs) that the origin domain may use for a CORS
    /// request. (comma separated)
    #[serde(rename = "AllowedMethods", skip_serializing_if = "Option::is_none")]
    pub allowed_methods: Option<String>,

    /// The origin domains that are permitted to make a request against the storage
    /// service via CORS. The origin domain is the domain from which the request
    /// originates. Note that the origin must be an exact case-sensitive match with the
    /// origin that the user age sends to the service. You can also use the wildcard
    /// character '*' to allow all origin domains to make requests via CORS.
    #[serde(rename = "AllowedOrigins", skip_serializing_if = "Option::is_none")]
    pub allowed_origins: Option<String>,

    /// The response headers that may be sent in the response to the CORS request and
    /// exposed by the browser to the request issuer
    #[serde(rename = "ExposedHeaders", skip_serializing_if = "Option::is_none")]
    pub exposed_headers: Option<String>,

    /// The maximum amount time that a browser should cache the preflight OPTIONS
    /// request.
    #[serde(rename = "MaxAgeInSeconds", skip_serializing_if = "Option::is_none")]
    pub max_age_in_seconds: Option<i32>,
}

/// The object returned in the QueueMessageList array when calling Get Messages on
/// a Queue.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DequeuedMessageItem {
    /// The number of times the message has been dequeued.
    #[serde(rename = "DequeueCount", skip_serializing_if = "Option::is_none")]
    pub dequeue_count: Option<i64>,

    /// The time that the Message will expire and be automatically deleted.
    #[serde(
        default,
        rename = "ExpirationTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub expiration_time: Option<OffsetDateTime>,

    /// The time the Message was inserted into the Queue.
    #[serde(
        default,
        rename = "InsertionTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub insertion_time: Option<OffsetDateTime>,

    /// The Id of the Message.
    #[serde(rename = "MessageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// The content of the message
    #[serde(rename = "MessageText", skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,

    /// This value is required to delete the Message. If deletion fails using this
    /// PopReceipt then the message has been dequeued by another client.
    #[serde(rename = "PopReceipt", skip_serializing_if = "Option::is_none")]
    pub pop_receipt: Option<String>,

    /// The time that the message will again become visible in the Queue.
    #[serde(
        default,
        rename = "TimeNextVisible",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub time_next_visible: Option<OffsetDateTime>,
}

/// The object returned in the QueueMessageList array when calling Put Message on a
/// Queue
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct EnqueuedMessage {
    /// The time that the Message will expire and be automatically deleted.
    #[serde(
        default,
        rename = "ExpirationTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub expiration_time: Option<OffsetDateTime>,

    /// The time the Message was inserted into the Queue.
    #[serde(
        default,
        rename = "InsertionTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub insertion_time: Option<OffsetDateTime>,

    /// The Id of the Message.
    #[serde(rename = "MessageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// This value is required to delete the Message. If deletion fails using this
    /// PopReceipt then the message has been dequeued by another client.
    #[serde(rename = "PopReceipt", skip_serializing_if = "Option::is_none")]
    pub pop_receipt: Option<String>,

    /// The time that the message will again become visible in the Queue.
    #[serde(
        default,
        rename = "TimeNextVisible",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub time_next_visible: Option<OffsetDateTime>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct GeoReplication {
    /// A GMT date/time value, to the second. All primary writes preceding this value
    /// are guaranteed to be available for read operations at the secondary. Primary
    /// writes after this point in time may or may not be available for reads.
    #[serde(
        default,
        rename = "LastSyncTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub last_sync_time: Option<OffsetDateTime>,

    /// The status of the secondary location
    #[serde(rename = "Status", skip_serializing_if = "Option::is_none")]
    pub status: Option<GeoReplicationStatusType>,
}

/// List wrapper for DequeuedMessageItem array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "QueueMessagesList")]
pub struct ListOfDequeuedMessageItem {
    #[serde(
        default,
        rename = "QueueMessage",
        skip_serializing_if = "Option::is_none"
    )]
    pub value: Option<Vec<DequeuedMessageItem>>,
}

/// List wrapper for EnqueuedMessage array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "QueueMessagesList")]
pub struct ListOfEnqueuedMessage {
    #[serde(
        default,
        rename = "QueueMessage",
        skip_serializing_if = "Option::is_none"
    )]
    pub value: Option<Vec<EnqueuedMessage>>,
}

/// List wrapper for PeekedMessageItem array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "QueueMessagesList")]
pub struct ListOfPeekedMessageItem {
    #[serde(
        default,
        rename = "QueueMessage",
        skip_serializing_if = "Option::is_none"
    )]
    pub value: Option<Vec<PeekedMessageItem>>,
}

/// List wrapper for SignedIdentifier array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[serde(rename = "SignedIdentifiers")]
pub struct ListOfSignedIdentifier {
    #[serde(
        default,
        rename = "SignedIdentifier",
        skip_serializing_if = "Option::is_none"
    )]
    pub value: Option<Vec<SignedIdentifier>>,
}

/// The object returned when calling List Queues on a Queue Service.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "EnumerationResults")]
pub struct ListQueuesSegmentResponse {
    #[serde(rename = "Marker", skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,

    #[serde(rename = "MaxResults", skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i32>,

    #[serde(rename = "NextMarker", skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,

    #[serde(rename = "Prefix", skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,

    #[serde(default, rename = "QueueItems")]
    pub queue_items: Vec<QueueItem>,

    #[serde(rename = "ServiceEndpoint", skip_serializing_if = "Option::is_none")]
    pub service_endpoint: Option<String>,
}

/// Azure Analytics Logging settings.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct Logging {
    /// Indicates whether all delete requests should be logged.
    #[serde(rename = "Delete", skip_serializing_if = "Option::is_none")]
    pub delete: Option<bool>,

    /// Indicates whether all read requests should be logged.
    #[serde(rename = "Read", skip_serializing_if = "Option::is_none")]
    pub read: Option<bool>,

    /// the retention policy
    #[serde(rename = "RetentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicy>,

    /// The version of Storage Analytics to configure.
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

    /// Indicates whether all write requests should be logged.
    #[serde(rename = "Write", skip_serializing_if = "Option::is_none")]
    pub write: Option<bool>,
}

/// a summary of request statistics grouped by API in hour or minute aggregates for
/// queues
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct Metrics {
    /// Indicates whether metrics are enabled for the Queue service.
    #[serde(rename = "Enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    /// Indicates whether metrics should generate summary statistics for called API
    /// operations.
    #[serde(rename = "IncludeAPIs", skip_serializing_if = "Option::is_none")]
    pub include_ap_is: Option<bool>,

    /// the retention policy
    #[serde(rename = "RetentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicy>,

    /// The version of Storage Analytics to configure.
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The object returned in the QueueMessageList array when calling Peek Messages on
/// a Queue
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct PeekedMessageItem {
    /// The number of times the message has been dequeued.
    #[serde(rename = "DequeueCount", skip_serializing_if = "Option::is_none")]
    pub dequeue_count: Option<i64>,

    /// The time that the Message will expire and be automatically deleted.
    #[serde(
        default,
        rename = "ExpirationTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub expiration_time: Option<OffsetDateTime>,

    /// The time the Message was inserted into the Queue.
    #[serde(
        default,
        rename = "InsertionTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::date::rfc7231::option"
    )]
    pub insertion_time: Option<OffsetDateTime>,

    /// The Id of the Message.
    #[serde(rename = "MessageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// The content of the Message.
    #[serde(rename = "MessageText", skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,
}

/// An Azure Storage Queue.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "Queue")]
pub struct QueueItem {
    /// Dictionary of <string>
    #[serde(rename = "Metadata", skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,

    /// The name of the Queue.
    #[serde(rename = "Name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// A Message object which can be stored in a Queue
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct QueueMessage {
    /// The content of the message
    #[serde(rename = "MessageText", skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,
}

/// the retention policy
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct RetentionPolicy {
    /// Indicates the number of days that metrics or logging or soft-deleted data
    /// should be retained. All data older than this value will be deleted
    #[serde(rename = "Days", skip_serializing_if = "Option::is_none")]
    pub days: Option<i32>,

    /// Indicates whether a retention policy is enabled for the storage service
    #[serde(rename = "Enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// signed identifier
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SignedIdentifier {
    /// The access policy
    #[serde(rename = "AccessPolicy", skip_serializing_if = "Option::is_none")]
    pub access_policy: Option<AccessPolicy>,

    /// a unique id
    #[serde(rename = "Id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// Storage Service Properties.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct StorageServiceProperties {
    /// The set of CORS rules.
    #[serde(default, rename = "Cors", skip_serializing_if = "Option::is_none")]
    pub cors: Option<Vec<CorsRule>>,

    /// A summary of request statistics grouped by API in hourly aggregates for queues
    #[serde(rename = "HourMetrics", skip_serializing_if = "Option::is_none")]
    pub hour_metrics: Option<Metrics>,

    /// Azure Analytics Logging settings
    #[serde(rename = "Logging", skip_serializing_if = "Option::is_none")]
    pub logging: Option<Logging>,

    /// a summary of request statistics grouped by API in minute aggregates for queues
    #[serde(rename = "MinuteMetrics", skip_serializing_if = "Option::is_none")]
    pub minute_metrics: Option<Metrics>,
}

/// Stats for the storage service.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct StorageServiceStats {
    /// Geo-Replication information for the Secondary Storage Service
    #[serde(rename = "GeoReplication", skip_serializing_if = "Option::is_none")]
    pub geo_replication: Option<GeoReplication>,
}
