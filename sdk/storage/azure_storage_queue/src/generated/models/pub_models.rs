// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::fmt::SafeDebug;
use serde::{Deserialize, Serialize, };
use super::xml_helpers::CorsCorsRuleResponse;
use time::OffsetDateTime;

/// CORS rule for request body
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct CorsRuleRequest {
/// the request headers that the origin domain may specify on the CORS request.
    #[serde(rename = "AllowedHeaders", skip_serializing_if = "Option::is_none")]
    pub allowed_headers: Option<String>,

/// The methods (HTTP request verbs) that the origin domain may use for a CORS
/// request. (comma separated)
    #[serde(rename = "AllowedMethods", skip_serializing_if = "Option::is_none")]
    pub allowed_methods: Option<String>,

/// The origin domains that are permitted to make a request against the storage
/// service via CORS. The origin domain is the domain from which the request
/// originates. Note that the origin must be an exact case-sensitive match with the
/// origin that the user age sends to the service. You can also use the wildcard
/// character '*' to allow all origin domains to make requests via CORS.
    #[serde(rename = "AllowedOrigins", skip_serializing_if = "Option::is_none")]
    pub allowed_origins: Option<String>,

/// The response headers that may be sent in the response to the CORS request and
/// exposed by the browser to the request issuer
    #[serde(rename = "ExposedHeaders", skip_serializing_if = "Option::is_none")]
    pub exposed_headers: Option<String>,

/// The maximum amount time that a browser should cache the preflight OPTIONS
/// request.
    #[serde(rename = "MaxAgeInSeconds", skip_serializing_if = "Option::is_none")]
    pub max_age_in_seconds: Option<i32>,

}

/// CORS rule for response body
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct CorsRuleResponse {
/// the request headers that the origin domain may specify on the CORS request.
    #[serde(rename = "AllowedHeaders", skip_serializing_if = "Option::is_none")]
    pub allowed_headers: Option<String>,

/// The methods (HTTP request verbs) that the origin domain may use for a CORS
/// request. (comma separated)
    #[serde(rename = "AllowedMethods", skip_serializing_if = "Option::is_none")]
    pub allowed_methods: Option<String>,

/// The origin domains that are permitted to make a request against the storage
/// service via CORS. The origin domain is the domain from which the request
/// originates. Note that the origin must be an exact case-sensitive match with the
/// origin that the user age sends to the service. You can also use the wildcard
/// character '*' to allow all origin domains to make requests via CORS.
    #[serde(rename = "AllowedOrigins", skip_serializing_if = "Option::is_none")]
    pub allowed_origins: Option<String>,

/// The response headers that may be sent in the response to the CORS request and
/// exposed by the browser to the request issuer
    #[serde(rename = "ExposedHeaders", skip_serializing_if = "Option::is_none")]
    pub exposed_headers: Option<String>,

/// The maximum amount time that a browser should cache the preflight OPTIONS
/// request.
    #[serde(rename = "MaxAgeInSeconds", skip_serializing_if = "Option::is_none")]
    pub max_age_in_seconds: Option<i32>,

}

/// The object returned in the QueueMessageList array when calling Get Messages on
/// a Queue.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DequeuedMessageItem {
/// The number of times the message has been dequeued.
    #[serde(rename = "DequeueCount", skip_serializing_if = "Option::is_none")]
    pub dequeue_count: Option<i64>,

/// The time that the Message will expire and be automatically deleted.
    #[serde(default, rename = "ExpirationTime", skip_serializing_if = "Option::is_none", with = "azure_core::date::rfc7231::option")]
    pub expiration_time: Option<OffsetDateTime>,

/// The time the Message was inserted into the Queue.
    #[serde(default, rename = "InsertionTime", skip_serializing_if = "Option::is_none", with = "azure_core::date::rfc7231::option")]
    pub insertion_time: Option<OffsetDateTime>,

/// The Id of the Message.
    #[serde(rename = "MessageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

/// The content of the message
    #[serde(rename = "MessageText", skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,

/// This value is required to delete the Message. If deletion fails using this
/// popreceipt then the message has been dequeued by another client.
    #[serde(rename = "PopReceipt", skip_serializing_if = "Option::is_none")]
    pub pop_receipt: Option<String>,

/// The time that the message will again become visible in the Queue.
    #[serde(default, rename = "TimeNextVisible", skip_serializing_if = "Option::is_none", with = "azure_core::date::rfc7231::option")]
    pub time_next_visible: Option<OffsetDateTime>,

}

/// The object returned in the QueueMessageList array when calling Put Message on a
/// Queue
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct EnqueuedMessage {
/// The time that the Message will expire and be automatically deleted.
    #[serde(default, rename = "ExpirationTime", skip_serializing_if = "Option::is_none", with = "azure_core::date::rfc7231::option")]
    pub expiration_time: Option<OffsetDateTime>,

/// The time the Message was inserted into the Queue.
    #[serde(default, rename = "InsertionTime", skip_serializing_if = "Option::is_none", with = "azure_core::date::rfc7231::option")]
    pub insertion_time: Option<OffsetDateTime>,

/// The Id of the Message.
    #[serde(rename = "MessageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

/// This value is required to delete the Message. If deletion fails using this
/// popreceipt then the message has been dequeued by another client.
    #[serde(rename = "PopReceipt", skip_serializing_if = "Option::is_none")]
    pub pop_receipt: Option<String>,

/// The time that the message will again become visible in the Queue.
    #[serde(default, rename = "TimeNextVisible", skip_serializing_if = "Option::is_none", with = "azure_core::date::rfc7231::option")]
    pub time_next_visible: Option<OffsetDateTime>,

}

/// List wrapper for DequeuedMessageItem array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "QueueMessagesList")]
pub struct ListOfDequeuedMessageItem {
    #[serde(rename = "QueueMessage", skip_serializing_if = "Option::is_none")]
    pub value: Option<Vec<DequeuedMessageItem>>,

}

/// List wrapper for EnqueuedMessage array
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "QueueMessagesList")]
pub struct ListOfEnqueuedMessage {
    #[serde(rename = "QueueMessage", skip_serializing_if = "Option::is_none")]
    pub value: Option<Vec<EnqueuedMessage>>,

}

/// Azure Analytics Logging settings for request.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct LoggingRequest {
/// Indicates whether all delete requests should be logged.
    #[serde(rename = "Delete", skip_serializing_if = "Option::is_none")]
    pub delete: Option<bool>,

/// Indicates whether all read requests should be logged.
    #[serde(rename = "Read", skip_serializing_if = "Option::is_none")]
    pub read: Option<bool>,

/// the retention policy
    #[serde(rename = "RetentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicyRequest>,

/// The version of Storage Analytics to configure.
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

/// Indicates whether all write requests should be logged.
    #[serde(rename = "Write", skip_serializing_if = "Option::is_none")]
    pub write: Option<bool>,

}

/// Azure Analytics Logging settings for response.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct LoggingResponse {
/// Indicates whether all delete requests should be logged.
    #[serde(rename = "Delete", skip_serializing_if = "Option::is_none")]
    pub delete: Option<bool>,

/// Indicates whether all read requests should be logged.
    #[serde(rename = "Read", skip_serializing_if = "Option::is_none")]
    pub read: Option<bool>,

/// the retention policy
    #[serde(rename = "RetentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicyResponse>,

/// The version of Storage Analytics to configure.
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

/// Indicates whether all write requests should be logged.
    #[serde(rename = "Write", skip_serializing_if = "Option::is_none")]
    pub write: Option<bool>,

}

/// a summary of request statistics grouped by API in hour or minute aggregates for
/// queues (for request)
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MetricsRequest {
/// Indicates whether metrics are enabled for the Queue service.
    #[serde(rename = "Enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

/// Indicates whether metrics should generate summary statistics for called API
/// operations.
    #[serde(rename = "IncludeAPIs", skip_serializing_if = "Option::is_none")]
    pub include_ap_is: Option<bool>,

/// the retention policy
    #[serde(rename = "RetentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicyRequest>,

/// The version of Storage Analytics to configure.
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

}

/// a summary of request statistics grouped by API in hour or minute aggregates for
/// queues (for response)
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct MetricsResponse {
/// Indicates whether metrics are enabled for the Queue service.
    #[serde(rename = "Enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

/// Indicates whether metrics should generate summary statistics for called API
/// operations.
    #[serde(rename = "IncludeAPIs", skip_serializing_if = "Option::is_none")]
    pub include_ap_is: Option<bool>,

/// the retention policy
    #[serde(rename = "RetentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicyResponse>,

/// The version of Storage Analytics to configure.
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

}

/// A Message object which can be stored in a Queue
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct QueueMessage {
/// The content of the message
    #[serde(rename = "MessageText", skip_serializing_if = "Option::is_none")]
    pub message_text: Option<String>,

}

/// the retention policy for request
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct RetentionPolicyRequest {
/// Indicates the number of days that metrics or logging or soft-deleted data
/// should be retained. All data older than this value will be deleted
    #[serde(rename = "Days", skip_serializing_if = "Option::is_none")]
    pub days: Option<i32>,

/// Indicates whether a retention policy is enabled for the storage service
    #[serde(rename = "Enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

}

/// the retention policy for response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct RetentionPolicyResponse {
/// Indicates the number of days that metrics or logging or soft-deleted data
/// should be retained. All data older than this value will be deleted
    #[serde(rename = "Days", skip_serializing_if = "Option::is_none")]
    pub days: Option<i32>,

/// Indicates whether a retention policy is enabled for the storage service
    #[serde(rename = "Enabled", skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

}

/// Storage Service Properties for request body.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct StorageServicePropertiesRequest {
/// The set of CORS rules.
    #[serde(rename = "Cors", skip_serializing_if = "Option::is_none")]
    pub cors: Option<Vec<CorsRuleRequest>>,

/// A summary of request statistics grouped by API in hourly aggregates for queues
    #[serde(rename = "HourMetrics", skip_serializing_if = "Option::is_none")]
    pub hour_metrics: Option<MetricsRequest>,

/// Azure Analytics Logging settings
    #[serde(rename = "Logging", skip_serializing_if = "Option::is_none")]
    pub logging: Option<LoggingRequest>,

/// a summary of request statistics grouped by API in minute aggregates for queues
    #[serde(rename = "MinuteMetrics", skip_serializing_if = "Option::is_none")]
    pub minute_metrics: Option<MetricsRequest>,

}

/// Storage Service Properties for response body.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct StorageServicePropertiesResponse {
/// The set of CORS rules.
    #[serde(default, deserialize_with = "CorsCorsRuleResponse::unwrap", rename = "Cors", serialize_with = "CorsCorsRuleResponse::wrap", skip_serializing_if = "Option::is_none")]
    pub cors: Option<Vec<CorsRuleResponse>>,

/// A summary of request statistics grouped by API in hourly aggregates for queues
    #[serde(rename = "HourMetrics", skip_serializing_if = "Option::is_none")]
    pub hour_metrics: Option<MetricsResponse>,

/// Azure Analytics Logging settings
    #[serde(rename = "Logging", skip_serializing_if = "Option::is_none")]
    pub logging: Option<LoggingResponse>,

/// a summary of request statistics grouped by API in minute aggregates for queues
    #[serde(rename = "MinuteMetrics", skip_serializing_if = "Option::is_none")]
    pub minute_metrics: Option<MetricsResponse>,

}

