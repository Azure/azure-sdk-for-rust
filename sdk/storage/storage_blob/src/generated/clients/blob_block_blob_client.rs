// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::{
    ClientMethodOptions, Context, Method, Pipeline, Request, RequestContent, Response, Result, Url, base64,
};
use crate::models::{
    AccessTier, BlobImmutabilityPolicyMode, BlockListType, BlockLookupList, EncryptionAlgorithmType,
};
use std::collections::HashMap;
use time::OffsetDateTime;

pub struct BlobBlockBlobClient {
    pub(crate) container_name: String,
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
    pub(crate) version: String,
}

impl BlobBlockBlobClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob. In order to be
/// written as part of a blob, a block must have been successfully written to the server in a prior Put Block operation. You
/// can call Put Block List to update a blob by uploading only those blocks that have changed, then committing the new and
/// existing blocks together. You can do this by specifying whether to commit a block from the committed block list or from
/// the uncommitted block list, or to commit the most recently uploaded version of the block, whichever list it may belong
/// to.
    pub async fn commit_block_list(&self, version: String, container_name: String, blob: String, blocks: RequestContent<BlockLookupList>, options: Option<BlobBlockBlobClientCommitBlockListOptions<'_>>) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("comp", "blocklist");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut().append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", base64::encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm.to_string());
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header("x-ms-immutability-policy-mode", immutability_policy_mode.to_string());
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header("x-ms-immutability-policy-until-date", immutability_policy_expiry);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(metadata) = options.metadata {
for (k, v) in &metadata {
                request.insert_header(format!("x-ms-meta-{}", k), v);
            }
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version);
        request.set_body(blocks);
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block blob.
    pub async fn get_block_list(&self, version: String, container_name: String, blob: String, list_type: BlockListType, options: Option<BlobBlockBlobClientGetBlockListOptions<'_>>) -> Result<Response<BlockLookupList>> {
        let options = options.unwrap_or_default();
        let mut ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("comp", "blocklist");
        url.query_pairs_mut().append_pair("blocklisttype", &list_type.to_string());
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut().append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/xml");
        request.insert_header("content-type", "application/xml");
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// The Put Blob from URL operation creates a new Block Blob where the contents of the blob are read from a given URL. This
/// API is supported beginning with the 2020-04-08 version. Partial updates are not supported with Put Blob from URL; the
/// content of an existing blob is overwritten with the content of the new blob. To perform partial updates to a block blobâ€™s
/// contents using a source URL, use the Put Block from URL API in conjunction with Put Block List.
    pub async fn put_blob_from_url(&self, version: String, container_name: String, blob: String, content_length: i64, copy_source: String, options: Option<BlobBlockBlobClientPutBlobFromUrlOptions<'_>>) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        url.query_pairs_mut().append_key_only("BlockBlob").append_key_only("fromUrl");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut().append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", base64::encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        request.insert_header("x-ms-copy-source", copy_source);
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(copy_source_blob_properties) = options.copy_source_blob_properties {
            request.insert_header("x-ms-copy-source-blob-properties", copy_source_blob_properties.to_string());
        }
        if let Some(copy_source_tags) = options.copy_source_tags {
            request.insert_header("x-ms-copy-source-tags", copy_source_tags);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm.to_string());
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(metadata) = options.metadata {
for (k, v) in &metadata {
                request.insert_header(format!("x-ms-meta-{}", k), v);
            }
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", source_content_md5);
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header("x-ms-source-if-modified-since", source_if_modified_since);
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_tags) = options.source_if_tags {
            request.insert_header("x-ms-source-if-tags", source_if_tags);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header("x-ms-source-if-unmodified-since", source_if_unmodified_since);
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// The Stage Block operation creates a new block to be committed as part of a blob
    pub async fn stage_block(&self, version: String, container_name: String, blob: String, block_id: String, content_length: i64, body: RequestContent<Vec<u8>>, options: Option<BlobBlockBlobClientStageBlockOptions<'_>>) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("comp", "block");
        url.query_pairs_mut().append_pair("blockid", &block_id);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut().append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/octet-stream");
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm.to_string());
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(structured_body_type) = options.structured_body_type {
            request.insert_header("x-ms-structured-body", structured_body_type);
        }
        if let Some(structured_content_length) = options.structured_content_length {
            request.insert_header("x-ms-structured-content-length", structured_content_length.to_string());
        }
        request.insert_header("x-ms-version", version);
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// The Stage Block From URL operation creates a new block to be committed as part of a blob where the contents are read from
/// a URL.
    pub async fn stage_block_from_url(&self, version: String, container_name: String, blob: String, block_id: String, content_length: i64, source_url: String, options: Option<BlobBlockBlobClientStageBlockFromUrlOptions<'_>>) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("comp", "block").append_key_only("fromURL");
        url.query_pairs_mut().append_pair("blockid", &block_id);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut().append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        request.insert_header("content-type", "application/xml");
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        request.insert_header("x-ms-copy-source", source_url);
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm.to_string());
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(source_content_crc64) = options.source_content_crc64 {
            request.insert_header("x-ms-source-content-crc64", base64::encode(source_content_crc64));
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", source_content_md5);
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header("x-ms-source-if-modified-since", source_if_modified_since);
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header("x-ms-source-if-unmodified-since", source_if_unmodified_since);
        }
        if let Some(source_range) = options.source_range {
            request.insert_header("x-ms-source-range", source_range);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// The Upload Block Blob operation updates the content of an existing block blob. Updating an existing block blob overwrites
/// any existing metadata on the blob. Partial updates are not supported with Put Blob; the content of the existing blob is
/// overwritten with the content of the new blob. To perform a partial update of the content of a block blob, use the Put
/// Block List operation.
    pub async fn upload(&self, version: String, container_name: String, blob: String, body: RequestContent<Vec<u8>>, content_length: i64, options: Option<BlobBlockBlobClientUploadOptions<'_>>) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        url.query_pairs_mut().append_key_only("BlockBlob");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut().append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", base64::encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm.to_string());
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header("x-ms-immutability-policy-mode", immutability_policy_mode.to_string());
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header("x-ms-immutability-policy-until-date", immutability_policy_expiry);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(metadata) = options.metadata {
for (k, v) in &metadata {
                request.insert_header(format!("x-ms-meta-{}", k), v);
            }
        }
        if let Some(structured_body_type) = options.structured_body_type {
            request.insert_header("x-ms-structured-body", structured_body_type);
        }
        if let Some(structured_content_length) = options.structured_content_length {
            request.insert_header("x-ms-structured-content-length", structured_content_length.to_string());
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version);
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await

    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobClientCommitBlockListOptions<'a> {
    pub blob_cache_control: Option<String>,
    pub blob_content_disposition: Option<String>,
    pub blob_content_encoding: Option<String>,
    pub blob_content_language: Option<String>,
    pub blob_content_md5: Option<Vec<u8>>,
    pub blob_content_type: Option<String>,
    pub blob_tags_string: Option<String>,
    pub client_request_id: Option<String>,
    pub encryption_algorithm: Option<EncryptionAlgorithmType>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub immutability_policy_expiry: Option<String>,
    pub immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,
    pub lease_id: Option<String>,
    pub legal_hold: Option<bool>,
    pub metadata: Option<HashMap<String, String>>,
    pub method_options: ClientMethodOptions<'a>,
    pub tier: Option<AccessTier>,
    pub timeout: Option<i32>,
    pub transactional_content_crc64: Option<String>,
    pub transactional_content_md5: Option<String>,
}


#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobClientGetBlockListOptions<'a> {
    pub client_request_id: Option<String>,
    pub if_tags: Option<String>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub snapshot: Option<String>,
    pub timeout: Option<i32>,
}


#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobClientPutBlobFromUrlOptions<'a> {
    pub blob_cache_control: Option<String>,
    pub blob_content_disposition: Option<String>,
    pub blob_content_encoding: Option<String>,
    pub blob_content_language: Option<String>,
    pub blob_content_md5: Option<Vec<u8>>,
    pub blob_content_type: Option<String>,
    pub blob_tags_string: Option<String>,
    pub client_request_id: Option<String>,
    pub copy_source_authorization: Option<String>,
    pub copy_source_blob_properties: Option<bool>,
    pub copy_source_tags: Option<String>,
    pub encryption_algorithm: Option<EncryptionAlgorithmType>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub metadata: Option<HashMap<String, String>>,
    pub method_options: ClientMethodOptions<'a>,
    pub source_content_md5: Option<String>,
    pub source_if_match: Option<String>,
    pub source_if_modified_since: Option<String>,
    pub source_if_none_match: Option<String>,
    pub source_if_tags: Option<String>,
    pub source_if_unmodified_since: Option<String>,
    pub tier: Option<AccessTier>,
    pub timeout: Option<i32>,
    pub transactional_content_md5: Option<String>,
}


#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobClientStageBlockOptions<'a> {
    pub client_request_id: Option<String>,
    pub encryption_algorithm: Option<EncryptionAlgorithmType>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub structured_body_type: Option<String>,
    pub structured_content_length: Option<i64>,
    pub timeout: Option<i32>,
    pub transactional_content_crc64: Option<String>,
    pub transactional_content_md5: Option<String>,
}


#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobClientStageBlockFromUrlOptions<'a> {
    pub client_request_id: Option<String>,
    pub copy_source_authorization: Option<String>,
    pub encryption_algorithm: Option<EncryptionAlgorithmType>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub source_content_crc64: Option<Vec<u8>>,
    pub source_content_md5: Option<String>,
    pub source_if_match: Option<String>,
    pub source_if_modified_since: Option<String>,
    pub source_if_none_match: Option<String>,
    pub source_if_unmodified_since: Option<String>,
    pub source_range: Option<String>,
    pub timeout: Option<i32>,
}


#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobClientUploadOptions<'a> {
    pub blob_cache_control: Option<String>,
    pub blob_content_disposition: Option<String>,
    pub blob_content_encoding: Option<String>,
    pub blob_content_language: Option<String>,
    pub blob_content_md5: Option<Vec<u8>>,
    pub blob_content_type: Option<String>,
    pub blob_tags_string: Option<String>,
    pub client_request_id: Option<String>,
    pub encryption_algorithm: Option<EncryptionAlgorithmType>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub immutability_policy_expiry: Option<String>,
    pub immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,
    pub lease_id: Option<String>,
    pub legal_hold: Option<bool>,
    pub metadata: Option<HashMap<String, String>>,
    pub method_options: ClientMethodOptions<'a>,
    pub structured_body_type: Option<String>,
    pub structured_content_length: Option<i64>,
    pub tier: Option<AccessTier>,
    pub timeout: Option<i32>,
    pub transactional_content_crc64: Option<String>,
    pub transactional_content_md5: Option<String>,
}


