// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use crate::models::{
    ArrowField, BlobTag, CorsRule, FilterBlobItem,
};
use serde::{
    Deserialize, Deserializer, Serialize, Serializer,
};

#[derive(Deserialize, Serialize)]
#[serde(rename = "TagSet")]
pub struct Blob_tag_setBlobTag {
    #[serde(default)]
    BlobTag: Option<Vec<BlobTag>>,
}

impl Blob_tag_setBlobTag {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<BlobTag>>, D::Error> where D: Deserializer<'de> {
        Ok(Blob_tag_setBlobTag::deserialize(deserializer)?.BlobTag)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<BlobTag>>, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
        Blob_tag_setBlobTag {
            BlobTag: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "Blobs")]
pub struct BlobsFilterBlobItem {
    #[serde(default)]
    FilterBlobItem: Option<Vec<FilterBlobItem>>,
}

impl BlobsFilterBlobItem {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<FilterBlobItem>>, D::Error> where D: Deserializer<'de> {
        Ok(BlobsFilterBlobItem::deserialize(deserializer)?.FilterBlobItem)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<FilterBlobItem>>, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
        BlobsFilterBlobItem {
            FilterBlobItem: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "Cors")]
pub struct CorsCorsRule {
    #[serde(default)]
    CorsRule: Option<Vec<CorsRule>>,
}

impl CorsCorsRule {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<CorsRule>>, D::Error> where D: Deserializer<'de> {
        Ok(CorsCorsRule::deserialize(deserializer)?.CorsRule)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<CorsRule>>, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
        CorsCorsRule {
            CorsRule: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "Schema")]
pub struct SchemaArrowField {
    #[serde(default)]
    ArrowField: Option<Vec<ArrowField>>,
}

impl SchemaArrowField {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<ArrowField>>, D::Error> where D: Deserializer<'de> {
        Ok(SchemaArrowField::deserialize(deserializer)?.ArrowField)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<ArrowField>>, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
        SchemaArrowField {
            ArrowField: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

