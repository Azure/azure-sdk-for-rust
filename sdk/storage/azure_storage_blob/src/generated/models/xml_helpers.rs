// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use super::{ArrowField, BlobTag, Block, ContainerItem, CorsRule, FilterBlobItem};
use serde::{Deserialize, Deserializer, Serialize, Serializer};

#[derive(Deserialize, Serialize)]
#[serde(rename = "TagSet")]
pub(crate) struct Blob_tag_setTag {
    #[serde(default)]
    Tag: Option<Vec<BlobTag>>,
}

impl Blob_tag_setTag {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<BlobTag>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(Blob_tag_setTag::deserialize(deserializer)?.Tag)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<BlobTag>>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        Blob_tag_setTag {
            Tag: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "Blobs")]
pub(crate) struct BlobsBlob {
    #[serde(default)]
    Blob: Option<Vec<FilterBlobItem>>,
}

impl BlobsBlob {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<FilterBlobItem>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(BlobsBlob::deserialize(deserializer)?.Blob)
    }

    pub fn wrap<S>(
        to_serialize: &Option<Vec<FilterBlobItem>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        BlobsBlob {
            Blob: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "CommittedBlocks")]
pub(crate) struct Committed_blocksBlock {
    #[serde(default)]
    Block: Option<Vec<Block>>,
}

impl Committed_blocksBlock {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<Block>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(Committed_blocksBlock::deserialize(deserializer)?.Block)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<Block>>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        Committed_blocksBlock {
            Block: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "Containers")]
pub(crate) struct Container_itemsContainer {
    #[serde(default)]
    Container: Vec<ContainerItem>,
}

impl Container_itemsContainer {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Vec<ContainerItem>, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(Container_itemsContainer::deserialize(deserializer)?.Container)
    }

    pub fn wrap<S>(to_serialize: &Vec<ContainerItem>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        Container_itemsContainer {
            Container: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "Cors")]
pub(crate) struct CorsCorsRule {
    #[serde(default)]
    CorsRule: Option<Vec<CorsRule>>,
}

impl CorsCorsRule {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<CorsRule>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(CorsCorsRule::deserialize(deserializer)?.CorsRule)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<CorsRule>>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        CorsCorsRule {
            CorsRule: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "Schema")]
pub(crate) struct SchemaField {
    #[serde(default)]
    Field: Option<Vec<ArrowField>>,
}

impl SchemaField {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<ArrowField>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(SchemaField::deserialize(deserializer)?.Field)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<ArrowField>>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        SchemaField {
            Field: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename = "UncommittedBlocks")]
pub(crate) struct Uncommitted_blocksBlock {
    #[serde(default)]
    Block: Option<Vec<Block>>,
}

impl Uncommitted_blocksBlock {
    pub fn unwrap<'de, D>(deserializer: D) -> Result<Option<Vec<Block>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(Uncommitted_blocksBlock::deserialize(deserializer)?.Block)
    }

    pub fn wrap<S>(to_serialize: &Option<Vec<Block>>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        Uncommitted_blocksBlock {
            Block: to_serialize.to_owned(),
        }
        .serialize(serializer)
    }
}
