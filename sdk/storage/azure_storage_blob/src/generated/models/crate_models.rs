// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    crate_models::{
        ArrowConfiguration, ArrowField, BlobHierarchyListSegment, BlobPrefix,
        DelimitedTextConfiguration, JsonTextConfiguration, ParquetConfiguration, QueryFormat,
        QuerySerialization,
    },
    xml_helpers::SchemaField,
    BlobItemInternal, BlobName, QueryRequestType, QueryType,
};
use azure_core::{
    base64::{deserialize, serialize},
    fmt::SafeDebug,
    http::{RequestContent, XmlFormat},
    xml::to_xml,
    Result, Value,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Represents the Apache Arrow configuration.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub(crate) struct ArrowConfiguration {
    /// The Apache Arrow schema
    #[serde(
        default,
        deserialize_with = "SchemaField::unwrap",
        rename = "Schema",
        serialize_with = "SchemaField::wrap"
    )]
    pub(crate) schema: Vec<ArrowField>,
}

/// Represents an Apache Arrow field.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[serde(rename = "Field")]
pub(crate) struct ArrowField {
    /// The arrow field name.
    #[serde(rename = "Name", skip_serializing_if = "Option::is_none")]
    pub(crate) name: Option<String>,

    /// The arrow field precision.
    #[serde(rename = "Precision", skip_serializing_if = "Option::is_none")]
    pub(crate) precision: Option<i32>,

    /// The arrow field scale.
    #[serde(rename = "Scale", skip_serializing_if = "Option::is_none")]
    pub(crate) scale: Option<i32>,

    /// The arrow field type.
    #[serde(rename = "Type")]
    pub(crate) type_prop: String,
}

/// Contains results for `BlobClient::copy_from_url()`
#[derive(SafeDebug)]
pub(crate) struct BlobClientCopyFromUrlResult;

/// Contains results for `BlobClient::set_expiry()`
#[derive(SafeDebug)]
pub(crate) struct BlobClientSetExpiryResult;

/// Contains results for `BlobClient::start_copy_from_url()`
#[derive(SafeDebug)]
pub(crate) struct BlobClientStartCopyFromUrlResult;

/// Represents an array of blobs.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub(crate) struct BlobHierarchyListSegment {
    /// The blob items
    #[serde(rename = "Blob")]
    pub(crate) blob_items: Vec<BlobItemInternal>,

    /// The blob prefixes.
    #[serde(rename = "BlobPrefix", skip_serializing_if = "Option::is_none")]
    pub(crate) blob_prefixes: Option<Vec<BlobPrefix>>,
}

/// Represents a blob prefix.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub(crate) struct BlobPrefix {
    /// The blob name.
    #[serde(rename = "Name")]
    pub(crate) name: BlobName,
}

/// Contains results for `BlockBlobClient::query()`
#[derive(SafeDebug)]
pub(crate) struct BlockBlobClientQueryResult;

/// Contains results for `BlockBlobClient::stage_block_from_url()`
#[derive(SafeDebug)]
pub(crate) struct BlockBlobClientStageBlockFromUrlResult;

/// Represents the delimited text configuration.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub(crate) struct DelimitedTextConfiguration {
    /// The string used to separate columns.
    #[serde(rename = "ColumnSeparator", skip_serializing_if = "Option::is_none")]
    pub(crate) column_separator: Option<String>,

    /// The string used to escape a quote character in a field.
    #[serde(rename = "EscapeChar", skip_serializing_if = "Option::is_none")]
    pub(crate) escape_char: Option<String>,

    /// The string used to quote a specific field.
    #[serde(rename = "FieldQuote", skip_serializing_if = "Option::is_none")]
    pub(crate) field_quote: Option<String>,

    /// Represents whether the data has headers.
    #[serde(rename = "HasHeaders", skip_serializing_if = "Option::is_none")]
    pub(crate) headers_present: Option<bool>,

    /// The string used to separate records.
    #[serde(rename = "RecordSeparator", skip_serializing_if = "Option::is_none")]
    pub(crate) record_separator: Option<String>,
}

/// Represents the JSON text configuration.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub(crate) struct JsonTextConfiguration {
    /// The string used to separate records.
    #[serde(rename = "RecordSeparator", skip_serializing_if = "Option::is_none")]
    pub(crate) record_separator: Option<String>,
}

/// Key information
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub(crate) struct KeyInfo {
    /// The delegated user tenant id in Azure AD.
    #[serde(rename = "DelegatedUserTid", skip_serializing_if = "Option::is_none")]
    pub(crate) delegated_user_tid: Option<String>,

    /// The date-time the key expires.
    #[serde(rename = "Expiry")]
    pub(crate) expiry: String,

    /// The date-time the key is active.
    #[serde(rename = "Start")]
    pub(crate) start: String,
}

/// An enumeration of blobs
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
#[serde(rename = "EnumerationResults")]
pub(crate) struct ListBlobsHierarchySegmentResponse {
    /// The container name.
    #[serde(rename = "@ContainerName")]
    pub(crate) container_name: String,

    /// The delimiter of the blobs.
    #[serde(rename = "Delimiter", skip_serializing_if = "Option::is_none")]
    pub(crate) delimiter: Option<String>,

    /// The marker of the blobs.
    #[serde(rename = "Marker", skip_serializing_if = "Option::is_none")]
    pub(crate) marker: Option<String>,

    /// The max results of the blobs.
    #[serde(rename = "MaxResults", skip_serializing_if = "Option::is_none")]
    pub(crate) max_results: Option<i32>,

    /// The next marker of the blobs.
    #[serde(rename = "NextMarker", skip_serializing_if = "Option::is_none")]
    pub(crate) next_marker: Option<String>,

    /// The prefix of the blobs.
    #[serde(rename = "Prefix", skip_serializing_if = "Option::is_none")]
    pub(crate) prefix: Option<String>,

    /// The blob segment.
    #[serde(rename = "Blobs")]
    pub(crate) segment: BlobHierarchyListSegment,

    /// The service endpoint.
    #[serde(rename = "@ServiceEndpoint")]
    pub(crate) service_endpoint: String,
}

/// Contains results for `PageBlobClient::copy_incremental()`
#[derive(SafeDebug)]
pub(crate) struct PageBlobClientCopyIncrementalResult;

/// Represents the Parquet configuration.
#[derive(Clone, Default, SafeDebug)]
pub(crate) struct ParquetConfiguration {
    /// contains unnamed additional properties
    pub additional_properties: Option<HashMap<String, Value>>,
}

/// The query format settings.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub(crate) struct QueryFormat {
    /// The Apache Arrow configuration.
    #[serde(rename = "ArrowConfiguration", skip_serializing_if = "Option::is_none")]
    pub(crate) arrow_configuration: Option<ArrowConfiguration>,

    /// The delimited text configuration.
    #[serde(
        rename = "DelimitedTextConfiguration",
        skip_serializing_if = "Option::is_none"
    )]
    pub(crate) delimited_text_configuration: Option<DelimitedTextConfiguration>,

    /// The JSON text configuration.
    #[serde(
        rename = "JsonTextConfiguration",
        skip_serializing_if = "Option::is_none"
    )]
    pub(crate) json_text_configuration: Option<JsonTextConfiguration>,

    /// The Parquet configuration.
    #[serde(
        rename = "ParquetConfiguration",
        skip_serializing_if = "Option::is_none"
    )]
    pub(crate) parquet_text_configuration: Option<ParquetConfiguration>,

    /// The query type.
    #[serde(rename = "Type")]
    pub(crate) type_prop: QueryType,
}

/// Groups the set of query request settings.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub(crate) struct QueryRequest {
    /// The query expression in SQL. The maximum size of the query expression is 256KiB.
    #[serde(rename = "Expression")]
    pub(crate) expression: String,

    /// The input serialization settings.
    #[serde(rename = "InputSerialization", skip_serializing_if = "Option::is_none")]
    pub(crate) input_serialization: Option<QuerySerialization>,

    /// The output serialization settings.
    #[serde(
        rename = "OutputSerialization",
        skip_serializing_if = "Option::is_none"
    )]
    pub(crate) output_serialization: Option<QuerySerialization>,

    /// Required. The type of the provided query expression.
    #[serde(rename = "QueryType")]
    pub(crate) query_type: QueryRequestType,
}

/// The query serialization settings.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub(crate) struct QuerySerialization {
    /// The query format.
    #[serde(rename = "Format")]
    pub(crate) format: QueryFormat,
}

/// A user delegation key.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub(crate) struct UserDelegationKey {
    /// The delegated user tenant id in Azure AD. Return if DelegatedUserTid is specified.
    #[serde(
        rename = "SignedDelegatedUserTid",
        skip_serializing_if = "Option::is_none"
    )]
    pub(crate) signed_delegated_user_tid: Option<String>,

    /// The date-time the key expires.
    #[serde(rename = "SignedExpiry")]
    pub(crate) signed_expiry: String,

    /// The Azure Active Directory object ID in GUID format.
    #[serde(rename = "SignedOid")]
    pub(crate) signed_oid: String,

    /// Abbreviation of the Azure Storage service that accepts the key.
    #[serde(rename = "SignedService")]
    pub(crate) signed_service: String,

    /// The date-time the key is active.
    #[serde(rename = "SignedStart")]
    pub(crate) signed_start: String,

    /// The Azure Active Directory tenant ID in GUID format.
    #[serde(rename = "SignedTid")]
    pub(crate) signed_tid: String,

    /// The service version that created the key.
    #[serde(rename = "SignedVersion")]
    pub(crate) signed_version: String,

    /// The key as a base64 string.
    #[serde(
        default,
        deserialize_with = "deserialize",
        rename = "Value",
        serialize_with = "serialize"
    )]
    pub(crate) value: Vec<u8>,
}

impl TryFrom<KeyInfo> for RequestContent<KeyInfo, XmlFormat> {
    type Error = azure_core::Error;
    fn try_from(value: KeyInfo) -> Result<Self> {
        Ok(to_xml(&value)?.into())
    }
}

impl TryFrom<QueryRequest> for RequestContent<QueryRequest, XmlFormat> {
    type Error = azure_core::Error;
    fn try_from(value: QueryRequest) -> Result<Self> {
        Ok(to_xml(&value)?.into())
    }
}
