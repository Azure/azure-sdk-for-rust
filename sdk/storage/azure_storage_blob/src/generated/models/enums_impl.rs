// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    AccessTier, AccountKind, ArchiveStatus, BlobCopySourceTags, BlobDeleteType, BlobExpiryOptions,
    BlobImmutabilityPolicyMode, BlobType, BlockListType, CopyStatus, DeleteSnapshotsOptionType,
    EncryptionAlgorithmType, FileShareTokenIntent, FilterBlobsIncludeItem,
    GeoReplicationStatusType, ImmutabilityPolicyMode, LeaseDuration, LeaseState, LeaseStatus,
    ListBlobsIncludeItem, ListContainersIncludeType, PremiumPageBlobAccessTier, PublicAccessType,
    QueryRequestType, QueryType, RehydratePriority, SequenceNumberActionType, SkuName,
    StorageErrorCode,
};
use azure_core::error::{Error, ErrorKind};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

impl<'a> From<&'a AccessTier> for &'a str {
    fn from(e: &'a AccessTier) -> Self {
        match e {
            AccessTier::Archive => "Archive",
            AccessTier::Cold => "Cold",
            AccessTier::Cool => "Cool",
            AccessTier::Hot => "Hot",
            AccessTier::P10 => "P10",
            AccessTier::P15 => "P15",
            AccessTier::P20 => "P20",
            AccessTier::P30 => "P30",
            AccessTier::P4 => "P4",
            AccessTier::P40 => "P40",
            AccessTier::P50 => "P50",
            AccessTier::P6 => "P6",
            AccessTier::P60 => "P60",
            AccessTier::P70 => "P70",
            AccessTier::P80 => "P80",
            AccessTier::Premium => "Premium",
            AccessTier::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for AccessTier {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Archive" => AccessTier::Archive,
            "Cold" => AccessTier::Cold,
            "Cool" => AccessTier::Cool,
            "Hot" => AccessTier::Hot,
            "P10" => AccessTier::P10,
            "P15" => AccessTier::P15,
            "P20" => AccessTier::P20,
            "P30" => AccessTier::P30,
            "P4" => AccessTier::P4,
            "P40" => AccessTier::P40,
            "P50" => AccessTier::P50,
            "P6" => AccessTier::P6,
            "P60" => AccessTier::P60,
            "P70" => AccessTier::P70,
            "P80" => AccessTier::P80,
            "Premium" => AccessTier::Premium,
            _ => AccessTier::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for AccessTier {
    fn as_ref(&self) -> &str {
        match self {
            AccessTier::Archive => "Archive",
            AccessTier::Cold => "Cold",
            AccessTier::Cool => "Cool",
            AccessTier::Hot => "Hot",
            AccessTier::P10 => "P10",
            AccessTier::P15 => "P15",
            AccessTier::P20 => "P20",
            AccessTier::P30 => "P30",
            AccessTier::P4 => "P4",
            AccessTier::P40 => "P40",
            AccessTier::P50 => "P50",
            AccessTier::P6 => "P6",
            AccessTier::P60 => "P60",
            AccessTier::P70 => "P70",
            AccessTier::P80 => "P80",
            AccessTier::Premium => "Premium",
            AccessTier::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for AccessTier {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AccessTier::Archive => f.write_str("Archive"),
            AccessTier::Cold => f.write_str("Cold"),
            AccessTier::Cool => f.write_str("Cool"),
            AccessTier::Hot => f.write_str("Hot"),
            AccessTier::P10 => f.write_str("P10"),
            AccessTier::P15 => f.write_str("P15"),
            AccessTier::P20 => f.write_str("P20"),
            AccessTier::P30 => f.write_str("P30"),
            AccessTier::P4 => f.write_str("P4"),
            AccessTier::P40 => f.write_str("P40"),
            AccessTier::P50 => f.write_str("P50"),
            AccessTier::P6 => f.write_str("P6"),
            AccessTier::P60 => f.write_str("P60"),
            AccessTier::P70 => f.write_str("P70"),
            AccessTier::P80 => f.write_str("P80"),
            AccessTier::Premium => f.write_str("Premium"),
            AccessTier::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for AccountKind {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "BlobStorage" => AccountKind::BlobStorage,
            "BlockBlobStorage" => AccountKind::BlockBlobStorage,
            "FileStorage" => AccountKind::FileStorage,
            "Storage" => AccountKind::Storage,
            "StorageV2" => AccountKind::StorageV2,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of AccountKind found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for AccountKind {
    fn as_ref(&self) -> &str {
        match self {
            AccountKind::BlobStorage => "BlobStorage",
            AccountKind::BlockBlobStorage => "BlockBlobStorage",
            AccountKind::FileStorage => "FileStorage",
            AccountKind::Storage => "Storage",
            AccountKind::StorageV2 => "StorageV2",
        }
    }
}

impl Display for AccountKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AccountKind::BlobStorage => Display::fmt("BlobStorage", f),
            AccountKind::BlockBlobStorage => Display::fmt("BlockBlobStorage", f),
            AccountKind::FileStorage => Display::fmt("FileStorage", f),
            AccountKind::Storage => Display::fmt("Storage", f),
            AccountKind::StorageV2 => Display::fmt("StorageV2", f),
        }
    }
}

impl<'a> From<&'a ArchiveStatus> for &'a str {
    fn from(e: &'a ArchiveStatus) -> Self {
        match e {
            ArchiveStatus::RehydratePendingToCold => "rehydrate-pending-to-cold",
            ArchiveStatus::RehydratePendingToCool => "rehydrate-pending-to-cool",
            ArchiveStatus::RehydratePendingToHot => "rehydrate-pending-to-hot",
            ArchiveStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ArchiveStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "rehydrate-pending-to-cold" => ArchiveStatus::RehydratePendingToCold,
            "rehydrate-pending-to-cool" => ArchiveStatus::RehydratePendingToCool,
            "rehydrate-pending-to-hot" => ArchiveStatus::RehydratePendingToHot,
            _ => ArchiveStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ArchiveStatus {
    fn as_ref(&self) -> &str {
        match self {
            ArchiveStatus::RehydratePendingToCold => "rehydrate-pending-to-cold",
            ArchiveStatus::RehydratePendingToCool => "rehydrate-pending-to-cool",
            ArchiveStatus::RehydratePendingToHot => "rehydrate-pending-to-hot",
            ArchiveStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ArchiveStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ArchiveStatus::RehydratePendingToCold => f.write_str("rehydrate-pending-to-cold"),
            ArchiveStatus::RehydratePendingToCool => f.write_str("rehydrate-pending-to-cool"),
            ArchiveStatus::RehydratePendingToHot => f.write_str("rehydrate-pending-to-hot"),
            ArchiveStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for BlobCopySourceTags {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "COPY" => BlobCopySourceTags::Copy,
            "REPLACE" => BlobCopySourceTags::Replace,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of BlobCopySourceTags found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for BlobCopySourceTags {
    fn as_ref(&self) -> &str {
        match self {
            BlobCopySourceTags::Copy => "COPY",
            BlobCopySourceTags::Replace => "REPLACE",
        }
    }
}

impl Display for BlobCopySourceTags {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobCopySourceTags::Copy => Display::fmt("COPY", f),
            BlobCopySourceTags::Replace => Display::fmt("REPLACE", f),
        }
    }
}

impl FromStr for BlobDeleteType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Permanent" => BlobDeleteType::Permanent,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of BlobDeleteType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for BlobDeleteType {
    fn as_ref(&self) -> &str {
        match self {
            BlobDeleteType::Permanent => "Permanent",
        }
    }
}

impl Display for BlobDeleteType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobDeleteType::Permanent => Display::fmt("Permanent", f),
        }
    }
}

impl<'a> From<&'a BlobExpiryOptions> for &'a str {
    fn from(e: &'a BlobExpiryOptions) -> Self {
        match e {
            BlobExpiryOptions::Absolute => "Absolute",
            BlobExpiryOptions::NeverExpire => "NeverExpire",
            BlobExpiryOptions::RelativeToCreation => "RelativeToCreation",
            BlobExpiryOptions::RelativeToNow => "RelativeToNow",
            BlobExpiryOptions::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobExpiryOptions {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Absolute" => BlobExpiryOptions::Absolute,
            "NeverExpire" => BlobExpiryOptions::NeverExpire,
            "RelativeToCreation" => BlobExpiryOptions::RelativeToCreation,
            "RelativeToNow" => BlobExpiryOptions::RelativeToNow,
            _ => BlobExpiryOptions::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobExpiryOptions {
    fn as_ref(&self) -> &str {
        match self {
            BlobExpiryOptions::Absolute => "Absolute",
            BlobExpiryOptions::NeverExpire => "NeverExpire",
            BlobExpiryOptions::RelativeToCreation => "RelativeToCreation",
            BlobExpiryOptions::RelativeToNow => "RelativeToNow",
            BlobExpiryOptions::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobExpiryOptions {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobExpiryOptions::Absolute => f.write_str("Absolute"),
            BlobExpiryOptions::NeverExpire => f.write_str("NeverExpire"),
            BlobExpiryOptions::RelativeToCreation => f.write_str("RelativeToCreation"),
            BlobExpiryOptions::RelativeToNow => f.write_str("RelativeToNow"),
            BlobExpiryOptions::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for BlobImmutabilityPolicyMode {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Locked" => BlobImmutabilityPolicyMode::Locked,
            "Mutable" => BlobImmutabilityPolicyMode::Mutable,
            "Unlocked" => BlobImmutabilityPolicyMode::Unlocked,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of BlobImmutabilityPolicyMode found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for BlobImmutabilityPolicyMode {
    fn as_ref(&self) -> &str {
        match self {
            BlobImmutabilityPolicyMode::Locked => "Locked",
            BlobImmutabilityPolicyMode::Mutable => "Mutable",
            BlobImmutabilityPolicyMode::Unlocked => "Unlocked",
        }
    }
}

impl Display for BlobImmutabilityPolicyMode {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobImmutabilityPolicyMode::Locked => Display::fmt("Locked", f),
            BlobImmutabilityPolicyMode::Mutable => Display::fmt("Mutable", f),
            BlobImmutabilityPolicyMode::Unlocked => Display::fmt("Unlocked", f),
        }
    }
}

impl FromStr for BlobType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AppendBlob" => BlobType::AppendBlob,
            "BlockBlob" => BlobType::BlockBlob,
            "PageBlob" => BlobType::PageBlob,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of BlobType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for BlobType {
    fn as_ref(&self) -> &str {
        match self {
            BlobType::AppendBlob => "AppendBlob",
            BlobType::BlockBlob => "BlockBlob",
            BlobType::PageBlob => "PageBlob",
        }
    }
}

impl Display for BlobType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobType::AppendBlob => Display::fmt("AppendBlob", f),
            BlobType::BlockBlob => Display::fmt("BlockBlob", f),
            BlobType::PageBlob => Display::fmt("PageBlob", f),
        }
    }
}

impl FromStr for BlockListType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "all" => BlockListType::All,
            "committed" => BlockListType::Committed,
            "uncommitted" => BlockListType::Uncommitted,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of BlockListType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for BlockListType {
    fn as_ref(&self) -> &str {
        match self {
            BlockListType::All => "all",
            BlockListType::Committed => "committed",
            BlockListType::Uncommitted => "uncommitted",
        }
    }
}

impl Display for BlockListType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlockListType::All => Display::fmt("all", f),
            BlockListType::Committed => Display::fmt("committed", f),
            BlockListType::Uncommitted => Display::fmt("uncommitted", f),
        }
    }
}

impl FromStr for CopyStatus {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "aborted" => CopyStatus::Aborted,
            "failed" => CopyStatus::Failed,
            "pending" => CopyStatus::Pending,
            "success" => CopyStatus::Success,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of CopyStatus found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for CopyStatus {
    fn as_ref(&self) -> &str {
        match self {
            CopyStatus::Aborted => "aborted",
            CopyStatus::Failed => "failed",
            CopyStatus::Pending => "pending",
            CopyStatus::Success => "success",
        }
    }
}

impl Display for CopyStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CopyStatus::Aborted => Display::fmt("aborted", f),
            CopyStatus::Failed => Display::fmt("failed", f),
            CopyStatus::Pending => Display::fmt("pending", f),
            CopyStatus::Success => Display::fmt("success", f),
        }
    }
}

impl FromStr for DeleteSnapshotsOptionType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "include" => DeleteSnapshotsOptionType::Include,
            "only" => DeleteSnapshotsOptionType::Only,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of DeleteSnapshotsOptionType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for DeleteSnapshotsOptionType {
    fn as_ref(&self) -> &str {
        match self {
            DeleteSnapshotsOptionType::Include => "include",
            DeleteSnapshotsOptionType::Only => "only",
        }
    }
}

impl Display for DeleteSnapshotsOptionType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            DeleteSnapshotsOptionType::Include => Display::fmt("include", f),
            DeleteSnapshotsOptionType::Only => Display::fmt("only", f),
        }
    }
}

impl FromStr for EncryptionAlgorithmType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AES256" => EncryptionAlgorithmType::Aes256,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of EncryptionAlgorithmType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for EncryptionAlgorithmType {
    fn as_ref(&self) -> &str {
        match self {
            EncryptionAlgorithmType::Aes256 => "AES256",
        }
    }
}

impl Display for EncryptionAlgorithmType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            EncryptionAlgorithmType::Aes256 => Display::fmt("AES256", f),
        }
    }
}

impl<'a> From<&'a FileShareTokenIntent> for &'a str {
    fn from(e: &'a FileShareTokenIntent) -> Self {
        match e {
            FileShareTokenIntent::Backup => "backup",
            FileShareTokenIntent::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for FileShareTokenIntent {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "backup" => FileShareTokenIntent::Backup,
            _ => FileShareTokenIntent::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for FileShareTokenIntent {
    fn as_ref(&self) -> &str {
        match self {
            FileShareTokenIntent::Backup => "backup",
            FileShareTokenIntent::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for FileShareTokenIntent {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            FileShareTokenIntent::Backup => f.write_str("backup"),
            FileShareTokenIntent::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for FilterBlobsIncludeItem {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "none" => FilterBlobsIncludeItem::None,
            "versions" => FilterBlobsIncludeItem::Versions,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of FilterBlobsIncludeItem found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for FilterBlobsIncludeItem {
    fn as_ref(&self) -> &str {
        match self {
            FilterBlobsIncludeItem::None => "none",
            FilterBlobsIncludeItem::Versions => "versions",
        }
    }
}

impl Display for FilterBlobsIncludeItem {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            FilterBlobsIncludeItem::None => Display::fmt("none", f),
            FilterBlobsIncludeItem::Versions => Display::fmt("versions", f),
        }
    }
}

impl<'a> From<&'a GeoReplicationStatusType> for &'a str {
    fn from(e: &'a GeoReplicationStatusType) -> Self {
        match e {
            GeoReplicationStatusType::Bootstrap => "bootstrap",
            GeoReplicationStatusType::Live => "live",
            GeoReplicationStatusType::Unavailable => "unavailable",
            GeoReplicationStatusType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for GeoReplicationStatusType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "bootstrap" => GeoReplicationStatusType::Bootstrap,
            "live" => GeoReplicationStatusType::Live,
            "unavailable" => GeoReplicationStatusType::Unavailable,
            _ => GeoReplicationStatusType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for GeoReplicationStatusType {
    fn as_ref(&self) -> &str {
        match self {
            GeoReplicationStatusType::Bootstrap => "bootstrap",
            GeoReplicationStatusType::Live => "live",
            GeoReplicationStatusType::Unavailable => "unavailable",
            GeoReplicationStatusType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for GeoReplicationStatusType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GeoReplicationStatusType::Bootstrap => f.write_str("bootstrap"),
            GeoReplicationStatusType::Live => f.write_str("live"),
            GeoReplicationStatusType::Unavailable => f.write_str("unavailable"),
            GeoReplicationStatusType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for ImmutabilityPolicyMode {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Locked" => ImmutabilityPolicyMode::Locked,
            "Unlocked" => ImmutabilityPolicyMode::Unlocked,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of ImmutabilityPolicyMode found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for ImmutabilityPolicyMode {
    fn as_ref(&self) -> &str {
        match self {
            ImmutabilityPolicyMode::Locked => "Locked",
            ImmutabilityPolicyMode::Unlocked => "Unlocked",
        }
    }
}

impl Display for ImmutabilityPolicyMode {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ImmutabilityPolicyMode::Locked => Display::fmt("Locked", f),
            ImmutabilityPolicyMode::Unlocked => Display::fmt("Unlocked", f),
        }
    }
}

impl FromStr for LeaseDuration {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "fixed" => LeaseDuration::Fixed,
            "infinite" => LeaseDuration::Infinite,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of LeaseDuration found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for LeaseDuration {
    fn as_ref(&self) -> &str {
        match self {
            LeaseDuration::Fixed => "fixed",
            LeaseDuration::Infinite => "infinite",
        }
    }
}

impl Display for LeaseDuration {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseDuration::Fixed => Display::fmt("fixed", f),
            LeaseDuration::Infinite => Display::fmt("infinite", f),
        }
    }
}

impl FromStr for LeaseState {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "available" => LeaseState::Available,
            "breaking" => LeaseState::Breaking,
            "broken" => LeaseState::Broken,
            "expired" => LeaseState::Expired,
            "leased" => LeaseState::Leased,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of LeaseState found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for LeaseState {
    fn as_ref(&self) -> &str {
        match self {
            LeaseState::Available => "available",
            LeaseState::Breaking => "breaking",
            LeaseState::Broken => "broken",
            LeaseState::Expired => "expired",
            LeaseState::Leased => "leased",
        }
    }
}

impl Display for LeaseState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseState::Available => Display::fmt("available", f),
            LeaseState::Breaking => Display::fmt("breaking", f),
            LeaseState::Broken => Display::fmt("broken", f),
            LeaseState::Expired => Display::fmt("expired", f),
            LeaseState::Leased => Display::fmt("leased", f),
        }
    }
}

impl FromStr for LeaseStatus {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "locked" => LeaseStatus::Locked,
            "unlocked" => LeaseStatus::Unlocked,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of LeaseStatus found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for LeaseStatus {
    fn as_ref(&self) -> &str {
        match self {
            LeaseStatus::Locked => "locked",
            LeaseStatus::Unlocked => "unlocked",
        }
    }
}

impl Display for LeaseStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseStatus::Locked => Display::fmt("locked", f),
            LeaseStatus::Unlocked => Display::fmt("unlocked", f),
        }
    }
}

impl FromStr for ListBlobsIncludeItem {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "copy" => ListBlobsIncludeItem::Copy,
            "deleted" => ListBlobsIncludeItem::Deleted,
            "deletedwithversions" => ListBlobsIncludeItem::DeletedWithVersions,
            "immutabilitypolicy" => ListBlobsIncludeItem::ImmutabilityPolicy,
            "legalhold" => ListBlobsIncludeItem::LegalHold,
            "metadata" => ListBlobsIncludeItem::Metadata,
            "snapshots" => ListBlobsIncludeItem::Snapshots,
            "tags" => ListBlobsIncludeItem::Tags,
            "uncommittedblobs" => ListBlobsIncludeItem::UncommittedBlobs,
            "versions" => ListBlobsIncludeItem::Versions,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of ListBlobsIncludeItem found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for ListBlobsIncludeItem {
    fn as_ref(&self) -> &str {
        match self {
            ListBlobsIncludeItem::Copy => "copy",
            ListBlobsIncludeItem::Deleted => "deleted",
            ListBlobsIncludeItem::DeletedWithVersions => "deletedwithversions",
            ListBlobsIncludeItem::ImmutabilityPolicy => "immutabilitypolicy",
            ListBlobsIncludeItem::LegalHold => "legalhold",
            ListBlobsIncludeItem::Metadata => "metadata",
            ListBlobsIncludeItem::Snapshots => "snapshots",
            ListBlobsIncludeItem::Tags => "tags",
            ListBlobsIncludeItem::UncommittedBlobs => "uncommittedblobs",
            ListBlobsIncludeItem::Versions => "versions",
        }
    }
}

impl Display for ListBlobsIncludeItem {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ListBlobsIncludeItem::Copy => Display::fmt("copy", f),
            ListBlobsIncludeItem::Deleted => Display::fmt("deleted", f),
            ListBlobsIncludeItem::DeletedWithVersions => Display::fmt("deletedwithversions", f),
            ListBlobsIncludeItem::ImmutabilityPolicy => Display::fmt("immutabilitypolicy", f),
            ListBlobsIncludeItem::LegalHold => Display::fmt("legalhold", f),
            ListBlobsIncludeItem::Metadata => Display::fmt("metadata", f),
            ListBlobsIncludeItem::Snapshots => Display::fmt("snapshots", f),
            ListBlobsIncludeItem::Tags => Display::fmt("tags", f),
            ListBlobsIncludeItem::UncommittedBlobs => Display::fmt("uncommittedblobs", f),
            ListBlobsIncludeItem::Versions => Display::fmt("versions", f),
        }
    }
}

impl FromStr for ListContainersIncludeType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "deleted" => ListContainersIncludeType::Deleted,
            "metadata" => ListContainersIncludeType::Metadata,
            "system" => ListContainersIncludeType::System,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of ListContainersIncludeType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for ListContainersIncludeType {
    fn as_ref(&self) -> &str {
        match self {
            ListContainersIncludeType::Deleted => "deleted",
            ListContainersIncludeType::Metadata => "metadata",
            ListContainersIncludeType::System => "system",
        }
    }
}

impl Display for ListContainersIncludeType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ListContainersIncludeType::Deleted => Display::fmt("deleted", f),
            ListContainersIncludeType::Metadata => Display::fmt("metadata", f),
            ListContainersIncludeType::System => Display::fmt("system", f),
        }
    }
}

impl<'a> From<&'a PremiumPageBlobAccessTier> for &'a str {
    fn from(e: &'a PremiumPageBlobAccessTier) -> Self {
        match e {
            PremiumPageBlobAccessTier::P10 => "P10",
            PremiumPageBlobAccessTier::P15 => "P15",
            PremiumPageBlobAccessTier::P20 => "P20",
            PremiumPageBlobAccessTier::P30 => "P30",
            PremiumPageBlobAccessTier::P4 => "P4",
            PremiumPageBlobAccessTier::P40 => "P40",
            PremiumPageBlobAccessTier::P50 => "P50",
            PremiumPageBlobAccessTier::P6 => "P6",
            PremiumPageBlobAccessTier::P60 => "P60",
            PremiumPageBlobAccessTier::P70 => "P70",
            PremiumPageBlobAccessTier::P80 => "P80",
            PremiumPageBlobAccessTier::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PremiumPageBlobAccessTier {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "P10" => PremiumPageBlobAccessTier::P10,
            "P15" => PremiumPageBlobAccessTier::P15,
            "P20" => PremiumPageBlobAccessTier::P20,
            "P30" => PremiumPageBlobAccessTier::P30,
            "P4" => PremiumPageBlobAccessTier::P4,
            "P40" => PremiumPageBlobAccessTier::P40,
            "P50" => PremiumPageBlobAccessTier::P50,
            "P6" => PremiumPageBlobAccessTier::P6,
            "P60" => PremiumPageBlobAccessTier::P60,
            "P70" => PremiumPageBlobAccessTier::P70,
            "P80" => PremiumPageBlobAccessTier::P80,
            _ => PremiumPageBlobAccessTier::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PremiumPageBlobAccessTier {
    fn as_ref(&self) -> &str {
        match self {
            PremiumPageBlobAccessTier::P10 => "P10",
            PremiumPageBlobAccessTier::P15 => "P15",
            PremiumPageBlobAccessTier::P20 => "P20",
            PremiumPageBlobAccessTier::P30 => "P30",
            PremiumPageBlobAccessTier::P4 => "P4",
            PremiumPageBlobAccessTier::P40 => "P40",
            PremiumPageBlobAccessTier::P50 => "P50",
            PremiumPageBlobAccessTier::P6 => "P6",
            PremiumPageBlobAccessTier::P60 => "P60",
            PremiumPageBlobAccessTier::P70 => "P70",
            PremiumPageBlobAccessTier::P80 => "P80",
            PremiumPageBlobAccessTier::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PremiumPageBlobAccessTier {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PremiumPageBlobAccessTier::P10 => f.write_str("P10"),
            PremiumPageBlobAccessTier::P15 => f.write_str("P15"),
            PremiumPageBlobAccessTier::P20 => f.write_str("P20"),
            PremiumPageBlobAccessTier::P30 => f.write_str("P30"),
            PremiumPageBlobAccessTier::P4 => f.write_str("P4"),
            PremiumPageBlobAccessTier::P40 => f.write_str("P40"),
            PremiumPageBlobAccessTier::P50 => f.write_str("P50"),
            PremiumPageBlobAccessTier::P6 => f.write_str("P6"),
            PremiumPageBlobAccessTier::P60 => f.write_str("P60"),
            PremiumPageBlobAccessTier::P70 => f.write_str("P70"),
            PremiumPageBlobAccessTier::P80 => f.write_str("P80"),
            PremiumPageBlobAccessTier::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a PublicAccessType> for &'a str {
    fn from(e: &'a PublicAccessType) -> Self {
        match e {
            PublicAccessType::Blob => "blob",
            PublicAccessType::Container => "container",
            PublicAccessType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PublicAccessType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "blob" => PublicAccessType::Blob,
            "container" => PublicAccessType::Container,
            _ => PublicAccessType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PublicAccessType {
    fn as_ref(&self) -> &str {
        match self {
            PublicAccessType::Blob => "blob",
            PublicAccessType::Container => "container",
            PublicAccessType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PublicAccessType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PublicAccessType::Blob => f.write_str("blob"),
            PublicAccessType::Container => f.write_str("container"),
            PublicAccessType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for QueryRequestType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "SQL" => QueryRequestType::Sql,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of QueryRequestType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for QueryRequestType {
    fn as_ref(&self) -> &str {
        match self {
            QueryRequestType::Sql => "SQL",
        }
    }
}

impl Display for QueryRequestType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            QueryRequestType::Sql => Display::fmt("SQL", f),
        }
    }
}

impl FromStr for QueryType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "arrow" => QueryType::Arrow,
            "delimited" => QueryType::Delimited,
            "json" => QueryType::Json,
            "parquet" => QueryType::Parquet,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of QueryType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for QueryType {
    fn as_ref(&self) -> &str {
        match self {
            QueryType::Arrow => "arrow",
            QueryType::Delimited => "delimited",
            QueryType::Json => "json",
            QueryType::Parquet => "parquet",
        }
    }
}

impl Display for QueryType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            QueryType::Arrow => Display::fmt("arrow", f),
            QueryType::Delimited => Display::fmt("delimited", f),
            QueryType::Json => Display::fmt("json", f),
            QueryType::Parquet => Display::fmt("parquet", f),
        }
    }
}

impl<'a> From<&'a RehydratePriority> for &'a str {
    fn from(e: &'a RehydratePriority) -> Self {
        match e {
            RehydratePriority::High => "High",
            RehydratePriority::Standard => "Standard",
            RehydratePriority::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for RehydratePriority {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "High" => RehydratePriority::High,
            "Standard" => RehydratePriority::Standard,
            _ => RehydratePriority::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for RehydratePriority {
    fn as_ref(&self) -> &str {
        match self {
            RehydratePriority::High => "High",
            RehydratePriority::Standard => "Standard",
            RehydratePriority::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for RehydratePriority {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            RehydratePriority::High => f.write_str("High"),
            RehydratePriority::Standard => f.write_str("Standard"),
            RehydratePriority::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for SequenceNumberActionType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "increment" => SequenceNumberActionType::Increment,
            "max" => SequenceNumberActionType::Max,
            "update" => SequenceNumberActionType::Update,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of SequenceNumberActionType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for SequenceNumberActionType {
    fn as_ref(&self) -> &str {
        match self {
            SequenceNumberActionType::Increment => "increment",
            SequenceNumberActionType::Max => "max",
            SequenceNumberActionType::Update => "update",
        }
    }
}

impl Display for SequenceNumberActionType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SequenceNumberActionType::Increment => Display::fmt("increment", f),
            SequenceNumberActionType::Max => Display::fmt("max", f),
            SequenceNumberActionType::Update => Display::fmt("update", f),
        }
    }
}

impl FromStr for SkuName {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Premium_LRS" => SkuName::PremiumLrs,
            "Standard_GRS" => SkuName::StandardGrs,
            "Standard_LRS" => SkuName::StandardLrs,
            "Standard_RAGRS" => SkuName::StandardRagrs,
            "Standard_ZRS" => SkuName::StandardZrs,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of SkuName found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for SkuName {
    fn as_ref(&self) -> &str {
        match self {
            SkuName::PremiumLrs => "Premium_LRS",
            SkuName::StandardGrs => "Standard_GRS",
            SkuName::StandardLrs => "Standard_LRS",
            SkuName::StandardRagrs => "Standard_RAGRS",
            SkuName::StandardZrs => "Standard_ZRS",
        }
    }
}

impl Display for SkuName {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SkuName::PremiumLrs => Display::fmt("Premium_LRS", f),
            SkuName::StandardGrs => Display::fmt("Standard_GRS", f),
            SkuName::StandardLrs => Display::fmt("Standard_LRS", f),
            SkuName::StandardRagrs => Display::fmt("Standard_RAGRS", f),
            SkuName::StandardZrs => Display::fmt("Standard_ZRS", f),
        }
    }
}

impl<'a> From<&'a StorageErrorCode> for &'a str {
    fn from(e: &'a StorageErrorCode) -> Self {
        match e {
            StorageErrorCode::AccountAlreadyExists => "AccountAlreadyExists",
            StorageErrorCode::AccountBeingCreated => "AccountBeingCreated",
            StorageErrorCode::AccountIsDisabled => "AccountIsDisabled",
            StorageErrorCode::AppendPositionConditionNotMet => "AppendPositionConditionNotMet",
            StorageErrorCode::AuthenticationFailed => "AuthenticationFailed",
            StorageErrorCode::AuthorizationFailure => "AuthorizationFailure",
            StorageErrorCode::AuthorizationPermissionMismatch => "AuthorizationPermissionMismatch",
            StorageErrorCode::AuthorizationProtocolMismatch => "AuthorizationProtocolMismatch",
            StorageErrorCode::AuthorizationResourceTypeMismatch => {
                "AuthorizationResourceTypeMismatch"
            }
            StorageErrorCode::AuthorizationServiceMismatch => "AuthorizationServiceMismatch",
            StorageErrorCode::AuthorizationSourceIPMismatch => "AuthorizationSourceIPMismatch",
            StorageErrorCode::BlobAccessTierNotSupportedForAccountType => {
                "BlobAccessTierNotSupportedForAccountType"
            }
            StorageErrorCode::BlobAlreadyExists => "BlobAlreadyExists",
            StorageErrorCode::BlobArchived => "BlobArchived",
            StorageErrorCode::BlobBeingRehydrated => "BlobBeingRehydrated",
            StorageErrorCode::BlobImmutableDueToPolicy => "BlobImmutableDueToPolicy",
            StorageErrorCode::BlobNotArchived => "BlobNotArchived",
            StorageErrorCode::BlobNotFound => "BlobNotFound",
            StorageErrorCode::BlobOverwritten => "BlobOverwritten",
            StorageErrorCode::BlobTierInadequateForContentLength => {
                "BlobTierInadequateForContentLength"
            }
            StorageErrorCode::BlobUsesCustomerSpecifiedEncryption => {
                "BlobUsesCustomerSpecifiedEncryption"
            }
            StorageErrorCode::BlockCountExceedsLimit => "BlockCountExceedsLimit",
            StorageErrorCode::BlockListTooLong => "BlockListTooLong",
            StorageErrorCode::CannotChangeToLowerTier => "CannotChangeToLowerTier",
            StorageErrorCode::CannotVerifyCopySource => "CannotVerifyCopySource",
            StorageErrorCode::ConditionHeadersNotSupported => "ConditionHeadersNotSupported",
            StorageErrorCode::ConditionNotMet => "ConditionNotMet",
            StorageErrorCode::ContainerAlreadyExists => "ContainerAlreadyExists",
            StorageErrorCode::ContainerBeingDeleted => "ContainerBeingDeleted",
            StorageErrorCode::ContainerDisabled => "ContainerDisabled",
            StorageErrorCode::ContainerNotFound => "ContainerNotFound",
            StorageErrorCode::ContentLengthLargerThanTierLimit => {
                "ContentLengthLargerThanTierLimit"
            }
            StorageErrorCode::CopyAcrossAccountsNotSupported => "CopyAcrossAccountsNotSupported",
            StorageErrorCode::CopyIdMismatch => "CopyIdMismatch",
            StorageErrorCode::EmptyMetadataKey => "EmptyMetadataKey",
            StorageErrorCode::FeatureVersionMismatch => "FeatureVersionMismatch",
            StorageErrorCode::IncrementalCopyBlobMismatch => "IncrementalCopyBlobMismatch",
            StorageErrorCode::IncrementalCopyOfEarlierVersionSnapshotNotAllowed => {
                "IncrementalCopyOfEarlierVersionSnapshotNotAllowed"
            }
            StorageErrorCode::IncrementalCopySourceMustBeSnapshot => {
                "IncrementalCopySourceMustBeSnapshot"
            }
            StorageErrorCode::InfiniteLeaseDurationRequired => "InfiniteLeaseDurationRequired",
            StorageErrorCode::InsufficientAccountPermissions => "InsufficientAccountPermissions",
            StorageErrorCode::InternalError => "InternalError",
            StorageErrorCode::InvalidAuthenticationInfo => "InvalidAuthenticationInfo",
            StorageErrorCode::InvalidBlobOrBlock => "InvalidBlobOrBlock",
            StorageErrorCode::InvalidBlobTier => "InvalidBlobTier",
            StorageErrorCode::InvalidBlobType => "InvalidBlobType",
            StorageErrorCode::InvalidBlockId => "InvalidBlockId",
            StorageErrorCode::InvalidBlockList => "InvalidBlockList",
            StorageErrorCode::InvalidHeaderValue => "InvalidHeaderValue",
            StorageErrorCode::InvalidHttpVerb => "InvalidHttpVerb",
            StorageErrorCode::InvalidInput => "InvalidInput",
            StorageErrorCode::InvalidMd5 => "InvalidMd5",
            StorageErrorCode::InvalidMetadata => "InvalidMetadata",
            StorageErrorCode::InvalidOperation => "InvalidOperation",
            StorageErrorCode::InvalidPageRange => "InvalidPageRange",
            StorageErrorCode::InvalidQueryParameterValue => "InvalidQueryParameterValue",
            StorageErrorCode::InvalidRange => "InvalidRange",
            StorageErrorCode::InvalidRequestUrl => "InvalidRequestUrl",
            StorageErrorCode::InvalidSourceBlobType => "InvalidSourceBlobType",
            StorageErrorCode::InvalidSourceBlobUrl => "InvalidSourceBlobUrl",
            StorageErrorCode::InvalidUri => "InvalidUri",
            StorageErrorCode::InvalidVersionForPageBlobOperation => {
                "InvalidVersionForPageBlobOperation"
            }
            StorageErrorCode::InvalidXmlDocument => "InvalidXmlDocument",
            StorageErrorCode::InvalidXmlNodeValue => "InvalidXmlNodeValue",
            StorageErrorCode::LeaseAlreadyBroken => "LeaseAlreadyBroken",
            StorageErrorCode::LeaseAlreadyPresent => "LeaseAlreadyPresent",
            StorageErrorCode::LeaseIdMismatchWithBlobOperation => {
                "LeaseIdMismatchWithBlobOperation"
            }
            StorageErrorCode::LeaseIdMismatchWithContainerOperation => {
                "LeaseIdMismatchWithContainerOperation"
            }
            StorageErrorCode::LeaseIdMismatchWithLeaseOperation => {
                "LeaseIdMismatchWithLeaseOperation"
            }
            StorageErrorCode::LeaseIdMissing => "LeaseIdMissing",
            StorageErrorCode::LeaseIsBreakingAndCannotBeAcquired => {
                "LeaseIsBreakingAndCannotBeAcquired"
            }
            StorageErrorCode::LeaseIsBreakingAndCannotBeChanged => {
                "LeaseIsBreakingAndCannotBeChanged"
            }
            StorageErrorCode::LeaseIsBrokenAndCannotBeRenewed => "LeaseIsBrokenAndCannotBeRenewed",
            StorageErrorCode::LeaseLost => "LeaseLost",
            StorageErrorCode::LeaseNotPresentWithBlobOperation => {
                "LeaseNotPresentWithBlobOperation"
            }
            StorageErrorCode::LeaseNotPresentWithContainerOperation => {
                "LeaseNotPresentWithContainerOperation"
            }
            StorageErrorCode::LeaseNotPresentWithLeaseOperation => {
                "LeaseNotPresentWithLeaseOperation"
            }
            StorageErrorCode::MaxBlobSizeConditionNotMet => "MaxBlobSizeConditionNotMet",
            StorageErrorCode::Md5Mismatch => "Md5Mismatch",
            StorageErrorCode::MetadataTooLarge => "MetadataTooLarge",
            StorageErrorCode::MissingContentLengthHeader => "MissingContentLengthHeader",
            StorageErrorCode::MissingRequiredHeader => "MissingRequiredHeader",
            StorageErrorCode::MissingRequiredQueryParameter => "MissingRequiredQueryParameter",
            StorageErrorCode::MissingRequiredXmlNode => "MissingRequiredXmlNode",
            StorageErrorCode::MultipleConditionHeadersNotSupported => {
                "MultipleConditionHeadersNotSupported"
            }
            StorageErrorCode::NoPendingCopyOperation => "NoPendingCopyOperation",
            StorageErrorCode::OperationNotAllowedOnIncrementalCopyBlob => {
                "OperationNotAllowedOnIncrementalCopyBlob"
            }
            StorageErrorCode::OperationTimedOut => "OperationTimedOut",
            StorageErrorCode::OutOfRangeInput => "OutOfRangeInput",
            StorageErrorCode::OutOfRangeQueryParameterValue => "OutOfRangeQueryParameterValue",
            StorageErrorCode::PendingCopyOperation => "PendingCopyOperation",
            StorageErrorCode::PreviousSnapshotCannotBeNewer => "PreviousSnapshotCannotBeNewer",
            StorageErrorCode::PreviousSnapshotNotFound => "PreviousSnapshotNotFound",
            StorageErrorCode::PreviousSnapshotOperationNotSupported => {
                "PreviousSnapshotOperationNotSupported"
            }
            StorageErrorCode::RequestBodyTooLarge => "RequestBodyTooLarge",
            StorageErrorCode::RequestUrlFailedToParse => "RequestUrlFailedToParse",
            StorageErrorCode::ResourceAlreadyExists => "ResourceAlreadyExists",
            StorageErrorCode::ResourceNotFound => "ResourceNotFound",
            StorageErrorCode::ResourceTypeMismatch => "ResourceTypeMismatch",
            StorageErrorCode::SequenceNumberConditionNotMet => "SequenceNumberConditionNotMet",
            StorageErrorCode::SequenceNumberIncrementTooLarge => "SequenceNumberIncrementTooLarge",
            StorageErrorCode::ServerBusy => "ServerBusy",
            StorageErrorCode::SnapshotCountExceeded => "SnapshotCountExceeded",
            StorageErrorCode::SnapshotOperationRateExceeded => "SnapshotOperationRateExceeded",
            StorageErrorCode::SnapshotsPresent => "SnapshotsPresent",
            StorageErrorCode::SourceConditionNotMet => "SourceConditionNotMet",
            StorageErrorCode::SystemInUse => "SystemInUse",
            StorageErrorCode::TargetConditionNotMet => "TargetConditionNotMet",
            StorageErrorCode::UnauthorizedBlobOverwrite => "UnauthorizedBlobOverwrite",
            StorageErrorCode::UnsupportedHeader => "UnsupportedHeader",
            StorageErrorCode::UnsupportedHttpVerb => "UnsupportedHttpVerb",
            StorageErrorCode::UnsupportedQueryParameter => "UnsupportedQueryParameter",
            StorageErrorCode::UnsupportedXmlNode => "UnsupportedXmlNode",
            StorageErrorCode::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for StorageErrorCode {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AccountAlreadyExists" => StorageErrorCode::AccountAlreadyExists,
            "AccountBeingCreated" => StorageErrorCode::AccountBeingCreated,
            "AccountIsDisabled" => StorageErrorCode::AccountIsDisabled,
            "AppendPositionConditionNotMet" => StorageErrorCode::AppendPositionConditionNotMet,
            "AuthenticationFailed" => StorageErrorCode::AuthenticationFailed,
            "AuthorizationFailure" => StorageErrorCode::AuthorizationFailure,
            "AuthorizationPermissionMismatch" => StorageErrorCode::AuthorizationPermissionMismatch,
            "AuthorizationProtocolMismatch" => StorageErrorCode::AuthorizationProtocolMismatch,
            "AuthorizationResourceTypeMismatch" => {
                StorageErrorCode::AuthorizationResourceTypeMismatch
            }
            "AuthorizationServiceMismatch" => StorageErrorCode::AuthorizationServiceMismatch,
            "AuthorizationSourceIPMismatch" => StorageErrorCode::AuthorizationSourceIPMismatch,
            "BlobAccessTierNotSupportedForAccountType" => {
                StorageErrorCode::BlobAccessTierNotSupportedForAccountType
            }
            "BlobAlreadyExists" => StorageErrorCode::BlobAlreadyExists,
            "BlobArchived" => StorageErrorCode::BlobArchived,
            "BlobBeingRehydrated" => StorageErrorCode::BlobBeingRehydrated,
            "BlobImmutableDueToPolicy" => StorageErrorCode::BlobImmutableDueToPolicy,
            "BlobNotArchived" => StorageErrorCode::BlobNotArchived,
            "BlobNotFound" => StorageErrorCode::BlobNotFound,
            "BlobOverwritten" => StorageErrorCode::BlobOverwritten,
            "BlobTierInadequateForContentLength" => {
                StorageErrorCode::BlobTierInadequateForContentLength
            }
            "BlobUsesCustomerSpecifiedEncryption" => {
                StorageErrorCode::BlobUsesCustomerSpecifiedEncryption
            }
            "BlockCountExceedsLimit" => StorageErrorCode::BlockCountExceedsLimit,
            "BlockListTooLong" => StorageErrorCode::BlockListTooLong,
            "CannotChangeToLowerTier" => StorageErrorCode::CannotChangeToLowerTier,
            "CannotVerifyCopySource" => StorageErrorCode::CannotVerifyCopySource,
            "ConditionHeadersNotSupported" => StorageErrorCode::ConditionHeadersNotSupported,
            "ConditionNotMet" => StorageErrorCode::ConditionNotMet,
            "ContainerAlreadyExists" => StorageErrorCode::ContainerAlreadyExists,
            "ContainerBeingDeleted" => StorageErrorCode::ContainerBeingDeleted,
            "ContainerDisabled" => StorageErrorCode::ContainerDisabled,
            "ContainerNotFound" => StorageErrorCode::ContainerNotFound,
            "ContentLengthLargerThanTierLimit" => {
                StorageErrorCode::ContentLengthLargerThanTierLimit
            }
            "CopyAcrossAccountsNotSupported" => StorageErrorCode::CopyAcrossAccountsNotSupported,
            "CopyIdMismatch" => StorageErrorCode::CopyIdMismatch,
            "EmptyMetadataKey" => StorageErrorCode::EmptyMetadataKey,
            "FeatureVersionMismatch" => StorageErrorCode::FeatureVersionMismatch,
            "IncrementalCopyBlobMismatch" => StorageErrorCode::IncrementalCopyBlobMismatch,
            "IncrementalCopyOfEarlierVersionSnapshotNotAllowed" => {
                StorageErrorCode::IncrementalCopyOfEarlierVersionSnapshotNotAllowed
            }
            "IncrementalCopySourceMustBeSnapshot" => {
                StorageErrorCode::IncrementalCopySourceMustBeSnapshot
            }
            "InfiniteLeaseDurationRequired" => StorageErrorCode::InfiniteLeaseDurationRequired,
            "InsufficientAccountPermissions" => StorageErrorCode::InsufficientAccountPermissions,
            "InternalError" => StorageErrorCode::InternalError,
            "InvalidAuthenticationInfo" => StorageErrorCode::InvalidAuthenticationInfo,
            "InvalidBlobOrBlock" => StorageErrorCode::InvalidBlobOrBlock,
            "InvalidBlobTier" => StorageErrorCode::InvalidBlobTier,
            "InvalidBlobType" => StorageErrorCode::InvalidBlobType,
            "InvalidBlockId" => StorageErrorCode::InvalidBlockId,
            "InvalidBlockList" => StorageErrorCode::InvalidBlockList,
            "InvalidHeaderValue" => StorageErrorCode::InvalidHeaderValue,
            "InvalidHttpVerb" => StorageErrorCode::InvalidHttpVerb,
            "InvalidInput" => StorageErrorCode::InvalidInput,
            "InvalidMd5" => StorageErrorCode::InvalidMd5,
            "InvalidMetadata" => StorageErrorCode::InvalidMetadata,
            "InvalidOperation" => StorageErrorCode::InvalidOperation,
            "InvalidPageRange" => StorageErrorCode::InvalidPageRange,
            "InvalidQueryParameterValue" => StorageErrorCode::InvalidQueryParameterValue,
            "InvalidRange" => StorageErrorCode::InvalidRange,
            "InvalidRequestUrl" => StorageErrorCode::InvalidRequestUrl,
            "InvalidSourceBlobType" => StorageErrorCode::InvalidSourceBlobType,
            "InvalidSourceBlobUrl" => StorageErrorCode::InvalidSourceBlobUrl,
            "InvalidUri" => StorageErrorCode::InvalidUri,
            "InvalidVersionForPageBlobOperation" => {
                StorageErrorCode::InvalidVersionForPageBlobOperation
            }
            "InvalidXmlDocument" => StorageErrorCode::InvalidXmlDocument,
            "InvalidXmlNodeValue" => StorageErrorCode::InvalidXmlNodeValue,
            "LeaseAlreadyBroken" => StorageErrorCode::LeaseAlreadyBroken,
            "LeaseAlreadyPresent" => StorageErrorCode::LeaseAlreadyPresent,
            "LeaseIdMismatchWithBlobOperation" => {
                StorageErrorCode::LeaseIdMismatchWithBlobOperation
            }
            "LeaseIdMismatchWithContainerOperation" => {
                StorageErrorCode::LeaseIdMismatchWithContainerOperation
            }
            "LeaseIdMismatchWithLeaseOperation" => {
                StorageErrorCode::LeaseIdMismatchWithLeaseOperation
            }
            "LeaseIdMissing" => StorageErrorCode::LeaseIdMissing,
            "LeaseIsBreakingAndCannotBeAcquired" => {
                StorageErrorCode::LeaseIsBreakingAndCannotBeAcquired
            }
            "LeaseIsBreakingAndCannotBeChanged" => {
                StorageErrorCode::LeaseIsBreakingAndCannotBeChanged
            }
            "LeaseIsBrokenAndCannotBeRenewed" => StorageErrorCode::LeaseIsBrokenAndCannotBeRenewed,
            "LeaseLost" => StorageErrorCode::LeaseLost,
            "LeaseNotPresentWithBlobOperation" => {
                StorageErrorCode::LeaseNotPresentWithBlobOperation
            }
            "LeaseNotPresentWithContainerOperation" => {
                StorageErrorCode::LeaseNotPresentWithContainerOperation
            }
            "LeaseNotPresentWithLeaseOperation" => {
                StorageErrorCode::LeaseNotPresentWithLeaseOperation
            }
            "MaxBlobSizeConditionNotMet" => StorageErrorCode::MaxBlobSizeConditionNotMet,
            "Md5Mismatch" => StorageErrorCode::Md5Mismatch,
            "MetadataTooLarge" => StorageErrorCode::MetadataTooLarge,
            "MissingContentLengthHeader" => StorageErrorCode::MissingContentLengthHeader,
            "MissingRequiredHeader" => StorageErrorCode::MissingRequiredHeader,
            "MissingRequiredQueryParameter" => StorageErrorCode::MissingRequiredQueryParameter,
            "MissingRequiredXmlNode" => StorageErrorCode::MissingRequiredXmlNode,
            "MultipleConditionHeadersNotSupported" => {
                StorageErrorCode::MultipleConditionHeadersNotSupported
            }
            "NoPendingCopyOperation" => StorageErrorCode::NoPendingCopyOperation,
            "OperationNotAllowedOnIncrementalCopyBlob" => {
                StorageErrorCode::OperationNotAllowedOnIncrementalCopyBlob
            }
            "OperationTimedOut" => StorageErrorCode::OperationTimedOut,
            "OutOfRangeInput" => StorageErrorCode::OutOfRangeInput,
            "OutOfRangeQueryParameterValue" => StorageErrorCode::OutOfRangeQueryParameterValue,
            "PendingCopyOperation" => StorageErrorCode::PendingCopyOperation,
            "PreviousSnapshotCannotBeNewer" => StorageErrorCode::PreviousSnapshotCannotBeNewer,
            "PreviousSnapshotNotFound" => StorageErrorCode::PreviousSnapshotNotFound,
            "PreviousSnapshotOperationNotSupported" => {
                StorageErrorCode::PreviousSnapshotOperationNotSupported
            }
            "RequestBodyTooLarge" => StorageErrorCode::RequestBodyTooLarge,
            "RequestUrlFailedToParse" => StorageErrorCode::RequestUrlFailedToParse,
            "ResourceAlreadyExists" => StorageErrorCode::ResourceAlreadyExists,
            "ResourceNotFound" => StorageErrorCode::ResourceNotFound,
            "ResourceTypeMismatch" => StorageErrorCode::ResourceTypeMismatch,
            "SequenceNumberConditionNotMet" => StorageErrorCode::SequenceNumberConditionNotMet,
            "SequenceNumberIncrementTooLarge" => StorageErrorCode::SequenceNumberIncrementTooLarge,
            "ServerBusy" => StorageErrorCode::ServerBusy,
            "SnapshotCountExceeded" => StorageErrorCode::SnapshotCountExceeded,
            "SnapshotOperationRateExceeded" => StorageErrorCode::SnapshotOperationRateExceeded,
            "SnapshotsPresent" => StorageErrorCode::SnapshotsPresent,
            "SourceConditionNotMet" => StorageErrorCode::SourceConditionNotMet,
            "SystemInUse" => StorageErrorCode::SystemInUse,
            "TargetConditionNotMet" => StorageErrorCode::TargetConditionNotMet,
            "UnauthorizedBlobOverwrite" => StorageErrorCode::UnauthorizedBlobOverwrite,
            "UnsupportedHeader" => StorageErrorCode::UnsupportedHeader,
            "UnsupportedHttpVerb" => StorageErrorCode::UnsupportedHttpVerb,
            "UnsupportedQueryParameter" => StorageErrorCode::UnsupportedQueryParameter,
            "UnsupportedXmlNode" => StorageErrorCode::UnsupportedXmlNode,
            _ => StorageErrorCode::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for StorageErrorCode {
    fn as_ref(&self) -> &str {
        match self {
            StorageErrorCode::AccountAlreadyExists => "AccountAlreadyExists",
            StorageErrorCode::AccountBeingCreated => "AccountBeingCreated",
            StorageErrorCode::AccountIsDisabled => "AccountIsDisabled",
            StorageErrorCode::AppendPositionConditionNotMet => "AppendPositionConditionNotMet",
            StorageErrorCode::AuthenticationFailed => "AuthenticationFailed",
            StorageErrorCode::AuthorizationFailure => "AuthorizationFailure",
            StorageErrorCode::AuthorizationPermissionMismatch => "AuthorizationPermissionMismatch",
            StorageErrorCode::AuthorizationProtocolMismatch => "AuthorizationProtocolMismatch",
            StorageErrorCode::AuthorizationResourceTypeMismatch => {
                "AuthorizationResourceTypeMismatch"
            }
            StorageErrorCode::AuthorizationServiceMismatch => "AuthorizationServiceMismatch",
            StorageErrorCode::AuthorizationSourceIPMismatch => "AuthorizationSourceIPMismatch",
            StorageErrorCode::BlobAccessTierNotSupportedForAccountType => {
                "BlobAccessTierNotSupportedForAccountType"
            }
            StorageErrorCode::BlobAlreadyExists => "BlobAlreadyExists",
            StorageErrorCode::BlobArchived => "BlobArchived",
            StorageErrorCode::BlobBeingRehydrated => "BlobBeingRehydrated",
            StorageErrorCode::BlobImmutableDueToPolicy => "BlobImmutableDueToPolicy",
            StorageErrorCode::BlobNotArchived => "BlobNotArchived",
            StorageErrorCode::BlobNotFound => "BlobNotFound",
            StorageErrorCode::BlobOverwritten => "BlobOverwritten",
            StorageErrorCode::BlobTierInadequateForContentLength => {
                "BlobTierInadequateForContentLength"
            }
            StorageErrorCode::BlobUsesCustomerSpecifiedEncryption => {
                "BlobUsesCustomerSpecifiedEncryption"
            }
            StorageErrorCode::BlockCountExceedsLimit => "BlockCountExceedsLimit",
            StorageErrorCode::BlockListTooLong => "BlockListTooLong",
            StorageErrorCode::CannotChangeToLowerTier => "CannotChangeToLowerTier",
            StorageErrorCode::CannotVerifyCopySource => "CannotVerifyCopySource",
            StorageErrorCode::ConditionHeadersNotSupported => "ConditionHeadersNotSupported",
            StorageErrorCode::ConditionNotMet => "ConditionNotMet",
            StorageErrorCode::ContainerAlreadyExists => "ContainerAlreadyExists",
            StorageErrorCode::ContainerBeingDeleted => "ContainerBeingDeleted",
            StorageErrorCode::ContainerDisabled => "ContainerDisabled",
            StorageErrorCode::ContainerNotFound => "ContainerNotFound",
            StorageErrorCode::ContentLengthLargerThanTierLimit => {
                "ContentLengthLargerThanTierLimit"
            }
            StorageErrorCode::CopyAcrossAccountsNotSupported => "CopyAcrossAccountsNotSupported",
            StorageErrorCode::CopyIdMismatch => "CopyIdMismatch",
            StorageErrorCode::EmptyMetadataKey => "EmptyMetadataKey",
            StorageErrorCode::FeatureVersionMismatch => "FeatureVersionMismatch",
            StorageErrorCode::IncrementalCopyBlobMismatch => "IncrementalCopyBlobMismatch",
            StorageErrorCode::IncrementalCopyOfEarlierVersionSnapshotNotAllowed => {
                "IncrementalCopyOfEarlierVersionSnapshotNotAllowed"
            }
            StorageErrorCode::IncrementalCopySourceMustBeSnapshot => {
                "IncrementalCopySourceMustBeSnapshot"
            }
            StorageErrorCode::InfiniteLeaseDurationRequired => "InfiniteLeaseDurationRequired",
            StorageErrorCode::InsufficientAccountPermissions => "InsufficientAccountPermissions",
            StorageErrorCode::InternalError => "InternalError",
            StorageErrorCode::InvalidAuthenticationInfo => "InvalidAuthenticationInfo",
            StorageErrorCode::InvalidBlobOrBlock => "InvalidBlobOrBlock",
            StorageErrorCode::InvalidBlobTier => "InvalidBlobTier",
            StorageErrorCode::InvalidBlobType => "InvalidBlobType",
            StorageErrorCode::InvalidBlockId => "InvalidBlockId",
            StorageErrorCode::InvalidBlockList => "InvalidBlockList",
            StorageErrorCode::InvalidHeaderValue => "InvalidHeaderValue",
            StorageErrorCode::InvalidHttpVerb => "InvalidHttpVerb",
            StorageErrorCode::InvalidInput => "InvalidInput",
            StorageErrorCode::InvalidMd5 => "InvalidMd5",
            StorageErrorCode::InvalidMetadata => "InvalidMetadata",
            StorageErrorCode::InvalidOperation => "InvalidOperation",
            StorageErrorCode::InvalidPageRange => "InvalidPageRange",
            StorageErrorCode::InvalidQueryParameterValue => "InvalidQueryParameterValue",
            StorageErrorCode::InvalidRange => "InvalidRange",
            StorageErrorCode::InvalidRequestUrl => "InvalidRequestUrl",
            StorageErrorCode::InvalidSourceBlobType => "InvalidSourceBlobType",
            StorageErrorCode::InvalidSourceBlobUrl => "InvalidSourceBlobUrl",
            StorageErrorCode::InvalidUri => "InvalidUri",
            StorageErrorCode::InvalidVersionForPageBlobOperation => {
                "InvalidVersionForPageBlobOperation"
            }
            StorageErrorCode::InvalidXmlDocument => "InvalidXmlDocument",
            StorageErrorCode::InvalidXmlNodeValue => "InvalidXmlNodeValue",
            StorageErrorCode::LeaseAlreadyBroken => "LeaseAlreadyBroken",
            StorageErrorCode::LeaseAlreadyPresent => "LeaseAlreadyPresent",
            StorageErrorCode::LeaseIdMismatchWithBlobOperation => {
                "LeaseIdMismatchWithBlobOperation"
            }
            StorageErrorCode::LeaseIdMismatchWithContainerOperation => {
                "LeaseIdMismatchWithContainerOperation"
            }
            StorageErrorCode::LeaseIdMismatchWithLeaseOperation => {
                "LeaseIdMismatchWithLeaseOperation"
            }
            StorageErrorCode::LeaseIdMissing => "LeaseIdMissing",
            StorageErrorCode::LeaseIsBreakingAndCannotBeAcquired => {
                "LeaseIsBreakingAndCannotBeAcquired"
            }
            StorageErrorCode::LeaseIsBreakingAndCannotBeChanged => {
                "LeaseIsBreakingAndCannotBeChanged"
            }
            StorageErrorCode::LeaseIsBrokenAndCannotBeRenewed => "LeaseIsBrokenAndCannotBeRenewed",
            StorageErrorCode::LeaseLost => "LeaseLost",
            StorageErrorCode::LeaseNotPresentWithBlobOperation => {
                "LeaseNotPresentWithBlobOperation"
            }
            StorageErrorCode::LeaseNotPresentWithContainerOperation => {
                "LeaseNotPresentWithContainerOperation"
            }
            StorageErrorCode::LeaseNotPresentWithLeaseOperation => {
                "LeaseNotPresentWithLeaseOperation"
            }
            StorageErrorCode::MaxBlobSizeConditionNotMet => "MaxBlobSizeConditionNotMet",
            StorageErrorCode::Md5Mismatch => "Md5Mismatch",
            StorageErrorCode::MetadataTooLarge => "MetadataTooLarge",
            StorageErrorCode::MissingContentLengthHeader => "MissingContentLengthHeader",
            StorageErrorCode::MissingRequiredHeader => "MissingRequiredHeader",
            StorageErrorCode::MissingRequiredQueryParameter => "MissingRequiredQueryParameter",
            StorageErrorCode::MissingRequiredXmlNode => "MissingRequiredXmlNode",
            StorageErrorCode::MultipleConditionHeadersNotSupported => {
                "MultipleConditionHeadersNotSupported"
            }
            StorageErrorCode::NoPendingCopyOperation => "NoPendingCopyOperation",
            StorageErrorCode::OperationNotAllowedOnIncrementalCopyBlob => {
                "OperationNotAllowedOnIncrementalCopyBlob"
            }
            StorageErrorCode::OperationTimedOut => "OperationTimedOut",
            StorageErrorCode::OutOfRangeInput => "OutOfRangeInput",
            StorageErrorCode::OutOfRangeQueryParameterValue => "OutOfRangeQueryParameterValue",
            StorageErrorCode::PendingCopyOperation => "PendingCopyOperation",
            StorageErrorCode::PreviousSnapshotCannotBeNewer => "PreviousSnapshotCannotBeNewer",
            StorageErrorCode::PreviousSnapshotNotFound => "PreviousSnapshotNotFound",
            StorageErrorCode::PreviousSnapshotOperationNotSupported => {
                "PreviousSnapshotOperationNotSupported"
            }
            StorageErrorCode::RequestBodyTooLarge => "RequestBodyTooLarge",
            StorageErrorCode::RequestUrlFailedToParse => "RequestUrlFailedToParse",
            StorageErrorCode::ResourceAlreadyExists => "ResourceAlreadyExists",
            StorageErrorCode::ResourceNotFound => "ResourceNotFound",
            StorageErrorCode::ResourceTypeMismatch => "ResourceTypeMismatch",
            StorageErrorCode::SequenceNumberConditionNotMet => "SequenceNumberConditionNotMet",
            StorageErrorCode::SequenceNumberIncrementTooLarge => "SequenceNumberIncrementTooLarge",
            StorageErrorCode::ServerBusy => "ServerBusy",
            StorageErrorCode::SnapshotCountExceeded => "SnapshotCountExceeded",
            StorageErrorCode::SnapshotOperationRateExceeded => "SnapshotOperationRateExceeded",
            StorageErrorCode::SnapshotsPresent => "SnapshotsPresent",
            StorageErrorCode::SourceConditionNotMet => "SourceConditionNotMet",
            StorageErrorCode::SystemInUse => "SystemInUse",
            StorageErrorCode::TargetConditionNotMet => "TargetConditionNotMet",
            StorageErrorCode::UnauthorizedBlobOverwrite => "UnauthorizedBlobOverwrite",
            StorageErrorCode::UnsupportedHeader => "UnsupportedHeader",
            StorageErrorCode::UnsupportedHttpVerb => "UnsupportedHttpVerb",
            StorageErrorCode::UnsupportedQueryParameter => "UnsupportedQueryParameter",
            StorageErrorCode::UnsupportedXmlNode => "UnsupportedXmlNode",
            StorageErrorCode::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for StorageErrorCode {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            StorageErrorCode::AccountAlreadyExists => f.write_str("AccountAlreadyExists"),
            StorageErrorCode::AccountBeingCreated => f.write_str("AccountBeingCreated"),
            StorageErrorCode::AccountIsDisabled => f.write_str("AccountIsDisabled"),
            StorageErrorCode::AppendPositionConditionNotMet => {
                f.write_str("AppendPositionConditionNotMet")
            }
            StorageErrorCode::AuthenticationFailed => f.write_str("AuthenticationFailed"),
            StorageErrorCode::AuthorizationFailure => f.write_str("AuthorizationFailure"),
            StorageErrorCode::AuthorizationPermissionMismatch => {
                f.write_str("AuthorizationPermissionMismatch")
            }
            StorageErrorCode::AuthorizationProtocolMismatch => {
                f.write_str("AuthorizationProtocolMismatch")
            }
            StorageErrorCode::AuthorizationResourceTypeMismatch => {
                f.write_str("AuthorizationResourceTypeMismatch")
            }
            StorageErrorCode::AuthorizationServiceMismatch => {
                f.write_str("AuthorizationServiceMismatch")
            }
            StorageErrorCode::AuthorizationSourceIPMismatch => {
                f.write_str("AuthorizationSourceIPMismatch")
            }
            StorageErrorCode::BlobAccessTierNotSupportedForAccountType => {
                f.write_str("BlobAccessTierNotSupportedForAccountType")
            }
            StorageErrorCode::BlobAlreadyExists => f.write_str("BlobAlreadyExists"),
            StorageErrorCode::BlobArchived => f.write_str("BlobArchived"),
            StorageErrorCode::BlobBeingRehydrated => f.write_str("BlobBeingRehydrated"),
            StorageErrorCode::BlobImmutableDueToPolicy => f.write_str("BlobImmutableDueToPolicy"),
            StorageErrorCode::BlobNotArchived => f.write_str("BlobNotArchived"),
            StorageErrorCode::BlobNotFound => f.write_str("BlobNotFound"),
            StorageErrorCode::BlobOverwritten => f.write_str("BlobOverwritten"),
            StorageErrorCode::BlobTierInadequateForContentLength => {
                f.write_str("BlobTierInadequateForContentLength")
            }
            StorageErrorCode::BlobUsesCustomerSpecifiedEncryption => {
                f.write_str("BlobUsesCustomerSpecifiedEncryption")
            }
            StorageErrorCode::BlockCountExceedsLimit => f.write_str("BlockCountExceedsLimit"),
            StorageErrorCode::BlockListTooLong => f.write_str("BlockListTooLong"),
            StorageErrorCode::CannotChangeToLowerTier => f.write_str("CannotChangeToLowerTier"),
            StorageErrorCode::CannotVerifyCopySource => f.write_str("CannotVerifyCopySource"),
            StorageErrorCode::ConditionHeadersNotSupported => {
                f.write_str("ConditionHeadersNotSupported")
            }
            StorageErrorCode::ConditionNotMet => f.write_str("ConditionNotMet"),
            StorageErrorCode::ContainerAlreadyExists => f.write_str("ContainerAlreadyExists"),
            StorageErrorCode::ContainerBeingDeleted => f.write_str("ContainerBeingDeleted"),
            StorageErrorCode::ContainerDisabled => f.write_str("ContainerDisabled"),
            StorageErrorCode::ContainerNotFound => f.write_str("ContainerNotFound"),
            StorageErrorCode::ContentLengthLargerThanTierLimit => {
                f.write_str("ContentLengthLargerThanTierLimit")
            }
            StorageErrorCode::CopyAcrossAccountsNotSupported => {
                f.write_str("CopyAcrossAccountsNotSupported")
            }
            StorageErrorCode::CopyIdMismatch => f.write_str("CopyIdMismatch"),
            StorageErrorCode::EmptyMetadataKey => f.write_str("EmptyMetadataKey"),
            StorageErrorCode::FeatureVersionMismatch => f.write_str("FeatureVersionMismatch"),
            StorageErrorCode::IncrementalCopyBlobMismatch => {
                f.write_str("IncrementalCopyBlobMismatch")
            }
            StorageErrorCode::IncrementalCopyOfEarlierVersionSnapshotNotAllowed => {
                f.write_str("IncrementalCopyOfEarlierVersionSnapshotNotAllowed")
            }
            StorageErrorCode::IncrementalCopySourceMustBeSnapshot => {
                f.write_str("IncrementalCopySourceMustBeSnapshot")
            }
            StorageErrorCode::InfiniteLeaseDurationRequired => {
                f.write_str("InfiniteLeaseDurationRequired")
            }
            StorageErrorCode::InsufficientAccountPermissions => {
                f.write_str("InsufficientAccountPermissions")
            }
            StorageErrorCode::InternalError => f.write_str("InternalError"),
            StorageErrorCode::InvalidAuthenticationInfo => f.write_str("InvalidAuthenticationInfo"),
            StorageErrorCode::InvalidBlobOrBlock => f.write_str("InvalidBlobOrBlock"),
            StorageErrorCode::InvalidBlobTier => f.write_str("InvalidBlobTier"),
            StorageErrorCode::InvalidBlobType => f.write_str("InvalidBlobType"),
            StorageErrorCode::InvalidBlockId => f.write_str("InvalidBlockId"),
            StorageErrorCode::InvalidBlockList => f.write_str("InvalidBlockList"),
            StorageErrorCode::InvalidHeaderValue => f.write_str("InvalidHeaderValue"),
            StorageErrorCode::InvalidHttpVerb => f.write_str("InvalidHttpVerb"),
            StorageErrorCode::InvalidInput => f.write_str("InvalidInput"),
            StorageErrorCode::InvalidMd5 => f.write_str("InvalidMd5"),
            StorageErrorCode::InvalidMetadata => f.write_str("InvalidMetadata"),
            StorageErrorCode::InvalidOperation => f.write_str("InvalidOperation"),
            StorageErrorCode::InvalidPageRange => f.write_str("InvalidPageRange"),
            StorageErrorCode::InvalidQueryParameterValue => {
                f.write_str("InvalidQueryParameterValue")
            }
            StorageErrorCode::InvalidRange => f.write_str("InvalidRange"),
            StorageErrorCode::InvalidRequestUrl => f.write_str("InvalidRequestUrl"),
            StorageErrorCode::InvalidSourceBlobType => f.write_str("InvalidSourceBlobType"),
            StorageErrorCode::InvalidSourceBlobUrl => f.write_str("InvalidSourceBlobUrl"),
            StorageErrorCode::InvalidUri => f.write_str("InvalidUri"),
            StorageErrorCode::InvalidVersionForPageBlobOperation => {
                f.write_str("InvalidVersionForPageBlobOperation")
            }
            StorageErrorCode::InvalidXmlDocument => f.write_str("InvalidXmlDocument"),
            StorageErrorCode::InvalidXmlNodeValue => f.write_str("InvalidXmlNodeValue"),
            StorageErrorCode::LeaseAlreadyBroken => f.write_str("LeaseAlreadyBroken"),
            StorageErrorCode::LeaseAlreadyPresent => f.write_str("LeaseAlreadyPresent"),
            StorageErrorCode::LeaseIdMismatchWithBlobOperation => {
                f.write_str("LeaseIdMismatchWithBlobOperation")
            }
            StorageErrorCode::LeaseIdMismatchWithContainerOperation => {
                f.write_str("LeaseIdMismatchWithContainerOperation")
            }
            StorageErrorCode::LeaseIdMismatchWithLeaseOperation => {
                f.write_str("LeaseIdMismatchWithLeaseOperation")
            }
            StorageErrorCode::LeaseIdMissing => f.write_str("LeaseIdMissing"),
            StorageErrorCode::LeaseIsBreakingAndCannotBeAcquired => {
                f.write_str("LeaseIsBreakingAndCannotBeAcquired")
            }
            StorageErrorCode::LeaseIsBreakingAndCannotBeChanged => {
                f.write_str("LeaseIsBreakingAndCannotBeChanged")
            }
            StorageErrorCode::LeaseIsBrokenAndCannotBeRenewed => {
                f.write_str("LeaseIsBrokenAndCannotBeRenewed")
            }
            StorageErrorCode::LeaseLost => f.write_str("LeaseLost"),
            StorageErrorCode::LeaseNotPresentWithBlobOperation => {
                f.write_str("LeaseNotPresentWithBlobOperation")
            }
            StorageErrorCode::LeaseNotPresentWithContainerOperation => {
                f.write_str("LeaseNotPresentWithContainerOperation")
            }
            StorageErrorCode::LeaseNotPresentWithLeaseOperation => {
                f.write_str("LeaseNotPresentWithLeaseOperation")
            }
            StorageErrorCode::MaxBlobSizeConditionNotMet => {
                f.write_str("MaxBlobSizeConditionNotMet")
            }
            StorageErrorCode::Md5Mismatch => f.write_str("Md5Mismatch"),
            StorageErrorCode::MetadataTooLarge => f.write_str("MetadataTooLarge"),
            StorageErrorCode::MissingContentLengthHeader => {
                f.write_str("MissingContentLengthHeader")
            }
            StorageErrorCode::MissingRequiredHeader => f.write_str("MissingRequiredHeader"),
            StorageErrorCode::MissingRequiredQueryParameter => {
                f.write_str("MissingRequiredQueryParameter")
            }
            StorageErrorCode::MissingRequiredXmlNode => f.write_str("MissingRequiredXmlNode"),
            StorageErrorCode::MultipleConditionHeadersNotSupported => {
                f.write_str("MultipleConditionHeadersNotSupported")
            }
            StorageErrorCode::NoPendingCopyOperation => f.write_str("NoPendingCopyOperation"),
            StorageErrorCode::OperationNotAllowedOnIncrementalCopyBlob => {
                f.write_str("OperationNotAllowedOnIncrementalCopyBlob")
            }
            StorageErrorCode::OperationTimedOut => f.write_str("OperationTimedOut"),
            StorageErrorCode::OutOfRangeInput => f.write_str("OutOfRangeInput"),
            StorageErrorCode::OutOfRangeQueryParameterValue => {
                f.write_str("OutOfRangeQueryParameterValue")
            }
            StorageErrorCode::PendingCopyOperation => f.write_str("PendingCopyOperation"),
            StorageErrorCode::PreviousSnapshotCannotBeNewer => {
                f.write_str("PreviousSnapshotCannotBeNewer")
            }
            StorageErrorCode::PreviousSnapshotNotFound => f.write_str("PreviousSnapshotNotFound"),
            StorageErrorCode::PreviousSnapshotOperationNotSupported => {
                f.write_str("PreviousSnapshotOperationNotSupported")
            }
            StorageErrorCode::RequestBodyTooLarge => f.write_str("RequestBodyTooLarge"),
            StorageErrorCode::RequestUrlFailedToParse => f.write_str("RequestUrlFailedToParse"),
            StorageErrorCode::ResourceAlreadyExists => f.write_str("ResourceAlreadyExists"),
            StorageErrorCode::ResourceNotFound => f.write_str("ResourceNotFound"),
            StorageErrorCode::ResourceTypeMismatch => f.write_str("ResourceTypeMismatch"),
            StorageErrorCode::SequenceNumberConditionNotMet => {
                f.write_str("SequenceNumberConditionNotMet")
            }
            StorageErrorCode::SequenceNumberIncrementTooLarge => {
                f.write_str("SequenceNumberIncrementTooLarge")
            }
            StorageErrorCode::ServerBusy => f.write_str("ServerBusy"),
            StorageErrorCode::SnapshotCountExceeded => f.write_str("SnapshotCountExceeded"),
            StorageErrorCode::SnapshotOperationRateExceeded => {
                f.write_str("SnapshotOperationRateExceeded")
            }
            StorageErrorCode::SnapshotsPresent => f.write_str("SnapshotsPresent"),
            StorageErrorCode::SourceConditionNotMet => f.write_str("SourceConditionNotMet"),
            StorageErrorCode::SystemInUse => f.write_str("SystemInUse"),
            StorageErrorCode::TargetConditionNotMet => f.write_str("TargetConditionNotMet"),
            StorageErrorCode::UnauthorizedBlobOverwrite => f.write_str("UnauthorizedBlobOverwrite"),
            StorageErrorCode::UnsupportedHeader => f.write_str("UnsupportedHeader"),
            StorageErrorCode::UnsupportedHttpVerb => f.write_str("UnsupportedHttpVerb"),
            StorageErrorCode::UnsupportedQueryParameter => f.write_str("UnsupportedQueryParameter"),
            StorageErrorCode::UnsupportedXmlNode => f.write_str("UnsupportedXmlNode"),
            StorageErrorCode::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}
