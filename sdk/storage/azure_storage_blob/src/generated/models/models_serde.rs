// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{BlobMetadata, ObjectReplicationMetadata, ParquetConfiguration};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

impl<'de> Deserialize<'de> for BlobMetadata {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct AdditionalPropertiesVisitor;
        impl<'de> serde::de::Visitor<'de> for AdditionalPropertiesVisitor {
            type Value = BlobMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("a BlobMetadata struct definition")
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                let mut additional_properties = HashMap::new();
                let mut encrypted = None;
                while let Some(key) = map.next_key::<String>()? {
                    match key.as_ref() {
                        "@Encrypted" => encrypted = Some(map.next_value()?),
                        _ => {
                            let value: String = map.next_value()?;
                            additional_properties.insert(key, value);
                        }
                    }
                }
                let additional_properties = match additional_properties.len() {
                    0 => None,
                    _ => Some(additional_properties),
                };
                Ok(BlobMetadata {
                    additional_properties,
                    encrypted,
                })
            }
        }
        deserializer.deserialize_map(AdditionalPropertiesVisitor)
    }
}

impl Serialize for BlobMetadata {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut map = serializer.serialize_map(Some(
            1 + match &self.additional_properties {
                Some(additional_properties) => additional_properties.len(),
                None => 0,
            },
        ))?;
        if let Some(additional_properties) = &self.additional_properties {
            for (k, v) in additional_properties {
                map.serialize_entry(k, v)?;
            }
        }
        if let Some(encrypted) = &self.encrypted {
            map.serialize_entry("@Encrypted", encrypted)?;
        }
        map.end()
    }
}

impl<'de> Deserialize<'de> for ObjectReplicationMetadata {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct AdditionalPropertiesVisitor;
        impl<'de> serde::de::Visitor<'de> for AdditionalPropertiesVisitor {
            type Value = ObjectReplicationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("a ObjectReplicationMetadata struct definition")
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                let mut additional_properties = HashMap::new();
                while let Some(key) = map.next_key::<String>()? {
                    let value: String = map.next_value()?;
                    additional_properties.insert(key, value);
                }
                let additional_properties = match additional_properties.len() {
                    0 => None,
                    _ => Some(additional_properties),
                };
                Ok(ObjectReplicationMetadata {
                    additional_properties,
                })
            }
        }
        deserializer.deserialize_map(AdditionalPropertiesVisitor)
    }
}

impl Serialize for ObjectReplicationMetadata {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut map = serializer.serialize_map(Some(match &self.additional_properties {
            Some(additional_properties) => additional_properties.len(),
            None => 0,
        }))?;
        if let Some(additional_properties) = &self.additional_properties {
            for (k, v) in additional_properties {
                map.serialize_entry(k, v)?;
            }
        }
        map.end()
    }
}

impl<'de> Deserialize<'de> for ParquetConfiguration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct AdditionalPropertiesVisitor;
        impl<'de> serde::de::Visitor<'de> for AdditionalPropertiesVisitor {
            type Value = ParquetConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("a ParquetConfiguration struct definition")
            }
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                let mut additional_properties = HashMap::new();
                while let Some(key) = map.next_key::<String>()? {
                    let value: Value = map.next_value()?;
                    additional_properties.insert(key, value);
                }
                let additional_properties = match additional_properties.len() {
                    0 => None,
                    _ => Some(additional_properties),
                };
                Ok(ParquetConfiguration {
                    additional_properties,
                })
            }
        }
        deserializer.deserialize_map(AdditionalPropertiesVisitor)
    }
}

impl Serialize for ParquetConfiguration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut map = serializer.serialize_map(Some(match &self.additional_properties {
            Some(additional_properties) => additional_properties.len(),
            None => 0,
        }))?;
        if let Some(additional_properties) = &self.additional_properties {
            for (k, v) in additional_properties {
                map.serialize_entry(k, v)?;
            }
        }
        map.end()
    }
}

pub mod option_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64::{decode, encode};
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<u8>>>::new();
                for v in to_deserialize {
                    decoded0.push(decode(v).map_err(serde::de::Error::custom)?);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize.iter().map(encode).collect();
            <Option<Vec<String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}
