// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::generated::models::{
    AppendBlobClientAppendBlockFromUrlOptions, AppendBlobClientAppendBlockFromUrlResult,
    AppendBlobClientAppendBlockOptions, AppendBlobClientAppendBlockResult,
    AppendBlobClientCreateOptions, AppendBlobClientCreateResult, AppendBlobClientSealOptions,
    AppendBlobClientSealResult,
};
use azure_core::{
    base64::encode,
    credentials::TokenCredential,
    error::{ErrorKind, HttpError},
    fmt::SafeDebug,
    http::{
        headers::ERROR_CODE,
        policies::{BearerTokenCredentialPolicy, Policy},
        ClientOptions, Method, NoFormat, Pipeline, Request, RequestContent, Response, Url,
    },
    time::to_rfc7231,
    tracing, Bytes, Error, Result,
};
use std::sync::Arc;

#[tracing::client]
pub struct AppendBlobClient {
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
    pub(crate) version: String,
}

/// Options used when creating a `AppendBlobClient`
#[derive(Clone, SafeDebug)]
pub struct AppendBlobClientOptions {
    /// Allows customization of the client.
    pub client_options: ClientOptions,
    /// Specifies the version of the operation to use for this request.
    pub version: String,
}

impl AppendBlobClient {
    /// Creates a new AppendBlobClient, using Entra ID authentication.
    ///
    /// # Arguments
    ///
    /// * `endpoint` - Service host
    /// * `credential` - An implementation of [`TokenCredential`](azure_core::credentials::TokenCredential) that can provide an
    ///   Entra ID token to use when authenticating.
    /// * `options` - Optional configuration for the client.
    #[tracing::new("Storage.Blob.AppendBlob")]
    pub fn new(
        endpoint: &str,
        credential: Arc<dyn TokenCredential>,
        options: Option<AppendBlobClientOptions>,
    ) -> Result<Self> {
        let options = options.unwrap_or_default();
        let mut endpoint = Url::parse(endpoint)?;
        if !endpoint.scheme().starts_with("http") {
            return Err(azure_core::Error::message(
                azure_core::error::ErrorKind::Other,
                format!("{endpoint} must use http(s)"),
            ));
        }
        endpoint.set_query(None);
        let auth_policy: Arc<dyn Policy> = Arc::new(BearerTokenCredentialPolicy::new(
            credential,
            vec!["https://storage.azure.com/.default"],
        ));
        Ok(Self {
            endpoint,
            version: options.version,
            pipeline: Pipeline::new(
                option_env!("CARGO_PKG_NAME"),
                option_env!("CARGO_PKG_VERSION"),
                options.client_options,
                Vec::default(),
                vec![auth_policy],
                None,
            ),
        })
    }

    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// The Append Block operation commits a new block of data to the end of an append blob.
    ///
    /// # Arguments
    ///
    /// * `body` - The body of the request.
    /// * `content_length` - The length of the request.
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`AppendBlobClientAppendBlockResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use blob_storage::models::{AppendBlobClientAppendBlockResult, AppendBlobClientAppendBlockResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<AppendBlobClientAppendBlockResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(content_md5) = response.content_md5()? {
    ///         println!("Content-MD5: {:?}", content_md5);
    ///     }
    ///     if let Some(last_modified) = response.last_modified()? {
    ///         println!("Last-Modified: {:?}", last_modified);
    ///     }
    ///     if let Some(etag) = response.etag()? {
    ///         println!("etag: {:?}", etag);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`content_md5`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::content_md5) - Content-MD5
    /// * [`last_modified`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::last_modified) - Last-Modified
    /// * [`etag`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::etag) - etag
    /// * [`blob_append_offset`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::blob_append_offset) - x-ms-blob-append-offset
    /// * [`blob_committed_block_count`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::blob_committed_block_count) - x-ms-blob-committed-block-count
    /// * [`content_crc64`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::content_crc64) - x-ms-content-crc64
    /// * [`encryption_key_sha256`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::encryption_key_sha256) - x-ms-encryption-key-sha256
    /// * [`encryption_scope`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::encryption_scope) - x-ms-encryption-scope
    /// * [`is_server_encrypted`()](crate::generated::models::AppendBlobClientAppendBlockResultHeaders::is_server_encrypted) - x-ms-request-server-encrypted
    ///
    /// [`AppendBlobClientAppendBlockResultHeaders`]: crate::generated::models::AppendBlobClientAppendBlockResultHeaders
    #[tracing::function("Storage.Blob.AppendBlob.appendBlock")]
    pub async fn append_block(
        &self,
        body: RequestContent<Bytes, NoFormat>,
        content_length: u64,
        options: Option<AppendBlobClientAppendBlockOptions<'_>>,
    ) -> Result<Response<AppendBlobClientAppendBlockResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url.query_pairs_mut().append_pair("comp", "appendblock");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", encode(transactional_content_md5));
        }
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", to_rfc7231(&if_unmodified_since));
        }
        if let Some(append_position) = options.append_position {
            request.insert_header("x-ms-blob-condition-appendpos", append_position.to_string());
        }
        if let Some(max_size) = options.max_size {
            request.insert_header("x-ms-blob-condition-maxsize", max_size.to_string());
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", encode(transactional_content_crc64));
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(structured_body_type) = options.structured_body_type {
            request.insert_header("x-ms-structured-body", structured_body_type);
        }
        if let Some(structured_content_length) = options.structured_content_length {
            request.insert_header(
                "x-ms-structured-content-length",
                structured_content_length.to_string(),
            );
        }
        request.insert_header("x-ms-version", &self.version);
        request.set_body(body);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp, Some(ERROR_CODE)).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// The Append Block From URL operation creates a new block to be committed as part of an append blob where the contents are
    /// read from a URL.
    ///
    /// # Arguments
    ///
    /// * `source_url` - Specify a URL to the copy source.
    /// * `content_length` - The length of the request.
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`AppendBlobClientAppendBlockFromUrlResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use blob_storage::models::{AppendBlobClientAppendBlockFromUrlResult, AppendBlobClientAppendBlockFromUrlResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<AppendBlobClientAppendBlockFromUrlResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(content_md5) = response.content_md5()? {
    ///         println!("Content-MD5: {:?}", content_md5);
    ///     }
    ///     if let Some(last_modified) = response.last_modified()? {
    ///         println!("Last-Modified: {:?}", last_modified);
    ///     }
    ///     if let Some(etag) = response.etag()? {
    ///         println!("etag: {:?}", etag);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`content_md5`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::content_md5) - Content-MD5
    /// * [`last_modified`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::last_modified) - Last-Modified
    /// * [`etag`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::etag) - etag
    /// * [`blob_append_offset`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::blob_append_offset) - x-ms-blob-append-offset
    /// * [`blob_committed_block_count`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::blob_committed_block_count) - x-ms-blob-committed-block-count
    /// * [`content_crc64`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::content_crc64) - x-ms-content-crc64
    /// * [`encryption_key_sha256`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::encryption_key_sha256) - x-ms-encryption-key-sha256
    /// * [`encryption_scope`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::encryption_scope) - x-ms-encryption-scope
    /// * [`is_server_encrypted`()](crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders::is_server_encrypted) - x-ms-request-server-encrypted
    ///
    /// [`AppendBlobClientAppendBlockFromUrlResultHeaders`]: crate::generated::models::AppendBlobClientAppendBlockFromUrlResultHeaders
    #[tracing::function("Storage.Blob.AppendBlob.appendBlockFromUrl")]
    pub async fn append_block_from_url(
        &self,
        source_url: String,
        content_length: u64,
        options: Option<AppendBlobClientAppendBlockFromUrlOptions<'_>>,
    ) -> Result<Response<AppendBlobClientAppendBlockFromUrlResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url.query_pairs_mut()
            .append_pair("comp", "appendblock")
            .append_key_only("fromUrl");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", encode(transactional_content_md5));
        }
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", to_rfc7231(&if_unmodified_since));
        }
        if let Some(append_position) = options.append_position {
            request.insert_header("x-ms-blob-condition-appendpos", append_position.to_string());
        }
        if let Some(max_size) = options.max_size {
            request.insert_header("x-ms-blob-condition-maxsize", max_size.to_string());
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        request.insert_header("x-ms-copy-source", source_url);
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(file_request_intent) = options.file_request_intent {
            request.insert_header("x-ms-file-request-intent", file_request_intent.to_string());
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(source_content_crc64) = options.source_content_crc64 {
            request.insert_header("x-ms-source-content-crc64", encode(source_content_crc64));
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", encode(source_content_md5));
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header(
                "x-ms-source-if-modified-since",
                to_rfc7231(&source_if_modified_since),
            );
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                to_rfc7231(&source_if_unmodified_since),
            );
        }
        if let Some(source_range) = options.source_range {
            request.insert_header("x-ms-source-range", source_range);
        }
        request.insert_header("x-ms-version", &self.version);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp, Some(ERROR_CODE)).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// The Create operation creates a new append blob.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`AppendBlobClientCreateResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use blob_storage::models::{AppendBlobClientCreateResult, AppendBlobClientCreateResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<AppendBlobClientCreateResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(content_md5) = response.content_md5()? {
    ///         println!("Content-MD5: {:?}", content_md5);
    ///     }
    ///     if let Some(last_modified) = response.last_modified()? {
    ///         println!("Last-Modified: {:?}", last_modified);
    ///     }
    ///     if let Some(etag) = response.etag()? {
    ///         println!("etag: {:?}", etag);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`content_md5`()](crate::generated::models::AppendBlobClientCreateResultHeaders::content_md5) - Content-MD5
    /// * [`last_modified`()](crate::generated::models::AppendBlobClientCreateResultHeaders::last_modified) - Last-Modified
    /// * [`etag`()](crate::generated::models::AppendBlobClientCreateResultHeaders::etag) - etag
    /// * [`encryption_key_sha256`()](crate::generated::models::AppendBlobClientCreateResultHeaders::encryption_key_sha256) - x-ms-encryption-key-sha256
    /// * [`encryption_scope`()](crate::generated::models::AppendBlobClientCreateResultHeaders::encryption_scope) - x-ms-encryption-scope
    /// * [`is_server_encrypted`()](crate::generated::models::AppendBlobClientCreateResultHeaders::is_server_encrypted) - x-ms-request-server-encrypted
    /// * [`version_id`()](crate::generated::models::AppendBlobClientCreateResultHeaders::version_id) - x-ms-version-id
    ///
    /// [`AppendBlobClientCreateResultHeaders`]: crate::generated::models::AppendBlobClientCreateResultHeaders
    #[tracing::function("Storage.Blob.AppendBlob.create")]
    pub async fn create(
        &self,
        options: Option<AppendBlobClientCreateOptions<'_>>,
    ) -> Result<Response<AppendBlobClientCreateResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("content-length", "0");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", to_rfc7231(&if_unmodified_since));
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        request.insert_header("x-ms-blob-type", "AppendBlob");
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                to_rfc7231(&immutability_policy_expiry),
            );
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(metadata) = options.metadata {
            for (k, v) in &metadata {
                request.insert_header(format!("x-ms-meta-{k}"), v);
            }
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", &self.version);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp, Some(ERROR_CODE)).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version 2019-12-12 version or
    /// later.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`AppendBlobClientSealResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use blob_storage::models::{AppendBlobClientSealResult, AppendBlobClientSealResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<AppendBlobClientSealResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(last_modified) = response.last_modified()? {
    ///         println!("Last-Modified: {:?}", last_modified);
    ///     }
    ///     if let Some(etag) = response.etag()? {
    ///         println!("etag: {:?}", etag);
    ///     }
    ///     if let Some(is_sealed) = response.is_sealed()? {
    ///         println!("x-ms-blob-sealed: {:?}", is_sealed);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`last_modified`()](crate::generated::models::AppendBlobClientSealResultHeaders::last_modified) - Last-Modified
    /// * [`etag`()](crate::generated::models::AppendBlobClientSealResultHeaders::etag) - etag
    /// * [`is_sealed`()](crate::generated::models::AppendBlobClientSealResultHeaders::is_sealed) - x-ms-blob-sealed
    ///
    /// [`AppendBlobClientSealResultHeaders`]: crate::generated::models::AppendBlobClientSealResultHeaders
    #[tracing::function("Storage.Blob.AppendBlob.seal")]
    pub async fn seal(
        &self,
        options: Option<AppendBlobClientSealOptions<'_>>,
    ) -> Result<Response<AppendBlobClientSealResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url.query_pairs_mut().append_pair("comp", "seal");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", to_rfc7231(&if_unmodified_since));
        }
        if let Some(append_position) = options.append_position {
            request.insert_header("x-ms-blob-condition-appendpos", append_position.to_string());
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", &self.version);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp, Some(ERROR_CODE)).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }
}

impl Default for AppendBlobClientOptions {
    fn default() -> Self {
        Self {
            client_options: ClientOptions::default(),
            version: String::from("2025-11-05"),
        }
    }
}
