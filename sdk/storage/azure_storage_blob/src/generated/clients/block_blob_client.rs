// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::generated::models::{
    BlockBlobClientCommitBlockListOptions, BlockBlobClientCommitBlockListResult,
    BlockBlobClientGetBlockListOptions, BlockBlobClientStageBlockFromUrlOptions,
    BlockBlobClientStageBlockFromUrlResult, BlockBlobClientStageBlockOptions,
    BlockBlobClientStageBlockResult, BlockBlobClientUploadBlobFromUrlOptions,
    BlockBlobClientUploadBlobFromUrlResult, BlockBlobClientUploadOptions,
    BlockBlobClientUploadResult, BlockList, BlockListType, BlockLookupList,
};
use azure_core::{
    base64::encode,
    error::CheckSuccessOptions,
    http::{
        Method, NoFormat, Pipeline, PipelineSendOptions, Request, RequestContent, Response, Url,
        UrlExt, XmlFormat,
    },
    time::to_rfc7231,
    tracing, Bytes, Result,
};

#[tracing::client]
pub struct BlockBlobClient {
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
    pub(crate) version: String,
}

impl BlockBlobClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob. In order to be
    /// written as part of a blob, a block must have been successfully written to the server in a prior Put Block operation. You
    /// can call Put Block List to update a blob by uploading only those blocks that have changed, then committing the new and
    /// existing blocks together. You can do this by specifying whether to commit a block from the committed block list or from
    /// the uncommitted block list, or to commit the most recently uploaded version of the block, whichever list it may belong
    /// to.
    ///
    /// # Arguments
    ///
    /// * `blocks` - Blob Blocks.
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`BlockBlobClientCommitBlockListResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use azure_storage_blob::models::{BlockBlobClientCommitBlockListResult, BlockBlobClientCommitBlockListResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<BlockBlobClientCommitBlockListResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(content_md5) = response.content_md5()? {
    ///         println!("content-md5: {:?}", content_md5);
    ///     }
    ///     if let Some(etag) = response.etag()? {
    ///         println!("etag: {:?}", etag);
    ///     }
    ///     if let Some(last_modified) = response.last_modified()? {
    ///         println!("last-modified: {:?}", last_modified);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`content_md5`()](crate::generated::models::BlockBlobClientCommitBlockListResultHeaders::content_md5) - content-md5
    /// * [`etag`()](crate::generated::models::BlockBlobClientCommitBlockListResultHeaders::etag) - etag
    /// * [`last_modified`()](crate::generated::models::BlockBlobClientCommitBlockListResultHeaders::last_modified) - last-modified
    /// * [`content_crc64`()](crate::generated::models::BlockBlobClientCommitBlockListResultHeaders::content_crc64) - x-ms-content-crc64
    /// * [`encryption_key_sha256`()](crate::generated::models::BlockBlobClientCommitBlockListResultHeaders::encryption_key_sha256) - x-ms-encryption-key-sha256
    /// * [`encryption_scope`()](crate::generated::models::BlockBlobClientCommitBlockListResultHeaders::encryption_scope) - x-ms-encryption-scope
    /// * [`is_server_encrypted`()](crate::generated::models::BlockBlobClientCommitBlockListResultHeaders::is_server_encrypted) - x-ms-request-server-encrypted
    /// * [`version_id`()](crate::generated::models::BlockBlobClientCommitBlockListResultHeaders::version_id) - x-ms-version-id
    ///
    /// [`BlockBlobClientCommitBlockListResultHeaders`]: crate::generated::models::BlockBlobClientCommitBlockListResultHeaders
    #[tracing::function("Storage.Blob.BlockBlob.commitBlockList")]
    pub async fn commit_block_list(
        &self,
        blocks: RequestContent<BlockLookupList, XmlFormat>,
        options: Option<BlockBlobClientCommitBlockListOptions<'_>>,
    ) -> Result<Response<BlockBlobClientCommitBlockListResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut query_builder = url.query_builder();
        query_builder.append_pair("comp", "blocklist");
        if let Some(timeout) = options.timeout {
            query_builder.set_pair("timeout", timeout.to_string());
        }
        query_builder.build();
        let mut request = Request::new(url, Method::Put);
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", encode(transactional_content_md5));
        }
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match.as_ref() {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match.as_ref() {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", to_rfc7231(&if_unmodified_since));
        }
        if let Some(tier) = options.tier.as_ref() {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control.as_ref() {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition.as_ref() {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding.as_ref() {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language.as_ref() {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type.as_ref() {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", encode(transactional_content_crc64));
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm.as_ref() {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key.as_ref() {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256.as_ref() {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope.as_ref() {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags.as_ref() {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode.as_ref() {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                to_rfc7231(&immutability_policy_expiry),
            );
        }
        if let Some(lease_id) = options.lease_id.as_ref() {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(metadata) = options.metadata.as_ref() {
            for (k, v) in metadata {
                request.insert_header(format!("x-ms-meta-{k}"), v);
            }
        }
        if let Some(blob_tags_string) = options.blob_tags_string.as_ref() {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", &self.version);
        request.set_body(blocks);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[201],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block blob.
    ///
    /// # Arguments
    ///
    /// * `list_type` - Specifies whether to return the list of committed blocks, the list of uncommitted blocks, or both lists
    ///   together.
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`BlockListHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, XmlFormat}};
    /// use azure_storage_blob::models::{BlockList, BlockListHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<BlockList, XmlFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(etag) = response.etag()? {
    ///         println!("etag: {:?}", etag);
    ///     }
    ///     if let Some(last_modified) = response.last_modified()? {
    ///         println!("last-modified: {:?}", last_modified);
    ///     }
    ///     if let Some(blob_content_length) = response.blob_content_length()? {
    ///         println!("x-ms-blob-content-length: {:?}", blob_content_length);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`etag`()](crate::generated::models::BlockListHeaders::etag) - etag
    /// * [`last_modified`()](crate::generated::models::BlockListHeaders::last_modified) - last-modified
    /// * [`blob_content_length`()](crate::generated::models::BlockListHeaders::blob_content_length) - x-ms-blob-content-length
    ///
    /// [`BlockListHeaders`]: crate::generated::models::BlockListHeaders
    #[tracing::function("Storage.Blob.BlockBlob.getBlockList")]
    pub async fn get_block_list(
        &self,
        list_type: BlockListType,
        options: Option<BlockBlobClientGetBlockListOptions<'_>>,
    ) -> Result<Response<BlockList, XmlFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut query_builder = url.query_builder();
        query_builder.append_pair("comp", "blocklist");
        query_builder.set_pair("blocklisttype", list_type.as_ref());
        if let Some(snapshot) = options.snapshot.as_ref() {
            query_builder.set_pair("snapshot", snapshot);
        }
        if let Some(timeout) = options.timeout {
            query_builder.set_pair("timeout", timeout.to_string());
        }
        query_builder.build();
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/xml");
        request.insert_header("content-type", "application/xml");
        if let Some(if_tags) = options.if_tags.as_ref() {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id.as_ref() {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", &self.version);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// The Stage Block operation creates a new block to be committed as part of a blob
    ///
    /// # Arguments
    ///
    /// * `block_id` - A valid Base64 string value that identifies the block. Prior to encoding, the string must be less than
    ///   or equal to 64 bytes in size. For a given blob, the length of the value specified for the blockid parameter must be the
    ///   same size for each block.
    /// * `content_length` - The length of the request.
    /// * `body` - The body of the request.
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`BlockBlobClientStageBlockResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use azure_storage_blob::models::{BlockBlobClientStageBlockResult, BlockBlobClientStageBlockResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<BlockBlobClientStageBlockResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(content_md5) = response.content_md5()? {
    ///         println!("content-md5: {:?}", content_md5);
    ///     }
    ///     if let Some(content_crc64) = response.content_crc64()? {
    ///         println!("x-ms-content-crc64: {:?}", content_crc64);
    ///     }
    ///     if let Some(encryption_key_sha256) = response.encryption_key_sha256()? {
    ///         println!("x-ms-encryption-key-sha256: {:?}", encryption_key_sha256);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`content_md5`()](crate::generated::models::BlockBlobClientStageBlockResultHeaders::content_md5) - content-md5
    /// * [`content_crc64`()](crate::generated::models::BlockBlobClientStageBlockResultHeaders::content_crc64) - x-ms-content-crc64
    /// * [`encryption_key_sha256`()](crate::generated::models::BlockBlobClientStageBlockResultHeaders::encryption_key_sha256) - x-ms-encryption-key-sha256
    /// * [`encryption_scope`()](crate::generated::models::BlockBlobClientStageBlockResultHeaders::encryption_scope) - x-ms-encryption-scope
    /// * [`is_server_encrypted`()](crate::generated::models::BlockBlobClientStageBlockResultHeaders::is_server_encrypted) - x-ms-request-server-encrypted
    ///
    /// [`BlockBlobClientStageBlockResultHeaders`]: crate::generated::models::BlockBlobClientStageBlockResultHeaders
    #[tracing::function("Storage.Blob.BlockBlob.stageBlock")]
    pub async fn stage_block(
        &self,
        block_id: &[u8],
        content_length: u64,
        body: RequestContent<Bytes, NoFormat>,
        options: Option<BlockBlobClientStageBlockOptions<'_>>,
    ) -> Result<Response<BlockBlobClientStageBlockResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut query_builder = url.query_builder();
        query_builder.append_pair("comp", "block");
        query_builder.set_pair("blockid", encode(block_id));
        if let Some(timeout) = options.timeout {
            query_builder.set_pair("timeout", timeout.to_string());
        }
        query_builder.build();
        let mut request = Request::new(url, Method::Put);
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", encode(transactional_content_md5));
        }
        request.insert_header("content-type", "application/octet-stream");
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", encode(transactional_content_crc64));
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm.as_ref() {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key.as_ref() {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256.as_ref() {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope.as_ref() {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(lease_id) = options.lease_id.as_ref() {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(structured_body_type) = options.structured_body_type.as_ref() {
            request.insert_header("x-ms-structured-body", structured_body_type);
        }
        if let Some(structured_content_length) = options.structured_content_length {
            request.insert_header(
                "x-ms-structured-content-length",
                structured_content_length.to_string(),
            );
        }
        request.insert_header("x-ms-version", &self.version);
        request.set_body(body);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[201],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// The Stage Block From URL operation creates a new block to be committed as part of a blob where the contents are read from
    /// a URL.
    ///
    /// # Arguments
    ///
    /// * `block_id` - A valid Base64 string value that identifies the block. Prior to encoding, the string must be less than
    ///   or equal to 64 bytes in size. For a given blob, the length of the value specified for the blockid parameter must be the
    ///   same size for each block.
    /// * `content_length` - The length of the request.
    /// * `source_url` - Specify a URL to the copy source.
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`BlockBlobClientStageBlockFromUrlResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use azure_storage_blob::models::{BlockBlobClientStageBlockFromUrlResult, BlockBlobClientStageBlockFromUrlResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<BlockBlobClientStageBlockFromUrlResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(content_md5) = response.content_md5()? {
    ///         println!("content-md5: {:?}", content_md5);
    ///     }
    ///     if let Some(content_crc64) = response.content_crc64()? {
    ///         println!("x-ms-content-crc64: {:?}", content_crc64);
    ///     }
    ///     if let Some(encryption_key_sha256) = response.encryption_key_sha256()? {
    ///         println!("x-ms-encryption-key-sha256: {:?}", encryption_key_sha256);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`content_md5`()](crate::generated::models::BlockBlobClientStageBlockFromUrlResultHeaders::content_md5) - content-md5
    /// * [`content_crc64`()](crate::generated::models::BlockBlobClientStageBlockFromUrlResultHeaders::content_crc64) - x-ms-content-crc64
    /// * [`encryption_key_sha256`()](crate::generated::models::BlockBlobClientStageBlockFromUrlResultHeaders::encryption_key_sha256) - x-ms-encryption-key-sha256
    /// * [`encryption_scope`()](crate::generated::models::BlockBlobClientStageBlockFromUrlResultHeaders::encryption_scope) - x-ms-encryption-scope
    /// * [`is_server_encrypted`()](crate::generated::models::BlockBlobClientStageBlockFromUrlResultHeaders::is_server_encrypted) - x-ms-request-server-encrypted
    ///
    /// [`BlockBlobClientStageBlockFromUrlResultHeaders`]: crate::generated::models::BlockBlobClientStageBlockFromUrlResultHeaders
    #[tracing::function("Storage.Blob.BlockBlob.stageBlockFromUrl")]
    pub async fn stage_block_from_url(
        &self,
        block_id: &[u8],
        content_length: u64,
        source_url: String,
        options: Option<BlockBlobClientStageBlockFromUrlOptions<'_>>,
    ) -> Result<Response<BlockBlobClientStageBlockFromUrlResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut query_builder = url.query_builder();
        query_builder.append_pair("comp", "block");
        query_builder.set_pair("blockid", encode(block_id));
        if let Some(timeout) = options.timeout {
            query_builder.set_pair("timeout", timeout.to_string());
        }
        query_builder.build();
        let mut request = Request::new(url, Method::Put);
        request.insert_header("content-length", content_length.to_string());
        request.insert_header("content-type", "application/xml");
        request.insert_header("x-ms-copy-source", source_url);
        if let Some(copy_source_authorization) = options.copy_source_authorization.as_ref() {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm.as_ref() {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key.as_ref() {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256.as_ref() {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope.as_ref() {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(file_request_intent) = options.file_request_intent.as_ref() {
            request.insert_header("x-ms-file-request-intent", file_request_intent.to_string());
        }
        if let Some(lease_id) = options.lease_id.as_ref() {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(source_content_crc64) = options.source_content_crc64 {
            request.insert_header("x-ms-source-content-crc64", encode(source_content_crc64));
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", encode(source_content_md5));
        }
        if let Some(source_encryption_algorithm) = options.source_encryption_algorithm.as_ref() {
            request.insert_header(
                "x-ms-source-encryption-algorithm",
                source_encryption_algorithm.to_string(),
            );
        }
        if let Some(source_encryption_key) = options.source_encryption_key.as_ref() {
            request.insert_header("x-ms-source-encryption-key", source_encryption_key);
        }
        if let Some(source_encryption_key_sha256) = options.source_encryption_key_sha256.as_ref() {
            request.insert_header(
                "x-ms-source-encryption-key-sha256",
                source_encryption_key_sha256,
            );
        }
        if let Some(source_if_match) = options.source_if_match.as_ref() {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header(
                "x-ms-source-if-modified-since",
                to_rfc7231(&source_if_modified_since),
            );
        }
        if let Some(source_if_none_match) = options.source_if_none_match.as_ref() {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                to_rfc7231(&source_if_unmodified_since),
            );
        }
        if let Some(source_range) = options.source_range.as_ref() {
            request.insert_header("x-ms-source-range", source_range);
        }
        request.insert_header("x-ms-version", &self.version);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[201],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// The Upload Block Blob operation updates the content of an existing block blob. Updating an existing block blob overwrites
    /// any existing metadata on the blob. Partial updates are not supported with Put Blob; the content of the existing blob is
    /// overwritten with the content of the new blob. To perform a partial update of the content of a block blob, use the Put
    /// Block List operation.
    ///
    /// # Arguments
    ///
    /// * `body` - The body of the request.
    /// * `content_length` - The length of the request.
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`BlockBlobClientUploadResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use azure_storage_blob::models::{BlockBlobClientUploadResult, BlockBlobClientUploadResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<BlockBlobClientUploadResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(content_md5) = response.content_md5()? {
    ///         println!("content-md5: {:?}", content_md5);
    ///     }
    ///     if let Some(etag) = response.etag()? {
    ///         println!("etag: {:?}", etag);
    ///     }
    ///     if let Some(last_modified) = response.last_modified()? {
    ///         println!("last-modified: {:?}", last_modified);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`content_md5`()](crate::generated::models::BlockBlobClientUploadResultHeaders::content_md5) - content-md5
    /// * [`etag`()](crate::generated::models::BlockBlobClientUploadResultHeaders::etag) - etag
    /// * [`last_modified`()](crate::generated::models::BlockBlobClientUploadResultHeaders::last_modified) - last-modified
    /// * [`encryption_key_sha256`()](crate::generated::models::BlockBlobClientUploadResultHeaders::encryption_key_sha256) - x-ms-encryption-key-sha256
    /// * [`encryption_scope`()](crate::generated::models::BlockBlobClientUploadResultHeaders::encryption_scope) - x-ms-encryption-scope
    /// * [`is_server_encrypted`()](crate::generated::models::BlockBlobClientUploadResultHeaders::is_server_encrypted) - x-ms-request-server-encrypted
    /// * [`version_id`()](crate::generated::models::BlockBlobClientUploadResultHeaders::version_id) - x-ms-version-id
    ///
    /// [`BlockBlobClientUploadResultHeaders`]: crate::generated::models::BlockBlobClientUploadResultHeaders
    #[tracing::function("Storage.Blob.BlockBlob.upload")]
    pub async fn upload(
        &self,
        body: RequestContent<Bytes, NoFormat>,
        content_length: u64,
        options: Option<BlockBlobClientUploadOptions<'_>>,
    ) -> Result<Response<BlockBlobClientUploadResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut query_builder = url.query_builder();
        if let Some(timeout) = options.timeout {
            query_builder.set_pair("timeout", timeout.to_string());
        }
        query_builder.build();
        let mut request = Request::new(url, Method::Put);
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", encode(transactional_content_md5));
        }
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match.as_ref() {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match.as_ref() {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", to_rfc7231(&if_unmodified_since));
        }
        if let Some(tier) = options.tier.as_ref() {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control.as_ref() {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition.as_ref() {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding.as_ref() {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language.as_ref() {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type.as_ref() {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        request.insert_header("x-ms-blob-type", "BlockBlob");
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", encode(transactional_content_crc64));
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm.as_ref() {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key.as_ref() {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256.as_ref() {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope.as_ref() {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags.as_ref() {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode.as_ref() {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                to_rfc7231(&immutability_policy_expiry),
            );
        }
        if let Some(lease_id) = options.lease_id.as_ref() {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(metadata) = options.metadata.as_ref() {
            for (k, v) in metadata {
                request.insert_header(format!("x-ms-meta-{k}"), v);
            }
        }
        if let Some(structured_body_type) = options.structured_body_type.as_ref() {
            request.insert_header("x-ms-structured-body", structured_body_type);
        }
        if let Some(structured_content_length) = options.structured_content_length {
            request.insert_header(
                "x-ms-structured-content-length",
                structured_content_length.to_string(),
            );
        }
        if let Some(blob_tags_string) = options.blob_tags_string.as_ref() {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", &self.version);
        request.set_body(body);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[201],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// The Put Blob from URL operation creates a new Block Blob where the contents of the blob are read from a given URL. This
    /// API is supported beginning with the 2020-04-08 version. Partial updates are not supported with Put Blob from URL; the
    /// content of an existing blob is overwritten with the content of the new blob. To perform partial updates to a block blobâ€™s
    /// contents using a source URL, use the Put Block from URL API in conjunction with Put Block List.
    ///
    /// # Arguments
    ///
    /// * `copy_source` - Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that
    ///   specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must
    ///   either be public or must be authenticated via a shared access signature.
    /// * `options` - Optional parameters for the request.
    ///
    /// ## Response Headers
    ///
    /// The returned [`Response`](azure_core::http::Response) implements the [`BlockBlobClientUploadBlobFromUrlResultHeaders`] trait, which provides
    /// access to response headers. For example:
    ///
    /// ```no_run
    /// use azure_core::{Result, http::{Response, NoFormat}};
    /// use azure_storage_blob::models::{BlockBlobClientUploadBlobFromUrlResult, BlockBlobClientUploadBlobFromUrlResultHeaders};
    /// async fn example() -> Result<()> {
    ///     let response: Response<BlockBlobClientUploadBlobFromUrlResult, NoFormat> = unimplemented!();
    ///     // Access response headers
    ///     if let Some(content_md5) = response.content_md5()? {
    ///         println!("content-md5: {:?}", content_md5);
    ///     }
    ///     if let Some(etag) = response.etag()? {
    ///         println!("etag: {:?}", etag);
    ///     }
    ///     if let Some(last_modified) = response.last_modified()? {
    ///         println!("last-modified: {:?}", last_modified);
    ///     }
    ///     Ok(())
    /// }
    /// ```
    ///
    /// ### Available headers
    /// * [`content_md5`()](crate::generated::models::BlockBlobClientUploadBlobFromUrlResultHeaders::content_md5) - content-md5
    /// * [`etag`()](crate::generated::models::BlockBlobClientUploadBlobFromUrlResultHeaders::etag) - etag
    /// * [`last_modified`()](crate::generated::models::BlockBlobClientUploadBlobFromUrlResultHeaders::last_modified) - last-modified
    /// * [`encryption_key_sha256`()](crate::generated::models::BlockBlobClientUploadBlobFromUrlResultHeaders::encryption_key_sha256) - x-ms-encryption-key-sha256
    /// * [`encryption_scope`()](crate::generated::models::BlockBlobClientUploadBlobFromUrlResultHeaders::encryption_scope) - x-ms-encryption-scope
    /// * [`is_server_encrypted`()](crate::generated::models::BlockBlobClientUploadBlobFromUrlResultHeaders::is_server_encrypted) - x-ms-request-server-encrypted
    /// * [`version_id`()](crate::generated::models::BlockBlobClientUploadBlobFromUrlResultHeaders::version_id) - x-ms-version-id
    ///
    /// [`BlockBlobClientUploadBlobFromUrlResultHeaders`]: crate::generated::models::BlockBlobClientUploadBlobFromUrlResultHeaders
    #[tracing::function("Storage.Blob.BlockBlob.uploadBlobFromUrl")]
    pub async fn upload_blob_from_url(
        &self,
        copy_source: String,
        options: Option<BlockBlobClientUploadBlobFromUrlOptions<'_>>,
    ) -> Result<Response<BlockBlobClientUploadBlobFromUrlResult, NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut query_builder = url.query_builder();
        if let Some(timeout) = options.timeout {
            query_builder.set_pair("timeout", timeout.to_string());
        }
        query_builder.build();
        let mut request = Request::new(url, Method::Put);
        request.insert_header("content-length", "0");
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", encode(transactional_content_md5));
        }
        if let Some(if_match) = options.if_match.as_ref() {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match.as_ref() {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", to_rfc7231(&if_unmodified_since));
        }
        if let Some(tier) = options.tier.as_ref() {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control.as_ref() {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition.as_ref() {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding.as_ref() {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language.as_ref() {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type.as_ref() {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        request.insert_header("x-ms-blob-type", "BlockBlob");
        request.insert_header("x-ms-copy-source", copy_source);
        if let Some(copy_source_authorization) = options.copy_source_authorization.as_ref() {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(copy_source_blob_properties) = options.copy_source_blob_properties {
            request.insert_header(
                "x-ms-copy-source-blob-properties",
                copy_source_blob_properties.to_string(),
            );
        }
        if let Some(copy_source_tags) = options.copy_source_tags.as_ref() {
            request.insert_header("x-ms-copy-source-tag-option", copy_source_tags.to_string());
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm.as_ref() {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key.as_ref() {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256.as_ref() {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope.as_ref() {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(file_request_intent) = options.file_request_intent.as_ref() {
            request.insert_header("x-ms-file-request-intent", file_request_intent.to_string());
        }
        if let Some(if_tags) = options.if_tags.as_ref() {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id.as_ref() {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(metadata) = options.metadata.as_ref() {
            for (k, v) in metadata {
                request.insert_header(format!("x-ms-meta-{k}"), v);
            }
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", encode(source_content_md5));
        }
        if let Some(source_encryption_algorithm) = options.source_encryption_algorithm.as_ref() {
            request.insert_header(
                "x-ms-source-encryption-algorithm",
                source_encryption_algorithm.to_string(),
            );
        }
        if let Some(source_encryption_key) = options.source_encryption_key.as_ref() {
            request.insert_header("x-ms-source-encryption-key", source_encryption_key);
        }
        if let Some(source_encryption_key_sha256) = options.source_encryption_key_sha256.as_ref() {
            request.insert_header(
                "x-ms-source-encryption-key-sha256",
                source_encryption_key_sha256,
            );
        }
        if let Some(source_if_match) = options.source_if_match.as_ref() {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header(
                "x-ms-source-if-modified-since",
                to_rfc7231(&source_if_modified_since),
            );
        }
        if let Some(source_if_none_match) = options.source_if_none_match.as_ref() {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_tags) = options.source_if_tags.as_ref() {
            request.insert_header("x-ms-source-if-tags", source_if_tags);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                to_rfc7231(&source_if_unmodified_since),
            );
        }
        if let Some(blob_tags_string) = options.blob_tags_string.as_ref() {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", &self.version);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[201],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }
}
