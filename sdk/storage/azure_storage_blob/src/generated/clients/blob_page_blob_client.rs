// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::generated::clients::method_options::*;
use crate::models::{BlobType, SequenceNumberActionType};
use azure_core::{
    base64, date, Bytes, Context, Method, Pipeline, Request, RequestContent, Response, Result, Url,
};

pub struct BlobPageBlobClient {
    pub(crate) blob: String,
    pub(crate) container_name: String,
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
    pub(crate) version: String,
}

impl BlobPageBlobClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// The Clear Pages operation clears a range of pages from a page blob
    ///
    /// # Arguments
    ///
    /// * `content_length` - The length of the request.
    /// * `options` - Optional parameters for the request.
    pub async fn clear_pages(
        &self,
        content_length: i64,
        options: Option<BlobPageBlobClientClearPagesOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_key_only("clear")
            .append_pair("comp", "page");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_sequence_number_equal_to) = options.if_sequence_number_equal_to {
            request.insert_header(
                "x-ms-if-sequence-number-eq",
                if_sequence_number_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than_or_equal_to) =
            options.if_sequence_number_less_than_or_equal_to
        {
            request.insert_header(
                "x-ms-if-sequence-number-le",
                if_sequence_number_less_than_or_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than) = options.if_sequence_number_less_than {
            request.insert_header(
                "x-ms-if-sequence-number-lt",
                if_sequence_number_less_than.to_string(),
            );
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(range) = options.range {
            request.insert_header("x-ms-range", range);
        }
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob. The snapshot is copied
    /// such that only the differential changes between the previously copied snapshot are transferred to the destination. The
    /// copied snapshots are complete copies of the original snapshot and can be read or copied from as usual. This API is supported
    /// since REST version 2016-05-31.
    ///
    /// # Arguments
    ///
    /// * `copy_source` - Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that
    ///   specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must
    ///   either be public or must be authenticated via a shared access signature.
    /// * `options` - Optional parameters for the request.
    pub async fn copy_incremental(
        &self,
        copy_source: &str,
        options: Option<BlobPageBlobClientCopyIncrementalOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("comp", "incrementalcopy");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        request.insert_header("x-ms-copy-source", copy_source.to_owned());
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Create operation creates a new page blob.
    ///
    /// # Arguments
    ///
    /// * `content_length` - The length of the request.
    /// * `blob_content_length` - This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must
    ///   be aligned to a 512-byte boundary.
    /// * `options` - Optional parameters for the request.
    pub async fn create(
        &self,
        content_length: i64,
        blob_content_length: i64,
        options: Option<BlobPageBlobClientCreateOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_key_only("PageBlob");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        request.insert_header("x-ms-blob-content-length", blob_content_length.to_string());
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", base64::encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(blob_sequence_number) = options.blob_sequence_number {
            request.insert_header(
                "x-ms-blob-sequence-number",
                blob_sequence_number.to_string(),
            );
        }
        request.insert_header("x-ms-blob-type", BlobType::PageBlob.to_string());
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                immutability_policy_expiry,
            );
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(metadata) = options.metadata {
            for (k, v) in &metadata {
                request.insert_header(format!("x-ms-meta-{}", k), v);
            }
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Resize operation increases the size of the page blob to the specified size.
    ///
    /// # Arguments
    ///
    /// * `blob_content_length` - This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must
    ///   be aligned to a 512-byte boundary.
    /// * `options` - Optional parameters for the request.
    pub async fn resize(
        &self,
        blob_content_length: i64,
        options: Option<BlobPageBlobClientResizeOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_key_only("Resize")
            .append_pair("comp", "properties");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        request.insert_header("x-ms-blob-content-length", blob_content_length.to_string());
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Update Sequence Number operation sets the blob's sequence number. The operation will fail if the specified sequence
    /// number is less than the current sequence number of the blob.
    ///
    /// # Arguments
    ///
    /// * `sequence_number_action` - Required if the x-ms-blob-sequence-number header is set for the request. This property applies
    ///   to page blobs only. This property indicates how the service should modify the blob's sequence number
    /// * `options` - Optional parameters for the request.
    pub async fn update_sequence_number(
        &self,
        sequence_number_action: SequenceNumberActionType,
        options: Option<BlobPageBlobClientUpdateSequenceNumberOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_key_only("UpdateSequenceNumber")
            .append_pair("comp", "properties");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(blob_sequence_number) = options.blob_sequence_number {
            request.insert_header(
                "x-ms-blob-sequence-number",
                blob_sequence_number.to_string(),
            );
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header(
            "x-ms-sequence-number-action",
            sequence_number_action.to_string(),
        );
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Upload Pages operation writes a range of pages to a page blob
    ///
    /// # Arguments
    ///
    /// * `body` - The body of the request.
    /// * `content_length` - The length of the request.
    /// * `options` - Optional parameters for the request.
    pub async fn upload_pages(
        &self,
        body: RequestContent<Bytes>,
        content_length: i64,
        options: Option<BlobPageBlobClientUploadPagesOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("comp", "page")
            .append_key_only("update");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_sequence_number_equal_to) = options.if_sequence_number_equal_to {
            request.insert_header(
                "x-ms-if-sequence-number-eq",
                if_sequence_number_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than_or_equal_to) =
            options.if_sequence_number_less_than_or_equal_to
        {
            request.insert_header(
                "x-ms-if-sequence-number-le",
                if_sequence_number_less_than_or_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than) = options.if_sequence_number_less_than {
            request.insert_header(
                "x-ms-if-sequence-number-lt",
                if_sequence_number_less_than.to_string(),
            );
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(range) = options.range {
            request.insert_header("x-ms-range", range);
        }
        if let Some(structured_body_type) = options.structured_body_type {
            request.insert_header("x-ms-structured-body", structured_body_type);
        }
        if let Some(structured_content_length) = options.structured_content_length {
            request.insert_header(
                "x-ms-structured-content-length",
                structured_content_length.to_string(),
            );
        }
        request.insert_header("x-ms-version", &self.version);
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Upload Pages operation writes a range of pages to a page blob where the contents are read from a URL.
    ///
    /// # Arguments
    ///
    /// * `source_url` - Specify a URL to the copy source.
    /// * `source_range` - Bytes of source data in the specified range. The length of this range should match the ContentLength
    ///   header and x-ms-range/Range destination range header.
    /// * `content_length` - The length of the request.
    /// * `range` - Bytes of source data in the specified range. The length of this range should match the ContentLength header
    ///   and x-ms-range/Range destination range header.
    /// * `options` - Optional parameters for the request.
    pub async fn upload_pages_from_url(
        &self,
        source_url: &str,
        source_range: &str,
        content_length: i64,
        range: &str,
        options: Option<BlobPageBlobClientUploadPagesFromUrlOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("comp", "page")
            .append_key_only("fromUrl")
            .append_key_only("update");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        request.insert_header("x-ms-copy-source", source_url.to_owned());
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_sequence_number_equal_to) = options.if_sequence_number_equal_to {
            request.insert_header(
                "x-ms-if-sequence-number-eq",
                if_sequence_number_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than_or_equal_to) =
            options.if_sequence_number_less_than_or_equal_to
        {
            request.insert_header(
                "x-ms-if-sequence-number-le",
                if_sequence_number_less_than_or_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than) = options.if_sequence_number_less_than {
            request.insert_header(
                "x-ms-if-sequence-number-lt",
                if_sequence_number_less_than.to_string(),
            );
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-range", range.to_owned());
        if let Some(source_content_crc64) = options.source_content_crc64 {
            request.insert_header(
                "x-ms-source-content-crc64",
                base64::encode(source_content_crc64),
            );
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", source_content_md5);
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header("x-ms-source-if-modified-since", source_if_modified_since);
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                source_if_unmodified_since,
            );
        }
        request.insert_header("x-ms-source-range", source_range.to_owned());
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }
}
