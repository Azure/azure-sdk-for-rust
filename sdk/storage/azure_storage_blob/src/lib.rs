// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

#![doc = include_str!("../README.md")]
#![allow(dead_code)]
#![allow(unused_imports)]

pub mod clients;
mod generated;
mod parsers;
mod pipeline;
pub use clients::*;
pub use parsers::*;
pub mod models;

#[cfg(test)]
mod tests {
    use crate::models::BlobPropertiesInternal; // Now uses the corrected version from generated code
    use serde_json;

    #[test]
    fn test_etag_deserialization_with_lowercase_etag() {
        // Test JSON with "Etag" field (correct according to REST API docs)
        let json_with_etag = r#"{"Etag": "\"0x8CB171113DEADBEEF\""}"#;
        
        let result = serde_json::from_str::<BlobPropertiesInternal>(json_with_etag);
        match result {
            Ok(props) => {
                println!("Successfully deserialized with 'Etag' field. ETag value: {:?}", props.etag);
                assert!(props.etag.is_some(), "ETag should not be None when 'Etag' field is present");
                assert_eq!(props.etag.unwrap(), "\"0x8CB171113DEADBEEF\"");
            },
            Err(e) => {
                println!("Failed to deserialize with 'Etag' field: {}", e);
                panic!("Should have successfully deserialized with 'Etag' field");
            }
        }
    }

    #[test]
    fn test_etag_deserialization_with_capital_etag() {
        // Test JSON with "ETag" field (incorrect but was previously expected)
        let json_with_capital_etag = r#"{"ETag": "\"0x8CB171113DEADBEEF\""}"#;
        
        let result = serde_json::from_str::<BlobPropertiesInternal>(json_with_capital_etag);
        match result {
            Ok(props) => {
                println!("Deserialized with 'ETag' field. ETag value: {:?}", props.etag);
                // This should now fail to populate etag since we fixed the rename to "Etag"
                assert!(props.etag.is_none(), "ETag should be None when 'ETag' field is used with corrected struct");
            },
            Err(e) => {
                println!("Failed to deserialize with 'ETag' field: {}", e);
                panic!("Should have successfully deserialized even if etag field is ignored");
            }
        }
    }

    #[test]
    fn test_full_blob_properties_deserialization() {
        // Test with more complete JSON including the correct Etag field
        let json = r#"{
            "Etag": "\"0x8CB171113DEADBEEF\"",
            "BlobType": "BlockBlob",
            "Content-Length": 1024,
            "Content-Type": "text/plain",
            "Last-Modified": "Wed, 09 Sep 2009 09:20:02 GMT"
        }"#;
        
        let result = serde_json::from_str::<BlobPropertiesInternal>(json);
        match result {
            Ok(props) => {
                assert!(props.etag.is_some());
                assert_eq!(props.etag.unwrap(), "\"0x8CB171113DEADBEEF\"");
                assert_eq!(props.content_length, Some(1024));
                assert_eq!(props.content_type, Some("text/plain".to_string()));
            },
            Err(e) => {
                panic!("Should have successfully deserialized complete blob properties: {}", e);
            }
        }
    }

    #[test]
    fn test_blob_list_response_etag_fix() {
        // Test simulating actual Azure Blob Storage List Blobs API response format
        // This tests the scenario described in the issue where etag was always None
        let list_blobs_response_json = r#"{
            "Blob": [
                {
                    "Name": {
                        "$text": "test-blob.txt"
                    },
                    "Properties": {
                        "Etag": "\"0x8CB171113DEADBEEF\"",
                        "BlobType": "BlockBlob",
                        "Content-Length": 1024,
                        "Content-Type": "text/plain",
                        "Last-Modified": "Wed, 09 Sep 2009 09:20:02 GMT"
                    }
                }
            ]
        }"#;
        
        use crate::models::{BlobFlatListSegment, BlobItemInternal};
        
        let result = serde_json::from_str::<BlobFlatListSegment>(list_blobs_response_json);
        match result {
            Ok(blob_list) => {
                println!("Parsed blob list with {} items", blob_list.blob_items.len());
                assert_eq!(blob_list.blob_items.len(), 1);
                let blob = &blob_list.blob_items[0];
                
                println!("Blob properties present: {:?}", blob.properties.is_some());
                assert!(blob.properties.is_some(), "Blob properties should be present");
                
                let properties = blob.properties.as_ref().unwrap();
                println!("ETag value in properties: {:?}", properties.etag);
                
                assert!(properties.etag.is_some(), "ETag should not be None - this was the bug!");
                assert_eq!(properties.etag.as_ref().unwrap(), "\"0x8CB171113DEADBEEF\"");
                
                println!("âœ… ETag is now correctly populated: {:?}", properties.etag);
            },
            Err(e) => {
                panic!("Should have successfully deserialized blob list response: {}", e);
            }
        }
    }
}
