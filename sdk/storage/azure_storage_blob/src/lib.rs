// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

#![doc = include_str!("../README.md")]
#![allow(dead_code)]
#![allow(unused_imports)]

pub mod clients;
mod generated;
mod parsers;
mod pipeline;
pub use clients::*;
pub use parsers::*;
pub mod models;

#[cfg(test)]
mod tests {
    use crate::generated::models::BlobPropertiesInternal; // Uses generated code (which still has the bug)
    use serde_json;

    #[test]
    fn test_etag_deserialization_issue_with_lowercase_etag() {
        // Test JSON with "Etag" field (correct according to REST API docs, but currently doesn't work)
        // This test demonstrates the existing bug where the correct API field name doesn't populate etag
        let json_with_etag = r#"{"Etag": "\"0x8CB171113DEADBEEF\""}"#;
        
        let result = serde_json::from_str::<BlobPropertiesInternal>(json_with_etag);
        match result {
            Ok(props) => {
                println!("Deserialized with 'Etag' field. ETag value: {:?}", props.etag);
                // This demonstrates the bug - etag will be None even though the JSON has the correct field name
                assert!(props.etag.is_none(), "BUG: ETag is None even when 'Etag' field is present (needs TypeSpec fix)");
            },
            Err(e) => {
                panic!("Should have successfully deserialized even if etag field is ignored: {}", e);
            }
        }
    }

    #[test]
    fn test_etag_deserialization_with_capital_etag() {
        // Test JSON with "ETag" field (incorrect according to API docs, but currently expected by generated code)
        let json_with_capital_etag = r#"{"ETag": "\"0x8CB171113DEADBEEF\""}"#;
        
        let result = serde_json::from_str::<BlobPropertiesInternal>(json_with_capital_etag);
        match result {
            Ok(props) => {
                println!("Deserialized with 'ETag' field. ETag value: {:?}", props.etag);
                // The generated code currently expects "ETag" so this works
                assert!(props.etag.is_some(), "ETag should be populated when using 'ETag' field (current generated code behavior)");
                assert_eq!(props.etag.unwrap(), "\"0x8CB171113DEADBEEF\"");
            },
            Err(e) => {
                panic!("Should have successfully deserialized with 'ETag' field: {}", e);
            }
        }
    }

    #[test]
    fn test_full_blob_properties_deserialization_demonstrates_bug() {
        // This test demonstrates the existing bug where the actual API field name "Etag" doesn't work
        let json_with_correct_field = r#"{
            "Etag": "\"0x8CB171113DEADBEEF\"",
            "BlobType": "BlockBlob",
            "Content-Length": 1024,
            "Content-Type": "text/plain",
            "Last-Modified": "Wed, 09 Sep 2009 09:20:02 GMT"
        }"#;
        
        let result = serde_json::from_str::<BlobPropertiesInternal>(json_with_correct_field);
        match result {
            Ok(props) => {
                // BUG: etag will be None even though the JSON has the correct field name
                assert!(props.etag.is_none(), "BUG: ETag is None when using correct API field name 'Etag'");
                assert_eq!(props.content_length, Some(1024));
                assert_eq!(props.content_type, Some("text/plain".to_string()));
            },
            Err(e) => {
                panic!("Should have successfully deserialized blob properties: {}", e);
            }
        }
        
        // But if we use "ETag" (incorrect according to API docs), it works
        let json_with_incorrect_field = r#"{
            "ETag": "\"0x8CB171113DEADBEEF\"",
            "BlobType": "BlockBlob",
            "Content-Length": 1024,
            "Content-Type": "text/plain",
            "Last-Modified": "Wed, 09 Sep 2009 09:20:02 GMT"
        }"#;
        
        let result2 = serde_json::from_str::<BlobPropertiesInternal>(json_with_incorrect_field);
        match result2 {
            Ok(props) => {
                // This works because the generated code currently expects "ETag"
                assert!(props.etag.is_some(), "ETag is populated when using incorrect field name 'ETag'");
                assert_eq!(props.etag.unwrap(), "\"0x8CB171113DEADBEEF\"");
            },
            Err(e) => {
                panic!("Should have successfully deserialized blob properties: {}", e);
            }
        }
    }
}
