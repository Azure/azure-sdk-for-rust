// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::generated::models::{
    BackupSecretResult, DeletedSecret, ListDeletedSecretPropertiesResult,
    ListSecretPropertiesResult, RestoreSecretParameters, Secret, SecretClientBackupSecretOptions,
    SecretClientDeleteSecretOptions, SecretClientGetDeletedSecretOptions,
    SecretClientGetSecretOptions, SecretClientListDeletedSecretPropertiesOptions,
    SecretClientListSecretPropertiesOptions, SecretClientListSecretPropertiesVersionsOptions,
    SecretClientPurgeDeletedSecretOptions, SecretClientRecoverDeletedSecretOptions,
    SecretClientRestoreSecretOptions, SecretClientSetSecretOptions,
    SecretClientUpdateSecretPropertiesOptions, SetSecretParameters,
    UpdateSecretPropertiesParameters,
};
use azure_core::{
    error::CheckSuccessOptions,
    http::{
        pager::{PagerContinuation, PagerResult, PagerState},
        Method, NoFormat, Pager, Pipeline, PipelineSendOptions, RawResponse, Request,
        RequestContent, Response, Url, UrlExt,
    },
    json, tracing, Result,
};

/// The key vault client performs cryptographic key operations and vault operations against the Key Vault service.
#[tracing::client]
pub struct SecretClient {
    pub(crate) api_version: String,
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
}

impl SecretClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// Backs up the specified secret.
    ///
    /// Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will be downloaded.
    /// This operation requires the secrets/backup permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.backupSecret")]
    pub async fn backup_secret(
        &self,
        secret_name: &str,
        options: Option<SecretClientBackupSecretOptions<'_>>,
    ) -> Result<Response<BackupSecretResult>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}/backup");
        path = path.replace("{secret-name}", secret_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Deletes a secret from a specified key vault.
    ///
    /// The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual version
    /// of a secret. This operation requires the secrets/delete permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.deleteSecret")]
    pub async fn delete_secret(
        &self,
        secret_name: &str,
        options: Option<SecretClientDeleteSecretOptions<'_>>,
    ) -> Result<Response<DeletedSecret>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}");
        path = path.replace("{secret-name}", secret_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Gets the specified deleted secret.
    ///
    /// The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This operation requires
    /// the secrets/get permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getDeletedSecret")]
    pub async fn get_deleted_secret(
        &self,
        secret_name: &str,
        options: Option<SecretClientGetDeletedSecretOptions<'_>>,
    ) -> Result<Response<DeletedSecret>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedsecrets/{secret-name}");
        path = path.replace("{secret-name}", secret_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Get a specified secret from a given key vault.
    ///
    /// The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getSecret")]
    pub async fn get_secret(
        &self,
        secret_name: &str,
        options: Option<SecretClientGetSecretOptions<'_>>,
    ) -> Result<Response<Secret>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}/{secret-version}");
        path = path.replace("{secret-name}", secret_name);
        path = match options.secret_version.as_ref() {
            Some(secret_version) => path.replace("{secret-version}", secret_version),
            None => path.replace("{secret-version}", ""),
        };
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        if let Some(out_content_type) = options.out_content_type.as_ref() {
            query_builder.set_pair("outContentType", out_content_type.as_ref());
        }
        query_builder.build();
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Lists deleted secrets for the specified vault.
    ///
    /// The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete. This
    /// operation requires the secrets/list permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getDeletedSecrets")]
    pub fn list_deleted_secret_properties(
        &self,
        options: Option<SecretClientListDeletedSecretPropertiesOptions<'_>>,
    ) -> Result<Pager<ListDeletedSecretPropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url.append_path("/deletedsecrets");
        let mut query_builder = first_url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            query_builder.set_pair("maxresults", maxresults.to_string());
        }
        query_builder.build();
        let api_version = self.api_version.clone();
        Ok(Pager::new(
            move |next_link: PagerState, pager_options| {
                let url = match next_link {
                    PagerState::More(next_link) => {
                        let mut next_link: Url = next_link.try_into().expect("expected Url");
                        let mut query_builder = next_link.query_builder();
                        query_builder.set_pair("api-version", &api_version);
                        query_builder.build();
                        next_link
                    }
                    PagerState::Initial => first_url.clone(),
                };
                let mut request = Request::new(url, Method::Get);
                request.insert_header("accept", "application/json");
                let pipeline = pipeline.clone();
                Box::pin({
                    let first_url = first_url.clone();
                    async move {
                        let rsp = pipeline
                            .send(
                                &pager_options.context,
                                &mut request,
                                Some(PipelineSendOptions {
                                    check_success: CheckSuccessOptions {
                                        success_codes: &[200],
                                    },
                                    ..Default::default()
                                }),
                            )
                            .await?;
                        let (status, headers, body) = rsp.deconstruct();
                        let res: ListDeletedSecretPropertiesResult = json::from_json(&body)?;
                        let rsp = RawResponse::from_bytes(status, headers, body).into();
                        Ok(match res.next_link {
                            Some(next_link) if !next_link.is_empty() => PagerResult::More {
                                response: rsp,
                                continuation: PagerContinuation::Link(
                                    first_url.join(next_link.as_ref())?,
                                ),
                            },
                            _ => PagerResult::Done { response: rsp },
                        })
                    }
                })
            },
            Some(options.method_options),
        ))
    }

    /// List secrets in a specified key vault.
    ///
    /// The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its attributes
    /// are provided in the response. Individual secret versions are not listed in the response. This operation requires the secrets/list
    /// permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getSecrets")]
    pub fn list_secret_properties(
        &self,
        options: Option<SecretClientListSecretPropertiesOptions<'_>>,
    ) -> Result<Pager<ListSecretPropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url.append_path("/secrets");
        let mut query_builder = first_url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            query_builder.set_pair("maxresults", maxresults.to_string());
        }
        query_builder.build();
        let api_version = self.api_version.clone();
        Ok(Pager::new(
            move |next_link: PagerState, pager_options| {
                let url = match next_link {
                    PagerState::More(next_link) => {
                        let mut next_link: Url = next_link.try_into().expect("expected Url");
                        let mut query_builder = next_link.query_builder();
                        query_builder.set_pair("api-version", &api_version);
                        query_builder.build();
                        next_link
                    }
                    PagerState::Initial => first_url.clone(),
                };
                let mut request = Request::new(url, Method::Get);
                request.insert_header("accept", "application/json");
                let pipeline = pipeline.clone();
                Box::pin({
                    let first_url = first_url.clone();
                    async move {
                        let rsp = pipeline
                            .send(
                                &pager_options.context,
                                &mut request,
                                Some(PipelineSendOptions {
                                    check_success: CheckSuccessOptions {
                                        success_codes: &[200],
                                    },
                                    ..Default::default()
                                }),
                            )
                            .await?;
                        let (status, headers, body) = rsp.deconstruct();
                        let res: ListSecretPropertiesResult = json::from_json(&body)?;
                        let rsp = RawResponse::from_bytes(status, headers, body).into();
                        Ok(match res.next_link {
                            Some(next_link) if !next_link.is_empty() => PagerResult::More {
                                response: rsp,
                                continuation: PagerContinuation::Link(
                                    first_url.join(next_link.as_ref())?,
                                ),
                            },
                            _ => PagerResult::Done { response: rsp },
                        })
                    }
                })
            },
            Some(options.method_options),
        ))
    }

    /// List all versions of the specified secret.
    ///
    /// The full secret identifier and attributes are provided in the response. No values are returned for the secrets. This operations
    /// requires the secrets/list permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getSecretVersions")]
    pub fn list_secret_properties_versions(
        &self,
        secret_name: &str,
        options: Option<SecretClientListSecretPropertiesVersionsOptions<'_>>,
    ) -> Result<Pager<ListSecretPropertiesResult>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}/versions");
        path = path.replace("{secret-name}", secret_name);
        first_url.append_path(&path);
        let mut query_builder = first_url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            query_builder.set_pair("maxresults", maxresults.to_string());
        }
        query_builder.build();
        let api_version = self.api_version.clone();
        Ok(Pager::new(
            move |next_link: PagerState, pager_options| {
                let url = match next_link {
                    PagerState::More(next_link) => {
                        let mut next_link: Url = next_link.try_into().expect("expected Url");
                        let mut query_builder = next_link.query_builder();
                        query_builder.set_pair("api-version", &api_version);
                        query_builder.build();
                        next_link
                    }
                    PagerState::Initial => first_url.clone(),
                };
                let mut request = Request::new(url, Method::Get);
                request.insert_header("accept", "application/json");
                let pipeline = pipeline.clone();
                Box::pin({
                    let first_url = first_url.clone();
                    async move {
                        let rsp = pipeline
                            .send(
                                &pager_options.context,
                                &mut request,
                                Some(PipelineSendOptions {
                                    check_success: CheckSuccessOptions {
                                        success_codes: &[200],
                                    },
                                    ..Default::default()
                                }),
                            )
                            .await?;
                        let (status, headers, body) = rsp.deconstruct();
                        let res: ListSecretPropertiesResult = json::from_json(&body)?;
                        let rsp = RawResponse::from_bytes(status, headers, body).into();
                        Ok(match res.next_link {
                            Some(next_link) if !next_link.is_empty() => PagerResult::More {
                                response: rsp,
                                continuation: PagerContinuation::Link(
                                    first_url.join(next_link.as_ref())?,
                                ),
                            },
                            _ => PagerResult::Done { response: rsp },
                        })
                    }
                })
            },
            Some(options.method_options),
        ))
    }

    /// Permanently deletes the specified secret.
    ///
    /// The purge deleted secret operation removes the secret permanently, without the possibility of recovery. This operation
    /// can only be enabled on a soft-delete enabled vault. This operation requires the secrets/purge permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.purgeDeletedSecret")]
    pub async fn purge_deleted_secret(
        &self,
        secret_name: &str,
        options: Option<SecretClientPurgeDeletedSecretOptions<'_>>,
    ) -> Result<Response<(), NoFormat>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedsecrets/{secret-name}");
        path = path.replace("{secret-name}", secret_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Delete);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[204],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Recovers the deleted secret to the latest version.
    ///
    /// Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete enabled vault.
    /// This operation requires the secrets/recover permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the deleted secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.recoverDeletedSecret")]
    pub async fn recover_deleted_secret(
        &self,
        secret_name: &str,
        options: Option<SecretClientRecoverDeletedSecretOptions<'_>>,
    ) -> Result<Response<Secret>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedsecrets/{secret-name}/recover");
        path = path.replace("{secret-name}", secret_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Restores a backed up secret to a vault.
    ///
    /// Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore permission.
    ///
    /// # Arguments
    ///
    /// * `parameters` - The parameters to restore the secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.restoreSecret")]
    pub async fn restore_secret(
        &self,
        parameters: RequestContent<RestoreSecretParameters>,
        options: Option<SecretClientRestoreSecretOptions<'_>>,
    ) -> Result<Response<Secret>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url.append_path("/secrets/restore");
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Sets a secret in a specified key vault.
    ///
    /// The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault creates a
    /// new version of that secret. This operation requires the secrets/set permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the secret. The value you provide may be copied globally for the purpose of running the
    ///   service. The value provided should not include personally identifiable or sensitive information.
    /// * `parameters` - The parameters for setting the secret.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.setSecret")]
    pub async fn set_secret(
        &self,
        secret_name: &str,
        parameters: RequestContent<SetSecretParameters>,
        options: Option<SecretClientSetSecretOptions<'_>>,
    ) -> Result<Response<Secret>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}");
        path = path.replace("{secret-name}", secret_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Updates the attributes associated with a specified secret in a given key vault.
    ///
    /// The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not specified in the
    /// request are left unchanged. The value of a secret itself cannot be changed. This operation requires the secrets/set permission.
    ///
    /// # Arguments
    ///
    /// * `secret_name` - The name of the secret.
    /// * `parameters` - The parameters for update secret operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateSecret")]
    pub async fn update_secret_properties(
        &self,
        secret_name: &str,
        parameters: RequestContent<UpdateSecretPropertiesParameters>,
        options: Option<SecretClientUpdateSecretPropertiesOptions<'_>>,
    ) -> Result<Response<Secret>> {
        if secret_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter secret_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}/{secret-version}");
        path = path.replace("{secret-name}", secret_name);
        path = match options.secret_version.as_ref() {
            Some(secret_version) => path.replace("{secret-version}", secret_version),
            None => path.replace("{secret-version}", ""),
        };
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }
}
