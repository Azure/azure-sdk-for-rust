// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::{
    AsClientMethodOptions, BearerTokenCredentialPolicy, ClientMethodOptions, ClientOptions, Method, Pager, Pipeline, Policy, Request, RequestContent, Response, Result, Url,
};
use azure_core::credentials::TokenCredential;
use crate::models::{
    BackupSecretResult, DeletedSecretBundle, DeletedSecretListResult, SecretBundle, SecretListResult, SecretRestoreParameters, SecretSetParameters, SecretUpdateParameters,
};
use std::sync::Arc;
use typespec_client_core::json;
use typespec_client_core::http::PagerResult;

pub struct KeyVaultClient {
    api_version: String,
    endpoint: Url,
    pipeline: Pipeline,
}

#[derive(Clone, Debug)]
pub struct KeyVaultClientOptions {
    pub api_version: String,
    pub client_options: ClientOptions,
}

impl KeyVaultClient {
    pub fn new(endpoint: &str, credential: Arc<dyn TokenCredential>, options: Option<KeyVaultClientOptions>) -> Result<Self> {
        let mut endpoint = Url::parse(endpoint.as_ref())?;
        endpoint.set_query(None);
        let auth_policy: Arc<dyn Policy> = Arc::new(BearerTokenCredentialPolicy::new(credential, vec!["https://vault.azure.net/.default"]));
        let options = options.unwrap_or_default();
        Ok(Self {
            api_version: options.api_version,
            endpoint,
            pipeline: Pipeline::new(
                option_env!("CARGO_PKG_NAME"),
                option_env!("CARGO_PKG_VERSION"),
                options.client_options,
                Vec::default(),
                vec![auth_policy],
            ),
        })
    }

    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// Backs up the specified secret.
///
/// Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will be downloaded.
/// This operation requires the secrets/backup permission.
    pub async fn backup_secret(&self, secret_name: String, options: Option<KeyVaultClientBackupSecretOptions<'_>>) -> Result<Response<BackupSecretResult>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}/backup");
        path = path.replace("{secret-name}", &secret_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// Deletes a secret from a specified key vault.
///
/// The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual version
/// of a secret. This operation requires the secrets/delete permission.
    pub async fn delete_secret(&self, secret_name: String, options: Option<KeyVaultClientDeleteSecretOptions<'_>>) -> Result<Response<DeletedSecretBundle>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}");
        path = path.replace("{secret-name}", &secret_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// Gets the specified deleted secret.
///
/// The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This operation requires
/// the secrets/get permission.
    pub async fn get_deleted_secret(&self, secret_name: String, options: Option<KeyVaultClientGetDeletedSecretOptions<'_>>) -> Result<Response<DeletedSecretBundle>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedsecrets/{secret-name}");
        path = path.replace("{secret-name}", &secret_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// Lists deleted secrets for the specified vault.
///
/// The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete. This
/// operation requires the secrets/list permission.
    pub fn get_deleted_secrets(&self, options: Option<KeyVaultClientGetDeletedSecretsOptions<'_>>) -> Result<Pager<DeletedSecretListResult>> {
        let options = options.unwrap_or_default().into_owned();
        let endpoint = self.endpoint.clone();
        let pipeline = self.pipeline.clone();
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: Option<Url>| {
            let mut url: Url;
            match next_link {
                Some(next_link) => {
                    url = next_link;
                },
                None => {
                    url = endpoint.clone();
                    url.set_path("/deletedsecrets");
                    url.query_pairs_mut().append_pair("api-version", &api_version);
                    if let Some(maxresults) = options.maxresults {
                        url.query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                    }
                },
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let mut ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: Response<DeletedSecretListResult> = pipeline.send(&mut ctx, &mut request).await?;
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: DeletedSecretListResult = json::from_json(bytes.clone())?;
                let rsp = Response::from_bytes(status, headers, bytes);
                Ok(match res.next_link {
                    Some(next_link) => PagerResult::Continue {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    None => PagerResult::Complete {
                        response: rsp,
                    },
                })
            }
        }))
    }

    /// Get a specified secret from a given key vault.
///
/// The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get permission.
    pub async fn get_secret(&self, secret_name: String, secret_version: String, options: Option<KeyVaultClientGetSecretOptions<'_>>) -> Result<Response<SecretBundle>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}/{secret-version}");
        path = path.replace("{secret-name}", &secret_name);
        path = path.replace("{secret-version}", &secret_version);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// List all versions of the specified secret.
///
/// The full secret identifier and attributes are provided in the response. No values are returned for the secrets. This operations
/// requires the secrets/list permission.
    pub fn get_secret_versions(&self, secret_name: String, options: Option<KeyVaultClientGetSecretVersionsOptions<'_>>) -> Result<Pager<SecretListResult>> {
        let options = options.unwrap_or_default().into_owned();
        let endpoint = self.endpoint.clone();
        let pipeline = self.pipeline.clone();
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: Option<Url>| {
            let mut url: Url;
            match next_link {
                Some(next_link) => {
                    url = next_link;
                },
                None => {
                    url = endpoint.clone();
                    let mut path = String::from("/secrets/{secret-name}/versions");
                    path = path.replace("{secret-name}", &secret_name);
                    url.set_path(&path);
                    url.query_pairs_mut().append_pair("api-version", &api_version);
                    if let Some(maxresults) = options.maxresults {
                        url.query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                    }
                },
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let mut ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: Response<SecretListResult> = pipeline.send(&mut ctx, &mut request).await?;
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: SecretListResult = json::from_json(bytes.clone())?;
                let rsp = Response::from_bytes(status, headers, bytes);
                Ok(match res.next_link {
                    Some(next_link) => PagerResult::Continue {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    None => PagerResult::Complete {
                        response: rsp,
                    },
                })
            }
        }))
    }

    /// List secrets in a specified key vault.
///
/// The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its attributes
/// are provided in the response. Individual secret versions are not listed in the response. This operation requires the secrets/list
/// permission.
    pub fn get_secrets(&self, options: Option<KeyVaultClientGetSecretsOptions<'_>>) -> Result<Pager<SecretListResult>> {
        let options = options.unwrap_or_default().into_owned();
        let endpoint = self.endpoint.clone();
        let pipeline = self.pipeline.clone();
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: Option<Url>| {
            let mut url: Url;
            match next_link {
                Some(next_link) => {
                    url = next_link;
                },
                None => {
                    url = endpoint.clone();
                    url.set_path("/secrets");
                    url.query_pairs_mut().append_pair("api-version", &api_version);
                    if let Some(maxresults) = options.maxresults {
                        url.query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                    }
                },
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let mut ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: Response<SecretListResult> = pipeline.send(&mut ctx, &mut request).await?;
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: SecretListResult = json::from_json(bytes.clone())?;
                let rsp = Response::from_bytes(status, headers, bytes);
                Ok(match res.next_link {
                    Some(next_link) => PagerResult::Continue {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    None => PagerResult::Complete {
                        response: rsp,
                    },
                })
            }
        }))
    }

    /// Permanently deletes the specified secret.
///
/// The purge deleted secret operation removes the secret permanently, without the possibility of recovery. This operation
/// can only be enabled on a soft-delete enabled vault. This operation requires the secrets/purge permission.
    pub async fn purge_deleted_secret(&self, secret_name: String, options: Option<KeyVaultClientPurgeDeletedSecretOptions<'_>>) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedsecrets/{secret-name}");
        path = path.replace("{secret-name}", &secret_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// Recovers the deleted secret to the latest version.
///
/// Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete enabled vault.
/// This operation requires the secrets/recover permission.
    pub async fn recover_deleted_secret(&self, secret_name: String, options: Option<KeyVaultClientRecoverDeletedSecretOptions<'_>>) -> Result<Response<SecretBundle>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedsecrets/{secret-name}/recover");
        path = path.replace("{secret-name}", &secret_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// Restores a backed up secret to a vault.
///
/// Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore permission.
    pub async fn restore_secret(&self, parameters: RequestContent<SecretRestoreParameters>, options: Option<KeyVaultClientRestoreSecretOptions<'_>>) -> Result<Response<SecretBundle>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/secrets/restore");
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// Sets a secret in a specified key vault.
///
/// The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault creates a
/// new version of that secret. This operation requires the secrets/set permission.
    pub async fn set_secret(&self, secret_name: String, parameters: RequestContent<SecretSetParameters>, options: Option<KeyVaultClientSetSecretOptions<'_>>) -> Result<Response<SecretBundle>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}");
        path = path.replace("{secret-name}", &secret_name);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&mut ctx, &mut request).await

    }

    /// Updates the attributes associated with a specified secret in a given key vault.
///
/// The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not specified in the
/// request are left unchanged. The value of a secret itself cannot be changed. This operation requires the secrets/set permission.
    pub async fn update_secret(&self, secret_name: String, secret_version: String, parameters: RequestContent<SecretUpdateParameters>, options: Option<KeyVaultClientUpdateSecretOptions<'_>>) -> Result<Response<SecretBundle>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/secrets/{secret-name}/{secret-version}");
        path = path.replace("{secret-name}", &secret_name);
        path = path.replace("{secret-version}", &secret_version);
        url.set_path(&path);
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&mut ctx, &mut request).await

    }
}

impl Default for KeyVaultClientOptions {
    fn default() -> Self {
        Self {
            api_version: String::from("7.6-preview.1"),
            client_options: ClientOptions::default(),
        }
    }
}

#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientBackupSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientDeleteSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientGetDeletedSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientGetDeletedSecretsOptions<'a> {
    pub maxresults: Option<i32>,
    pub method_options: ClientMethodOptions<'a>,
}

impl<'a> KeyVaultClientGetDeletedSecretsOptions<'a> {
    pub fn into_owned(self) -> KeyVaultClientGetDeletedSecretsOptions<'static> {
        KeyVaultClientGetDeletedSecretsOptions {
            maxresults: self.maxresults,
            method_options: ClientMethodOptions {
                context: self.method_options.context.into_owned(),
            },
        }
    }
}

#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientGetSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientGetSecretVersionsOptions<'a> {
    pub maxresults: Option<i32>,
    pub method_options: ClientMethodOptions<'a>,
}

impl<'a> KeyVaultClientGetSecretVersionsOptions<'a> {
    pub fn into_owned(self) -> KeyVaultClientGetSecretVersionsOptions<'static> {
        KeyVaultClientGetSecretVersionsOptions {
            maxresults: self.maxresults,
            method_options: ClientMethodOptions {
                context: self.method_options.context.into_owned(),
            },
        }
    }
}

#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientGetSecretsOptions<'a> {
    pub maxresults: Option<i32>,
    pub method_options: ClientMethodOptions<'a>,
}

impl<'a> KeyVaultClientGetSecretsOptions<'a> {
    pub fn into_owned(self) -> KeyVaultClientGetSecretsOptions<'static> {
        KeyVaultClientGetSecretsOptions {
            maxresults: self.maxresults,
            method_options: ClientMethodOptions {
                context: self.method_options.context.into_owned(),
            },
        }
    }
}

#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientPurgeDeletedSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientRecoverDeletedSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientRestoreSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientSetSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Debug, Default)]
pub struct KeyVaultClientUpdateSecretOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


