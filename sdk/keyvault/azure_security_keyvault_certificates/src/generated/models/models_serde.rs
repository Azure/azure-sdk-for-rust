// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    CertificateCreateParameters, CertificateImportParameters, CertificateIssuerSetParameters,
    CertificateIssuerUpdateParameters, CertificateMergeParameters,
    CertificateOperationUpdateParameter, CertificatePolicy, CertificateRestoreParameters,
    CertificateUpdateParameters, Contacts,
};
use azure_core::{http::RequestContent, json::to_json, Result};

impl TryFrom<CertificateCreateParameters> for RequestContent<CertificateCreateParameters> {
    type Error = azure_core::Error;
    fn try_from(value: CertificateCreateParameters) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CertificateImportParameters> for RequestContent<CertificateImportParameters> {
    type Error = azure_core::Error;
    fn try_from(value: CertificateImportParameters) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CertificateIssuerSetParameters> for RequestContent<CertificateIssuerSetParameters> {
    type Error = azure_core::Error;
    fn try_from(value: CertificateIssuerSetParameters) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CertificateIssuerUpdateParameters>
    for RequestContent<CertificateIssuerUpdateParameters>
{
    type Error = azure_core::Error;
    fn try_from(value: CertificateIssuerUpdateParameters) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CertificateMergeParameters> for RequestContent<CertificateMergeParameters> {
    type Error = azure_core::Error;
    fn try_from(value: CertificateMergeParameters) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CertificateOperationUpdateParameter>
    for RequestContent<CertificateOperationUpdateParameter>
{
    type Error = azure_core::Error;
    fn try_from(value: CertificateOperationUpdateParameter) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CertificatePolicy> for RequestContent<CertificatePolicy> {
    type Error = azure_core::Error;
    fn try_from(value: CertificatePolicy) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CertificateRestoreParameters> for RequestContent<CertificateRestoreParameters> {
    type Error = azure_core::Error;
    fn try_from(value: CertificateRestoreParameters) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CertificateUpdateParameters> for RequestContent<CertificateUpdateParameters> {
    type Error = azure_core::Error;
    fn try_from(value: CertificateUpdateParameters) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<Contacts> for RequestContent<Contacts> {
    type Error = azure_core::Error;
    fn try_from(value: Contacts) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

pub mod vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<u8>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<u8>>>::new();
                for v in to_deserialize {
                    decoded0.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<u8>>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[Vec<u8>], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize.iter().map(base64::encode).collect();
        <Vec<String>>::serialize(&encoded0, serializer)
    }
}
