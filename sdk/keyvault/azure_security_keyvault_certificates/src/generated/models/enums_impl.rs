// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    CertificatePolicyAction, CurveName, DeletionRecoveryLevel, KeyType, KeyUsageType,
};
use azure_core::error::{Error, ErrorKind};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

impl FromStr for CertificatePolicyAction {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AutoRenew" => CertificatePolicyAction::AutoRenew,
            "EmailContacts" => CertificatePolicyAction::EmailContacts,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of CertificatePolicyAction found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for CertificatePolicyAction {
    fn as_ref(&self) -> &str {
        match self {
            CertificatePolicyAction::AutoRenew => "AutoRenew",
            CertificatePolicyAction::EmailContacts => "EmailContacts",
        }
    }
}

impl Display for CertificatePolicyAction {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CertificatePolicyAction::AutoRenew => Display::fmt("AutoRenew", f),
            CertificatePolicyAction::EmailContacts => Display::fmt("EmailContacts", f),
        }
    }
}

impl<'a> From<&'a CurveName> for &'a str {
    fn from(e: &'a CurveName) -> Self {
        match e {
            CurveName::P256 => "P-256",
            CurveName::P256K => "P-256K",
            CurveName::P384 => "P-384",
            CurveName::P521 => "P-521",
            CurveName::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for CurveName {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "P-256" => CurveName::P256,
            "P-256K" => CurveName::P256K,
            "P-384" => CurveName::P384,
            "P-521" => CurveName::P521,
            _ => CurveName::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for CurveName {
    fn as_ref(&self) -> &str {
        match self {
            CurveName::P256 => "P-256",
            CurveName::P256K => "P-256K",
            CurveName::P384 => "P-384",
            CurveName::P521 => "P-521",
            CurveName::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for CurveName {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CurveName::P256 => f.write_str("P-256"),
            CurveName::P256K => f.write_str("P-256K"),
            CurveName::P384 => f.write_str("P-384"),
            CurveName::P521 => f.write_str("P-521"),
            CurveName::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a DeletionRecoveryLevel> for &'a str {
    fn from(e: &'a DeletionRecoveryLevel) -> Self {
        match e {
            DeletionRecoveryLevel::CustomizedRecoverable => "CustomizedRecoverable",
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                "CustomizedRecoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                "CustomizedRecoverable+Purgeable"
            }
            DeletionRecoveryLevel::Purgeable => "Purgeable",
            DeletionRecoveryLevel::Recoverable => "Recoverable",
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                "Recoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::RecoverablePurgeable => "Recoverable+Purgeable",
            DeletionRecoveryLevel::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for DeletionRecoveryLevel {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "CustomizedRecoverable" => DeletionRecoveryLevel::CustomizedRecoverable,
            "CustomizedRecoverable+ProtectedSubscription" => {
                DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription
            }
            "CustomizedRecoverable+Purgeable" => {
                DeletionRecoveryLevel::CustomizedRecoverablePurgeable
            }
            "Purgeable" => DeletionRecoveryLevel::Purgeable,
            "Recoverable" => DeletionRecoveryLevel::Recoverable,
            "Recoverable+ProtectedSubscription" => {
                DeletionRecoveryLevel::RecoverableProtectedSubscription
            }
            "Recoverable+Purgeable" => DeletionRecoveryLevel::RecoverablePurgeable,
            _ => DeletionRecoveryLevel::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for DeletionRecoveryLevel {
    fn as_ref(&self) -> &str {
        match self {
            DeletionRecoveryLevel::CustomizedRecoverable => "CustomizedRecoverable",
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                "CustomizedRecoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                "CustomizedRecoverable+Purgeable"
            }
            DeletionRecoveryLevel::Purgeable => "Purgeable",
            DeletionRecoveryLevel::Recoverable => "Recoverable",
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                "Recoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::RecoverablePurgeable => "Recoverable+Purgeable",
            DeletionRecoveryLevel::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for DeletionRecoveryLevel {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            DeletionRecoveryLevel::CustomizedRecoverable => f.write_str("CustomizedRecoverable"),
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                f.write_str("CustomizedRecoverable+ProtectedSubscription")
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                f.write_str("CustomizedRecoverable+Purgeable")
            }
            DeletionRecoveryLevel::Purgeable => f.write_str("Purgeable"),
            DeletionRecoveryLevel::Recoverable => f.write_str("Recoverable"),
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                f.write_str("Recoverable+ProtectedSubscription")
            }
            DeletionRecoveryLevel::RecoverablePurgeable => f.write_str("Recoverable+Purgeable"),
            DeletionRecoveryLevel::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a KeyType> for &'a str {
    fn from(e: &'a KeyType) -> Self {
        match e {
            KeyType::Ec => "EC",
            KeyType::EcHsm => "EC-HSM",
            KeyType::Oct => "oct",
            KeyType::OctHsm => "oct-HSM",
            KeyType::Rsa => "RSA",
            KeyType::RsaHsm => "RSA-HSM",
            KeyType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for KeyType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "EC" => KeyType::Ec,
            "EC-HSM" => KeyType::EcHsm,
            "oct" => KeyType::Oct,
            "oct-HSM" => KeyType::OctHsm,
            "RSA" => KeyType::Rsa,
            "RSA-HSM" => KeyType::RsaHsm,
            _ => KeyType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for KeyType {
    fn as_ref(&self) -> &str {
        match self {
            KeyType::Ec => "EC",
            KeyType::EcHsm => "EC-HSM",
            KeyType::Oct => "oct",
            KeyType::OctHsm => "oct-HSM",
            KeyType::Rsa => "RSA",
            KeyType::RsaHsm => "RSA-HSM",
            KeyType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for KeyType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyType::Ec => f.write_str("EC"),
            KeyType::EcHsm => f.write_str("EC-HSM"),
            KeyType::Oct => f.write_str("oct"),
            KeyType::OctHsm => f.write_str("oct-HSM"),
            KeyType::Rsa => f.write_str("RSA"),
            KeyType::RsaHsm => f.write_str("RSA-HSM"),
            KeyType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a KeyUsageType> for &'a str {
    fn from(e: &'a KeyUsageType) -> Self {
        match e {
            KeyUsageType::CRlSign => "cRLSign",
            KeyUsageType::DataEncipherment => "dataEncipherment",
            KeyUsageType::DecipherOnly => "decipherOnly",
            KeyUsageType::DigitalSignature => "digitalSignature",
            KeyUsageType::EncipherOnly => "encipherOnly",
            KeyUsageType::KeyAgreement => "keyAgreement",
            KeyUsageType::KeyCertSign => "keyCertSign",
            KeyUsageType::KeyEncipherment => "keyEncipherment",
            KeyUsageType::NonRepudiation => "nonRepudiation",
            KeyUsageType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for KeyUsageType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "cRLSign" => KeyUsageType::CRlSign,
            "dataEncipherment" => KeyUsageType::DataEncipherment,
            "decipherOnly" => KeyUsageType::DecipherOnly,
            "digitalSignature" => KeyUsageType::DigitalSignature,
            "encipherOnly" => KeyUsageType::EncipherOnly,
            "keyAgreement" => KeyUsageType::KeyAgreement,
            "keyCertSign" => KeyUsageType::KeyCertSign,
            "keyEncipherment" => KeyUsageType::KeyEncipherment,
            "nonRepudiation" => KeyUsageType::NonRepudiation,
            _ => KeyUsageType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for KeyUsageType {
    fn as_ref(&self) -> &str {
        match self {
            KeyUsageType::CRlSign => "cRLSign",
            KeyUsageType::DataEncipherment => "dataEncipherment",
            KeyUsageType::DecipherOnly => "decipherOnly",
            KeyUsageType::DigitalSignature => "digitalSignature",
            KeyUsageType::EncipherOnly => "encipherOnly",
            KeyUsageType::KeyAgreement => "keyAgreement",
            KeyUsageType::KeyCertSign => "keyCertSign",
            KeyUsageType::KeyEncipherment => "keyEncipherment",
            KeyUsageType::NonRepudiation => "nonRepudiation",
            KeyUsageType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for KeyUsageType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyUsageType::CRlSign => f.write_str("cRLSign"),
            KeyUsageType::DataEncipherment => f.write_str("dataEncipherment"),
            KeyUsageType::DecipherOnly => f.write_str("decipherOnly"),
            KeyUsageType::DigitalSignature => f.write_str("digitalSignature"),
            KeyUsageType::EncipherOnly => f.write_str("encipherOnly"),
            KeyUsageType::KeyAgreement => f.write_str("keyAgreement"),
            KeyUsageType::KeyCertSign => f.write_str("keyCertSign"),
            KeyUsageType::KeyEncipherment => f.write_str("keyEncipherment"),
            KeyUsageType::NonRepudiation => f.write_str("nonRepudiation"),
            KeyUsageType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}
