// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::generated::models::{
    BackupCertificateResult, Certificate, CertificateClientBackupCertificateOptions,
    CertificateClientDeleteCertificateOperationOptions, CertificateClientDeleteCertificateOptions,
    CertificateClientDeleteContactsOptions, CertificateClientDeleteIssuerOptions,
    CertificateClientGetCertificateOperationOptions, CertificateClientGetCertificateOptions,
    CertificateClientGetCertificatePolicyOptions, CertificateClientGetContactsOptions,
    CertificateClientGetDeletedCertificateOptions, CertificateClientGetIssuerOptions,
    CertificateClientImportCertificateOptions, CertificateClientListCertificatePropertiesOptions,
    CertificateClientListCertificatePropertiesVersionsOptions,
    CertificateClientListDeletedCertificatePropertiesOptions,
    CertificateClientListIssuerPropertiesOptions, CertificateClientMergeCertificateOptions,
    CertificateClientPurgeDeletedCertificateOptions,
    CertificateClientRecoverDeletedCertificateOptions, CertificateClientRestoreCertificateOptions,
    CertificateClientSetContactsOptions, CertificateClientSetIssuerOptions,
    CertificateClientUpdateCertificateOperationOptions,
    CertificateClientUpdateCertificatePolicyOptions,
    CertificateClientUpdateCertificatePropertiesOptions, CertificateClientUpdateIssuerOptions,
    CertificateOperation, CertificatePolicy, Contacts, DeletedCertificate,
    ImportCertificateParameters, Issuer, ListCertificatePropertiesResult,
    ListDeletedCertificatePropertiesResult, ListIssuerPropertiesResult, MergeCertificateParameters,
    RestoreCertificateParameters, SetIssuerParameters, UpdateCertificateOperationParameter,
    UpdateCertificatePropertiesParameters, UpdateIssuerParameters,
};
use azure_core::{
    credentials::TokenCredential,
    error::CheckSuccessOptions,
    fmt::SafeDebug,
    http::{
        pager::{PagerResult, PagerState},
        policies::{BearerTokenCredentialPolicy, Policy},
        ClientOptions, Method, NoFormat, Pager, Pipeline, PipelineSendOptions, RawResponse,
        Request, RequestContent, Response, Url,
    },
    json, tracing, Result,
};
use std::sync::Arc;

/// The key vault client performs cryptographic key operations and vault operations against the Key Vault service.
#[tracing::client]
pub struct CertificateClient {
    pub(crate) api_version: String,
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
}

/// Options used when creating a [`CertificateClient`](CertificateClient)
#[derive(Clone, SafeDebug)]
pub struct CertificateClientOptions {
    /// The API version to use for this operation.
    pub api_version: String,
    /// Allows customization of the client.
    pub client_options: ClientOptions,
}

impl CertificateClient {
    /// Creates a new CertificateClient, using Entra ID authentication.
    ///
    /// # Arguments
    ///
    /// * `endpoint` - Service host
    /// * `credential` - An implementation of [`TokenCredential`](azure_core::credentials::TokenCredential) that can provide an
    ///   Entra ID token to use when authenticating.
    /// * `options` - Optional configuration for the client.
    #[tracing::new("KeyVault")]
    pub fn new(
        endpoint: &str,
        credential: Arc<dyn TokenCredential>,
        options: Option<CertificateClientOptions>,
    ) -> Result<Self> {
        let options = options.unwrap_or_default();
        let endpoint = Url::parse(endpoint)?;
        if !endpoint.scheme().starts_with("http") {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                format!("{endpoint} must use http(s)"),
            ));
        }
        let auth_policy: Arc<dyn Policy> = Arc::new(BearerTokenCredentialPolicy::new(
            credential,
            vec!["https://vault.azure.net/.default"],
        ));
        Ok(Self {
            endpoint,
            api_version: options.api_version,
            pipeline: Pipeline::new(
                option_env!("CARGO_PKG_NAME"),
                option_env!("CARGO_PKG_VERSION"),
                options.client_options,
                Vec::default(),
                vec![auth_policy],
                None,
            ),
        })
    }

    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// Backs up the specified certificate.
    ///
    /// Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate will
    /// be downloaded. This operation requires the certificates/backup permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.backupCertificate")]
    pub async fn backup_certificate(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientBackupCertificateOptions<'_>>,
    ) -> Result<Response<BackupCertificateResult>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/backup");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Deletes a certificate from a specified key vault.
    ///
    /// Deletes all versions of a certificate object along with its associated policy. Delete certificate cannot be used to remove
    /// individual versions of a certificate object. This operation requires the certificates/delete permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.deleteCertificate")]
    pub async fn delete_certificate(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientDeleteCertificateOptions<'_>>,
    ) -> Result<Response<DeletedCertificate>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Deletes the creation operation for a specific certificate.
    ///
    /// Deletes the creation operation for a specified certificate that is in the process of being created. The certificate is
    /// no longer created. This operation requires the certificates/update permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.deleteCertificateOperation")]
    pub async fn delete_certificate_operation(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientDeleteCertificateOperationOptions<'_>>,
    ) -> Result<Response<CertificateOperation>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/pending");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Deletes the certificate contacts for a specified key vault.
    ///
    /// Deletes the certificate contacts for a specified key vault certificate. This operation requires the certificates/managecontacts
    /// permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.deleteCertificateContacts")]
    pub async fn delete_contacts(
        &self,
        options: Option<CertificateClientDeleteContactsOptions<'_>>,
    ) -> Result<Response<Contacts>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url = url.join("certificates/contacts")?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Deletes the specified certificate issuer.
    ///
    /// The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from the vault. This operation
    /// requires the certificates/manageissuers/deleteissuers permission.
    ///
    /// # Arguments
    ///
    /// * `issuer_name` - The name of the issuer.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.deleteCertificateIssuer")]
    pub async fn delete_issuer(
        &self,
        issuer_name: &str,
        options: Option<CertificateClientDeleteIssuerOptions<'_>>,
    ) -> Result<Response<Issuer>> {
        if issuer_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter issuer_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/issuers/{issuer-name}");
        path = path.replace("{issuer-name}", issuer_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Gets information about a certificate.
    ///
    /// Gets information about a specific certificate. This operation requires the certificates/get permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate in the given vault.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getCertificate")]
    pub async fn get_certificate(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientGetCertificateOptions<'_>>,
    ) -> Result<Response<Certificate>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/{certificate-version}");
        path = path.replace("{certificate-name}", certificate_name);
        path = match options.certificate_version {
            Some(certificate_version) => {
                path.replace("{certificate-version}", &certificate_version)
            }
            None => path.replace("{certificate-version}", ""),
        };
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Gets the creation operation of a certificate.
    ///
    /// Gets the creation operation associated with a specified certificate. This operation requires the certificates/get permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getCertificateOperation")]
    pub async fn get_certificate_operation(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientGetCertificateOperationOptions<'_>>,
    ) -> Result<Response<CertificateOperation>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/pending");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Lists the policy for a certificate.
    ///
    /// The GetCertificatePolicy operation returns the specified certificate policy resources in the specified key vault. This
    /// operation requires the certificates/get permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate in a given key vault.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getCertificatePolicy")]
    pub async fn get_certificate_policy(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientGetCertificatePolicyOptions<'_>>,
    ) -> Result<Response<CertificatePolicy>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/policy");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Lists the certificate contacts for a specified key vault.
    ///
    /// The GetCertificateContacts operation returns the set of certificate contact resources in the specified key vault. This
    /// operation requires the certificates/managecontacts permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getCertificateContacts")]
    pub async fn get_contacts(
        &self,
        options: Option<CertificateClientGetContactsOptions<'_>>,
    ) -> Result<Response<Contacts>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url = url.join("certificates/contacts")?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Retrieves information about the specified deleted certificate.
    ///
    /// The GetDeletedCertificate operation retrieves the deleted certificate information plus its attributes, such as retention
    /// interval, scheduled permanent deletion and the current deletion recovery level. This operation requires the certificates/get
    /// permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getDeletedCertificate")]
    pub async fn get_deleted_certificate(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientGetDeletedCertificateOptions<'_>>,
    ) -> Result<Response<DeletedCertificate>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedcertificates/{certificate-name}");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Lists the specified certificate issuer.
    ///
    /// The GetCertificateIssuer operation returns the specified certificate issuer resources in the specified key vault. This
    /// operation requires the certificates/manageissuers/getissuers permission.
    ///
    /// # Arguments
    ///
    /// * `issuer_name` - The name of the issuer.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getCertificateIssuer")]
    pub async fn get_issuer(
        &self,
        issuer_name: &str,
        options: Option<CertificateClientGetIssuerOptions<'_>>,
    ) -> Result<Response<Issuer>> {
        if issuer_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter issuer_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/issuers/{issuer-name}");
        path = path.replace("{issuer-name}", issuer_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Imports a certificate into a specified key vault.
    ///
    /// Imports an existing valid certificate, containing a private key, into Azure Key Vault. This operation requires the certificates/import
    /// permission. The certificate to be imported can be in either PFX or PEM format. If the certificate is in PEM format the
    /// PEM file must contain the key as well as x509 certificates. Key Vault will only accept a key in PKCS#8 format.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate. The value you provide may be copied globally for the purpose of running
    ///   the service. The value provided should not include personally identifiable or sensitive information.
    /// * `parameters` - The parameters to import the certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.importCertificate")]
    pub async fn import_certificate(
        &self,
        certificate_name: &str,
        parameters: RequestContent<ImportCertificateParameters>,
        options: Option<CertificateClientImportCertificateOptions<'_>>,
    ) -> Result<Response<Certificate>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/import");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// List certificates in a specified key vault
    ///
    /// The GetCertificates operation returns the set of certificates resources in the specified key vault. This operation requires
    /// the certificates/list permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getCertificates")]
    pub fn list_certificate_properties(
        &self,
        options: Option<CertificateClientListCertificatePropertiesOptions<'_>>,
    ) -> Result<Pager<ListCertificatePropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url = first_url.join("certificates")?;
        first_url
            .query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        if let Some(include_pending) = options.include_pending {
            first_url
                .query_pairs_mut()
                .append_pair("includePending", &include_pending.to_string());
        }
        if let Some(maxresults) = options.maxresults {
            first_url
                .query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: PagerState<Url>| {
            let url = match next_link {
                PagerState::More(next_link) => {
                    let qp = next_link
                        .query_pairs()
                        .filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link
                        .query_pairs_mut()
                        .clear()
                        .extend_pairs(qp)
                        .append_pair("api-version", &api_version);
                    next_link
                }
                PagerState::Initial => first_url.clone(),
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp = pipeline
                    .send(
                        &ctx,
                        &mut request,
                        Some(PipelineSendOptions {
                            check_success: CheckSuccessOptions {
                                success_codes: &[200],
                            },
                            ..Default::default()
                        }),
                    )
                    .await?;
                let (status, headers, body) = rsp.deconstruct();
                let res: ListCertificatePropertiesResult = json::from_json(&body)?;
                let rsp = RawResponse::from_bytes(status, headers, body).into();
                Ok(match res.next_link {
                    Some(next_link) if !next_link.is_empty() => PagerResult::More {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    _ => PagerResult::Done { response: rsp },
                })
            }
        }))
    }

    /// List the versions of a certificate.
    ///
    /// The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This operation
    /// requires the certificates/list permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getCertificateVersions")]
    pub fn list_certificate_properties_versions(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientListCertificatePropertiesVersionsOptions<'_>>,
    ) -> Result<Pager<ListCertificatePropertiesResult>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/versions");
        path = path.replace("{certificate-name}", certificate_name);
        first_url = first_url.join(&path)?;
        first_url
            .query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            first_url
                .query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: PagerState<Url>| {
            let url = match next_link {
                PagerState::More(next_link) => {
                    let qp = next_link
                        .query_pairs()
                        .filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link
                        .query_pairs_mut()
                        .clear()
                        .extend_pairs(qp)
                        .append_pair("api-version", &api_version);
                    next_link
                }
                PagerState::Initial => first_url.clone(),
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp = pipeline
                    .send(
                        &ctx,
                        &mut request,
                        Some(PipelineSendOptions {
                            check_success: CheckSuccessOptions {
                                success_codes: &[200],
                            },
                            ..Default::default()
                        }),
                    )
                    .await?;
                let (status, headers, body) = rsp.deconstruct();
                let res: ListCertificatePropertiesResult = json::from_json(&body)?;
                let rsp = RawResponse::from_bytes(status, headers, body).into();
                Ok(match res.next_link {
                    Some(next_link) if !next_link.is_empty() => PagerResult::More {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    _ => PagerResult::Done { response: rsp },
                })
            }
        }))
    }

    /// Lists the deleted certificates in the specified vault currently available for recovery.
    ///
    /// The GetDeletedCertificates operation retrieves the certificates in the current vault which are in a deleted state and
    /// ready for recovery or purging. This operation includes deletion-specific information. This operation requires the certificates/get/list
    /// permission. This operation can only be enabled on soft-delete enabled vaults.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getDeletedCertificates")]
    pub fn list_deleted_certificate_properties(
        &self,
        options: Option<CertificateClientListDeletedCertificatePropertiesOptions<'_>>,
    ) -> Result<Pager<ListDeletedCertificatePropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url = first_url.join("deletedcertificates")?;
        first_url
            .query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        if let Some(include_pending) = options.include_pending {
            first_url
                .query_pairs_mut()
                .append_pair("includePending", &include_pending.to_string());
        }
        if let Some(maxresults) = options.maxresults {
            first_url
                .query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: PagerState<Url>| {
            let url = match next_link {
                PagerState::More(next_link) => {
                    let qp = next_link
                        .query_pairs()
                        .filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link
                        .query_pairs_mut()
                        .clear()
                        .extend_pairs(qp)
                        .append_pair("api-version", &api_version);
                    next_link
                }
                PagerState::Initial => first_url.clone(),
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp = pipeline
                    .send(
                        &ctx,
                        &mut request,
                        Some(PipelineSendOptions {
                            check_success: CheckSuccessOptions {
                                success_codes: &[200],
                            },
                            ..Default::default()
                        }),
                    )
                    .await?;
                let (status, headers, body) = rsp.deconstruct();
                let res: ListDeletedCertificatePropertiesResult = json::from_json(&body)?;
                let rsp = RawResponse::from_bytes(status, headers, body).into();
                Ok(match res.next_link {
                    Some(next_link) if !next_link.is_empty() => PagerResult::More {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    _ => PagerResult::Done { response: rsp },
                })
            }
        }))
    }

    /// List certificate issuers for a specified key vault.
    ///
    /// The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified key vault. This operation
    /// requires the certificates/manageissuers/getissuers permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getCertificateIssuers")]
    pub fn list_issuer_properties(
        &self,
        options: Option<CertificateClientListIssuerPropertiesOptions<'_>>,
    ) -> Result<Pager<ListIssuerPropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url = first_url.join("certificates/issuers")?;
        first_url
            .query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            first_url
                .query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: PagerState<Url>| {
            let url = match next_link {
                PagerState::More(next_link) => {
                    let qp = next_link
                        .query_pairs()
                        .filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link
                        .query_pairs_mut()
                        .clear()
                        .extend_pairs(qp)
                        .append_pair("api-version", &api_version);
                    next_link
                }
                PagerState::Initial => first_url.clone(),
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp = pipeline
                    .send(
                        &ctx,
                        &mut request,
                        Some(PipelineSendOptions {
                            check_success: CheckSuccessOptions {
                                success_codes: &[200],
                            },
                            ..Default::default()
                        }),
                    )
                    .await?;
                let (status, headers, body) = rsp.deconstruct();
                let res: ListIssuerPropertiesResult = json::from_json(&body)?;
                let rsp = RawResponse::from_bytes(status, headers, body).into();
                Ok(match res.next_link {
                    Some(next_link) if !next_link.is_empty() => PagerResult::More {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    _ => PagerResult::Done { response: rsp },
                })
            }
        }))
    }

    /// Merges a certificate or a certificate chain with a key pair existing on the server.
    ///
    /// The MergeCertificate operation performs the merging of a certificate or certificate chain with a key pair currently available
    /// in the service. This operation requires the certificates/create permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate.
    /// * `parameters` - The parameters to merge certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.mergeCertificate")]
    pub async fn merge_certificate(
        &self,
        certificate_name: &str,
        parameters: RequestContent<MergeCertificateParameters>,
        options: Option<CertificateClientMergeCertificateOptions<'_>>,
    ) -> Result<Response<Certificate>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/pending/merge");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[201],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Permanently deletes the specified deleted certificate.
    ///
    /// The PurgeDeletedCertificate operation performs an irreversible deletion of the specified certificate, without possibility
    /// for recovery. The operation is not available if the recovery level does not specify 'Purgeable'. This operation requires
    /// the certificate/purge permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.purgeDeletedCertificate")]
    pub async fn purge_deleted_certificate(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientPurgeDeletedCertificateOptions<'_>>,
    ) -> Result<Response<(), NoFormat>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedcertificates/{certificate-name}");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[204],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Recovers the deleted certificate back to its current version under /certificates.
    ///
    /// The RecoverDeletedCertificate operation performs the reversal of the Delete operation. The operation is applicable in
    /// vaults enabled for soft-delete, and must be issued during the retention interval (available in the deleted certificate's
    /// attributes). This operation requires the certificates/recover permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the deleted certificate
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.recoverDeletedCertificate")]
    pub async fn recover_deleted_certificate(
        &self,
        certificate_name: &str,
        options: Option<CertificateClientRecoverDeletedCertificateOptions<'_>>,
    ) -> Result<Response<Certificate>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedcertificates/{certificate-name}/recover");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Restores a backed up certificate to a vault.
    ///
    /// Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore permission.
    ///
    /// # Arguments
    ///
    /// * `parameters` - The parameters to restore the certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.restoreCertificate")]
    pub async fn restore_certificate(
        &self,
        parameters: RequestContent<RestoreCertificateParameters>,
        options: Option<CertificateClientRestoreCertificateOptions<'_>>,
    ) -> Result<Response<Certificate>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url = url.join("certificates/restore")?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Sets the certificate contacts for the specified key vault.
    ///
    /// Sets the certificate contacts for the specified key vault. This operation requires the certificates/managecontacts permission.
    ///
    /// # Arguments
    ///
    /// * `contacts` - The contacts for the key vault certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.setCertificateContacts")]
    pub async fn set_contacts(
        &self,
        contacts: RequestContent<Contacts>,
        options: Option<CertificateClientSetContactsOptions<'_>>,
    ) -> Result<Response<Contacts>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url = url.join("certificates/contacts")?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(contacts);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Sets the specified certificate issuer.
    ///
    /// The SetCertificateIssuer operation adds or updates the specified certificate issuer. This operation requires the certificates/setissuers
    /// permission.
    ///
    /// # Arguments
    ///
    /// * `issuer_name` - The name of the issuer. The value you provide may be copied globally for the purpose of running the
    ///   service. The value provided should not include personally identifiable or sensitive information.
    /// * `parameter` - Certificate issuer set parameter.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.setCertificateIssuer")]
    pub async fn set_issuer(
        &self,
        issuer_name: &str,
        parameter: RequestContent<SetIssuerParameters>,
        options: Option<CertificateClientSetIssuerOptions<'_>>,
    ) -> Result<Response<Issuer>> {
        if issuer_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter issuer_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/issuers/{issuer-name}");
        path = path.replace("{issuer-name}", issuer_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameter);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Updates a certificate operation.
    ///
    /// Updates a certificate creation operation that is already in progress. This operation requires the certificates/update
    /// permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate.
    /// * `certificate_operation` - The certificate operation response.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateCertificateOperation")]
    pub async fn update_certificate_operation(
        &self,
        certificate_name: &str,
        certificate_operation: RequestContent<UpdateCertificateOperationParameter>,
        options: Option<CertificateClientUpdateCertificateOperationOptions<'_>>,
    ) -> Result<Response<CertificateOperation>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/pending");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(certificate_operation);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Updates the policy for a certificate.
    ///
    /// Set specified members in the certificate policy. Leave others as null. This operation requires the certificates/update
    /// permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate in the given vault.
    /// * `certificate_policy` - The policy for the certificate.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateCertificatePolicy")]
    pub async fn update_certificate_policy(
        &self,
        certificate_name: &str,
        certificate_policy: RequestContent<CertificatePolicy>,
        options: Option<CertificateClientUpdateCertificatePolicyOptions<'_>>,
    ) -> Result<Response<CertificatePolicy>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/policy");
        path = path.replace("{certificate-name}", certificate_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(certificate_policy);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Updates the specified attributes associated with the given certificate.
    ///
    /// The UpdateCertificate operation applies the specified update on the given certificate; the only elements updated are the
    /// certificate's attributes. This operation requires the certificates/update permission.
    ///
    /// # Arguments
    ///
    /// * `certificate_name` - The name of the certificate in the given key vault.
    /// * `parameters` - The parameters for certificate update.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateCertificate")]
    pub async fn update_certificate_properties(
        &self,
        certificate_name: &str,
        parameters: RequestContent<UpdateCertificatePropertiesParameters>,
        options: Option<CertificateClientUpdateCertificatePropertiesOptions<'_>>,
    ) -> Result<Response<Certificate>> {
        if certificate_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter certificate_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/{certificate-name}/{certificate-version}");
        path = path.replace("{certificate-name}", certificate_name);
        path = match options.certificate_version {
            Some(certificate_version) => {
                path.replace("{certificate-version}", &certificate_version)
            }
            None => path.replace("{certificate-version}", ""),
        };
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Updates the specified certificate issuer.
    ///
    /// The UpdateCertificateIssuer operation performs an update on the specified certificate issuer entity. This operation requires
    /// the certificates/setissuers permission.
    ///
    /// # Arguments
    ///
    /// * `issuer_name` - The name of the issuer.
    /// * `parameter` - Certificate issuer update parameter.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateCertificateIssuer")]
    pub async fn update_issuer(
        &self,
        issuer_name: &str,
        parameter: RequestContent<UpdateIssuerParameters>,
        options: Option<CertificateClientUpdateIssuerOptions<'_>>,
    ) -> Result<Response<Issuer>> {
        if issuer_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter issuer_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("certificates/issuers/{issuer-name}");
        path = path.replace("{issuer-name}", issuer_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameter);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }
}

impl Default for CertificateClientOptions {
    fn default() -> Self {
        Self {
            api_version: String::from("2025-07-01"),
            client_options: ClientOptions::default(),
        }
    }
}
