// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    CurveName, DeletionRecoveryLevel, EncryptionAlgorithm, KeyEncryptionAlgorithm, KeyOperation,
    KeyRotationPolicyAction, KeyType, SignatureAlgorithm,
};
use azure_core::{
    base64::{deserialize_url_safe, serialize_url_safe},
    fmt::SafeDebug,
    time::OffsetDateTime,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// The backup key result, containing the backup blob.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct BackupKeyResult {
    /// The backup blob containing the backed up key.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub value: Option<Vec<u8>>,
}

/// The key create parameters.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct CreateKeyParameters {
    /// Elliptic curve name. For valid values, see JsonWebKeyCurveName.
    #[serde(rename = "crv", skip_serializing_if = "Option::is_none")]
    pub curve: Option<CurveName>,

    /// The attributes of a key managed by the key vault service.
    #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
    pub key_attributes: Option<KeyAttributes>,

    /// Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_ops: Option<Vec<KeyOperation>>,

    /// The key size in bits. For example: 2048, 3072, or 4096 for RSA.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_size: Option<i32>,

    /// The type of key to create. For valid values, see JsonWebKeyType.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kty: Option<KeyType>,

    /// The public exponent for a RSA key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public_exponent: Option<i32>,

    /// The policy rules under which the key can be exported.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_policy: Option<KeyReleasePolicy>,

    /// Application specific metadata in the form of key-value pairs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// A DeletedKeyBundle consisting of a WebKey plus its Attributes and deletion info
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DeletedKey {
    /// The key management attributes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<KeyAttributes>,

    /// The time when the key was deleted, in UTC
    #[serde(
        default,
        rename = "deletedDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub deleted_date: Option<OffsetDateTime>,

    /// The Json web key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<JsonWebKey>,

    /// True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub managed: Option<bool>,

    /// The url of the recovery object, used to identify and recover the deleted key.
    #[serde(rename = "recoveryId", skip_serializing_if = "Option::is_none")]
    pub recovery_id: Option<String>,

    /// The policy rules under which the key can be exported.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_policy: Option<KeyReleasePolicy>,

    /// The time when the key is scheduled to be purged, in UTC
    #[serde(
        default,
        rename = "scheduledPurgeDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub scheduled_purge_date: Option<OffsetDateTime>,

    /// Application specific metadata in the form of key-value pairs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The deleted key item containing the deleted key metadata and information about deletion.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DeletedKeyProperties {
    /// The key management attributes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<KeyAttributes>,

    /// The time when the key was deleted, in UTC
    #[serde(
        default,
        rename = "deletedDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub deleted_date: Option<OffsetDateTime>,

    /// Key identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kid: Option<String>,

    /// True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub managed: Option<bool>,

    /// The url of the recovery object, used to identify and recover the deleted key.
    #[serde(rename = "recoveryId", skip_serializing_if = "Option::is_none")]
    pub recovery_id: Option<String>,

    /// The time when the key is scheduled to be purged, in UTC
    #[serde(
        default,
        rename = "scheduledPurgeDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub scheduled_purge_date: Option<OffsetDateTime>,

    /// Application specific metadata in the form of key-value pairs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The get random bytes request object.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct GetRandomBytesParameters {
    /// The requested number of random bytes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
}

/// The key import parameters.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ImportKeyParameters {
    /// Whether to import as a hardware key (HSM) or software key.
    #[serde(rename = "Hsm", skip_serializing_if = "Option::is_none")]
    pub hsm: Option<bool>,

    /// The Json web key
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<JsonWebKey>,

    /// The key management attributes.
    #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
    pub key_attributes: Option<KeyAttributes>,

    /// The policy rules under which the key can be exported.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_policy: Option<KeyReleasePolicy>,

    /// Application specific metadata in the form of key-value pairs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// As of <http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18>
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct JsonWebKey {
    /// Elliptic curve name. For valid values, see JsonWebKeyCurveName.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub crv: Option<CurveName>,

    /// RSA private exponent, or the D component of an EC private key.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub d: Option<Vec<u8>>,

    /// RSA private key parameter.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub dp: Option<Vec<u8>>,

    /// RSA private key parameter.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub dq: Option<Vec<u8>>,

    /// RSA public exponent.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub e: Option<Vec<u8>>,

    /// Symmetric key.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub k: Option<Vec<u8>>,

    /// Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_ops: Option<Vec<String>>,

    /// Key identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kid: Option<String>,

    /// JsonWebKey Key Type (kty), as defined in <https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40>.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kty: Option<KeyType>,

    /// RSA modulus.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub n: Option<Vec<u8>>,

    /// RSA secret prime.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub p: Option<Vec<u8>>,

    /// RSA secret prime, with p < q.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub q: Option<Vec<u8>>,

    /// RSA private key parameter.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub qi: Option<Vec<u8>>,

    /// Protected Key, used with 'Bring Your Own Key'.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "key_hsm",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub t: Option<Vec<u8>>,

    /// X component of an EC public key.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub x: Option<Vec<u8>>,

    /// Y component of an EC public key.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub y: Option<Vec<u8>>,
}

/// A KeyBundle consisting of a WebKey plus its attributes.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct Key {
    /// The key management attributes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<KeyAttributes>,

    /// The Json web key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<JsonWebKey>,

    /// True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub managed: Option<bool>,

    /// The policy rules under which the key can be exported.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_policy: Option<KeyReleasePolicy>,

    /// Application specific metadata in the form of key-value pairs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The key attestation information.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct KeyAttestation {
    /// A base64url-encoded string containing certificates in PEM format, used for attestation validation.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "certificatePemFile",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub certificate_pem_file: Option<Vec<u8>>,

    /// The attestation blob bytes encoded as base64url string corresponding to a private key.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "privateKeyAttestation",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub private_key_attestation: Option<Vec<u8>>,

    /// The attestation blob bytes encoded as base64url string corresponding to a public key in case of asymmetric key.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "publicKeyAttestation",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub public_key_attestation: Option<Vec<u8>>,

    /// The version of the attestation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The attributes of a key managed by the key vault service.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyAttributes {
    /// The key or key version attestation information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attestation: Option<KeyAttestation>,

    /// Creation time in UTC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub created: Option<OffsetDateTime>,

    /// Determines whether the object is enabled.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    /// Expiry date in UTC.
    #[serde(
        default,
        rename = "exp",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub expires: Option<OffsetDateTime>,

    /// Indicates if the private key can be exported. Release policy must be provided when creating the first version of an exportable
    /// key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exportable: Option<bool>,

    /// The underlying HSM Platform.
    #[serde(rename = "hsmPlatform", skip_serializing_if = "Option::is_none")]
    pub hsm_platform: Option<String>,

    /// Not before date in UTC.
    #[serde(
        default,
        rename = "nbf",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub not_before: Option<OffsetDateTime>,

    /// softDelete data retention days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
    #[serde(rename = "recoverableDays", skip_serializing_if = "Option::is_none")]
    pub recoverable_days: Option<i32>,

    /// Reflects the deletion recovery level currently in effect for keys in the current vault. If it contains 'Purgeable' the
    /// key can be permanently deleted by a privileged user; otherwise, only the system can purge the key, at the end of the retention
    /// interval.
    #[serde(rename = "recoveryLevel", skip_serializing_if = "Option::is_none")]
    pub recovery_level: Option<DeletionRecoveryLevel>,

    /// Last updated time in UTC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub updated: Option<OffsetDateTime>,
}

/// The key operations parameters.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyOperationParameters {
    /// Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "aad",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub additional_authenticated_data: Option<Vec<u8>>,

    /// algorithm identifier
    #[serde(rename = "alg", skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<EncryptionAlgorithm>,

    /// The tag to authenticate when performing decryption with an authenticated algorithm.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "tag",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub authentication_tag: Option<Vec<u8>>,

    /// Cryptographically random, non-repeating initialization vector for symmetric algorithms.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub iv: Option<Vec<u8>>,

    /// The value to operate on.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub value: Option<Vec<u8>>,
}

/// The key operation result.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct KeyOperationResult {
    /// Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "aad",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub additional_authenticated_data: Option<Vec<u8>>,

    /// The tag to authenticate when performing decryption with an authenticated algorithm.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "tag",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub authentication_tag: Option<Vec<u8>>,

    /// Cryptographically random, non-repeating initialization vector for symmetric algorithms.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub iv: Option<Vec<u8>>,

    /// Key identifier
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kid: Option<String>,

    /// The result of the operation.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "value",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub result: Option<Vec<u8>>,
}

/// The key item containing key metadata.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct KeyProperties {
    /// The key management attributes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<KeyAttributes>,

    /// Key identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kid: Option<String>,

    /// True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub managed: Option<bool>,

    /// Application specific metadata in the form of key-value pairs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The policy rules under which the key can be exported.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyReleasePolicy {
    /// Content type and version of key release policy
    #[serde(rename = "contentType", skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// Blob encoding the policy rules under which the key can be released. Blob must be base64 URL encoded.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "data",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub encoded_policy: Option<Vec<u8>>,

    /// Defines the mutability state of the policy. Once marked immutable, this flag cannot be reset and the policy cannot be
    /// changed under any circumstances.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub immutable: Option<bool>,
}

/// The release result, containing the released key.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct KeyReleaseResult {
    /// A signed object containing the released key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Management policy for a key.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyRotationPolicy {
    /// The key rotation policy attributes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<KeyRotationPolicyAttributes>,

    /// The key policy id.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Actions that will be performed by Key Vault over the lifetime of a key. For preview, lifetimeActions can only have two
    /// items at maximum: one for rotate, one for notify. Notification time would be default to 30 days before expiry and it is
    /// not configurable.
    #[serde(rename = "lifetimeActions", skip_serializing_if = "Option::is_none")]
    pub lifetime_actions: Option<Vec<LifetimeAction>>,
}

/// The key rotation policy attributes.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyRotationPolicyAttributes {
    /// The key rotation policy created time in UTC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub created: Option<OffsetDateTime>,

    /// The expiryTime will be applied on the new key version. It should be at least 28 days. It will be in ISO 8601 Format. Examples:
    /// 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and 10 days: P1Y10D
    #[serde(rename = "expiryTime", skip_serializing_if = "Option::is_none")]
    pub expiry_time: Option<String>,

    /// The key rotation policy's last updated time in UTC.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub updated: Option<OffsetDateTime>,
}

/// The key verify result.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct KeyVerifyResult {
    /// True if the signature is verified, otherwise false.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<bool>,
}

/// Action and its trigger that will be performed by Key Vault over the lifetime of a key.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct LifetimeAction {
    /// The action that will be executed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<LifetimeActionType>,

    /// The condition that will execute the action.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<LifetimeActionTrigger>,
}

/// A condition to be satisfied for an action to be executed.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct LifetimeActionTrigger {
    /// Time after creation to attempt to rotate. It only applies to rotate. It will be in ISO 8601 duration format. Example:
    /// 90 days : "P90D"
    #[serde(rename = "timeAfterCreate", skip_serializing_if = "Option::is_none")]
    pub time_after_create: Option<String>,

    /// Time before expiry to attempt to rotate or notify. It will be in ISO 8601 duration format. Example: 90 days : "P90D"
    #[serde(rename = "timeBeforeExpiry", skip_serializing_if = "Option::is_none")]
    pub time_before_expiry: Option<String>,
}

/// The action that will be executed.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct LifetimeActionType {
    /// The type of the action. The value should be compared case-insensitively.
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<KeyRotationPolicyAction>,
}

/// A list of keys that have been deleted in this vault.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ListDeletedKeyPropertiesResult {
    /// The URL to get the next set of deleted keys.
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// A response message containing a list of deleted keys in the key vault along with a link to the next page of deleted keys.
    #[serde(default)]
    pub value: Vec<DeletedKeyProperties>,
}

/// The key list result.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ListKeyPropertiesResult {
    /// The URL to get the next set of keys.
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// A response message containing a list of keys in the key vault along with a link to the next page of keys.
    #[serde(default)]
    pub value: Vec<KeyProperties>,
}

/// The get random bytes response object containing the bytes.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct RandomBytes {
    /// The bytes encoded as a base64url string.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub value: Option<Vec<u8>>,
}

/// The release key parameters.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ReleaseParameters {
    /// The encryption algorithm to use to protected the exported key material
    #[serde(rename = "enc", skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<KeyEncryptionAlgorithm>,

    /// A client provided nonce for freshness.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,

    /// The attestation assertion for the target of the key release.
    #[serde(rename = "target", skip_serializing_if = "Option::is_none")]
    pub target_attestation_token: Option<String>,
}

/// The key restore parameters.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct RestoreKeyParameters {
    /// The backup blob associated with a key bundle.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "value",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub key_backup: Option<Vec<u8>>,
}

/// The key operations parameters.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SignParameters {
    /// The signing/verification algorithm identifier. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
    #[serde(rename = "alg", skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<SignatureAlgorithm>,

    /// The value to operate on.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub value: Option<Vec<u8>>,
}

/// The key update parameters.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct UpdateKeyPropertiesParameters {
    /// The attributes of a key managed by the key vault service.
    #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
    pub key_attributes: Option<KeyAttributes>,

    /// Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_ops: Option<Vec<KeyOperation>>,

    /// The policy rules under which the key can be exported.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_policy: Option<KeyReleasePolicy>,

    /// Application specific metadata in the form of key-value pairs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The key verify parameters.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VerifyParameters {
    /// The signing/verification algorithm. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
    #[serde(rename = "alg", skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<SignatureAlgorithm>,

    /// The digest used for signing.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub digest: Option<Vec<u8>>,

    /// The signature to be verified.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        rename = "value",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub signature: Option<Vec<u8>>,
}
