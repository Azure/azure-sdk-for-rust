// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    CurveName, DeletionRecoveryLevel, EncryptionAlgorithm, KeyEncryptionAlgorithm, KeyOperation,
    KeyRotationPolicyAction, KeyType, SignatureAlgorithm,
};
use azure_core::error::{Error, ErrorKind};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

impl<'a> From<&'a CurveName> for &'a str {
    fn from(e: &'a CurveName) -> Self {
        match e {
            CurveName::P256 => "P-256",
            CurveName::P256K => "P-256K",
            CurveName::P384 => "P-384",
            CurveName::P521 => "P-521",
            CurveName::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for CurveName {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "P-256" => CurveName::P256,
            "P-256K" => CurveName::P256K,
            "P-384" => CurveName::P384,
            "P-521" => CurveName::P521,
            _ => CurveName::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for CurveName {
    fn as_ref(&self) -> &str {
        match self {
            CurveName::P256 => "P-256",
            CurveName::P256K => "P-256K",
            CurveName::P384 => "P-384",
            CurveName::P521 => "P-521",
            CurveName::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for CurveName {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CurveName::P256 => f.write_str("P-256"),
            CurveName::P256K => f.write_str("P-256K"),
            CurveName::P384 => f.write_str("P-384"),
            CurveName::P521 => f.write_str("P-521"),
            CurveName::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a DeletionRecoveryLevel> for &'a str {
    fn from(e: &'a DeletionRecoveryLevel) -> Self {
        match e {
            DeletionRecoveryLevel::CustomizedRecoverable => "CustomizedRecoverable",
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                "CustomizedRecoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                "CustomizedRecoverable+Purgeable"
            }
            DeletionRecoveryLevel::Purgeable => "Purgeable",
            DeletionRecoveryLevel::Recoverable => "Recoverable",
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                "Recoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::RecoverablePurgeable => "Recoverable+Purgeable",
            DeletionRecoveryLevel::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for DeletionRecoveryLevel {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "CustomizedRecoverable" => DeletionRecoveryLevel::CustomizedRecoverable,
            "CustomizedRecoverable+ProtectedSubscription" => {
                DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription
            }
            "CustomizedRecoverable+Purgeable" => {
                DeletionRecoveryLevel::CustomizedRecoverablePurgeable
            }
            "Purgeable" => DeletionRecoveryLevel::Purgeable,
            "Recoverable" => DeletionRecoveryLevel::Recoverable,
            "Recoverable+ProtectedSubscription" => {
                DeletionRecoveryLevel::RecoverableProtectedSubscription
            }
            "Recoverable+Purgeable" => DeletionRecoveryLevel::RecoverablePurgeable,
            _ => DeletionRecoveryLevel::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for DeletionRecoveryLevel {
    fn as_ref(&self) -> &str {
        match self {
            DeletionRecoveryLevel::CustomizedRecoverable => "CustomizedRecoverable",
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                "CustomizedRecoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                "CustomizedRecoverable+Purgeable"
            }
            DeletionRecoveryLevel::Purgeable => "Purgeable",
            DeletionRecoveryLevel::Recoverable => "Recoverable",
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                "Recoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::RecoverablePurgeable => "Recoverable+Purgeable",
            DeletionRecoveryLevel::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for DeletionRecoveryLevel {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            DeletionRecoveryLevel::CustomizedRecoverable => f.write_str("CustomizedRecoverable"),
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                f.write_str("CustomizedRecoverable+ProtectedSubscription")
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                f.write_str("CustomizedRecoverable+Purgeable")
            }
            DeletionRecoveryLevel::Purgeable => f.write_str("Purgeable"),
            DeletionRecoveryLevel::Recoverable => f.write_str("Recoverable"),
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                f.write_str("Recoverable+ProtectedSubscription")
            }
            DeletionRecoveryLevel::RecoverablePurgeable => f.write_str("Recoverable+Purgeable"),
            DeletionRecoveryLevel::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a EncryptionAlgorithm> for &'a str {
    fn from(e: &'a EncryptionAlgorithm) -> Self {
        match e {
            EncryptionAlgorithm::A128Cbc => "A128CBC",
            EncryptionAlgorithm::A128Cbcpad => "A128CBCPAD",
            EncryptionAlgorithm::A128Gcm => "A128GCM",
            EncryptionAlgorithm::A128Kw => "A128KW",
            EncryptionAlgorithm::A192Cbc => "A192CBC",
            EncryptionAlgorithm::A192Cbcpad => "A192CBCPAD",
            EncryptionAlgorithm::A192Gcm => "A192GCM",
            EncryptionAlgorithm::A192Kw => "A192KW",
            EncryptionAlgorithm::A256Cbc => "A256CBC",
            EncryptionAlgorithm::A256Cbcpad => "A256CBCPAD",
            EncryptionAlgorithm::A256Gcm => "A256GCM",
            EncryptionAlgorithm::A256Kw => "A256KW",
            EncryptionAlgorithm::CkmAesKeyWrap => "CKM_AES_KEY_WRAP",
            EncryptionAlgorithm::CkmAesKeyWrapPad => "CKM_AES_KEY_WRAP_PAD",
            EncryptionAlgorithm::Rsa1_5 => "RSA1_5",
            EncryptionAlgorithm::RsaOaep => "RSA-OAEP",
            EncryptionAlgorithm::RsaOaep256 => "RSA-OAEP-256",
            EncryptionAlgorithm::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for EncryptionAlgorithm {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "A128CBC" => EncryptionAlgorithm::A128Cbc,
            "A128CBCPAD" => EncryptionAlgorithm::A128Cbcpad,
            "A128GCM" => EncryptionAlgorithm::A128Gcm,
            "A128KW" => EncryptionAlgorithm::A128Kw,
            "A192CBC" => EncryptionAlgorithm::A192Cbc,
            "A192CBCPAD" => EncryptionAlgorithm::A192Cbcpad,
            "A192GCM" => EncryptionAlgorithm::A192Gcm,
            "A192KW" => EncryptionAlgorithm::A192Kw,
            "A256CBC" => EncryptionAlgorithm::A256Cbc,
            "A256CBCPAD" => EncryptionAlgorithm::A256Cbcpad,
            "A256GCM" => EncryptionAlgorithm::A256Gcm,
            "A256KW" => EncryptionAlgorithm::A256Kw,
            "CKM_AES_KEY_WRAP" => EncryptionAlgorithm::CkmAesKeyWrap,
            "CKM_AES_KEY_WRAP_PAD" => EncryptionAlgorithm::CkmAesKeyWrapPad,
            "RSA1_5" => EncryptionAlgorithm::Rsa1_5,
            "RSA-OAEP" => EncryptionAlgorithm::RsaOaep,
            "RSA-OAEP-256" => EncryptionAlgorithm::RsaOaep256,
            _ => EncryptionAlgorithm::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for EncryptionAlgorithm {
    fn as_ref(&self) -> &str {
        match self {
            EncryptionAlgorithm::A128Cbc => "A128CBC",
            EncryptionAlgorithm::A128Cbcpad => "A128CBCPAD",
            EncryptionAlgorithm::A128Gcm => "A128GCM",
            EncryptionAlgorithm::A128Kw => "A128KW",
            EncryptionAlgorithm::A192Cbc => "A192CBC",
            EncryptionAlgorithm::A192Cbcpad => "A192CBCPAD",
            EncryptionAlgorithm::A192Gcm => "A192GCM",
            EncryptionAlgorithm::A192Kw => "A192KW",
            EncryptionAlgorithm::A256Cbc => "A256CBC",
            EncryptionAlgorithm::A256Cbcpad => "A256CBCPAD",
            EncryptionAlgorithm::A256Gcm => "A256GCM",
            EncryptionAlgorithm::A256Kw => "A256KW",
            EncryptionAlgorithm::CkmAesKeyWrap => "CKM_AES_KEY_WRAP",
            EncryptionAlgorithm::CkmAesKeyWrapPad => "CKM_AES_KEY_WRAP_PAD",
            EncryptionAlgorithm::Rsa1_5 => "RSA1_5",
            EncryptionAlgorithm::RsaOaep => "RSA-OAEP",
            EncryptionAlgorithm::RsaOaep256 => "RSA-OAEP-256",
            EncryptionAlgorithm::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for EncryptionAlgorithm {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            EncryptionAlgorithm::A128Cbc => f.write_str("A128CBC"),
            EncryptionAlgorithm::A128Cbcpad => f.write_str("A128CBCPAD"),
            EncryptionAlgorithm::A128Gcm => f.write_str("A128GCM"),
            EncryptionAlgorithm::A128Kw => f.write_str("A128KW"),
            EncryptionAlgorithm::A192Cbc => f.write_str("A192CBC"),
            EncryptionAlgorithm::A192Cbcpad => f.write_str("A192CBCPAD"),
            EncryptionAlgorithm::A192Gcm => f.write_str("A192GCM"),
            EncryptionAlgorithm::A192Kw => f.write_str("A192KW"),
            EncryptionAlgorithm::A256Cbc => f.write_str("A256CBC"),
            EncryptionAlgorithm::A256Cbcpad => f.write_str("A256CBCPAD"),
            EncryptionAlgorithm::A256Gcm => f.write_str("A256GCM"),
            EncryptionAlgorithm::A256Kw => f.write_str("A256KW"),
            EncryptionAlgorithm::CkmAesKeyWrap => f.write_str("CKM_AES_KEY_WRAP"),
            EncryptionAlgorithm::CkmAesKeyWrapPad => f.write_str("CKM_AES_KEY_WRAP_PAD"),
            EncryptionAlgorithm::Rsa1_5 => f.write_str("RSA1_5"),
            EncryptionAlgorithm::RsaOaep => f.write_str("RSA-OAEP"),
            EncryptionAlgorithm::RsaOaep256 => f.write_str("RSA-OAEP-256"),
            EncryptionAlgorithm::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a KeyEncryptionAlgorithm> for &'a str {
    fn from(e: &'a KeyEncryptionAlgorithm) -> Self {
        match e {
            KeyEncryptionAlgorithm::CkmRsaAesKeyWrap => "CKM_RSA_AES_KEY_WRAP",
            KeyEncryptionAlgorithm::RsaAesKeyWrap256 => "RSA_AES_KEY_WRAP_256",
            KeyEncryptionAlgorithm::RsaAesKeyWrap384 => "RSA_AES_KEY_WRAP_384",
            KeyEncryptionAlgorithm::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for KeyEncryptionAlgorithm {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "CKM_RSA_AES_KEY_WRAP" => KeyEncryptionAlgorithm::CkmRsaAesKeyWrap,
            "RSA_AES_KEY_WRAP_256" => KeyEncryptionAlgorithm::RsaAesKeyWrap256,
            "RSA_AES_KEY_WRAP_384" => KeyEncryptionAlgorithm::RsaAesKeyWrap384,
            _ => KeyEncryptionAlgorithm::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for KeyEncryptionAlgorithm {
    fn as_ref(&self) -> &str {
        match self {
            KeyEncryptionAlgorithm::CkmRsaAesKeyWrap => "CKM_RSA_AES_KEY_WRAP",
            KeyEncryptionAlgorithm::RsaAesKeyWrap256 => "RSA_AES_KEY_WRAP_256",
            KeyEncryptionAlgorithm::RsaAesKeyWrap384 => "RSA_AES_KEY_WRAP_384",
            KeyEncryptionAlgorithm::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for KeyEncryptionAlgorithm {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyEncryptionAlgorithm::CkmRsaAesKeyWrap => f.write_str("CKM_RSA_AES_KEY_WRAP"),
            KeyEncryptionAlgorithm::RsaAesKeyWrap256 => f.write_str("RSA_AES_KEY_WRAP_256"),
            KeyEncryptionAlgorithm::RsaAesKeyWrap384 => f.write_str("RSA_AES_KEY_WRAP_384"),
            KeyEncryptionAlgorithm::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a KeyOperation> for &'a str {
    fn from(e: &'a KeyOperation) -> Self {
        match e {
            KeyOperation::Decrypt => "decrypt",
            KeyOperation::Encrypt => "encrypt",
            KeyOperation::Export => "export",
            KeyOperation::Import => "import",
            KeyOperation::Sign => "sign",
            KeyOperation::UnwrapKey => "unwrapKey",
            KeyOperation::Verify => "verify",
            KeyOperation::WrapKey => "wrapKey",
            KeyOperation::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for KeyOperation {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "decrypt" => KeyOperation::Decrypt,
            "encrypt" => KeyOperation::Encrypt,
            "export" => KeyOperation::Export,
            "import" => KeyOperation::Import,
            "sign" => KeyOperation::Sign,
            "unwrapKey" => KeyOperation::UnwrapKey,
            "verify" => KeyOperation::Verify,
            "wrapKey" => KeyOperation::WrapKey,
            _ => KeyOperation::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for KeyOperation {
    fn as_ref(&self) -> &str {
        match self {
            KeyOperation::Decrypt => "decrypt",
            KeyOperation::Encrypt => "encrypt",
            KeyOperation::Export => "export",
            KeyOperation::Import => "import",
            KeyOperation::Sign => "sign",
            KeyOperation::UnwrapKey => "unwrapKey",
            KeyOperation::Verify => "verify",
            KeyOperation::WrapKey => "wrapKey",
            KeyOperation::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for KeyOperation {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyOperation::Decrypt => f.write_str("decrypt"),
            KeyOperation::Encrypt => f.write_str("encrypt"),
            KeyOperation::Export => f.write_str("export"),
            KeyOperation::Import => f.write_str("import"),
            KeyOperation::Sign => f.write_str("sign"),
            KeyOperation::UnwrapKey => f.write_str("unwrapKey"),
            KeyOperation::Verify => f.write_str("verify"),
            KeyOperation::WrapKey => f.write_str("wrapKey"),
            KeyOperation::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for KeyRotationPolicyAction {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Notify" => KeyRotationPolicyAction::Notify,
            "Rotate" => KeyRotationPolicyAction::Rotate,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of KeyRotationPolicyAction found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for KeyRotationPolicyAction {
    fn as_ref(&self) -> &str {
        match self {
            KeyRotationPolicyAction::Notify => "Notify",
            KeyRotationPolicyAction::Rotate => "Rotate",
        }
    }
}

impl Display for KeyRotationPolicyAction {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyRotationPolicyAction::Notify => Display::fmt("Notify", f),
            KeyRotationPolicyAction::Rotate => Display::fmt("Rotate", f),
        }
    }
}

impl<'a> From<&'a KeyType> for &'a str {
    fn from(e: &'a KeyType) -> Self {
        match e {
            KeyType::Ec => "EC",
            KeyType::EcHsm => "EC-HSM",
            KeyType::Oct => "oct",
            KeyType::OctHsm => "oct-HSM",
            KeyType::Rsa => "RSA",
            KeyType::RsaHsm => "RSA-HSM",
            KeyType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for KeyType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "EC" => KeyType::Ec,
            "EC-HSM" => KeyType::EcHsm,
            "oct" => KeyType::Oct,
            "oct-HSM" => KeyType::OctHsm,
            "RSA" => KeyType::Rsa,
            "RSA-HSM" => KeyType::RsaHsm,
            _ => KeyType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for KeyType {
    fn as_ref(&self) -> &str {
        match self {
            KeyType::Ec => "EC",
            KeyType::EcHsm => "EC-HSM",
            KeyType::Oct => "oct",
            KeyType::OctHsm => "oct-HSM",
            KeyType::Rsa => "RSA",
            KeyType::RsaHsm => "RSA-HSM",
            KeyType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for KeyType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyType::Ec => f.write_str("EC"),
            KeyType::EcHsm => f.write_str("EC-HSM"),
            KeyType::Oct => f.write_str("oct"),
            KeyType::OctHsm => f.write_str("oct-HSM"),
            KeyType::Rsa => f.write_str("RSA"),
            KeyType::RsaHsm => f.write_str("RSA-HSM"),
            KeyType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a SignatureAlgorithm> for &'a str {
    fn from(e: &'a SignatureAlgorithm) -> Self {
        match e {
            SignatureAlgorithm::Es256 => "ES256",
            SignatureAlgorithm::Es256K => "ES256K",
            SignatureAlgorithm::Es384 => "ES384",
            SignatureAlgorithm::Es512 => "ES512",
            SignatureAlgorithm::Hs256 => "HS256",
            SignatureAlgorithm::Hs384 => "HS384",
            SignatureAlgorithm::Hs512 => "HS512",
            SignatureAlgorithm::Ps256 => "PS256",
            SignatureAlgorithm::Ps384 => "PS384",
            SignatureAlgorithm::Ps512 => "PS512",
            SignatureAlgorithm::Rs256 => "RS256",
            SignatureAlgorithm::Rs384 => "RS384",
            SignatureAlgorithm::Rs512 => "RS512",
            SignatureAlgorithm::Rsnull => "RSNULL",
            SignatureAlgorithm::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SignatureAlgorithm {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "ES256" => SignatureAlgorithm::Es256,
            "ES256K" => SignatureAlgorithm::Es256K,
            "ES384" => SignatureAlgorithm::Es384,
            "ES512" => SignatureAlgorithm::Es512,
            "HS256" => SignatureAlgorithm::Hs256,
            "HS384" => SignatureAlgorithm::Hs384,
            "HS512" => SignatureAlgorithm::Hs512,
            "PS256" => SignatureAlgorithm::Ps256,
            "PS384" => SignatureAlgorithm::Ps384,
            "PS512" => SignatureAlgorithm::Ps512,
            "RS256" => SignatureAlgorithm::Rs256,
            "RS384" => SignatureAlgorithm::Rs384,
            "RS512" => SignatureAlgorithm::Rs512,
            "RSNULL" => SignatureAlgorithm::Rsnull,
            _ => SignatureAlgorithm::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SignatureAlgorithm {
    fn as_ref(&self) -> &str {
        match self {
            SignatureAlgorithm::Es256 => "ES256",
            SignatureAlgorithm::Es256K => "ES256K",
            SignatureAlgorithm::Es384 => "ES384",
            SignatureAlgorithm::Es512 => "ES512",
            SignatureAlgorithm::Hs256 => "HS256",
            SignatureAlgorithm::Hs384 => "HS384",
            SignatureAlgorithm::Hs512 => "HS512",
            SignatureAlgorithm::Ps256 => "PS256",
            SignatureAlgorithm::Ps384 => "PS384",
            SignatureAlgorithm::Ps512 => "PS512",
            SignatureAlgorithm::Rs256 => "RS256",
            SignatureAlgorithm::Rs384 => "RS384",
            SignatureAlgorithm::Rs512 => "RS512",
            SignatureAlgorithm::Rsnull => "RSNULL",
            SignatureAlgorithm::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SignatureAlgorithm {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SignatureAlgorithm::Es256 => f.write_str("ES256"),
            SignatureAlgorithm::Es256K => f.write_str("ES256K"),
            SignatureAlgorithm::Es384 => f.write_str("ES384"),
            SignatureAlgorithm::Es512 => f.write_str("ES512"),
            SignatureAlgorithm::Hs256 => f.write_str("HS256"),
            SignatureAlgorithm::Hs384 => f.write_str("HS384"),
            SignatureAlgorithm::Hs512 => f.write_str("HS512"),
            SignatureAlgorithm::Ps256 => f.write_str("PS256"),
            SignatureAlgorithm::Ps384 => f.write_str("PS384"),
            SignatureAlgorithm::Ps512 => f.write_str("PS512"),
            SignatureAlgorithm::Rs256 => f.write_str("RS256"),
            SignatureAlgorithm::Rs384 => f.write_str("RS384"),
            SignatureAlgorithm::Rs512 => f.write_str("RS512"),
            SignatureAlgorithm::Rsnull => f.write_str("RSNULL"),
            SignatureAlgorithm::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}
