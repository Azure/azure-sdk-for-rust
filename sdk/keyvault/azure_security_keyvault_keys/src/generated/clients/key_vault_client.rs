// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::{
    BearerTokenCredentialPolicy, ClientMethodOptions, ClientOptions, Context, Method, Pager, Pipeline, Policy, Request, RequestContent, Response, Result, Url,
};
use azure_core::credentials::TokenCredential;
use crate::models::{
    BackupKeyResult, DeletedKeyBundle, DeletedKeyListResult, GetRandomBytesRequest, KeyBundle, KeyCreateParameters, KeyImportParameters, KeyListResult, KeyOperationResult, KeyOperationsParameters, KeyReleaseParameters, KeyReleaseResult, KeyRestoreParameters, KeyRotationPolicy, KeySignParameters, KeyUpdateParameters, KeyVerifyParameters, KeyVerifyResult, RandomBytes,
};
use std::sync::Arc;
use typespec_client_core::json;
use typespec_client_core::fmt::SafeDebug;
use typespec_client_core::http::PagerResult;

pub struct KeyVaultClient {
    api_version: String,
    endpoint: Url,
    pipeline: Pipeline,
}

#[derive(Clone, SafeDebug)]
pub struct KeyVaultClientOptions {
    pub api_version: String,
    pub client_options: ClientOptions,
}

impl KeyVaultClient {
    pub fn new(endpoint: &str, credential: Arc<dyn TokenCredential>, options: Option<KeyVaultClientOptions>) -> Result<Self> {
    let options = options.unwrap_or_default();
        let mut endpoint = Url::parse(endpoint)?;
        endpoint.set_query(None);
        let auth_policy: Arc<dyn Policy> = Arc::new(BearerTokenCredentialPolicy::new(credential, vec!["https://vault.azure.net/.default"]));
        Ok(Self {
            endpoint,
            api_version: options.api_version,
            pipeline: Pipeline::new(
                option_env!("CARGO_PKG_NAME"),
                option_env!("CARGO_PKG_VERSION"),
                options.client_options,
                Vec::default(),
                vec![auth_policy],
            ),
        })
    }

    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// Requests that a backup of the specified key be downloaded to the client.
///
/// The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this operation does NOT return
/// key material in a form that can be used outside the Azure Key Vault system, the returned key material is either protected
/// to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of this operation is to allow a client to GENERATE a
/// key in one Azure Key Vault instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP
/// operation may be used to export, in protected form, any key type from Azure Key Vault. Individual versions of a key cannot
/// be backed up. BACKUP / RESTORE can be performed within geographical boundaries only; meaning that a BACKUP from one geographical
/// area cannot be restored to another geographical area. For example, a backup from the US geographical area cannot be restored
/// in an EU geographical area. This operation requires the key/backup permission.
    pub async fn backup_key(&self, key_name: &str, options: Option<KeyVaultClientBackupKeyOptions<'_>>) -> Result<Response<BackupKeyResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/backup");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Creates a new key, stores it, then returns key parameters and attributes to the client.
///
/// The create key operation can be used to create any key type in Azure Key Vault. If the named key already exists, Azure
/// Key Vault creates a new version of the key. It requires the keys/create permission.
    pub async fn create_key(&self, key_name: &str, parameters: RequestContent<KeyCreateParameters>, options: Option<KeyVaultClientCreateKeyOptions<'_>>) -> Result<Response<KeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/create");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Decrypts a single block of encrypted data.
///
/// The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm.
/// This operation is the reverse of the ENCRYPT operation; only a single block of data may be decrypted, the size of this
/// block is dependent on the target key and the algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric
/// keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/decrypt
/// permission. Microsoft recommends not to use CBC algorithms for decryption without first ensuring the integrity of the
/// ciphertext using an HMAC, for example. See https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode
/// for more information.
    pub async fn decrypt(&self, key_name: &str, key_version: &str, parameters: RequestContent<KeyOperationsParameters>, options: Option<KeyVaultClientDecryptOptions<'_>>) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/decrypt");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Deletes a key of any type from storage in Azure Key Vault.
///
/// The delete key operation cannot be used to remove individual versions of a key. This operation removes the cryptographic
/// material associated with the key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations.
/// This operation requires the keys/delete permission.
    pub async fn delete_key(&self, key_name: &str, options: Option<KeyVaultClientDeleteKeyOptions<'_>>) -> Result<Response<DeletedKeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key vault.
///
/// The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure Key Vault.
/// Note that the ENCRYPT operation only supports a single block of data, the size of which is dependent on the target key
/// and the encryption algorithm to be used. The ENCRYPT operation is only strictly necessary for symmetric keys stored in
/// Azure Key Vault since protection with an asymmetric key can be performed using public portion of the key. This operation
/// is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the
/// public key material. This operation requires the keys/encrypt permission.
    pub async fn encrypt(&self, key_name: &str, key_version: &str, parameters: RequestContent<KeyOperationsParameters>, options: Option<KeyVaultClientEncryptOptions<'_>>) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/encrypt");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Gets the public part of a deleted key.
///
/// The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any
/// vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/get permission.
    pub async fn get_deleted_key(&self, key_name: &str, options: Option<KeyVaultClientGetDeletedKeyOptions<'_>>) -> Result<Response<DeletedKeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedkeys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Lists the deleted keys in the specified vault.
///
/// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a deleted key.
/// This operation includes deletion-specific information. The Get Deleted Keys operation is applicable for vaults enabled
/// for soft-delete. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete
/// enabled vault. This operation requires the keys/list permission.
    pub fn get_deleted_keys(&self, options: Option<KeyVaultClientGetDeletedKeysOptions<'_>>) -> Result<Pager<DeletedKeyListResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url = first_url.join("deletedkeys")?;
        first_url.query_pairs_mut().append_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            first_url.query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: Option<Url>| {
            let url = match next_link {
                Some(next_link) => {
                    let qp = next_link.query_pairs().filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link.query_pairs_mut().clear().extend_pairs(qp).append_pair("api-version", &api_version);
                    next_link
                },
                None => {
                    first_url.clone()
                },
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: Response<DeletedKeyListResult> = pipeline.send(&ctx, &mut request).await?;
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: DeletedKeyListResult = json::from_json(bytes.clone())?;
                let rsp = Response::from_bytes(status, headers, bytes);
                Ok(match res.next_link {
                    Some(next_link) => PagerResult::Continue {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    None => PagerResult::Complete {
                        response: rsp,
                    },
                })
            }
        }))
    }

    /// Gets the public part of a stored key.
///
/// The get key operation is applicable to all key types. If the requested key is symmetric, then no key material is released
/// in the response. This operation requires the keys/get permission.
    pub async fn get_key(&self, key_name: &str, key_version: &str, options: Option<KeyVaultClientGetKeyOptions<'_>>) -> Result<Response<KeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Lists the policy for a key.
///
/// The GetKeyRotationPolicy operation returns the specified key policy resources in the specified key vault. This operation
/// requires the keys/get permission.
    pub async fn get_key_rotation_policy(&self, key_name: &str, options: Option<KeyVaultClientGetKeyRotationPolicyOptions<'_>>) -> Result<Response<KeyRotationPolicy>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/rotationpolicy");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Retrieves a list of individual key versions with the same key name.
///
/// The full key identifier, attributes, and tags are provided in the response. This operation requires the keys/list permission.
    pub fn get_key_versions(&self, key_name: &str, options: Option<KeyVaultClientGetKeyVersionsOptions<'_>>) -> Result<Pager<KeyListResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/versions");
        path = path.replace("{key-name}", key_name);
        first_url = first_url.join(&path)?;
        first_url.query_pairs_mut().append_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            first_url.query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: Option<Url>| {
            let url = match next_link {
                Some(next_link) => {
                    let qp = next_link.query_pairs().filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link.query_pairs_mut().clear().extend_pairs(qp).append_pair("api-version", &api_version);
                    next_link
                },
                None => {
                    first_url.clone()
                },
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: Response<KeyListResult> = pipeline.send(&ctx, &mut request).await?;
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: KeyListResult = json::from_json(bytes.clone())?;
                let rsp = Response::from_bytes(status, headers, bytes);
                Ok(match res.next_link {
                    Some(next_link) => PagerResult::Continue {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    None => PagerResult::Complete {
                        response: rsp,
                    },
                })
            }
        }))
    }

    /// List keys in the specified vault.
///
/// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a stored key.
/// The LIST operation is applicable to all key types, however only the base key identifier, attributes, and tags are provided
/// in the response. Individual versions of a key are not listed in the response. This operation requires the keys/list permission.
    pub fn get_keys(&self, options: Option<KeyVaultClientGetKeysOptions<'_>>) -> Result<Pager<KeyListResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url = first_url.join("keys")?;
        first_url.query_pairs_mut().append_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            first_url.query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: Option<Url>| {
            let url = match next_link {
                Some(next_link) => {
                    let qp = next_link.query_pairs().filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link.query_pairs_mut().clear().extend_pairs(qp).append_pair("api-version", &api_version);
                    next_link
                },
                None => {
                    first_url.clone()
                },
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: Response<KeyListResult> = pipeline.send(&ctx, &mut request).await?;
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: KeyListResult = json::from_json(bytes.clone())?;
                let rsp = Response::from_bytes(status, headers, bytes);
                Ok(match res.next_link {
                    Some(next_link) => PagerResult::Continue {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    None => PagerResult::Complete {
                        response: rsp,
                    },
                })
            }
        }))
    }

    /// Get the requested number of bytes containing random values.
///
/// Get the requested number of bytes containing random values from a managed HSM.
    pub async fn get_random_bytes(&self, parameters: RequestContent<GetRandomBytesRequest>, options: Option<KeyVaultClientGetRandomBytesOptions<'_>>) -> Result<Response<RandomBytes>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("rng")?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Imports an externally created key, stores it, and returns key parameters and attributes to the client.
///
/// The import key operation may be used to import any key type into an Azure Key Vault. If the named key already exists,
/// Azure Key Vault creates a new version of the key. This operation requires the keys/import permission.
    pub async fn import_key(&self, key_name: &str, parameters: RequestContent<KeyImportParameters>, options: Option<KeyVaultClientImportKeyOptions<'_>>) -> Result<Response<KeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Permanently deletes the specified key.
///
/// The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any
/// vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/purge permission.
    pub async fn purge_deleted_key(&self, key_name: &str, options: Option<KeyVaultClientPurgeDeletedKeyOptions<'_>>) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedkeys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Recovers the deleted key to its latest version.
///
/// The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It recovers the deleted
/// key back to its latest version under /keys. An attempt to recover an non-deleted key will return an error. Consider this
/// the inverse of the delete operation on soft-delete enabled vaults. This operation requires the keys/recover permission.
    pub async fn recover_deleted_key(&self, key_name: &str, options: Option<KeyVaultClientRecoverDeletedKeyOptions<'_>>) -> Result<Response<KeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedkeys/{key-name}/recover");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Releases a key.
///
/// The release key operation is applicable to all key types. The target key must be marked exportable. This operation requires
/// the keys/release permission.
    pub async fn release(&self, key_name: &str, key_version: &str, parameters: RequestContent<KeyReleaseParameters>, options: Option<KeyVaultClientReleaseOptions<'_>>) -> Result<Response<KeyReleaseResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/release");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Restores a backed up key to a vault.
///
/// Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier, attributes and access
/// control policies. The RESTORE operation may be used to import a previously backed up key. Individual versions of a key
/// cannot be restored. The key is restored in its entirety with the same key name as it had when it was backed up. If the
/// key name is not available in the target Key Vault, the RESTORE operation will be rejected. While the key name is retained
/// during restore, the final key identifier will change if the key is restored to a different vault. Restore will restore
/// all versions and preserve version identifiers. The RESTORE operation is subject to security constraints: The target Key
/// Vault must be owned by the same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
/// in the target Key Vault. This operation requires the keys/restore permission.
    pub async fn restore_key(&self, parameters: RequestContent<KeyRestoreParameters>, options: Option<KeyVaultClientRestoreKeyOptions<'_>>) -> Result<Response<KeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("keys/restore")?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Creates a new key version, stores it, then returns key parameters, attributes and policy to the client.
///
/// The operation will rotate the key based on the key policy. It requires the keys/rotate permission.
    pub async fn rotate_key(&self, key_name: &str, options: Option<KeyVaultClientRotateKeyOptions<'_>>) -> Result<Response<KeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/rotate");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Creates a signature from a digest using the specified key.
///
/// The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since this operation uses
/// the private portion of the key. This operation requires the keys/sign permission.
    pub async fn sign(&self, key_name: &str, key_version: &str, parameters: RequestContent<KeySignParameters>, options: Option<KeyVaultClientSignOptions<'_>>) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/sign");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Unwraps a symmetric key using the specified key that was initially used for wrapping that key.
///
/// The UNWRAP operation supports decryption of a symmetric key using the target key encryption key. This operation is the
/// reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key Vault
/// since it uses the private portion of the key. This operation requires the keys/unwrapKey permission.
    pub async fn unwrap_key(&self, key_name: &str, key_version: &str, parameters: RequestContent<KeyOperationsParameters>, options: Option<KeyVaultClientUnwrapKeyOptions<'_>>) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/unwrapkey");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// The update key operation changes specified attributes of a stored key and can be applied to any key type and key version
/// stored in Azure Key Vault.
///
/// In order to perform this operation, the key must already exist in the Key Vault. Note: The cryptographic material of a
/// key itself cannot be changed. This operation requires the keys/update permission.
    pub async fn update_key(&self, key_name: &str, key_version: &str, parameters: RequestContent<KeyUpdateParameters>, options: Option<KeyVaultClientUpdateKeyOptions<'_>>) -> Result<Response<KeyBundle>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Updates the rotation policy for a key.
///
/// Set specified members in the key policy. Leave others as undefined. This operation requires the keys/update permission.
    pub async fn update_key_rotation_policy(&self, key_name: &str, key_rotation_policy: RequestContent<KeyRotationPolicy>, options: Option<KeyVaultClientUpdateKeyRotationPolicyOptions<'_>>) -> Result<Response<KeyRotationPolicy>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/rotationpolicy");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(key_rotation_policy);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Verifies a signature using a specified key.
///
/// The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not strictly necessary for asymmetric
/// keys stored in Azure Key Vault since signature verification can be performed using the public portion of the key but this
/// operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
/// This operation requires the keys/verify permission.
    pub async fn verify(&self, key_name: &str, key_version: &str, parameters: RequestContent<KeyVerifyParameters>, options: Option<KeyVaultClientVerifyOptions<'_>>) -> Result<Response<KeyVerifyResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/verify");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }

    /// Wraps a symmetric key using a specified key.
///
/// The WRAP operation supports encryption of a symmetric key using a key encryption key that has previously been stored in
/// an Azure Key Vault. The WRAP operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection
/// with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric
/// keys as a convenience for callers that have a key-reference but do not have access to the public key material. This operation
/// requires the keys/wrapKey permission.
    pub async fn wrap_key(&self, key_name: &str, key_version: &str, parameters: RequestContent<KeyOperationsParameters>, options: Option<KeyVaultClientWrapKeyOptions<'_>>) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/wrapkey");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        self.pipeline.send(&ctx, &mut request).await

    }
}

impl Default for KeyVaultClientOptions {
    fn default() -> Self {
        Self {
            api_version: String::from("7.6-preview.1"),
            client_options: ClientOptions::default(),
        }
    }
}

#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientBackupKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientCreateKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientDecryptOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientDeleteKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientEncryptOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientGetDeletedKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientGetDeletedKeysOptions<'a> {
    pub maxresults: Option<i32>,
    pub method_options: ClientMethodOptions<'a>,
}

impl KeyVaultClientGetDeletedKeysOptions<'_> {
    pub fn into_owned(self) -> KeyVaultClientGetDeletedKeysOptions<'static> {
        KeyVaultClientGetDeletedKeysOptions {
            maxresults: self.maxresults,
            method_options: ClientMethodOptions {
                context: self.method_options.context.into_owned(),
            },
        }
    }
}

#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientGetKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientGetKeyRotationPolicyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientGetKeyVersionsOptions<'a> {
    pub maxresults: Option<i32>,
    pub method_options: ClientMethodOptions<'a>,
}

impl KeyVaultClientGetKeyVersionsOptions<'_> {
    pub fn into_owned(self) -> KeyVaultClientGetKeyVersionsOptions<'static> {
        KeyVaultClientGetKeyVersionsOptions {
            maxresults: self.maxresults,
            method_options: ClientMethodOptions {
                context: self.method_options.context.into_owned(),
            },
        }
    }
}

#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientGetKeysOptions<'a> {
    pub maxresults: Option<i32>,
    pub method_options: ClientMethodOptions<'a>,
}

impl KeyVaultClientGetKeysOptions<'_> {
    pub fn into_owned(self) -> KeyVaultClientGetKeysOptions<'static> {
        KeyVaultClientGetKeysOptions {
            maxresults: self.maxresults,
            method_options: ClientMethodOptions {
                context: self.method_options.context.into_owned(),
            },
        }
    }
}

#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientGetRandomBytesOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientImportKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientPurgeDeletedKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientRecoverDeletedKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientReleaseOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientRestoreKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientRotateKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientSignOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientUnwrapKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientUpdateKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientUpdateKeyRotationPolicyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientVerifyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


#[derive(Clone, Default, SafeDebug)]
pub struct KeyVaultClientWrapKeyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}


