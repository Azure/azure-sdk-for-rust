// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::generated::models::{
    BackupKeyResult, CreateKeyParameters, DeletedKey, GetRandomBytesParameters,
    ImportKeyParameters, Key, KeyClientBackupKeyOptions, KeyClientCreateKeyOptions,
    KeyClientDecryptOptions, KeyClientDeleteKeyOptions, KeyClientEncryptOptions,
    KeyClientGetDeletedKeyOptions, KeyClientGetKeyAttestationOptions, KeyClientGetKeyOptions,
    KeyClientGetKeyRotationPolicyOptions, KeyClientGetRandomBytesOptions,
    KeyClientImportKeyOptions, KeyClientListDeletedKeyPropertiesOptions,
    KeyClientListKeyPropertiesOptions, KeyClientListKeyPropertiesVersionsOptions,
    KeyClientPurgeDeletedKeyOptions, KeyClientRecoverDeletedKeyOptions, KeyClientReleaseOptions,
    KeyClientRestoreKeyOptions, KeyClientRotateKeyOptions, KeyClientSignOptions,
    KeyClientUnwrapKeyOptions, KeyClientUpdateKeyPropertiesOptions,
    KeyClientUpdateKeyRotationPolicyOptions, KeyClientVerifyOptions, KeyClientWrapKeyOptions,
    KeyOperationParameters, KeyOperationResult, KeyReleaseResult, KeyRotationPolicy,
    KeyVerifyResult, ListDeletedKeyPropertiesResult, ListKeyPropertiesResult, RandomBytes,
    ReleaseParameters, RestoreKeyParameters, SignParameters, UpdateKeyPropertiesParameters,
    VerifyParameters,
};
use azure_core::{
    credentials::TokenCredential,
    error::{ErrorKind, HttpError},
    fmt::SafeDebug,
    http::{
        policies::{BearerTokenCredentialPolicy, Policy},
        ClientOptions, Context, Method, NoFormat, Pager, PagerResult, PagerState, Pipeline,
        RawResponse, Request, RequestContent, Response, Url,
    },
    json, tracing, Error, Result,
};
use std::sync::Arc;

/// The key vault client performs cryptographic key operations and vault operations against the Key Vault service.
#[tracing::client]
pub struct KeyClient {
    pub(crate) api_version: String,
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
}

/// Options used when creating a [`KeyClient`](KeyClient)
#[derive(Clone, SafeDebug)]
pub struct KeyClientOptions {
    /// The API version to use for this operation.
    pub api_version: String,
    /// Allows customization of the client.
    pub client_options: ClientOptions,
}

impl KeyClient {
    /// Creates a new KeyClient, using Entra ID authentication.
    ///
    /// # Arguments
    ///
    /// * `endpoint` - Service host
    /// * `credential` - An implementation of [`TokenCredential`](azure_core::credentials::TokenCredential) that can provide an
    ///   Entra ID token to use when authenticating.
    /// * `options` - Optional configuration for the client.
    #[tracing::new("azure_security_keyvault_keys")]
    pub fn new(
        endpoint: &str,
        credential: Arc<dyn TokenCredential>,
        options: Option<KeyClientOptions>,
    ) -> Result<Self> {
        let options = options.unwrap_or_default();
        let mut endpoint = Url::parse(endpoint)?;
        if !endpoint.scheme().starts_with("http") {
            return Err(azure_core::Error::message(
                azure_core::error::ErrorKind::Other,
                format!("{endpoint} must use http(s)"),
            ));
        }
        endpoint.set_query(None);
        let auth_policy: Arc<dyn Policy> = Arc::new(BearerTokenCredentialPolicy::new(
            credential,
            vec!["https://vault.azure.net/.default"],
        ));
        Ok(Self {
            endpoint,
            api_version: options.api_version,
            pipeline: Pipeline::new(
                option_env!("CARGO_PKG_NAME"),
                option_env!("CARGO_PKG_VERSION"),
                options.client_options,
                Vec::default(),
                vec![auth_policy],
            ),
        })
    }

    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// Requests that a backup of the specified key be downloaded to the client.
    ///
    /// The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this operation does NOT return
    /// key material in a form that can be used outside the Azure Key Vault system, the returned key material is either protected
    /// to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of this operation is to allow a client to GENERATE a
    /// key in one Azure Key Vault instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP
    /// operation may be used to export, in protected form, any key type from Azure Key Vault. Individual versions of a key cannot
    /// be backed up. BACKUP / RESTORE can be performed within geographical boundaries only; meaning that a BACKUP from one geographical
    /// area cannot be restored to another geographical area. For example, a backup from the US geographical area cannot be restored
    /// in an EU geographical area. This operation requires the key/backup permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.backupKey")]
    pub async fn backup_key(
        &self,
        key_name: &str,
        options: Option<KeyClientBackupKeyOptions<'_>>,
    ) -> Result<Response<BackupKeyResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/backup");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Creates a new key, stores it, then returns key parameters and attributes to the client.
    ///
    /// The create key operation can be used to create any key type in Azure Key Vault. If the named key already exists, Azure
    /// Key Vault creates a new version of the key. It requires the keys/create permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name for the new key. The system will generate the version name for the new key. The value you provide
    ///   may be copied globally for the purpose of running the service. The value provided should not include personally identifiable
    ///   or sensitive information.
    /// * `parameters` - The parameters to create a key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.createKey")]
    pub async fn create_key(
        &self,
        key_name: &str,
        parameters: RequestContent<CreateKeyParameters>,
        options: Option<KeyClientCreateKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/create");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Decrypts a single block of encrypted data.
    ///
    /// The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm.
    /// This operation is the reverse of the ENCRYPT operation; only a single block of data may be decrypted, the size of this
    /// block is dependent on the target key and the algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric
    /// keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/decrypt
    /// permission. Microsoft recommends not to use CBC algorithms for decryption without first ensuring the integrity of the
    /// ciphertext using an HMAC, for example. See <https://learn.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode>
    /// for more information.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for the decryption operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.decrypt")]
    pub async fn decrypt(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<KeyOperationParameters>,
        options: Option<KeyClientDecryptOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/decrypt");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Deletes a key of any type from storage in Azure Key Vault.
    ///
    /// The delete key operation cannot be used to remove individual versions of a key. This operation removes the cryptographic
    /// material associated with the key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations.
    /// This operation requires the keys/delete permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key to delete.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.deleteKey")]
    pub async fn delete_key(
        &self,
        key_name: &str,
        options: Option<KeyClientDeleteKeyOptions<'_>>,
    ) -> Result<Response<DeletedKey>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key vault.
    ///
    /// The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure Key Vault.
    /// Note that the ENCRYPT operation only supports a single block of data, the size of which is dependent on the target key
    /// and the encryption algorithm to be used. The ENCRYPT operation is only strictly necessary for symmetric keys stored in
    /// Azure Key Vault since protection with an asymmetric key can be performed using public portion of the key. This operation
    /// is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the
    /// public key material. This operation requires the keys/encrypt permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for the encryption operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.encrypt")]
    pub async fn encrypt(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<KeyOperationParameters>,
        options: Option<KeyClientEncryptOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/encrypt");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Gets the public part of a deleted key.
    ///
    /// The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any
    /// vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/get permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getDeletedKey")]
    pub async fn get_deleted_key(
        &self,
        key_name: &str,
        options: Option<KeyClientGetDeletedKeyOptions<'_>>,
    ) -> Result<Response<DeletedKey>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedkeys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Gets the public part of a stored key.
    ///
    /// The get key operation is applicable to all key types. If the requested key is symmetric, then no key material is released
    /// in the response. This operation requires the keys/get permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key to get.
    /// * `key_version` - Adding the version parameter retrieves a specific version of a key. This URI fragment is optional. If
    ///   not specified, the latest version of the key is returned.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKey")]
    pub async fn get_key(
        &self,
        key_name: &str,
        key_version: &str,
        options: Option<KeyClientGetKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Gets the public part of a stored key along with its attestation blob.
    ///
    /// The get key attestation operation returns the key along with its attestation blob. This operation requires the keys/get
    /// permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key to retrieve attestation for.
    /// * `key_version` - Adding the version parameter retrieves attestation blob for specific version of a key. This URI fragment
    ///   is optional. If not specified, the latest version of the key attestation blob is returned.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKeyAttestation")]
    pub async fn get_key_attestation(
        &self,
        key_name: &str,
        key_version: &str,
        options: Option<KeyClientGetKeyAttestationOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/attestation");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Lists the policy for a key.
    ///
    /// The GetKeyRotationPolicy operation returns the specified key policy resources in the specified key vault. This operation
    /// requires the keys/get permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key in a given key vault.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKeyRotationPolicy")]
    pub async fn get_key_rotation_policy(
        &self,
        key_name: &str,
        options: Option<KeyClientGetKeyRotationPolicyOptions<'_>>,
    ) -> Result<Response<KeyRotationPolicy>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/rotationpolicy");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Get the requested number of bytes containing random values.
    ///
    /// Get the requested number of bytes containing random values from a managed HSM.
    ///
    /// # Arguments
    ///
    /// * `parameters` - The request object to get random bytes.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getRandomBytes")]
    pub async fn get_random_bytes(
        &self,
        parameters: RequestContent<GetRandomBytesParameters>,
        options: Option<KeyClientGetRandomBytesOptions<'_>>,
    ) -> Result<Response<RandomBytes>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("rng")?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Imports an externally created key, stores it, and returns key parameters and attributes to the client.
    ///
    /// The import key operation may be used to import any key type into an Azure Key Vault. If the named key already exists,
    /// Azure Key Vault creates a new version of the key. This operation requires the keys/import permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - Name for the imported key. The value you provide may be copied globally for the purpose of running the
    ///   service. The value provided should not include personally identifiable or sensitive information.
    /// * `parameters` - The parameters to import a key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.importKey")]
    pub async fn import_key(
        &self,
        key_name: &str,
        parameters: RequestContent<ImportKeyParameters>,
        options: Option<KeyClientImportKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Lists the deleted keys in the specified vault.
    ///
    /// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a deleted key.
    /// This operation includes deletion-specific information. The Get Deleted Keys operation is applicable for vaults enabled
    /// for soft-delete. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete
    /// enabled vault. This operation requires the keys/list permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getDeletedKeys")]
    pub fn list_deleted_key_properties(
        &self,
        options: Option<KeyClientListDeletedKeyPropertiesOptions<'_>>,
    ) -> Result<Pager<ListDeletedKeyPropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url = first_url.join("deletedkeys")?;
        first_url
            .query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            first_url
                .query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: PagerState<Url>| {
            let url = match next_link {
                PagerState::More(next_link) => {
                    let qp = next_link
                        .query_pairs()
                        .filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link
                        .query_pairs_mut()
                        .clear()
                        .extend_pairs(qp)
                        .append_pair("api-version", &api_version);
                    next_link
                }
                PagerState::Initial => first_url.clone(),
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                if !rsp.status().is_success() {
                    let status = rsp.status();
                    let http_error = HttpError::new(rsp).await;
                    let error_kind = ErrorKind::http_response(
                        status,
                        http_error.error_code().map(std::borrow::ToOwned::to_owned),
                    );
                    return Err(Error::new(error_kind, http_error));
                }
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: ListDeletedKeyPropertiesResult = json::from_json(&bytes)?;
                let rsp = RawResponse::from_bytes(status, headers, bytes).into();
                Ok(match res.next_link {
                    Some(next_link) if !next_link.is_empty() => PagerResult::More {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    _ => PagerResult::Done { response: rsp },
                })
            }
        }))
    }

    /// List keys in the specified vault.
    ///
    /// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a stored key.
    /// The LIST operation is applicable to all key types, however only the base key identifier, attributes, and tags are provided
    /// in the response. Individual versions of a key are not listed in the response. This operation requires the keys/list permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKeys")]
    pub fn list_key_properties(
        &self,
        options: Option<KeyClientListKeyPropertiesOptions<'_>>,
    ) -> Result<Pager<ListKeyPropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url = first_url.join("keys")?;
        first_url
            .query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            first_url
                .query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: PagerState<Url>| {
            let url = match next_link {
                PagerState::More(next_link) => {
                    let qp = next_link
                        .query_pairs()
                        .filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link
                        .query_pairs_mut()
                        .clear()
                        .extend_pairs(qp)
                        .append_pair("api-version", &api_version);
                    next_link
                }
                PagerState::Initial => first_url.clone(),
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                if !rsp.status().is_success() {
                    let status = rsp.status();
                    let http_error = HttpError::new(rsp).await;
                    let error_kind = ErrorKind::http_response(
                        status,
                        http_error.error_code().map(std::borrow::ToOwned::to_owned),
                    );
                    return Err(Error::new(error_kind, http_error));
                }
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: ListKeyPropertiesResult = json::from_json(&bytes)?;
                let rsp = RawResponse::from_bytes(status, headers, bytes).into();
                Ok(match res.next_link {
                    Some(next_link) if !next_link.is_empty() => PagerResult::More {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    _ => PagerResult::Done { response: rsp },
                })
            }
        }))
    }

    /// Retrieves a list of individual key versions with the same key name.
    ///
    /// The full key identifier, attributes, and tags are provided in the response. This operation requires the keys/list permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKeyVersions")]
    pub fn list_key_properties_versions(
        &self,
        key_name: &str,
        options: Option<KeyClientListKeyPropertiesVersionsOptions<'_>>,
    ) -> Result<Pager<ListKeyPropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/versions");
        path = path.replace("{key-name}", key_name);
        first_url = first_url.join(&path)?;
        first_url
            .query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            first_url
                .query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        let api_version = self.api_version.clone();
        Ok(Pager::from_callback(move |next_link: PagerState<Url>| {
            let url = match next_link {
                PagerState::More(next_link) => {
                    let qp = next_link
                        .query_pairs()
                        .filter(|(name, _)| name.ne("api-version"));
                    let mut next_link = next_link.clone();
                    next_link
                        .query_pairs_mut()
                        .clear()
                        .extend_pairs(qp)
                        .append_pair("api-version", &api_version);
                    next_link
                }
                PagerState::Initial => first_url.clone(),
            };
            let mut request = Request::new(url, Method::Get);
            request.insert_header("accept", "application/json");
            let ctx = options.method_options.context.clone();
            let pipeline = pipeline.clone();
            async move {
                let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                if !rsp.status().is_success() {
                    let status = rsp.status();
                    let http_error = HttpError::new(rsp).await;
                    let error_kind = ErrorKind::http_response(
                        status,
                        http_error.error_code().map(std::borrow::ToOwned::to_owned),
                    );
                    return Err(Error::new(error_kind, http_error));
                }
                let (status, headers, body) = rsp.deconstruct();
                let bytes = body.collect().await?;
                let res: ListKeyPropertiesResult = json::from_json(&bytes)?;
                let rsp = RawResponse::from_bytes(status, headers, bytes).into();
                Ok(match res.next_link {
                    Some(next_link) if !next_link.is_empty() => PagerResult::More {
                        response: rsp,
                        continuation: next_link.parse()?,
                    },
                    _ => PagerResult::Done { response: rsp },
                })
            }
        }))
    }

    /// Permanently deletes the specified key.
    ///
    /// The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any
    /// vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/purge permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.purgeDeletedKey")]
    pub async fn purge_deleted_key(
        &self,
        key_name: &str,
        options: Option<KeyClientPurgeDeletedKeyOptions<'_>>,
    ) -> Result<Response<(), NoFormat>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedkeys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Recovers the deleted key to its latest version.
    ///
    /// The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It recovers the deleted
    /// key back to its latest version under /keys. An attempt to recover an non-deleted key will return an error. Consider this
    /// the inverse of the delete operation on soft-delete enabled vaults. This operation requires the keys/recover permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the deleted key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.recoverDeletedKey")]
    pub async fn recover_deleted_key(
        &self,
        key_name: &str,
        options: Option<KeyClientRecoverDeletedKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("deletedkeys/{key-name}/recover");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Releases a key.
    ///
    /// The release key operation is applicable to all key types. The target key must be marked exportable. This operation requires
    /// the keys/release permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key to get.
    /// * `key_version` - Adding the version parameter retrieves a specific version of a key.
    /// * `parameters` - The parameters for the key release operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.release")]
    pub async fn release(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<ReleaseParameters>,
        options: Option<KeyClientReleaseOptions<'_>>,
    ) -> Result<Response<KeyReleaseResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/release");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Restores a backed up key to a vault.
    ///
    /// Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier, attributes and access
    /// control policies. The RESTORE operation may be used to import a previously backed up key. Individual versions of a key
    /// cannot be restored. The key is restored in its entirety with the same key name as it had when it was backed up. If the
    /// key name is not available in the target Key Vault, the RESTORE operation will be rejected. While the key name is retained
    /// during restore, the final key identifier will change if the key is restored to a different vault. Restore will restore
    /// all versions and preserve version identifiers. The RESTORE operation is subject to security constraints: The target Key
    /// Vault must be owned by the same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
    /// in the target Key Vault. This operation requires the keys/restore permission.
    ///
    /// # Arguments
    ///
    /// * `parameters` - The parameters to restore the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.restoreKey")]
    pub async fn restore_key(
        &self,
        parameters: RequestContent<RestoreKeyParameters>,
        options: Option<KeyClientRestoreKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("keys/restore")?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Creates a new key version, stores it, then returns key parameters, attributes and policy to the client.
    ///
    /// The operation will rotate the key based on the key policy. It requires the keys/rotate permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of key to be rotated. The system will generate a new version in the specified key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.rotateKey")]
    pub async fn rotate_key(
        &self,
        key_name: &str,
        options: Option<KeyClientRotateKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/rotate");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Creates a signature from a digest using the specified key.
    ///
    /// The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since this operation uses
    /// the private portion of the key. This operation requires the keys/sign permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for the signing operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.sign")]
    pub async fn sign(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<SignParameters>,
        options: Option<KeyClientSignOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/sign");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Unwraps a symmetric key using the specified key that was initially used for wrapping that key.
    ///
    /// The UNWRAP operation supports decryption of a symmetric key using the target key encryption key. This operation is the
    /// reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key Vault
    /// since it uses the private portion of the key. This operation requires the keys/unwrapKey permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for the key operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.unwrapKey")]
    pub async fn unwrap_key(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<KeyOperationParameters>,
        options: Option<KeyClientUnwrapKeyOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/unwrapkey");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// The update key operation changes specified attributes of a stored key and can be applied to any key type and key version
    /// stored in Azure Key Vault.
    ///
    /// In order to perform this operation, the key must already exist in the Key Vault. Note: The cryptographic material of a
    /// key itself cannot be changed. This operation requires the keys/update permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of key to update.
    /// * `key_version` - The version of the key to update.
    /// * `parameters` - The parameters of the key to update.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateKey")]
    pub async fn update_key_properties(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<UpdateKeyPropertiesParameters>,
        options: Option<KeyClientUpdateKeyPropertiesOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Updates the rotation policy for a key.
    ///
    /// Set specified members in the key policy. Leave others as undefined. This operation requires the keys/update permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key in the given vault.
    /// * `key_rotation_policy` - The policy for the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateKeyRotationPolicy")]
    pub async fn update_key_rotation_policy(
        &self,
        key_name: &str,
        key_rotation_policy: RequestContent<KeyRotationPolicy>,
        options: Option<KeyClientUpdateKeyRotationPolicyOptions<'_>>,
    ) -> Result<Response<KeyRotationPolicy>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/rotationpolicy");
        path = path.replace("{key-name}", key_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(key_rotation_policy);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Verifies a signature using a specified key.
    ///
    /// The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not strictly necessary for asymmetric
    /// keys stored in Azure Key Vault since signature verification can be performed using the public portion of the key but this
    /// operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
    /// This operation requires the keys/verify permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for verify operations.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.verify")]
    pub async fn verify(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<VerifyParameters>,
        options: Option<KeyClientVerifyOptions<'_>>,
    ) -> Result<Response<KeyVerifyResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/verify");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }

    /// Wraps a symmetric key using a specified key.
    ///
    /// The WRAP operation supports encryption of a symmetric key using a key encryption key that has previously been stored in
    /// an Azure Key Vault. The WRAP operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection
    /// with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric
    /// keys as a convenience for callers that have a key-reference but do not have access to the public key material. This operation
    /// requires the keys/wrapKey permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for wrap operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.wrapKey")]
    pub async fn wrap_key(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<KeyOperationParameters>,
        options: Option<KeyClientWrapKeyOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("keys/{key-name}/{key-version}/wrapkey");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("api-version", &self.api_version);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self.pipeline.send(&ctx, &mut request).await?;
        if !rsp.status().is_success() {
            let status = rsp.status();
            let http_error = HttpError::new(rsp).await;
            let error_kind = ErrorKind::http_response(
                status,
                http_error.error_code().map(std::borrow::ToOwned::to_owned),
            );
            return Err(Error::new(error_kind, http_error));
        }
        Ok(rsp.into())
    }
}

impl Default for KeyClientOptions {
    fn default() -> Self {
        Self {
            api_version: String::from("7.6"),
            client_options: ClientOptions::default(),
        }
    }
}
