// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::generated::models::{
    BackupKeyResult, CreateKeyParameters, DeletedKey, GetRandomBytesParameters,
    ImportKeyParameters, Key, KeyClientBackupKeyOptions, KeyClientCreateKeyOptions,
    KeyClientDecryptOptions, KeyClientDeleteKeyOptions, KeyClientEncryptOptions,
    KeyClientGetDeletedKeyOptions, KeyClientGetKeyAttestationOptions, KeyClientGetKeyOptions,
    KeyClientGetKeyRotationPolicyOptions, KeyClientGetRandomBytesOptions,
    KeyClientImportKeyOptions, KeyClientListDeletedKeyPropertiesOptions,
    KeyClientListKeyPropertiesOptions, KeyClientListKeyPropertiesVersionsOptions,
    KeyClientPurgeDeletedKeyOptions, KeyClientRecoverDeletedKeyOptions, KeyClientReleaseOptions,
    KeyClientRestoreKeyOptions, KeyClientRotateKeyOptions, KeyClientSignOptions,
    KeyClientUnwrapKeyOptions, KeyClientUpdateKeyPropertiesOptions,
    KeyClientUpdateKeyRotationPolicyOptions, KeyClientVerifyOptions, KeyClientWrapKeyOptions,
    KeyOperationParameters, KeyOperationResult, KeyReleaseResult, KeyRotationPolicy,
    KeyVerifyResult, ListDeletedKeyPropertiesResult, ListKeyPropertiesResult, RandomBytes,
    ReleaseParameters, RestoreKeyParameters, SignParameters, UpdateKeyPropertiesParameters,
    VerifyParameters,
};
use azure_core::{
    error::CheckSuccessOptions,
    http::{
        pager::{PagerContinuation, PagerResult, PagerState},
        Method, NoFormat, Pager, Pipeline, PipelineSendOptions, RawResponse, Request,
        RequestContent, Response, Url, UrlExt,
    },
    json, tracing, Result,
};

/// The key vault client performs cryptographic key operations and vault operations against the Key Vault service.
#[tracing::client]
pub struct KeyClient {
    pub(crate) api_version: String,
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
}

impl KeyClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// Requests that a backup of the specified key be downloaded to the client.
    ///
    /// The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this operation does NOT return
    /// key material in a form that can be used outside the Azure Key Vault system, the returned key material is either protected
    /// to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of this operation is to allow a client to GENERATE a
    /// key in one Azure Key Vault instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP
    /// operation may be used to export, in protected form, any key type from Azure Key Vault. Individual versions of a key cannot
    /// be backed up. BACKUP / RESTORE can be performed within geographical boundaries only; meaning that a BACKUP from one geographical
    /// area cannot be restored to another geographical area. For example, a backup from the US geographical area cannot be restored
    /// in an EU geographical area. This operation requires the key/backup permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.backupKey")]
    pub async fn backup_key(
        &self,
        key_name: &str,
        options: Option<KeyClientBackupKeyOptions<'_>>,
    ) -> Result<Response<BackupKeyResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/backup");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Creates a new key, stores it, then returns key parameters and attributes to the client.
    ///
    /// The create key operation can be used to create any key type in Azure Key Vault. If the named key already exists, Azure
    /// Key Vault creates a new version of the key. It requires the keys/create permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name for the new key. The system will generate the version name for the new key. The value you provide
    ///   may be copied globally for the purpose of running the service. The value provided should not include personally identifiable
    ///   or sensitive information.
    /// * `parameters` - The parameters to create a key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.createKey")]
    pub async fn create_key(
        &self,
        key_name: &str,
        parameters: RequestContent<CreateKeyParameters>,
        options: Option<KeyClientCreateKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/create");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Decrypts a single block of encrypted data.
    ///
    /// The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm.
    /// This operation is the reverse of the ENCRYPT operation; only a single block of data may be decrypted, the size of this
    /// block is dependent on the target key and the algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric
    /// keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/decrypt
    /// permission. Microsoft recommends not to use CBC algorithms for decryption without first ensuring the integrity of the
    /// ciphertext using an HMAC, for example. See <https://learn.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode>
    /// for more information.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for the decryption operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.decrypt")]
    pub async fn decrypt(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<KeyOperationParameters>,
        options: Option<KeyClientDecryptOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        if key_version.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_version cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}/decrypt");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Deletes a key of any type from storage in Azure Key Vault.
    ///
    /// The delete key operation cannot be used to remove individual versions of a key. This operation removes the cryptographic
    /// material associated with the key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations.
    /// This operation requires the keys/delete permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key to delete.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.deleteKey")]
    pub async fn delete_key(
        &self,
        key_name: &str,
        options: Option<KeyClientDeleteKeyOptions<'_>>,
    ) -> Result<Response<DeletedKey>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key vault.
    ///
    /// The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure Key Vault.
    /// Note that the ENCRYPT operation only supports a single block of data, the size of which is dependent on the target key
    /// and the encryption algorithm to be used. The ENCRYPT operation is only strictly necessary for symmetric keys stored in
    /// Azure Key Vault since protection with an asymmetric key can be performed using public portion of the key. This operation
    /// is supported for asymmetric keys as a convenience for callers that have a key-reference but do not have access to the
    /// public key material. This operation requires the keys/encrypt permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for the encryption operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.encrypt")]
    pub async fn encrypt(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<KeyOperationParameters>,
        options: Option<KeyClientEncryptOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        if key_version.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_version cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}/encrypt");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Gets the public part of a deleted key.
    ///
    /// The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any
    /// vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/get permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getDeletedKey")]
    pub async fn get_deleted_key(
        &self,
        key_name: &str,
        options: Option<KeyClientGetDeletedKeyOptions<'_>>,
    ) -> Result<Response<DeletedKey>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedkeys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Gets the public part of a stored key.
    ///
    /// The get key operation is applicable to all key types. If the requested key is symmetric, then no key material is released
    /// in the response. This operation requires the keys/get permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key to get.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKey")]
    pub async fn get_key(
        &self,
        key_name: &str,
        options: Option<KeyClientGetKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}");
        path = path.replace("{key-name}", key_name);
        path = match options.key_version.as_ref() {
            Some(key_version) => path.replace("{key-version}", key_version),
            None => path.replace("{key-version}", ""),
        };
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Gets the public part of a stored key along with its attestation blob.
    ///
    /// The get key attestation operation returns the key along with its attestation blob. This operation requires the keys/get
    /// permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key to retrieve attestation for.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKeyAttestation")]
    pub async fn get_key_attestation(
        &self,
        key_name: &str,
        options: Option<KeyClientGetKeyAttestationOptions<'_>>,
    ) -> Result<Response<Key>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}/attestation");
        path = path.replace("{key-name}", key_name);
        path = match options.key_version.as_ref() {
            Some(key_version) => path.replace("{key-version}", key_version),
            None => path.replace("{key-version}", ""),
        };
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Lists the policy for a key.
    ///
    /// The GetKeyRotationPolicy operation returns the specified key policy resources in the specified key vault. This operation
    /// requires the keys/get permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key in a given key vault.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKeyRotationPolicy")]
    pub async fn get_key_rotation_policy(
        &self,
        key_name: &str,
        options: Option<KeyClientGetKeyRotationPolicyOptions<'_>>,
    ) -> Result<Response<KeyRotationPolicy>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/rotationpolicy");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Get the requested number of bytes containing random values.
    ///
    /// Get the requested number of bytes containing random values from a managed HSM.
    ///
    /// # Arguments
    ///
    /// * `parameters` - The request object to get random bytes.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getRandomBytes")]
    pub async fn get_random_bytes(
        &self,
        parameters: RequestContent<GetRandomBytesParameters>,
        options: Option<KeyClientGetRandomBytesOptions<'_>>,
    ) -> Result<Response<RandomBytes>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url.append_path("/rng");
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Imports an externally created key, stores it, and returns key parameters and attributes to the client.
    ///
    /// The import key operation may be used to import any key type into an Azure Key Vault. If the named key already exists,
    /// Azure Key Vault creates a new version of the key. This operation requires the keys/import permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - Name for the imported key. The value you provide may be copied globally for the purpose of running the
    ///   service. The value provided should not include personally identifiable or sensitive information.
    /// * `parameters` - The parameters to import a key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.importKey")]
    pub async fn import_key(
        &self,
        key_name: &str,
        parameters: RequestContent<ImportKeyParameters>,
        options: Option<KeyClientImportKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Lists the deleted keys in the specified vault.
    ///
    /// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a deleted key.
    /// This operation includes deletion-specific information. The Get Deleted Keys operation is applicable for vaults enabled
    /// for soft-delete. While the operation can be invoked on any vault, it will return an error if invoked on a non soft-delete
    /// enabled vault. This operation requires the keys/list permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getDeletedKeys")]
    pub fn list_deleted_key_properties(
        &self,
        options: Option<KeyClientListDeletedKeyPropertiesOptions<'_>>,
    ) -> Result<Pager<ListDeletedKeyPropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url.append_path("/deletedkeys");
        let mut query_builder = first_url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            query_builder.set_pair("maxresults", maxresults.to_string());
        }
        query_builder.build();
        let api_version = self.api_version.clone();
        Ok(Pager::new(
            move |next_link: PagerState, pager_options| {
                let url = match next_link {
                    PagerState::More(next_link) => {
                        let mut next_link: Url = next_link.try_into().expect("expected Url");
                        let mut query_builder = next_link.query_builder();
                        query_builder.set_pair("api-version", &api_version);
                        query_builder.build();
                        next_link
                    }
                    PagerState::Initial => first_url.clone(),
                };
                let mut request = Request::new(url, Method::Get);
                request.insert_header("accept", "application/json");
                let pipeline = pipeline.clone();
                Box::pin({
                    let first_url = first_url.clone();
                    async move {
                        let rsp = pipeline
                            .send(
                                &pager_options.context,
                                &mut request,
                                Some(PipelineSendOptions {
                                    check_success: CheckSuccessOptions {
                                        success_codes: &[200],
                                    },
                                    ..Default::default()
                                }),
                            )
                            .await?;
                        let (status, headers, body) = rsp.deconstruct();
                        let res: ListDeletedKeyPropertiesResult = json::from_json(&body)?;
                        let rsp = RawResponse::from_bytes(status, headers, body).into();
                        Ok(match res.next_link {
                            Some(next_link) if !next_link.is_empty() => PagerResult::More {
                                response: rsp,
                                continuation: PagerContinuation::Link(
                                    first_url.join(next_link.as_ref())?,
                                ),
                            },
                            _ => PagerResult::Done { response: rsp },
                        })
                    }
                })
            },
            Some(options.method_options),
        ))
    }

    /// List keys in the specified vault.
    ///
    /// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a stored key.
    /// The LIST operation is applicable to all key types, however only the base key identifier, attributes, and tags are provided
    /// in the response. Individual versions of a key are not listed in the response. This operation requires the keys/list permission.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKeys")]
    pub fn list_key_properties(
        &self,
        options: Option<KeyClientListKeyPropertiesOptions<'_>>,
    ) -> Result<Pager<ListKeyPropertiesResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        first_url.append_path("/keys");
        let mut query_builder = first_url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            query_builder.set_pair("maxresults", maxresults.to_string());
        }
        query_builder.build();
        let api_version = self.api_version.clone();
        Ok(Pager::new(
            move |next_link: PagerState, pager_options| {
                let url = match next_link {
                    PagerState::More(next_link) => {
                        let mut next_link: Url = next_link.try_into().expect("expected Url");
                        let mut query_builder = next_link.query_builder();
                        query_builder.set_pair("api-version", &api_version);
                        query_builder.build();
                        next_link
                    }
                    PagerState::Initial => first_url.clone(),
                };
                let mut request = Request::new(url, Method::Get);
                request.insert_header("accept", "application/json");
                let pipeline = pipeline.clone();
                Box::pin({
                    let first_url = first_url.clone();
                    async move {
                        let rsp = pipeline
                            .send(
                                &pager_options.context,
                                &mut request,
                                Some(PipelineSendOptions {
                                    check_success: CheckSuccessOptions {
                                        success_codes: &[200],
                                    },
                                    ..Default::default()
                                }),
                            )
                            .await?;
                        let (status, headers, body) = rsp.deconstruct();
                        let res: ListKeyPropertiesResult = json::from_json(&body)?;
                        let rsp = RawResponse::from_bytes(status, headers, body).into();
                        Ok(match res.next_link {
                            Some(next_link) if !next_link.is_empty() => PagerResult::More {
                                response: rsp,
                                continuation: PagerContinuation::Link(
                                    first_url.join(next_link.as_ref())?,
                                ),
                            },
                            _ => PagerResult::Done { response: rsp },
                        })
                    }
                })
            },
            Some(options.method_options),
        ))
    }

    /// Retrieves a list of individual key versions with the same key name.
    ///
    /// The full key identifier, attributes, and tags are provided in the response. This operation requires the keys/list permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.getKeyVersions")]
    pub fn list_key_properties_versions(
        &self,
        key_name: &str,
        options: Option<KeyClientListKeyPropertiesVersionsOptions<'_>>,
    ) -> Result<Pager<ListKeyPropertiesResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut first_url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/versions");
        path = path.replace("{key-name}", key_name);
        first_url.append_path(&path);
        let mut query_builder = first_url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        if let Some(maxresults) = options.maxresults {
            query_builder.set_pair("maxresults", maxresults.to_string());
        }
        query_builder.build();
        let api_version = self.api_version.clone();
        Ok(Pager::new(
            move |next_link: PagerState, pager_options| {
                let url = match next_link {
                    PagerState::More(next_link) => {
                        let mut next_link: Url = next_link.try_into().expect("expected Url");
                        let mut query_builder = next_link.query_builder();
                        query_builder.set_pair("api-version", &api_version);
                        query_builder.build();
                        next_link
                    }
                    PagerState::Initial => first_url.clone(),
                };
                let mut request = Request::new(url, Method::Get);
                request.insert_header("accept", "application/json");
                let pipeline = pipeline.clone();
                Box::pin({
                    let first_url = first_url.clone();
                    async move {
                        let rsp = pipeline
                            .send(
                                &pager_options.context,
                                &mut request,
                                Some(PipelineSendOptions {
                                    check_success: CheckSuccessOptions {
                                        success_codes: &[200],
                                    },
                                    ..Default::default()
                                }),
                            )
                            .await?;
                        let (status, headers, body) = rsp.deconstruct();
                        let res: ListKeyPropertiesResult = json::from_json(&body)?;
                        let rsp = RawResponse::from_bytes(status, headers, body).into();
                        Ok(match res.next_link {
                            Some(next_link) if !next_link.is_empty() => PagerResult::More {
                                response: rsp,
                                continuation: PagerContinuation::Link(
                                    first_url.join(next_link.as_ref())?,
                                ),
                            },
                            _ => PagerResult::Done { response: rsp },
                        })
                    }
                })
            },
            Some(options.method_options),
        ))
    }

    /// Permanently deletes the specified key.
    ///
    /// The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any
    /// vault, it will return an error if invoked on a non soft-delete enabled vault. This operation requires the keys/purge permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.purgeDeletedKey")]
    pub async fn purge_deleted_key(
        &self,
        key_name: &str,
        options: Option<KeyClientPurgeDeletedKeyOptions<'_>>,
    ) -> Result<Response<(), NoFormat>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedkeys/{key-name}");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Delete);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[204],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Recovers the deleted key to its latest version.
    ///
    /// The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It recovers the deleted
    /// key back to its latest version under /keys. An attempt to recover an non-deleted key will return an error. Consider this
    /// the inverse of the delete operation on soft-delete enabled vaults. This operation requires the keys/recover permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the deleted key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.recoverDeletedKey")]
    pub async fn recover_deleted_key(
        &self,
        key_name: &str,
        options: Option<KeyClientRecoverDeletedKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/deletedkeys/{key-name}/recover");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Releases a key.
    ///
    /// The release key operation is applicable to all key types. The target key must be marked exportable. This operation requires
    /// the keys/release permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key to get.
    /// * `parameters` - The parameters for the key release operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.release")]
    pub async fn release(
        &self,
        key_name: &str,
        parameters: RequestContent<ReleaseParameters>,
        options: Option<KeyClientReleaseOptions<'_>>,
    ) -> Result<Response<KeyReleaseResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}/release");
        path = path.replace("{key-name}", key_name);
        path = match options.key_version.as_ref() {
            Some(key_version) => path.replace("{key-version}", key_version),
            None => path.replace("{key-version}", ""),
        };
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Restores a backed up key to a vault.
    ///
    /// Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier, attributes and access
    /// control policies. The RESTORE operation may be used to import a previously backed up key. Individual versions of a key
    /// cannot be restored. The key is restored in its entirety with the same key name as it had when it was backed up. If the
    /// key name is not available in the target Key Vault, the RESTORE operation will be rejected. While the key name is retained
    /// during restore, the final key identifier will change if the key is restored to a different vault. Restore will restore
    /// all versions and preserve version identifiers. The RESTORE operation is subject to security constraints: The target Key
    /// Vault must be owned by the same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
    /// in the target Key Vault. This operation requires the keys/restore permission.
    ///
    /// # Arguments
    ///
    /// * `parameters` - The parameters to restore the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.restoreKey")]
    pub async fn restore_key(
        &self,
        parameters: RequestContent<RestoreKeyParameters>,
        options: Option<KeyClientRestoreKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        url.append_path("/keys/restore");
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Creates a new key version, stores it, then returns key parameters, attributes and policy to the client.
    ///
    /// The operation will rotate the key based on the key policy. It requires the keys/rotate permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of key to be rotated. The system will generate a new version in the specified key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.rotateKey")]
    pub async fn rotate_key(
        &self,
        key_name: &str,
        options: Option<KeyClientRotateKeyOptions<'_>>,
    ) -> Result<Response<Key>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/rotate");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Creates a signature from a digest using the specified key.
    ///
    /// The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since this operation uses
    /// the private portion of the key. This operation requires the keys/sign permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for the signing operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.sign")]
    pub async fn sign(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<SignParameters>,
        options: Option<KeyClientSignOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        if key_version.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_version cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}/sign");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Unwraps a symmetric key using the specified key that was initially used for wrapping that key.
    ///
    /// The UNWRAP operation supports decryption of a symmetric key using the target key encryption key. This operation is the
    /// reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key Vault
    /// since it uses the private portion of the key. This operation requires the keys/unwrapKey permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for the key operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.unwrapKey")]
    pub async fn unwrap_key(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<KeyOperationParameters>,
        options: Option<KeyClientUnwrapKeyOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        if key_version.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_version cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}/unwrapkey");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// The update key operation changes specified attributes of a stored key and can be applied to any key type and key version
    /// stored in Azure Key Vault.
    ///
    /// In order to perform this operation, the key must already exist in the Key Vault. Note: The cryptographic material of a
    /// key itself cannot be changed. This operation requires the keys/update permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of key to update.
    /// * `parameters` - The parameters of the key to update.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateKey")]
    pub async fn update_key_properties(
        &self,
        key_name: &str,
        parameters: RequestContent<UpdateKeyPropertiesParameters>,
        options: Option<KeyClientUpdateKeyPropertiesOptions<'_>>,
    ) -> Result<Response<Key>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}");
        path = path.replace("{key-name}", key_name);
        path = match options.key_version.as_ref() {
            Some(key_version) => path.replace("{key-version}", key_version),
            None => path.replace("{key-version}", ""),
        };
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Patch);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Updates the rotation policy for a key.
    ///
    /// Set specified members in the key policy. Leave others as undefined. This operation requires the keys/update permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key in the given vault.
    /// * `key_rotation_policy` - The policy for the key.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.updateKeyRotationPolicy")]
    pub async fn update_key_rotation_policy(
        &self,
        key_name: &str,
        key_rotation_policy: RequestContent<KeyRotationPolicy>,
        options: Option<KeyClientUpdateKeyRotationPolicyOptions<'_>>,
    ) -> Result<Response<KeyRotationPolicy>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/rotationpolicy");
        path = path.replace("{key-name}", key_name);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(key_rotation_policy);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Verifies a signature using a specified key.
    ///
    /// The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not strictly necessary for asymmetric
    /// keys stored in Azure Key Vault since signature verification can be performed using the public portion of the key but this
    /// operation is supported as a convenience for callers that only have a key-reference and not the public portion of the key.
    /// This operation requires the keys/verify permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for verify operations.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.verify")]
    pub async fn verify(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<VerifyParameters>,
        options: Option<KeyClientVerifyOptions<'_>>,
    ) -> Result<Response<KeyVerifyResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        if key_version.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_version cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}/verify");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }

    /// Wraps a symmetric key using a specified key.
    ///
    /// The WRAP operation supports encryption of a symmetric key using a key encryption key that has previously been stored in
    /// an Azure Key Vault. The WRAP operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection
    /// with an asymmetric key can be performed using the public portion of the key. This operation is supported for asymmetric
    /// keys as a convenience for callers that have a key-reference but do not have access to the public key material. This operation
    /// requires the keys/wrapKey permission.
    ///
    /// # Arguments
    ///
    /// * `key_name` - The name of the key.
    /// * `key_version` - The version of the key.
    /// * `parameters` - The parameters for wrap operation.
    /// * `options` - Optional parameters for the request.
    #[tracing::function("KeyVault.wrapKey")]
    pub async fn wrap_key(
        &self,
        key_name: &str,
        key_version: &str,
        parameters: RequestContent<KeyOperationParameters>,
        options: Option<KeyClientWrapKeyOptions<'_>>,
    ) -> Result<Response<KeyOperationResult>> {
        if key_name.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_name cannot be empty",
            ));
        }
        if key_version.is_empty() {
            return Err(azure_core::Error::with_message(
                azure_core::error::ErrorKind::Other,
                "parameter key_version cannot be empty",
            ));
        }
        let options = options.unwrap_or_default();
        let ctx = options.method_options.context.to_borrowed();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/keys/{key-name}/{key-version}/wrapkey");
        path = path.replace("{key-name}", key_name);
        path = path.replace("{key-version}", key_version);
        url.append_path(&path);
        let mut query_builder = url.query_builder();
        query_builder.set_pair("api-version", &self.api_version);
        query_builder.build();
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        request.set_body(parameters);
        let rsp = self
            .pipeline
            .send(
                &ctx,
                &mut request,
                Some(PipelineSendOptions {
                    check_success: CheckSuccessOptions {
                        success_codes: &[200],
                    },
                    ..Default::default()
                }),
            )
            .await?;
        Ok(rsp.into())
    }
}
