// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    AccessPolicyUpdateKind, ActionsRequired, ActivationStatus, CertificatePermissions, CreateMode,
    CreatedByType, DeletionRecoveryLevel, GeoReplicationRegionProvisioningState,
    JsonWebKeyCurveName, JsonWebKeyOperation, JsonWebKeyType, KeyPermissions,
    KeyRotationPolicyActionType, ManagedHsmSkuFamily, ManagedHsmSkuName,
    ManagedServiceIdentityType, NetworkRuleAction, NetworkRuleBypassOptions,
    PrivateEndpointConnectionProvisioningState, PrivateEndpointServiceConnectionStatus,
    ProvisioningState, PublicNetworkAccess, Reason, ResourceProvisioningState, SecretPermissions,
    SkuFamily, SkuName, StoragePermissions, VaultProvisioningState,
};
use azure_core::error::{Error, ErrorKind};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

impl FromStr for AccessPolicyUpdateKind {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "add" => AccessPolicyUpdateKind::Add,
            "remove" => AccessPolicyUpdateKind::Remove,
            "replace" => AccessPolicyUpdateKind::Replace,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of AccessPolicyUpdateKind found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for AccessPolicyUpdateKind {
    fn as_ref(&self) -> &str {
        match self {
            AccessPolicyUpdateKind::Add => "add",
            AccessPolicyUpdateKind::Remove => "remove",
            AccessPolicyUpdateKind::Replace => "replace",
        }
    }
}

impl Display for AccessPolicyUpdateKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AccessPolicyUpdateKind::Add => Display::fmt("add", f),
            AccessPolicyUpdateKind::Remove => Display::fmt("remove", f),
            AccessPolicyUpdateKind::Replace => Display::fmt("replace", f),
        }
    }
}

impl<'a> From<&'a ActionsRequired> for &'a str {
    fn from(e: &'a ActionsRequired) -> Self {
        match e {
            ActionsRequired::None => "None",
            ActionsRequired::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ActionsRequired {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "None" => ActionsRequired::None,
            _ => ActionsRequired::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ActionsRequired {
    fn as_ref(&self) -> &str {
        match self {
            ActionsRequired::None => "None",
            ActionsRequired::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ActionsRequired {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ActionsRequired::None => f.write_str("None"),
            ActionsRequired::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a ActivationStatus> for &'a str {
    fn from(e: &'a ActivationStatus) -> Self {
        match e {
            ActivationStatus::Active => "Active",
            ActivationStatus::Failed => "Failed",
            ActivationStatus::NotActivated => "NotActivated",
            ActivationStatus::Unknown => "Unknown",
            ActivationStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ActivationStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Active" => ActivationStatus::Active,
            "Failed" => ActivationStatus::Failed,
            "NotActivated" => ActivationStatus::NotActivated,
            "Unknown" => ActivationStatus::Unknown,
            _ => ActivationStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ActivationStatus {
    fn as_ref(&self) -> &str {
        match self {
            ActivationStatus::Active => "Active",
            ActivationStatus::Failed => "Failed",
            ActivationStatus::NotActivated => "NotActivated",
            ActivationStatus::Unknown => "Unknown",
            ActivationStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ActivationStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ActivationStatus::Active => f.write_str("Active"),
            ActivationStatus::Failed => f.write_str("Failed"),
            ActivationStatus::NotActivated => f.write_str("NotActivated"),
            ActivationStatus::Unknown => f.write_str("Unknown"),
            ActivationStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a CertificatePermissions> for &'a str {
    fn from(e: &'a CertificatePermissions) -> Self {
        match e {
            CertificatePermissions::All => "all",
            CertificatePermissions::Backup => "backup",
            CertificatePermissions::Create => "create",
            CertificatePermissions::Delete => "delete",
            CertificatePermissions::Deleteissuers => "deleteissuers",
            CertificatePermissions::Get => "get",
            CertificatePermissions::Getissuers => "getissuers",
            CertificatePermissions::Import => "import",
            CertificatePermissions::List => "list",
            CertificatePermissions::Listissuers => "listissuers",
            CertificatePermissions::Managecontacts => "managecontacts",
            CertificatePermissions::Manageissuers => "manageissuers",
            CertificatePermissions::Purge => "purge",
            CertificatePermissions::Recover => "recover",
            CertificatePermissions::Restore => "restore",
            CertificatePermissions::Setissuers => "setissuers",
            CertificatePermissions::Update => "update",
            CertificatePermissions::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for CertificatePermissions {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "all" => CertificatePermissions::All,
            "backup" => CertificatePermissions::Backup,
            "create" => CertificatePermissions::Create,
            "delete" => CertificatePermissions::Delete,
            "deleteissuers" => CertificatePermissions::Deleteissuers,
            "get" => CertificatePermissions::Get,
            "getissuers" => CertificatePermissions::Getissuers,
            "import" => CertificatePermissions::Import,
            "list" => CertificatePermissions::List,
            "listissuers" => CertificatePermissions::Listissuers,
            "managecontacts" => CertificatePermissions::Managecontacts,
            "manageissuers" => CertificatePermissions::Manageissuers,
            "purge" => CertificatePermissions::Purge,
            "recover" => CertificatePermissions::Recover,
            "restore" => CertificatePermissions::Restore,
            "setissuers" => CertificatePermissions::Setissuers,
            "update" => CertificatePermissions::Update,
            _ => CertificatePermissions::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for CertificatePermissions {
    fn as_ref(&self) -> &str {
        match self {
            CertificatePermissions::All => "all",
            CertificatePermissions::Backup => "backup",
            CertificatePermissions::Create => "create",
            CertificatePermissions::Delete => "delete",
            CertificatePermissions::Deleteissuers => "deleteissuers",
            CertificatePermissions::Get => "get",
            CertificatePermissions::Getissuers => "getissuers",
            CertificatePermissions::Import => "import",
            CertificatePermissions::List => "list",
            CertificatePermissions::Listissuers => "listissuers",
            CertificatePermissions::Managecontacts => "managecontacts",
            CertificatePermissions::Manageissuers => "manageissuers",
            CertificatePermissions::Purge => "purge",
            CertificatePermissions::Recover => "recover",
            CertificatePermissions::Restore => "restore",
            CertificatePermissions::Setissuers => "setissuers",
            CertificatePermissions::Update => "update",
            CertificatePermissions::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for CertificatePermissions {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CertificatePermissions::All => f.write_str("all"),
            CertificatePermissions::Backup => f.write_str("backup"),
            CertificatePermissions::Create => f.write_str("create"),
            CertificatePermissions::Delete => f.write_str("delete"),
            CertificatePermissions::Deleteissuers => f.write_str("deleteissuers"),
            CertificatePermissions::Get => f.write_str("get"),
            CertificatePermissions::Getissuers => f.write_str("getissuers"),
            CertificatePermissions::Import => f.write_str("import"),
            CertificatePermissions::List => f.write_str("list"),
            CertificatePermissions::Listissuers => f.write_str("listissuers"),
            CertificatePermissions::Managecontacts => f.write_str("managecontacts"),
            CertificatePermissions::Manageissuers => f.write_str("manageissuers"),
            CertificatePermissions::Purge => f.write_str("purge"),
            CertificatePermissions::Recover => f.write_str("recover"),
            CertificatePermissions::Restore => f.write_str("restore"),
            CertificatePermissions::Setissuers => f.write_str("setissuers"),
            CertificatePermissions::Update => f.write_str("update"),
            CertificatePermissions::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for CreateMode {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "default" => CreateMode::Default,
            "recover" => CreateMode::Recover,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of CreateMode found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for CreateMode {
    fn as_ref(&self) -> &str {
        match self {
            CreateMode::Default => "default",
            CreateMode::Recover => "recover",
        }
    }
}

impl Display for CreateMode {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CreateMode::Default => Display::fmt("default", f),
            CreateMode::Recover => Display::fmt("recover", f),
        }
    }
}

impl<'a> From<&'a CreatedByType> for &'a str {
    fn from(e: &'a CreatedByType) -> Self {
        match e {
            CreatedByType::Application => "Application",
            CreatedByType::Key => "Key",
            CreatedByType::ManagedIdentity => "ManagedIdentity",
            CreatedByType::User => "User",
            CreatedByType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for CreatedByType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Application" => CreatedByType::Application,
            "Key" => CreatedByType::Key,
            "ManagedIdentity" => CreatedByType::ManagedIdentity,
            "User" => CreatedByType::User,
            _ => CreatedByType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for CreatedByType {
    fn as_ref(&self) -> &str {
        match self {
            CreatedByType::Application => "Application",
            CreatedByType::Key => "Key",
            CreatedByType::ManagedIdentity => "ManagedIdentity",
            CreatedByType::User => "User",
            CreatedByType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for CreatedByType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CreatedByType::Application => f.write_str("Application"),
            CreatedByType::Key => f.write_str("Key"),
            CreatedByType::ManagedIdentity => f.write_str("ManagedIdentity"),
            CreatedByType::User => f.write_str("User"),
            CreatedByType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a DeletionRecoveryLevel> for &'a str {
    fn from(e: &'a DeletionRecoveryLevel) -> Self {
        match e {
            DeletionRecoveryLevel::Purgeable => "Purgeable",
            DeletionRecoveryLevel::Recoverable => "Recoverable",
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                "Recoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::RecoverablePurgeable => "Recoverable+Purgeable",
            DeletionRecoveryLevel::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for DeletionRecoveryLevel {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Purgeable" => DeletionRecoveryLevel::Purgeable,
            "Recoverable" => DeletionRecoveryLevel::Recoverable,
            "Recoverable+ProtectedSubscription" => {
                DeletionRecoveryLevel::RecoverableProtectedSubscription
            }
            "Recoverable+Purgeable" => DeletionRecoveryLevel::RecoverablePurgeable,
            _ => DeletionRecoveryLevel::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for DeletionRecoveryLevel {
    fn as_ref(&self) -> &str {
        match self {
            DeletionRecoveryLevel::Purgeable => "Purgeable",
            DeletionRecoveryLevel::Recoverable => "Recoverable",
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                "Recoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::RecoverablePurgeable => "Recoverable+Purgeable",
            DeletionRecoveryLevel::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for DeletionRecoveryLevel {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            DeletionRecoveryLevel::Purgeable => f.write_str("Purgeable"),
            DeletionRecoveryLevel::Recoverable => f.write_str("Recoverable"),
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                f.write_str("Recoverable+ProtectedSubscription")
            }
            DeletionRecoveryLevel::RecoverablePurgeable => f.write_str("Recoverable+Purgeable"),
            DeletionRecoveryLevel::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a GeoReplicationRegionProvisioningState> for &'a str {
    fn from(e: &'a GeoReplicationRegionProvisioningState) -> Self {
        match e {
            GeoReplicationRegionProvisioningState::Cleanup => "Cleanup",
            GeoReplicationRegionProvisioningState::Deleting => "Deleting",
            GeoReplicationRegionProvisioningState::Failed => "Failed",
            GeoReplicationRegionProvisioningState::Preprovisioning => "Preprovisioning",
            GeoReplicationRegionProvisioningState::Provisioning => "Provisioning",
            GeoReplicationRegionProvisioningState::Succeeded => "Succeeded",
            GeoReplicationRegionProvisioningState::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for GeoReplicationRegionProvisioningState {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Cleanup" => GeoReplicationRegionProvisioningState::Cleanup,
            "Deleting" => GeoReplicationRegionProvisioningState::Deleting,
            "Failed" => GeoReplicationRegionProvisioningState::Failed,
            "Preprovisioning" => GeoReplicationRegionProvisioningState::Preprovisioning,
            "Provisioning" => GeoReplicationRegionProvisioningState::Provisioning,
            "Succeeded" => GeoReplicationRegionProvisioningState::Succeeded,
            _ => GeoReplicationRegionProvisioningState::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for GeoReplicationRegionProvisioningState {
    fn as_ref(&self) -> &str {
        match self {
            GeoReplicationRegionProvisioningState::Cleanup => "Cleanup",
            GeoReplicationRegionProvisioningState::Deleting => "Deleting",
            GeoReplicationRegionProvisioningState::Failed => "Failed",
            GeoReplicationRegionProvisioningState::Preprovisioning => "Preprovisioning",
            GeoReplicationRegionProvisioningState::Provisioning => "Provisioning",
            GeoReplicationRegionProvisioningState::Succeeded => "Succeeded",
            GeoReplicationRegionProvisioningState::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for GeoReplicationRegionProvisioningState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GeoReplicationRegionProvisioningState::Cleanup => f.write_str("Cleanup"),
            GeoReplicationRegionProvisioningState::Deleting => f.write_str("Deleting"),
            GeoReplicationRegionProvisioningState::Failed => f.write_str("Failed"),
            GeoReplicationRegionProvisioningState::Preprovisioning => {
                f.write_str("Preprovisioning")
            }
            GeoReplicationRegionProvisioningState::Provisioning => f.write_str("Provisioning"),
            GeoReplicationRegionProvisioningState::Succeeded => f.write_str("Succeeded"),
            GeoReplicationRegionProvisioningState::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a JsonWebKeyCurveName> for &'a str {
    fn from(e: &'a JsonWebKeyCurveName) -> Self {
        match e {
            JsonWebKeyCurveName::P256 => "P-256",
            JsonWebKeyCurveName::P256K => "P-256K",
            JsonWebKeyCurveName::P384 => "P-384",
            JsonWebKeyCurveName::P521 => "P-521",
            JsonWebKeyCurveName::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for JsonWebKeyCurveName {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "P-256" => JsonWebKeyCurveName::P256,
            "P-256K" => JsonWebKeyCurveName::P256K,
            "P-384" => JsonWebKeyCurveName::P384,
            "P-521" => JsonWebKeyCurveName::P521,
            _ => JsonWebKeyCurveName::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for JsonWebKeyCurveName {
    fn as_ref(&self) -> &str {
        match self {
            JsonWebKeyCurveName::P256 => "P-256",
            JsonWebKeyCurveName::P256K => "P-256K",
            JsonWebKeyCurveName::P384 => "P-384",
            JsonWebKeyCurveName::P521 => "P-521",
            JsonWebKeyCurveName::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for JsonWebKeyCurveName {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            JsonWebKeyCurveName::P256 => f.write_str("P-256"),
            JsonWebKeyCurveName::P256K => f.write_str("P-256K"),
            JsonWebKeyCurveName::P384 => f.write_str("P-384"),
            JsonWebKeyCurveName::P521 => f.write_str("P-521"),
            JsonWebKeyCurveName::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a JsonWebKeyOperation> for &'a str {
    fn from(e: &'a JsonWebKeyOperation) -> Self {
        match e {
            JsonWebKeyOperation::Decrypt => "decrypt",
            JsonWebKeyOperation::Encrypt => "encrypt",
            JsonWebKeyOperation::Import => "import",
            JsonWebKeyOperation::Release => "release",
            JsonWebKeyOperation::Sign => "sign",
            JsonWebKeyOperation::UnwrapKey => "unwrapKey",
            JsonWebKeyOperation::Verify => "verify",
            JsonWebKeyOperation::WrapKey => "wrapKey",
            JsonWebKeyOperation::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for JsonWebKeyOperation {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "decrypt" => JsonWebKeyOperation::Decrypt,
            "encrypt" => JsonWebKeyOperation::Encrypt,
            "import" => JsonWebKeyOperation::Import,
            "release" => JsonWebKeyOperation::Release,
            "sign" => JsonWebKeyOperation::Sign,
            "unwrapKey" => JsonWebKeyOperation::UnwrapKey,
            "verify" => JsonWebKeyOperation::Verify,
            "wrapKey" => JsonWebKeyOperation::WrapKey,
            _ => JsonWebKeyOperation::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for JsonWebKeyOperation {
    fn as_ref(&self) -> &str {
        match self {
            JsonWebKeyOperation::Decrypt => "decrypt",
            JsonWebKeyOperation::Encrypt => "encrypt",
            JsonWebKeyOperation::Import => "import",
            JsonWebKeyOperation::Release => "release",
            JsonWebKeyOperation::Sign => "sign",
            JsonWebKeyOperation::UnwrapKey => "unwrapKey",
            JsonWebKeyOperation::Verify => "verify",
            JsonWebKeyOperation::WrapKey => "wrapKey",
            JsonWebKeyOperation::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for JsonWebKeyOperation {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            JsonWebKeyOperation::Decrypt => f.write_str("decrypt"),
            JsonWebKeyOperation::Encrypt => f.write_str("encrypt"),
            JsonWebKeyOperation::Import => f.write_str("import"),
            JsonWebKeyOperation::Release => f.write_str("release"),
            JsonWebKeyOperation::Sign => f.write_str("sign"),
            JsonWebKeyOperation::UnwrapKey => f.write_str("unwrapKey"),
            JsonWebKeyOperation::Verify => f.write_str("verify"),
            JsonWebKeyOperation::WrapKey => f.write_str("wrapKey"),
            JsonWebKeyOperation::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a JsonWebKeyType> for &'a str {
    fn from(e: &'a JsonWebKeyType) -> Self {
        match e {
            JsonWebKeyType::Ec => "EC",
            JsonWebKeyType::EcHsm => "EC-HSM",
            JsonWebKeyType::Rsa => "RSA",
            JsonWebKeyType::RsaHsm => "RSA-HSM",
            JsonWebKeyType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for JsonWebKeyType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "EC" => JsonWebKeyType::Ec,
            "EC-HSM" => JsonWebKeyType::EcHsm,
            "RSA" => JsonWebKeyType::Rsa,
            "RSA-HSM" => JsonWebKeyType::RsaHsm,
            _ => JsonWebKeyType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for JsonWebKeyType {
    fn as_ref(&self) -> &str {
        match self {
            JsonWebKeyType::Ec => "EC",
            JsonWebKeyType::EcHsm => "EC-HSM",
            JsonWebKeyType::Rsa => "RSA",
            JsonWebKeyType::RsaHsm => "RSA-HSM",
            JsonWebKeyType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for JsonWebKeyType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            JsonWebKeyType::Ec => f.write_str("EC"),
            JsonWebKeyType::EcHsm => f.write_str("EC-HSM"),
            JsonWebKeyType::Rsa => f.write_str("RSA"),
            JsonWebKeyType::RsaHsm => f.write_str("RSA-HSM"),
            JsonWebKeyType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a KeyPermissions> for &'a str {
    fn from(e: &'a KeyPermissions) -> Self {
        match e {
            KeyPermissions::All => "all",
            KeyPermissions::Backup => "backup",
            KeyPermissions::Create => "create",
            KeyPermissions::Decrypt => "decrypt",
            KeyPermissions::Delete => "delete",
            KeyPermissions::Encrypt => "encrypt",
            KeyPermissions::Get => "get",
            KeyPermissions::Getrotationpolicy => "getrotationpolicy",
            KeyPermissions::Import => "import",
            KeyPermissions::List => "list",
            KeyPermissions::Purge => "purge",
            KeyPermissions::Recover => "recover",
            KeyPermissions::Release => "release",
            KeyPermissions::Restore => "restore",
            KeyPermissions::Rotate => "rotate",
            KeyPermissions::Setrotationpolicy => "setrotationpolicy",
            KeyPermissions::Sign => "sign",
            KeyPermissions::UnwrapKey => "unwrapKey",
            KeyPermissions::Update => "update",
            KeyPermissions::Verify => "verify",
            KeyPermissions::WrapKey => "wrapKey",
            KeyPermissions::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for KeyPermissions {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "all" => KeyPermissions::All,
            "backup" => KeyPermissions::Backup,
            "create" => KeyPermissions::Create,
            "decrypt" => KeyPermissions::Decrypt,
            "delete" => KeyPermissions::Delete,
            "encrypt" => KeyPermissions::Encrypt,
            "get" => KeyPermissions::Get,
            "getrotationpolicy" => KeyPermissions::Getrotationpolicy,
            "import" => KeyPermissions::Import,
            "list" => KeyPermissions::List,
            "purge" => KeyPermissions::Purge,
            "recover" => KeyPermissions::Recover,
            "release" => KeyPermissions::Release,
            "restore" => KeyPermissions::Restore,
            "rotate" => KeyPermissions::Rotate,
            "setrotationpolicy" => KeyPermissions::Setrotationpolicy,
            "sign" => KeyPermissions::Sign,
            "unwrapKey" => KeyPermissions::UnwrapKey,
            "update" => KeyPermissions::Update,
            "verify" => KeyPermissions::Verify,
            "wrapKey" => KeyPermissions::WrapKey,
            _ => KeyPermissions::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for KeyPermissions {
    fn as_ref(&self) -> &str {
        match self {
            KeyPermissions::All => "all",
            KeyPermissions::Backup => "backup",
            KeyPermissions::Create => "create",
            KeyPermissions::Decrypt => "decrypt",
            KeyPermissions::Delete => "delete",
            KeyPermissions::Encrypt => "encrypt",
            KeyPermissions::Get => "get",
            KeyPermissions::Getrotationpolicy => "getrotationpolicy",
            KeyPermissions::Import => "import",
            KeyPermissions::List => "list",
            KeyPermissions::Purge => "purge",
            KeyPermissions::Recover => "recover",
            KeyPermissions::Release => "release",
            KeyPermissions::Restore => "restore",
            KeyPermissions::Rotate => "rotate",
            KeyPermissions::Setrotationpolicy => "setrotationpolicy",
            KeyPermissions::Sign => "sign",
            KeyPermissions::UnwrapKey => "unwrapKey",
            KeyPermissions::Update => "update",
            KeyPermissions::Verify => "verify",
            KeyPermissions::WrapKey => "wrapKey",
            KeyPermissions::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for KeyPermissions {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyPermissions::All => f.write_str("all"),
            KeyPermissions::Backup => f.write_str("backup"),
            KeyPermissions::Create => f.write_str("create"),
            KeyPermissions::Decrypt => f.write_str("decrypt"),
            KeyPermissions::Delete => f.write_str("delete"),
            KeyPermissions::Encrypt => f.write_str("encrypt"),
            KeyPermissions::Get => f.write_str("get"),
            KeyPermissions::Getrotationpolicy => f.write_str("getrotationpolicy"),
            KeyPermissions::Import => f.write_str("import"),
            KeyPermissions::List => f.write_str("list"),
            KeyPermissions::Purge => f.write_str("purge"),
            KeyPermissions::Recover => f.write_str("recover"),
            KeyPermissions::Release => f.write_str("release"),
            KeyPermissions::Restore => f.write_str("restore"),
            KeyPermissions::Rotate => f.write_str("rotate"),
            KeyPermissions::Setrotationpolicy => f.write_str("setrotationpolicy"),
            KeyPermissions::Sign => f.write_str("sign"),
            KeyPermissions::UnwrapKey => f.write_str("unwrapKey"),
            KeyPermissions::Update => f.write_str("update"),
            KeyPermissions::Verify => f.write_str("verify"),
            KeyPermissions::WrapKey => f.write_str("wrapKey"),
            KeyPermissions::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for KeyRotationPolicyActionType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "notify" => KeyRotationPolicyActionType::Notify,
            "rotate" => KeyRotationPolicyActionType::Rotate,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of KeyRotationPolicyActionType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for KeyRotationPolicyActionType {
    fn as_ref(&self) -> &str {
        match self {
            KeyRotationPolicyActionType::Notify => "notify",
            KeyRotationPolicyActionType::Rotate => "rotate",
        }
    }
}

impl Display for KeyRotationPolicyActionType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyRotationPolicyActionType::Notify => Display::fmt("notify", f),
            KeyRotationPolicyActionType::Rotate => Display::fmt("rotate", f),
        }
    }
}

impl<'a> From<&'a ManagedHsmSkuFamily> for &'a str {
    fn from(e: &'a ManagedHsmSkuFamily) -> Self {
        match e {
            ManagedHsmSkuFamily::B => "B",
            ManagedHsmSkuFamily::C => "C",
            ManagedHsmSkuFamily::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ManagedHsmSkuFamily {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "B" => ManagedHsmSkuFamily::B,
            "C" => ManagedHsmSkuFamily::C,
            _ => ManagedHsmSkuFamily::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ManagedHsmSkuFamily {
    fn as_ref(&self) -> &str {
        match self {
            ManagedHsmSkuFamily::B => "B",
            ManagedHsmSkuFamily::C => "C",
            ManagedHsmSkuFamily::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ManagedHsmSkuFamily {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ManagedHsmSkuFamily::B => f.write_str("B"),
            ManagedHsmSkuFamily::C => f.write_str("C"),
            ManagedHsmSkuFamily::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for ManagedHsmSkuName {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Custom_B32" => ManagedHsmSkuName::CustomB32,
            "Custom_B6" => ManagedHsmSkuName::CustomB6,
            "Custom_C10" => ManagedHsmSkuName::CustomC10,
            "Custom_C42" => ManagedHsmSkuName::CustomC42,
            "Standard_B1" => ManagedHsmSkuName::StandardB1,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of ManagedHsmSkuName found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for ManagedHsmSkuName {
    fn as_ref(&self) -> &str {
        match self {
            ManagedHsmSkuName::CustomB32 => "Custom_B32",
            ManagedHsmSkuName::CustomB6 => "Custom_B6",
            ManagedHsmSkuName::CustomC10 => "Custom_C10",
            ManagedHsmSkuName::CustomC42 => "Custom_C42",
            ManagedHsmSkuName::StandardB1 => "Standard_B1",
        }
    }
}

impl Display for ManagedHsmSkuName {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ManagedHsmSkuName::CustomB32 => Display::fmt("Custom_B32", f),
            ManagedHsmSkuName::CustomB6 => Display::fmt("Custom_B6", f),
            ManagedHsmSkuName::CustomC10 => Display::fmt("Custom_C10", f),
            ManagedHsmSkuName::CustomC42 => Display::fmt("Custom_C42", f),
            ManagedHsmSkuName::StandardB1 => Display::fmt("Standard_B1", f),
        }
    }
}

impl<'a> From<&'a ManagedServiceIdentityType> for &'a str {
    fn from(e: &'a ManagedServiceIdentityType) -> Self {
        match e {
            ManagedServiceIdentityType::None => "None",
            ManagedServiceIdentityType::SystemAssigned => "SystemAssigned",
            ManagedServiceIdentityType::SystemAssignedUserAssigned => "SystemAssigned,UserAssigned",
            ManagedServiceIdentityType::UserAssigned => "UserAssigned",
            ManagedServiceIdentityType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ManagedServiceIdentityType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "None" => ManagedServiceIdentityType::None,
            "SystemAssigned" => ManagedServiceIdentityType::SystemAssigned,
            "SystemAssigned,UserAssigned" => ManagedServiceIdentityType::SystemAssignedUserAssigned,
            "UserAssigned" => ManagedServiceIdentityType::UserAssigned,
            _ => ManagedServiceIdentityType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ManagedServiceIdentityType {
    fn as_ref(&self) -> &str {
        match self {
            ManagedServiceIdentityType::None => "None",
            ManagedServiceIdentityType::SystemAssigned => "SystemAssigned",
            ManagedServiceIdentityType::SystemAssignedUserAssigned => "SystemAssigned,UserAssigned",
            ManagedServiceIdentityType::UserAssigned => "UserAssigned",
            ManagedServiceIdentityType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ManagedServiceIdentityType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ManagedServiceIdentityType::None => f.write_str("None"),
            ManagedServiceIdentityType::SystemAssigned => f.write_str("SystemAssigned"),
            ManagedServiceIdentityType::SystemAssignedUserAssigned => {
                f.write_str("SystemAssigned,UserAssigned")
            }
            ManagedServiceIdentityType::UserAssigned => f.write_str("UserAssigned"),
            ManagedServiceIdentityType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a NetworkRuleAction> for &'a str {
    fn from(e: &'a NetworkRuleAction) -> Self {
        match e {
            NetworkRuleAction::Allow => "Allow",
            NetworkRuleAction::Deny => "Deny",
            NetworkRuleAction::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for NetworkRuleAction {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Allow" => NetworkRuleAction::Allow,
            "Deny" => NetworkRuleAction::Deny,
            _ => NetworkRuleAction::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for NetworkRuleAction {
    fn as_ref(&self) -> &str {
        match self {
            NetworkRuleAction::Allow => "Allow",
            NetworkRuleAction::Deny => "Deny",
            NetworkRuleAction::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for NetworkRuleAction {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            NetworkRuleAction::Allow => f.write_str("Allow"),
            NetworkRuleAction::Deny => f.write_str("Deny"),
            NetworkRuleAction::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a NetworkRuleBypassOptions> for &'a str {
    fn from(e: &'a NetworkRuleBypassOptions) -> Self {
        match e {
            NetworkRuleBypassOptions::AzureServices => "AzureServices",
            NetworkRuleBypassOptions::None => "None",
            NetworkRuleBypassOptions::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for NetworkRuleBypassOptions {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AzureServices" => NetworkRuleBypassOptions::AzureServices,
            "None" => NetworkRuleBypassOptions::None,
            _ => NetworkRuleBypassOptions::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for NetworkRuleBypassOptions {
    fn as_ref(&self) -> &str {
        match self {
            NetworkRuleBypassOptions::AzureServices => "AzureServices",
            NetworkRuleBypassOptions::None => "None",
            NetworkRuleBypassOptions::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for NetworkRuleBypassOptions {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            NetworkRuleBypassOptions::AzureServices => f.write_str("AzureServices"),
            NetworkRuleBypassOptions::None => f.write_str("None"),
            NetworkRuleBypassOptions::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a PrivateEndpointConnectionProvisioningState> for &'a str {
    fn from(e: &'a PrivateEndpointConnectionProvisioningState) -> Self {
        match e {
            PrivateEndpointConnectionProvisioningState::Creating => "Creating",
            PrivateEndpointConnectionProvisioningState::Deleting => "Deleting",
            PrivateEndpointConnectionProvisioningState::Disconnected => "Disconnected",
            PrivateEndpointConnectionProvisioningState::Failed => "Failed",
            PrivateEndpointConnectionProvisioningState::Succeeded => "Succeeded",
            PrivateEndpointConnectionProvisioningState::Updating => "Updating",
            PrivateEndpointConnectionProvisioningState::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PrivateEndpointConnectionProvisioningState {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Creating" => PrivateEndpointConnectionProvisioningState::Creating,
            "Deleting" => PrivateEndpointConnectionProvisioningState::Deleting,
            "Disconnected" => PrivateEndpointConnectionProvisioningState::Disconnected,
            "Failed" => PrivateEndpointConnectionProvisioningState::Failed,
            "Succeeded" => PrivateEndpointConnectionProvisioningState::Succeeded,
            "Updating" => PrivateEndpointConnectionProvisioningState::Updating,
            _ => PrivateEndpointConnectionProvisioningState::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PrivateEndpointConnectionProvisioningState {
    fn as_ref(&self) -> &str {
        match self {
            PrivateEndpointConnectionProvisioningState::Creating => "Creating",
            PrivateEndpointConnectionProvisioningState::Deleting => "Deleting",
            PrivateEndpointConnectionProvisioningState::Disconnected => "Disconnected",
            PrivateEndpointConnectionProvisioningState::Failed => "Failed",
            PrivateEndpointConnectionProvisioningState::Succeeded => "Succeeded",
            PrivateEndpointConnectionProvisioningState::Updating => "Updating",
            PrivateEndpointConnectionProvisioningState::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PrivateEndpointConnectionProvisioningState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PrivateEndpointConnectionProvisioningState::Creating => f.write_str("Creating"),
            PrivateEndpointConnectionProvisioningState::Deleting => f.write_str("Deleting"),
            PrivateEndpointConnectionProvisioningState::Disconnected => f.write_str("Disconnected"),
            PrivateEndpointConnectionProvisioningState::Failed => f.write_str("Failed"),
            PrivateEndpointConnectionProvisioningState::Succeeded => f.write_str("Succeeded"),
            PrivateEndpointConnectionProvisioningState::Updating => f.write_str("Updating"),
            PrivateEndpointConnectionProvisioningState::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a PrivateEndpointServiceConnectionStatus> for &'a str {
    fn from(e: &'a PrivateEndpointServiceConnectionStatus) -> Self {
        match e {
            PrivateEndpointServiceConnectionStatus::Approved => "Approved",
            PrivateEndpointServiceConnectionStatus::Disconnected => "Disconnected",
            PrivateEndpointServiceConnectionStatus::Pending => "Pending",
            PrivateEndpointServiceConnectionStatus::Rejected => "Rejected",
            PrivateEndpointServiceConnectionStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PrivateEndpointServiceConnectionStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Approved" => PrivateEndpointServiceConnectionStatus::Approved,
            "Disconnected" => PrivateEndpointServiceConnectionStatus::Disconnected,
            "Pending" => PrivateEndpointServiceConnectionStatus::Pending,
            "Rejected" => PrivateEndpointServiceConnectionStatus::Rejected,
            _ => PrivateEndpointServiceConnectionStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PrivateEndpointServiceConnectionStatus {
    fn as_ref(&self) -> &str {
        match self {
            PrivateEndpointServiceConnectionStatus::Approved => "Approved",
            PrivateEndpointServiceConnectionStatus::Disconnected => "Disconnected",
            PrivateEndpointServiceConnectionStatus::Pending => "Pending",
            PrivateEndpointServiceConnectionStatus::Rejected => "Rejected",
            PrivateEndpointServiceConnectionStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PrivateEndpointServiceConnectionStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PrivateEndpointServiceConnectionStatus::Approved => f.write_str("Approved"),
            PrivateEndpointServiceConnectionStatus::Disconnected => f.write_str("Disconnected"),
            PrivateEndpointServiceConnectionStatus::Pending => f.write_str("Pending"),
            PrivateEndpointServiceConnectionStatus::Rejected => f.write_str("Rejected"),
            PrivateEndpointServiceConnectionStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a ProvisioningState> for &'a str {
    fn from(e: &'a ProvisioningState) -> Self {
        match e {
            ProvisioningState::Activated => "Activated",
            ProvisioningState::Deleting => "Deleting",
            ProvisioningState::Failed => "Failed",
            ProvisioningState::Provisioning => "Provisioning",
            ProvisioningState::Restoring => "Restoring",
            ProvisioningState::SecurityDomainRestore => "SecurityDomainRestore",
            ProvisioningState::Succeeded => "Succeeded",
            ProvisioningState::Updating => "Updating",
            ProvisioningState::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ProvisioningState {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Activated" => ProvisioningState::Activated,
            "Deleting" => ProvisioningState::Deleting,
            "Failed" => ProvisioningState::Failed,
            "Provisioning" => ProvisioningState::Provisioning,
            "Restoring" => ProvisioningState::Restoring,
            "SecurityDomainRestore" => ProvisioningState::SecurityDomainRestore,
            "Succeeded" => ProvisioningState::Succeeded,
            "Updating" => ProvisioningState::Updating,
            _ => ProvisioningState::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ProvisioningState {
    fn as_ref(&self) -> &str {
        match self {
            ProvisioningState::Activated => "Activated",
            ProvisioningState::Deleting => "Deleting",
            ProvisioningState::Failed => "Failed",
            ProvisioningState::Provisioning => "Provisioning",
            ProvisioningState::Restoring => "Restoring",
            ProvisioningState::SecurityDomainRestore => "SecurityDomainRestore",
            ProvisioningState::Succeeded => "Succeeded",
            ProvisioningState::Updating => "Updating",
            ProvisioningState::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ProvisioningState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ProvisioningState::Activated => f.write_str("Activated"),
            ProvisioningState::Deleting => f.write_str("Deleting"),
            ProvisioningState::Failed => f.write_str("Failed"),
            ProvisioningState::Provisioning => f.write_str("Provisioning"),
            ProvisioningState::Restoring => f.write_str("Restoring"),
            ProvisioningState::SecurityDomainRestore => f.write_str("SecurityDomainRestore"),
            ProvisioningState::Succeeded => f.write_str("Succeeded"),
            ProvisioningState::Updating => f.write_str("Updating"),
            ProvisioningState::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a PublicNetworkAccess> for &'a str {
    fn from(e: &'a PublicNetworkAccess) -> Self {
        match e {
            PublicNetworkAccess::Disabled => "Disabled",
            PublicNetworkAccess::Enabled => "Enabled",
            PublicNetworkAccess::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PublicNetworkAccess {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Disabled" => PublicNetworkAccess::Disabled,
            "Enabled" => PublicNetworkAccess::Enabled,
            _ => PublicNetworkAccess::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PublicNetworkAccess {
    fn as_ref(&self) -> &str {
        match self {
            PublicNetworkAccess::Disabled => "Disabled",
            PublicNetworkAccess::Enabled => "Enabled",
            PublicNetworkAccess::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PublicNetworkAccess {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PublicNetworkAccess::Disabled => f.write_str("Disabled"),
            PublicNetworkAccess::Enabled => f.write_str("Enabled"),
            PublicNetworkAccess::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a Reason> for &'a str {
    fn from(e: &'a Reason) -> Self {
        match e {
            Reason::AccountNameInvalid => "AccountNameInvalid",
            Reason::AlreadyExists => "AlreadyExists",
            Reason::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for Reason {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AccountNameInvalid" => Reason::AccountNameInvalid,
            "AlreadyExists" => Reason::AlreadyExists,
            _ => Reason::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for Reason {
    fn as_ref(&self) -> &str {
        match self {
            Reason::AccountNameInvalid => "AccountNameInvalid",
            Reason::AlreadyExists => "AlreadyExists",
            Reason::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for Reason {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Reason::AccountNameInvalid => f.write_str("AccountNameInvalid"),
            Reason::AlreadyExists => f.write_str("AlreadyExists"),
            Reason::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a ResourceProvisioningState> for &'a str {
    fn from(e: &'a ResourceProvisioningState) -> Self {
        match e {
            ResourceProvisioningState::Canceled => "Canceled",
            ResourceProvisioningState::Failed => "Failed",
            ResourceProvisioningState::Succeeded => "Succeeded",
            ResourceProvisioningState::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ResourceProvisioningState {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Canceled" => ResourceProvisioningState::Canceled,
            "Failed" => ResourceProvisioningState::Failed,
            "Succeeded" => ResourceProvisioningState::Succeeded,
            _ => ResourceProvisioningState::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ResourceProvisioningState {
    fn as_ref(&self) -> &str {
        match self {
            ResourceProvisioningState::Canceled => "Canceled",
            ResourceProvisioningState::Failed => "Failed",
            ResourceProvisioningState::Succeeded => "Succeeded",
            ResourceProvisioningState::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ResourceProvisioningState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ResourceProvisioningState::Canceled => f.write_str("Canceled"),
            ResourceProvisioningState::Failed => f.write_str("Failed"),
            ResourceProvisioningState::Succeeded => f.write_str("Succeeded"),
            ResourceProvisioningState::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a SecretPermissions> for &'a str {
    fn from(e: &'a SecretPermissions) -> Self {
        match e {
            SecretPermissions::All => "all",
            SecretPermissions::Backup => "backup",
            SecretPermissions::Delete => "delete",
            SecretPermissions::Get => "get",
            SecretPermissions::List => "list",
            SecretPermissions::Purge => "purge",
            SecretPermissions::Recover => "recover",
            SecretPermissions::Restore => "restore",
            SecretPermissions::Set => "set",
            SecretPermissions::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SecretPermissions {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "all" => SecretPermissions::All,
            "backup" => SecretPermissions::Backup,
            "delete" => SecretPermissions::Delete,
            "get" => SecretPermissions::Get,
            "list" => SecretPermissions::List,
            "purge" => SecretPermissions::Purge,
            "recover" => SecretPermissions::Recover,
            "restore" => SecretPermissions::Restore,
            "set" => SecretPermissions::Set,
            _ => SecretPermissions::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SecretPermissions {
    fn as_ref(&self) -> &str {
        match self {
            SecretPermissions::All => "all",
            SecretPermissions::Backup => "backup",
            SecretPermissions::Delete => "delete",
            SecretPermissions::Get => "get",
            SecretPermissions::List => "list",
            SecretPermissions::Purge => "purge",
            SecretPermissions::Recover => "recover",
            SecretPermissions::Restore => "restore",
            SecretPermissions::Set => "set",
            SecretPermissions::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SecretPermissions {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SecretPermissions::All => f.write_str("all"),
            SecretPermissions::Backup => f.write_str("backup"),
            SecretPermissions::Delete => f.write_str("delete"),
            SecretPermissions::Get => f.write_str("get"),
            SecretPermissions::List => f.write_str("list"),
            SecretPermissions::Purge => f.write_str("purge"),
            SecretPermissions::Recover => f.write_str("recover"),
            SecretPermissions::Restore => f.write_str("restore"),
            SecretPermissions::Set => f.write_str("set"),
            SecretPermissions::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a SkuFamily> for &'a str {
    fn from(e: &'a SkuFamily) -> Self {
        match e {
            SkuFamily::A => "A",
            SkuFamily::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SkuFamily {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "A" => SkuFamily::A,
            _ => SkuFamily::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SkuFamily {
    fn as_ref(&self) -> &str {
        match self {
            SkuFamily::A => "A",
            SkuFamily::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SkuFamily {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SkuFamily::A => f.write_str("A"),
            SkuFamily::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for SkuName {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "premium" => SkuName::Premium,
            "standard" => SkuName::Standard,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of SkuName found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for SkuName {
    fn as_ref(&self) -> &str {
        match self {
            SkuName::Premium => "premium",
            SkuName::Standard => "standard",
        }
    }
}

impl Display for SkuName {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SkuName::Premium => Display::fmt("premium", f),
            SkuName::Standard => Display::fmt("standard", f),
        }
    }
}

impl<'a> From<&'a StoragePermissions> for &'a str {
    fn from(e: &'a StoragePermissions) -> Self {
        match e {
            StoragePermissions::All => "all",
            StoragePermissions::Backup => "backup",
            StoragePermissions::Delete => "delete",
            StoragePermissions::Deletesas => "deletesas",
            StoragePermissions::Get => "get",
            StoragePermissions::Getsas => "getsas",
            StoragePermissions::List => "list",
            StoragePermissions::Listsas => "listsas",
            StoragePermissions::Purge => "purge",
            StoragePermissions::Recover => "recover",
            StoragePermissions::Regeneratekey => "regeneratekey",
            StoragePermissions::Restore => "restore",
            StoragePermissions::Set => "set",
            StoragePermissions::Setsas => "setsas",
            StoragePermissions::Update => "update",
            StoragePermissions::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for StoragePermissions {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "all" => StoragePermissions::All,
            "backup" => StoragePermissions::Backup,
            "delete" => StoragePermissions::Delete,
            "deletesas" => StoragePermissions::Deletesas,
            "get" => StoragePermissions::Get,
            "getsas" => StoragePermissions::Getsas,
            "list" => StoragePermissions::List,
            "listsas" => StoragePermissions::Listsas,
            "purge" => StoragePermissions::Purge,
            "recover" => StoragePermissions::Recover,
            "regeneratekey" => StoragePermissions::Regeneratekey,
            "restore" => StoragePermissions::Restore,
            "set" => StoragePermissions::Set,
            "setsas" => StoragePermissions::Setsas,
            "update" => StoragePermissions::Update,
            _ => StoragePermissions::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for StoragePermissions {
    fn as_ref(&self) -> &str {
        match self {
            StoragePermissions::All => "all",
            StoragePermissions::Backup => "backup",
            StoragePermissions::Delete => "delete",
            StoragePermissions::Deletesas => "deletesas",
            StoragePermissions::Get => "get",
            StoragePermissions::Getsas => "getsas",
            StoragePermissions::List => "list",
            StoragePermissions::Listsas => "listsas",
            StoragePermissions::Purge => "purge",
            StoragePermissions::Recover => "recover",
            StoragePermissions::Regeneratekey => "regeneratekey",
            StoragePermissions::Restore => "restore",
            StoragePermissions::Set => "set",
            StoragePermissions::Setsas => "setsas",
            StoragePermissions::Update => "update",
            StoragePermissions::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for StoragePermissions {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            StoragePermissions::All => f.write_str("all"),
            StoragePermissions::Backup => f.write_str("backup"),
            StoragePermissions::Delete => f.write_str("delete"),
            StoragePermissions::Deletesas => f.write_str("deletesas"),
            StoragePermissions::Get => f.write_str("get"),
            StoragePermissions::Getsas => f.write_str("getsas"),
            StoragePermissions::List => f.write_str("list"),
            StoragePermissions::Listsas => f.write_str("listsas"),
            StoragePermissions::Purge => f.write_str("purge"),
            StoragePermissions::Recover => f.write_str("recover"),
            StoragePermissions::Regeneratekey => f.write_str("regeneratekey"),
            StoragePermissions::Restore => f.write_str("restore"),
            StoragePermissions::Set => f.write_str("set"),
            StoragePermissions::Setsas => f.write_str("setsas"),
            StoragePermissions::Update => f.write_str("update"),
            StoragePermissions::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a VaultProvisioningState> for &'a str {
    fn from(e: &'a VaultProvisioningState) -> Self {
        match e {
            VaultProvisioningState::RegisteringDns => "RegisteringDns",
            VaultProvisioningState::Succeeded => "Succeeded",
            VaultProvisioningState::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for VaultProvisioningState {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "RegisteringDns" => VaultProvisioningState::RegisteringDns,
            "Succeeded" => VaultProvisioningState::Succeeded,
            _ => VaultProvisioningState::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for VaultProvisioningState {
    fn as_ref(&self) -> &str {
        match self {
            VaultProvisioningState::RegisteringDns => "RegisteringDns",
            VaultProvisioningState::Succeeded => "Succeeded",
            VaultProvisioningState::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for VaultProvisioningState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            VaultProvisioningState::RegisteringDns => f.write_str("RegisteringDns"),
            VaultProvisioningState::Succeeded => f.write_str("Succeeded"),
            VaultProvisioningState::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}
