// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    models_serde, ActionsRequired, ActivationStatus, CertificatePermissions, CreateMode,
    CreatedByType, DeletionRecoveryLevel, GeoReplicationRegionProvisioningState,
    JsonWebKeyCurveName, JsonWebKeyOperation, JsonWebKeyType, KeyPermissions,
    KeyRotationPolicyActionType, ManagedHsmSkuFamily, ManagedHsmSkuName,
    ManagedServiceIdentityType, NetworkRuleAction, NetworkRuleBypassOptions,
    PrivateEndpointConnectionProvisioningState, PrivateEndpointServiceConnectionStatus,
    ProvisioningState, PublicNetworkAccess, Reason, ResourceProvisioningState, SecretPermissions,
    SkuFamily, SkuName, StoragePermissions, VaultProvisioningState,
};
use azure_core::{
    base64::option::{deserialize_url_safe, serialize_url_safe},
    fmt::SafeDebug,
    http::Etag,
    time::OffsetDateTime,
    Value,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// An identity that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's
/// tenant ID.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct AccessPolicyEntry {
    /// Application ID of the client making request on behalf of a principal
    #[serde(rename = "applicationId", skip_serializing_if = "Option::is_none")]
    pub application_id: Option<String>,

    /// The object ID of a user, service principal or security group in the Azure Active Directory tenant for the vault. The object
    /// ID must be unique for the list of access policies.
    #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
    pub object_id: Option<String>,

    /// Permissions the identity has for keys, secrets and certificates.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Permissions>,

    /// The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
    #[serde(rename = "tenantId", skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct Action {
    /// The type of action.
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<KeyRotationPolicyActionType>,
}

/// The parameters used to check the availability of the managed hsm name.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct CheckMhsmNameAvailabilityParameters {
    /// The managed hsm name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// The CheckMhsmNameAvailability operation response.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct CheckMhsmNameAvailabilityResult {
    /// An error message explaining the Reason value in more detail.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,

    /// A boolean value that indicates whether the name is available for you to use. If true, the name is available. If false,
    /// the name has already been taken or is invalid and cannot be used.
    #[serde(rename = "nameAvailable", skip_serializing_if = "Option::is_none")]
    pub name_available: Option<bool>,

    /// The reason that a managed hsm name could not be used. The reason element is only returned if NameAvailable is false.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<Reason>,
}

/// The CheckNameAvailability operation response.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct CheckNameAvailabilityResult {
    /// An error message explaining the Reason value in more detail.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,

    /// A boolean value that indicates whether the name is available for you to use. If true, the name is available. If false,
    /// the name has already been taken or is invalid and cannot be used.
    #[serde(rename = "nameAvailable", skip_serializing_if = "Option::is_none")]
    pub name_available: Option<bool>,

    /// The reason that a vault name could not be used. The Reason element is only returned if NameAvailable is false.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<Reason>,
}

/// Concrete proxy resource types can be created by aliasing this type using a specific property type.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DeletedManagedHsm {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the deleted managed HSM.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Properties of the deleted managed HSM
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<DeletedManagedHsmProperties>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// The response of a DeletedManagedHsm list operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DeletedManagedHsmListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The DeletedManagedHsm items on this page
    #[serde(default)]
    pub value: Vec<DeletedManagedHsm>,
}

/// Properties of the deleted managed HSM.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DeletedManagedHsmProperties {
    /// The deleted date.
    #[serde(
        default,
        rename = "deletionDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub deletion_date: Option<OffsetDateTime>,

    /// The location of the original managed HSM.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The resource id of the original managed HSM.
    #[serde(rename = "mhsmId", skip_serializing_if = "Option::is_none")]
    pub mhsm_id: Option<String>,

    /// Purge protection status of the original managed HSM.
    #[serde(
        rename = "purgeProtectionEnabled",
        skip_serializing_if = "Option::is_none"
    )]
    pub purge_protection_enabled: Option<bool>,

    /// The scheduled purged date.
    #[serde(
        default,
        rename = "scheduledPurgeDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub scheduled_purge_date: Option<OffsetDateTime>,

    /// Tags of the original managed HSM.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// Deleted vault information with extended details.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DeletedVault {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Properties of the vault
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<DeletedVaultProperties>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// The response of a DeletedVault list operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DeletedVaultListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The DeletedVault items on this page
    #[serde(default)]
    pub value: Vec<DeletedVault>,
}

/// Properties of the deleted vault.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DeletedVaultProperties {
    /// The deleted date.
    #[serde(
        default,
        rename = "deletionDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub deletion_date: Option<OffsetDateTime>,

    /// The location of the original vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// Purge protection status of the original vault.
    #[serde(
        rename = "purgeProtectionEnabled",
        skip_serializing_if = "Option::is_none"
    )]
    pub purge_protection_enabled: Option<bool>,

    /// The scheduled purged date.
    #[serde(
        default,
        rename = "scheduledPurgeDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub scheduled_purge_date: Option<OffsetDateTime>,

    /// Tags of the original vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The resource id of the original vault.
    #[serde(rename = "vaultId", skip_serializing_if = "Option::is_none")]
    pub vault_id: Option<String>,
}

/// Type of operation: get, read, delete, etc.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct DimensionProperties {
    /// Display name of dimension.
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,

    /// Name of dimension.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Property to specify whether the dimension should be exported for Shoebox.
    #[serde(
        rename = "toBeExportedForShoebox",
        skip_serializing_if = "Option::is_none"
    )]
    pub to_be_exported_for_shoebox: Option<bool>,
}

/// The resource management error additional info.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ErrorAdditionalInfo {
    /// The additional info.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<Value>,

    /// The additional info type.
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// The error detail.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ErrorDetail {
    /// The error additional info.
    #[serde(rename = "additionalInfo", skip_serializing_if = "Option::is_none")]
    pub additional_info: Option<Vec<ErrorAdditionalInfo>>,

    /// The error code.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,

    /// The error details.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<Vec<ErrorDetail>>,

    /// The error message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,

    /// The error target.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
}

/// A rule governing the accessibility of a vault from a specific ip address or ip range.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct IPRule {
    /// An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or '124.56.78.0/24' (all addresses
    /// that start with 124.56.78).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The key resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct Key {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The supported Azure location where the managed HSM Pool should be created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The name of the key to be retrieved.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The properties of the key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<KeyProperties>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Resource tags
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// The object attributes managed by the Azure Key Vault service.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyAttributes {
    /// Creation time in seconds since 1970-01-01T00:00:00Z.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<i64>,

    /// Determines whether or not the object is enabled.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    /// Expiry date in seconds since 1970-01-01T00:00:00Z.
    #[serde(rename = "exp", skip_serializing_if = "Option::is_none")]
    pub expires: Option<i64>,

    /// Indicates if the private key can be exported.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exportable: Option<bool>,

    /// Not before date in seconds since 1970-01-01T00:00:00Z.
    #[serde(rename = "nbf", skip_serializing_if = "Option::is_none")]
    pub not_before: Option<i64>,

    /// The deletion recovery level currently in effect for the object. If it contains 'Purgeable', then the object can be permanently
    /// deleted by a privileged user; otherwise, only the system can purge the object at the end of the retention interval.
    #[serde(rename = "recoveryLevel", skip_serializing_if = "Option::is_none")]
    pub recovery_level: Option<DeletionRecoveryLevel>,

    /// Last updated time in seconds since 1970-01-01T00:00:00Z.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<i64>,
}

/// The parameters used to create a key.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyCreateParameters {
    /// The properties of the key to be created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<KeyProperties>,

    /// The tags that will be assigned to the key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The response of a Key list operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct KeyListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The Key items on this page
    #[serde(default)]
    pub value: Vec<Key>,
}

/// The properties of the key.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyProperties {
    /// The attributes of the key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<KeyAttributes>,

    /// The elliptic curve name. For valid values, see JsonWebKeyCurveName. Default for EC and EC-HSM keys is P-256
    #[serde(rename = "curveName", skip_serializing_if = "Option::is_none")]
    pub curve_name: Option<JsonWebKeyCurveName>,

    #[serde(rename = "keyOps", skip_serializing_if = "Option::is_none")]
    pub key_ops: Option<Vec<JsonWebKeyOperation>>,

    /// The key size in bits. For example: 2048, 3072, or 4096 for RSA. Default for RSA and RSA-HSM keys is 2048. Exception made
    /// for bring your own key (BYOK), key exchange keys default to 4096.
    #[serde(rename = "keySize", skip_serializing_if = "Option::is_none")]
    pub key_size: Option<i32>,

    /// The URI to retrieve the current version of the key.
    #[serde(rename = "keyUri", skip_serializing_if = "Option::is_none")]
    pub key_uri: Option<String>,

    /// The URI to retrieve the specific version of the key.
    #[serde(rename = "keyUriWithVersion", skip_serializing_if = "Option::is_none")]
    pub key_uri_with_version: Option<String>,

    /// The type of the key. For valid values, see JsonWebKeyType.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kty: Option<JsonWebKeyType>,

    /// Key release policy in response. It will be used for both output and input. Omitted if empty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_policy: Option<KeyReleasePolicy>,

    /// Key rotation policy in response. It will be used for both output and input. Omitted if empty
    #[serde(rename = "rotationPolicy", skip_serializing_if = "Option::is_none")]
    pub rotation_policy: Option<RotationPolicy>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyReleasePolicy {
    /// Content type and version of key release policy
    #[serde(rename = "contentType", skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// Blob encoding the policy rules under which the key can be released.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub data: Option<Vec<u8>>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyRotationPolicyAttributes {
    /// Creation time in seconds since 1970-01-01T00:00:00Z.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<i64>,

    /// The expiration time for the new key version. It should be in ISO8601 format. Eg: 'P90D', 'P1Y'.
    #[serde(rename = "expiryTime", skip_serializing_if = "Option::is_none")]
    pub expiry_time: Option<String>,

    /// Last updated time in seconds since 1970-01-01T00:00:00Z.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<i64>,
}

/// Standard Azure Resource Manager operation status response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyVaultMHSMPrivateEndpointConnectionsClientDeleteOperationStatus {
    /// Operation complete time
    #[serde(
        default,
        rename = "endTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub end_time: Option<OffsetDateTime>,

    /// Errors that occurred if the operation ended with Canceled or Failed status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,

    /// The unique identifier for the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The progress made toward completing the operation
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,

    /// Operation start time
    #[serde(
        default,
        rename = "startTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start_time: Option<OffsetDateTime>,

    /// The operation status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResourceProvisioningState>,
}

/// Standard Azure Resource Manager operation status response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyVaultManagedHsmsClientCreateOrUpdateOperationStatus {
    /// Operation complete time
    #[serde(
        default,
        rename = "endTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub end_time: Option<OffsetDateTime>,

    /// Errors that occurred if the operation ended with Canceled or Failed status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,

    /// The unique identifier for the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The progress made toward completing the operation
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,

    /// Operation start time
    #[serde(
        default,
        rename = "startTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start_time: Option<OffsetDateTime>,

    /// The operation status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResourceProvisioningState>,
}

/// Standard Azure Resource Manager operation status response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyVaultManagedHsmsClientDeleteOperationStatus {
    /// Operation complete time
    #[serde(
        default,
        rename = "endTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub end_time: Option<OffsetDateTime>,

    /// Errors that occurred if the operation ended with Canceled or Failed status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,

    /// The unique identifier for the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The progress made toward completing the operation
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,

    /// Operation start time
    #[serde(
        default,
        rename = "startTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start_time: Option<OffsetDateTime>,

    /// The operation status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResourceProvisioningState>,
}

/// Standard Azure Resource Manager operation status response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyVaultManagedHsmsClientPurgeDeletedOperationStatus {
    /// Operation complete time
    #[serde(
        default,
        rename = "endTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub end_time: Option<OffsetDateTime>,

    /// Errors that occurred if the operation ended with Canceled or Failed status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,

    /// The unique identifier for the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The progress made toward completing the operation
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,

    /// Operation start time
    #[serde(
        default,
        rename = "startTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start_time: Option<OffsetDateTime>,

    /// The operation status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResourceProvisioningState>,
}

/// Standard Azure Resource Manager operation status response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyVaultManagedHsmsClientUpdateOperationStatus {
    /// Operation complete time
    #[serde(
        default,
        rename = "endTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub end_time: Option<OffsetDateTime>,

    /// Errors that occurred if the operation ended with Canceled or Failed status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,

    /// The unique identifier for the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The progress made toward completing the operation
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,

    /// Operation start time
    #[serde(
        default,
        rename = "startTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start_time: Option<OffsetDateTime>,

    /// The operation status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResourceProvisioningState>,
}

/// Standard Azure Resource Manager operation status response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyVaultPrivateEndpointConnectionsClientDeleteOperationStatus {
    /// Operation complete time
    #[serde(
        default,
        rename = "endTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub end_time: Option<OffsetDateTime>,

    /// Errors that occurred if the operation ended with Canceled or Failed status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,

    /// The unique identifier for the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The progress made toward completing the operation
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,

    /// Operation start time
    #[serde(
        default,
        rename = "startTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start_time: Option<OffsetDateTime>,

    /// The operation status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResourceProvisioningState>,
}

/// Standard Azure Resource Manager operation status response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyVaultVaultsClientCreateOrUpdateOperationStatus {
    /// Operation complete time
    #[serde(
        default,
        rename = "endTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub end_time: Option<OffsetDateTime>,

    /// Errors that occurred if the operation ended with Canceled or Failed status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,

    /// The unique identifier for the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The progress made toward completing the operation
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,

    /// Operation start time
    #[serde(
        default,
        rename = "startTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start_time: Option<OffsetDateTime>,

    /// The operation status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResourceProvisioningState>,
}

/// Standard Azure Resource Manager operation status response
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct KeyVaultVaultsClientPurgeDeletedOperationStatus {
    /// Operation complete time
    #[serde(
        default,
        rename = "endTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub end_time: Option<OffsetDateTime>,

    /// Errors that occurred if the operation ended with Canceled or Failed status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,

    /// The unique identifier for the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the operationStatus resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The progress made toward completing the operation
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,

    /// Operation start time
    #[serde(
        default,
        rename = "startTime",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub start_time: Option<OffsetDateTime>,

    /// The operation status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResourceProvisioningState>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct LifetimeAction {
    /// The action of key rotation policy lifetimeAction.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<Action>,

    /// The trigger of key rotation policy lifetimeAction.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Trigger>,
}

/// Log specification of operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct LogSpecification {
    /// Blob duration of specification.
    #[serde(rename = "blobDuration", skip_serializing_if = "Option::is_none")]
    pub blob_duration: Option<String>,

    /// Display name of log specification.
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,

    /// Name of log specification.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// A region that this managed HSM Pool has been extended to.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMGeoReplicatedRegion {
    /// A boolean value that indicates whether the region is the primary region or a secondary region.
    #[serde(rename = "isPrimary", skip_serializing_if = "Option::is_none")]
    pub is_primary: Option<bool>,

    /// Name of the geo replicated region.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Provisioning state of the geo replicated region.
    #[serde(rename = "provisioningState", skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<GeoReplicationRegionProvisioningState>,
}

/// A rule governing the accessibility of a managed HSM pool from a specific IP address or IP range.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMIPRule {
    /// An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or '124.56.78.0/24' (all addresses
    /// that start with 124.56.78).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// A set of rules governing the network accessibility of a managed hsm pool.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMNetworkRuleSet {
    /// Tells what traffic can bypass network rules. This can be 'AzureServices' or 'None'. If not specified the default is 'AzureServices'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bypass: Option<NetworkRuleBypassOptions>,

    /// The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property
    /// has been evaluated.
    #[serde(rename = "defaultAction", skip_serializing_if = "Option::is_none")]
    pub default_action: Option<NetworkRuleAction>,

    /// The list of IP address rules.
    #[serde(rename = "ipRules", skip_serializing_if = "Option::is_none")]
    pub ip_rules: Option<Vec<MHSMIPRule>>,

    /// The list of service tags.
    #[serde(rename = "serviceTags", skip_serializing_if = "Option::is_none")]
    pub service_tags: Option<Vec<MHSMServiceTagRule>>,

    /// The list of virtual network rules.
    #[serde(
        rename = "virtualNetworkRules",
        skip_serializing_if = "Option::is_none"
    )]
    pub virtual_network_rules: Option<Vec<MHSMVirtualNetworkRule>>,
}

/// Private endpoint object properties.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMPrivateEndpoint {
    /// Full identifier of the private endpoint resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// Private endpoint connection resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMPrivateEndpointConnection {
    /// Modified whenever there is a change in the state of private endpoint connection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<Etag>,

    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Managed service identity
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedServiceIdentity>,

    /// The geo-location where the resource lives
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// Name of the private endpoint connection associated with the managed hsm pool.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Resource properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<MHSMPrivateEndpointConnectionProperties>,

    /// SKU details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<ManagedHsmSku>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Resource tags.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// Private endpoint connection item.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct MHSMPrivateEndpointConnectionItem {
    /// Modified whenever there is a change in the state of private endpoint connection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<Etag>,

    /// Id of private endpoint connection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Private endpoint connection properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<MHSMPrivateEndpointConnectionProperties>,
}

/// Properties of the private endpoint connection resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMPrivateEndpointConnectionProperties {
    /// Properties of the private endpoint object.
    #[serde(rename = "privateEndpoint", skip_serializing_if = "Option::is_none")]
    pub private_endpoint: Option<MHSMPrivateEndpoint>,

    /// Approval state of the private link connection.
    #[serde(
        rename = "privateLinkServiceConnectionState",
        skip_serializing_if = "Option::is_none"
    )]
    pub private_link_service_connection_state: Option<MHSMPrivateLinkServiceConnectionState>,

    /// Provisioning state of the private endpoint connection.
    #[serde(rename = "provisioningState", skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<PrivateEndpointConnectionProvisioningState>,
}

/// List of private endpoint connections associated with a managed HSM Pools
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct MHSMPrivateEndpointConnectionsListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The MhsmPrivateEndpointConnection items on this page
    #[serde(default)]
    pub value: Vec<MHSMPrivateEndpointConnection>,
}

/// A private link resource
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct MHSMPrivateLinkResource {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Managed service identity (system assigned and/or user assigned identities)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedServiceIdentity>,

    /// The geo-location where the resource lives
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The name of the resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Resource properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<MHSMPrivateLinkResourceProperties>,

    /// SKU details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<ManagedHsmSku>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Resource tags.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// A list of private link resources
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct MHSMPrivateLinkResourceListResult {
    /// Array of private link resources
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<Vec<MHSMPrivateLinkResource>>,
}

/// Properties of a private link resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct MHSMPrivateLinkResourceProperties {
    /// Group identifier of private link resource.
    #[serde(rename = "groupId", skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    /// Required member names of private link resource.
    #[serde(rename = "requiredMembers", skip_serializing_if = "Option::is_none")]
    pub required_members: Option<Vec<String>>,

    /// Required DNS zone names of the the private link resource.
    #[serde(rename = "requiredZoneNames", skip_serializing_if = "Option::is_none")]
    pub required_zone_names: Option<Vec<String>>,
}

/// An object that represents the approval state of the private link connection.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMPrivateLinkServiceConnectionState {
    /// A message indicating if changes on the service provider require any updates on the consumer.
    #[serde(rename = "actionsRequired", skip_serializing_if = "Option::is_none")]
    pub actions_required: Option<ActionsRequired>,

    /// The reason for approval or rejection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Indicates whether the connection has been approved, rejected or removed by the key vault owner.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<PrivateEndpointServiceConnectionStatus>,
}

/// List of regions associated with a managed HSM Pools
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct MHSMRegionsListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The MhsmGeoReplicatedRegion items on this page
    #[serde(default)]
    pub value: Vec<MHSMGeoReplicatedRegion>,
}

/// A rule governing the accessibility of a managed hsm pool from a specific service tags.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMServiceTagRule {
    /// Name of the service tag.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// A rule governing the accessibility of a managed hsm pool from a specific virtual network.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct MHSMVirtualNetworkRule {
    /// Full resource id of a vnet subnet, such as '/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// The security domain properties of the managed hsm.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ManagedHSMSecurityDomainProperties {
    /// Activation Status
    #[serde(rename = "activationStatus", skip_serializing_if = "Option::is_none")]
    pub activation_status: Option<ActivationStatus>,

    /// Activation Status Message.
    #[serde(
        rename = "activationStatusMessage",
        skip_serializing_if = "Option::is_none"
    )]
    pub activation_status_message: Option<String>,
}

/// Resource information with extended details.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsm {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Managed service identity
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedServiceIdentity>,

    /// The geo-location where the resource lives
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The name of the managed HSM Pool.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Properties of the managed HSM
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagedHsmProperties>,

    /// SKU details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<ManagedHsmSku>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Resource tags.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmAction {
    /// The type of action.
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<KeyRotationPolicyActionType>,
}

/// The key resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ManagedHsmKey {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The name of the key to be created. The value you provide may be copied globally for the purpose of running the service.
    /// The value provided should not include personally identifiable or sensitive information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The properties of the key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagedHsmKeyProperties>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Resource tags
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// The object attributes managed by the Azure Key Vault service.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmKeyAttributes {
    /// Creation time in seconds since 1970-01-01T00:00:00Z.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<i64>,

    /// Determines whether or not the object is enabled.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    /// Expiry date in seconds since 1970-01-01T00:00:00Z.
    #[serde(rename = "exp", skip_serializing_if = "Option::is_none")]
    pub expires: Option<i64>,

    /// Indicates if the private key can be exported.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exportable: Option<bool>,

    /// Not before date in seconds since 1970-01-01T00:00:00Z.
    #[serde(rename = "nbf", skip_serializing_if = "Option::is_none")]
    pub not_before: Option<i64>,

    /// The deletion recovery level currently in effect for the object. If it contains 'Purgeable', then the object can be permanently
    /// deleted by a privileged user; otherwise, only the system can purge the object at the end of the retention interval.
    #[serde(rename = "recoveryLevel", skip_serializing_if = "Option::is_none")]
    pub recovery_level: Option<DeletionRecoveryLevel>,

    /// Last updated time in seconds since 1970-01-01T00:00:00Z.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<i64>,
}

/// The parameters used to create a key.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmKeyCreateParameters {
    /// The properties of the key to be created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagedHsmKeyProperties>,

    /// The tags that will be assigned to the key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The response of a ManagedHsmKey list operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ManagedHsmKeyListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The ManagedHsmKey items on this page
    #[serde(default)]
    pub value: Vec<ManagedHsmKey>,
}

/// The properties of the key.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmKeyProperties {
    /// The attributes of the key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<ManagedHsmKeyAttributes>,

    /// The elliptic curve name. For valid values, see JsonWebKeyCurveName. Default for EC and EC-HSM keys is P-256
    #[serde(rename = "curveName", skip_serializing_if = "Option::is_none")]
    pub curve_name: Option<JsonWebKeyCurveName>,

    #[serde(rename = "keyOps", skip_serializing_if = "Option::is_none")]
    pub key_ops: Option<Vec<JsonWebKeyOperation>>,

    /// The key size in bits. For example: 2048, 3072, or 4096 for RSA. Default for RSA and RSA-HSM keys is 2048. Exception made
    /// for bring your own key (BYOK), key exchange keys default to 4096.
    #[serde(rename = "keySize", skip_serializing_if = "Option::is_none")]
    pub key_size: Option<i32>,

    /// The URI to retrieve the current version of the key.
    #[serde(rename = "keyUri", skip_serializing_if = "Option::is_none")]
    pub key_uri: Option<String>,

    /// The URI to retrieve the specific version of the key.
    #[serde(rename = "keyUriWithVersion", skip_serializing_if = "Option::is_none")]
    pub key_uri_with_version: Option<String>,

    /// The type of the key. For valid values, see JsonWebKeyType.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kty: Option<JsonWebKeyType>,

    /// Key release policy in response. It will be used for both output and input. Omitted if empty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_policy: Option<ManagedHsmKeyReleasePolicy>,

    /// Key rotation policy in response. It will be used for both output and input. Omitted if empty
    #[serde(rename = "rotationPolicy", skip_serializing_if = "Option::is_none")]
    pub rotation_policy: Option<ManagedHsmRotationPolicy>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmKeyReleasePolicy {
    /// Content type and version of key release policy
    #[serde(rename = "contentType", skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// Blob encoding the policy rules under which the key can be released.
    #[serde(
        default,
        deserialize_with = "deserialize_url_safe",
        serialize_with = "serialize_url_safe",
        skip_serializing_if = "Option::is_none"
    )]
    pub data: Option<Vec<u8>>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmKeyRotationPolicyAttributes {
    /// Creation time in seconds since 1970-01-01T00:00:00Z.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<i64>,

    /// The expiration time for the new key version. It should be in ISO8601 format. Eg: 'P90D', 'P1Y'.
    #[serde(rename = "expiryTime", skip_serializing_if = "Option::is_none")]
    pub expiry_time: Option<String>,

    /// Last updated time in seconds since 1970-01-01T00:00:00Z.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<i64>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmLifetimeAction {
    /// The action of key rotation policy lifetimeAction.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<ManagedHsmAction>,

    /// The trigger of key rotation policy lifetimeAction.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<ManagedHsmTrigger>,
}

/// The response of a ManagedHsm list operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ManagedHsmListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The ManagedHsm items on this page
    #[serde(default)]
    pub value: Vec<ManagedHsm>,
}

/// Properties of the managed HSM Pool
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmProperties {
    /// The create mode to indicate whether the resource is being created or is being recovered from a deleted resource.
    #[serde(rename = "createMode", skip_serializing_if = "Option::is_none")]
    pub create_mode: Option<CreateMode>,

    /// Property specifying whether protection against purge is enabled for this managed HSM pool. Setting this property to true
    /// activates protection against purge for this managed HSM pool and its content - only the Managed HSM service may initiate
    /// a hard, irrecoverable deletion. Enabling this functionality is irreversible.
    #[serde(
        rename = "enablePurgeProtection",
        skip_serializing_if = "Option::is_none"
    )]
    pub enable_purge_protection: Option<bool>,

    /// Property to specify whether the 'soft delete' functionality is enabled for this managed HSM pool. Soft delete is enabled
    /// by default for all managed HSMs and is immutable.
    #[serde(rename = "enableSoftDelete", skip_serializing_if = "Option::is_none")]
    pub enable_soft_delete: Option<bool>,

    /// The URI of the managed hsm pool for performing operations on keys.
    #[serde(rename = "hsmUri", skip_serializing_if = "Option::is_none")]
    pub hsm_uri: Option<String>,

    /// Array of initial administrators object ids for this managed hsm pool.
    #[serde(
        rename = "initialAdminObjectIds",
        skip_serializing_if = "Option::is_none"
    )]
    pub initial_admin_object_ids: Option<Vec<String>>,

    /// Rules governing the accessibility of the key vault from specific network locations.
    #[serde(rename = "networkAcls", skip_serializing_if = "Option::is_none")]
    pub network_acls: Option<MHSMNetworkRuleSet>,

    /// List of private endpoint connections associated with the managed hsm pool.
    #[serde(
        rename = "privateEndpointConnections",
        skip_serializing_if = "Option::is_none"
    )]
    pub private_endpoint_connections: Option<Vec<MHSMPrivateEndpointConnectionItem>>,

    /// Provisioning state.
    #[serde(rename = "provisioningState", skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<ProvisioningState>,

    /// Control permission to the managed HSM from public networks.
    #[serde(
        rename = "publicNetworkAccess",
        skip_serializing_if = "Option::is_none"
    )]
    pub public_network_access: Option<PublicNetworkAccess>,

    /// List of all regions associated with the managed hsm pool.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub regions: Option<Vec<MHSMGeoReplicatedRegion>>,

    /// The scheduled purge date in UTC.
    #[serde(
        default,
        rename = "scheduledPurgeDate",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub scheduled_purge_date: Option<OffsetDateTime>,

    /// Managed HSM security domain properties.
    #[serde(
        rename = "securityDomainProperties",
        skip_serializing_if = "Option::is_none"
    )]
    pub security_domain_properties: Option<ManagedHSMSecurityDomainProperties>,

    /// Soft deleted data retention days. When you delete an HSM or a key, it will remain recoverable for the configured retention
    /// period or for a default period of 90 days. It accepts values between 7 and 90.
    #[serde(
        rename = "softDeleteRetentionInDays",
        skip_serializing_if = "Option::is_none"
    )]
    pub soft_delete_retention_in_days: Option<i32>,

    /// Resource Status Message.
    #[serde(rename = "statusMessage", skip_serializing_if = "Option::is_none")]
    pub status_message: Option<String>,

    /// The Azure Active Directory tenant ID that should be used for authenticating requests to the managed HSM pool.
    #[serde(rename = "tenantId", skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmRotationPolicy {
    /// The attributes of key rotation policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<ManagedHsmKeyRotationPolicyAttributes>,

    /// The lifetimeActions for key rotation action.
    #[serde(rename = "lifetimeActions", skip_serializing_if = "Option::is_none")]
    pub lifetime_actions: Option<Vec<ManagedHsmLifetimeAction>>,
}

/// SKU details
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmSku {
    /// SKU Family of the managed HSM Pool
    #[serde(skip_serializing_if = "Option::is_none")]
    pub family: Option<ManagedHsmSkuFamily>,

    /// SKU of the managed HSM Pool
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<ManagedHsmSkuName>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedHsmTrigger {
    /// The time duration after key creation to rotate the key. It only applies to rotate. It will be in ISO 8601 duration format.
    /// Eg: 'P90D', 'P1Y'.
    #[serde(rename = "timeAfterCreate", skip_serializing_if = "Option::is_none")]
    pub time_after_create: Option<String>,

    /// The time duration before key expiring to rotate or notify. It will be in ISO 8601 duration format. Eg: 'P90D', 'P1Y'.
    #[serde(rename = "timeBeforeExpiry", skip_serializing_if = "Option::is_none")]
    pub time_before_expiry: Option<String>,
}

/// Managed service identity (system assigned and/or user assigned identities)
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ManagedServiceIdentity {
    /// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
    #[serde(rename = "principalId", skip_serializing_if = "Option::is_none")]
    pub principal_id: Option<String>,

    /// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
    #[serde(rename = "tenantId", skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,

    /// The type of managed identity assigned to this resource.
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<ManagedServiceIdentityType>,

    /// The identities assigned to this resource by the user.
    #[serde(
        rename = "userAssignedIdentities",
        skip_serializing_if = "Option::is_none"
    )]
    pub user_assigned_identities: Option<HashMap<String, UserAssignedIdentity>>,
}

/// Metric specification of operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct MetricSpecification {
    /// The metric aggregation type. Possible values include: 'Average', 'Count', 'Total'.
    #[serde(rename = "aggregationType", skip_serializing_if = "Option::is_none")]
    pub aggregation_type: Option<String>,

    /// The dimensions of metric
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dimensions: Option<Vec<DimensionProperties>>,

    /// Display description of metric specification.
    #[serde(rename = "displayDescription", skip_serializing_if = "Option::is_none")]
    pub display_description: Option<String>,

    /// Display name of metric specification.
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,

    /// Property to specify whether to fill gap with zero.
    #[serde(rename = "fillGapWithZero", skip_serializing_if = "Option::is_none")]
    pub fill_gap_with_zero: Option<bool>,

    /// The internal metric name.
    #[serde(rename = "internalMetricName", skip_serializing_if = "Option::is_none")]
    pub internal_metric_name: Option<String>,

    /// The metric lock aggregation type.
    #[serde(
        rename = "lockAggregationType",
        skip_serializing_if = "Option::is_none"
    )]
    pub lock_aggregation_type: Option<String>,

    /// Name of metric specification.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The supported aggregation types for the metrics.
    #[serde(
        rename = "supportedAggregationTypes",
        skip_serializing_if = "Option::is_none"
    )]
    pub supported_aggregation_types: Option<Vec<String>>,

    /// The supported time grain types for the metrics.
    #[serde(
        rename = "supportedTimeGrainTypes",
        skip_serializing_if = "Option::is_none"
    )]
    pub supported_time_grain_types: Option<Vec<String>>,

    /// The metric unit. Possible values include: 'Bytes', 'Count', 'Milliseconds'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
}

/// A set of rules governing the network accessibility of a vault.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct NetworkRuleSet {
    /// Tells what traffic can bypass network rules. This can be 'AzureServices' or 'None'. If not specified the default is 'AzureServices'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bypass: Option<NetworkRuleBypassOptions>,

    /// The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property
    /// has been evaluated.
    #[serde(rename = "defaultAction", skip_serializing_if = "Option::is_none")]
    pub default_action: Option<NetworkRuleAction>,

    /// The list of IP address rules.
    #[serde(rename = "ipRules", skip_serializing_if = "Option::is_none")]
    pub ip_rules: Option<Vec<IPRule>>,

    /// The list of virtual network rules.
    #[serde(
        rename = "virtualNetworkRules",
        skip_serializing_if = "Option::is_none"
    )]
    pub virtual_network_rules: Option<Vec<VirtualNetworkRule>>,
}

/// Key Vault REST API operation definition.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct Operation {
    /// Display metadata associated with the operation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display: Option<OperationDisplay>,

    /// Property to specify whether the action is a data action.
    #[serde(rename = "isDataAction", skip_serializing_if = "Option::is_none")]
    pub is_data_action: Option<bool>,

    /// Operation name: {provider}/{resource}/{operation}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Properties of operation, include metric specifications.
    #[serde(rename = "properties", skip_serializing_if = "Option::is_none")]
    pub operation_properties: Option<OperationProperties>,

    /// The origin of operations.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
}

/// Display metadata associated with the operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct OperationDisplay {
    /// Description of operation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Type of operation: get, read, delete, etc.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,

    /// Service provider: Microsoft Key Vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,

    /// Resource on which the operation is performed etc.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
}

/// Result of the request to list Storage operations. It contains a list of operations and a URL link to get the next set
/// of results.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct OperationListResult {
    /// The URL to get the next set of operations.
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// List of Storage operations supported by the Storage resource provider.
    #[serde(default)]
    pub value: Vec<Operation>,
}

/// Properties of operation, include metric specifications.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct OperationProperties {
    /// One property of operation, include metric specifications.
    #[serde(
        rename = "serviceSpecification",
        skip_serializing_if = "Option::is_none"
    )]
    pub service_specification: Option<ServiceSpecification>,
}

/// Permissions the identity has for keys, secrets, certificates and storage.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct Permissions {
    /// Permissions to certificates
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificates: Option<Vec<CertificatePermissions>>,

    /// Permissions to keys
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keys: Option<Vec<KeyPermissions>>,

    /// Permissions to secrets
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<SecretPermissions>>,

    /// Permissions to storage accounts
    #[serde(skip_serializing_if = "Option::is_none")]
    pub storage: Option<Vec<StoragePermissions>>,
}

/// Private endpoint object properties.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct PrivateEndpoint {
    /// Full identifier of the private endpoint resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// Private endpoint connection resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct PrivateEndpointConnection {
    /// Modified whenever there is a change in the state of private endpoint connection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<Etag>,

    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Azure location of the key vault resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// Name of the private endpoint connection associated with the key vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Resource properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateEndpointConnectionProperties>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Tags assigned to the key vault resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// Private endpoint connection item.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct PrivateEndpointConnectionItem {
    /// Modified whenever there is a change in the state of private endpoint connection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<Etag>,

    /// Id of private endpoint connection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Private endpoint connection properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateEndpointConnectionProperties>,
}

/// The response of a PrivateEndpointConnection list operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct PrivateEndpointConnectionListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The PrivateEndpointConnection items on this page
    #[serde(default)]
    pub value: Vec<PrivateEndpointConnection>,
}

/// Properties of the private endpoint connection resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct PrivateEndpointConnectionProperties {
    /// Properties of the private endpoint object.
    #[serde(rename = "privateEndpoint", skip_serializing_if = "Option::is_none")]
    pub private_endpoint: Option<PrivateEndpoint>,

    /// Approval state of the private link connection.
    #[serde(
        rename = "privateLinkServiceConnectionState",
        skip_serializing_if = "Option::is_none"
    )]
    pub private_link_service_connection_state: Option<PrivateLinkServiceConnectionState>,

    /// Provisioning state of the private endpoint connection.
    #[serde(rename = "provisioningState", skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<PrivateEndpointConnectionProvisioningState>,
}

/// A private link resource
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct PrivateLinkResource {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Azure location of the key vault resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The name of the resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Resource properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateLinkResourceProperties>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Tags assigned to the key vault resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// A list of private link resources
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct PrivateLinkResourceListResult {
    /// Array of private link resources
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<Vec<PrivateLinkResource>>,
}

/// Properties of a private link resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct PrivateLinkResourceProperties {
    /// Group identifier of private link resource.
    #[serde(rename = "groupId", skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    /// Required member names of private link resource.
    #[serde(rename = "requiredMembers", skip_serializing_if = "Option::is_none")]
    pub required_members: Option<Vec<String>>,

    /// Required DNS zone names of the the private link resource.
    #[serde(rename = "requiredZoneNames", skip_serializing_if = "Option::is_none")]
    pub required_zone_names: Option<Vec<String>>,
}

/// An object that represents the approval state of the private link connection.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct PrivateLinkServiceConnectionState {
    /// A message indicating if changes on the service provider require any updates on the consumer.
    #[serde(rename = "actionsRequired", skip_serializing_if = "Option::is_none")]
    pub actions_required: Option<ActionsRequired>,

    /// The reason for approval or rejection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Indicates whether the connection has been approved, rejected or removed by the key vault owner.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<PrivateEndpointServiceConnectionStatus>,
}

/// The list of vault resources.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ResourceListResult {
    /// The URL to get the next set of vault resources.
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The list of vault resources.
    #[serde(default)]
    pub value: Vec<TrackedResource>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct RotationPolicy {
    /// The attributes of key rotation policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<KeyRotationPolicyAttributes>,

    /// The lifetimeActions for key rotation action.
    #[serde(rename = "lifetimeActions", skip_serializing_if = "Option::is_none")]
    pub lifetime_actions: Option<Vec<LifetimeAction>>,
}

/// Resource information with extended details.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct Secret {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Azure location of the key vault resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The name of the secret.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Properties of the secret
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SecretProperties>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Tags assigned to the key vault resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// The secret management attributes.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SecretAttributes {
    /// Creation time in seconds since 1970-01-01T00:00:00Z.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub created: Option<OffsetDateTime>,

    /// Determines whether the object is enabled.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    /// Expiry date in seconds since 1970-01-01T00:00:00Z.
    #[serde(
        default,
        rename = "exp",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub expires: Option<OffsetDateTime>,

    /// Not before date in seconds since 1970-01-01T00:00:00Z.
    #[serde(
        default,
        rename = "nbf",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub not_before: Option<OffsetDateTime>,

    /// Last updated time in seconds since 1970-01-01T00:00:00Z.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::unix_time::option"
    )]
    pub updated: Option<OffsetDateTime>,
}

/// Parameters for creating or updating a secret
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SecretCreateOrUpdateParameters {
    /// Properties of the secret
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SecretProperties>,

    /// The tags that will be assigned to the secret.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The response of a Secret list operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct SecretListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The Secret items on this page
    #[serde(default)]
    pub value: Vec<Secret>,
}

/// Parameters for patching a secret
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SecretPatchParameters {
    /// Properties of the secret
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SecretPatchProperties>,

    /// The tags that will be assigned to the secret.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// Properties of the secret
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SecretPatchProperties {
    /// The attributes of the secret.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<SecretAttributes>,

    /// The content type of the secret.
    #[serde(rename = "contentType", skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// The value of the secret.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Properties of the secret
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SecretProperties {
    /// The attributes of the secret.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<SecretAttributes>,

    /// The content type of the secret.
    #[serde(rename = "contentType", skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// The URI to retrieve the current version of the secret.
    #[serde(rename = "secretUri", skip_serializing_if = "Option::is_none")]
    pub secret_uri: Option<String>,

    /// The URI to retrieve the specific version of the secret.
    #[serde(
        rename = "secretUriWithVersion",
        skip_serializing_if = "Option::is_none"
    )]
    pub secret_uri_with_version: Option<String>,

    /// The value of the secret. NOTE: 'value' will never be returned from the service, as APIs using this model are is intended
    /// for internal use in ARM deployments. Users should use the data-plane REST service for interaction with vault secrets.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// One property of operation, include log specifications.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct ServiceSpecification {
    /// Log specifications of operation.
    #[serde(rename = "logSpecifications", skip_serializing_if = "Option::is_none")]
    pub log_specifications: Option<Vec<LogSpecification>>,

    /// Metric specifications of operation.
    #[serde(
        rename = "metricSpecifications",
        skip_serializing_if = "Option::is_none"
    )]
    pub metric_specifications: Option<Vec<MetricSpecification>>,
}

/// SKU details
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct Sku {
    /// SKU family name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub family: Option<SkuFamily>,

    /// SKU name to specify whether the key vault is a standard vault or a premium vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<SkuName>,
}

/// Metadata pertaining to creation and last modification of the resource.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct SystemData {
    /// The timestamp of resource creation (UTC).
    #[serde(
        default,
        rename = "createdAt",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub created_at: Option<OffsetDateTime>,

    /// The identity that created the resource.
    #[serde(rename = "createdBy", skip_serializing_if = "Option::is_none")]
    pub created_by: Option<String>,

    /// The type of identity that created the resource.
    #[serde(rename = "createdByType", skip_serializing_if = "Option::is_none")]
    pub created_by_type: Option<CreatedByType>,

    /// The timestamp of resource last modification (UTC)
    #[serde(
        default,
        rename = "lastModifiedAt",
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc3339::option"
    )]
    pub last_modified_at: Option<OffsetDateTime>,

    /// The identity that last modified the resource.
    #[serde(rename = "lastModifiedBy", skip_serializing_if = "Option::is_none")]
    pub last_modified_by: Option<String>,

    /// The type of identity that last modified the resource.
    #[serde(rename = "lastModifiedByType", skip_serializing_if = "Option::is_none")]
    pub last_modified_by_type: Option<CreatedByType>,
}

/// Tracked Resource
///
/// The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct TrackedResource {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The geo-location where the resource lives
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The name of the resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Resource tags.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct Trigger {
    /// The time duration after key creation to rotate the key. It only applies to rotate. It will be in ISO 8601 duration format.
    /// Eg: 'P90D', 'P1Y'.
    #[serde(rename = "timeAfterCreate", skip_serializing_if = "Option::is_none")]
    pub time_after_create: Option<String>,

    /// The time duration before key expiring to rotate or notify. It will be in ISO 8601 duration format. Eg: 'P90D', 'P1Y'.
    #[serde(rename = "timeBeforeExpiry", skip_serializing_if = "Option::is_none")]
    pub time_before_expiry: Option<String>,
}

/// User assigned identity properties
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct UserAssignedIdentity {
    /// The client ID of the assigned identity.
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,

    /// The principal ID of the assigned identity.
    #[serde(rename = "principalId", skip_serializing_if = "Option::is_none")]
    pub principal_id: Option<String>,
}

/// Resource information with extended details.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct Vault {
    /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Azure location of the key vault resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The name of the vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Properties of the vault
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VaultProperties>,

    /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
    #[serde(rename = "systemData", skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,

    /// Tags assigned to the key vault resource.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,

    /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// Parameters for updating the access policy in a vault
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VaultAccessPolicyParameters {
    /// The resource id of the access policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The resource type of the access policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// The resource name of the access policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Properties of the access policy
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VaultAccessPolicyProperties>,

    /// The resource name of the access policy.
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// Properties of the vault access policy
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VaultAccessPolicyProperties {
    /// An array of 0 to 16 identities that have access to the key vault. All identities in the array must use the same tenant
    /// ID as the key vault's tenant ID.
    #[serde(rename = "accessPolicies", skip_serializing_if = "Option::is_none")]
    pub access_policies: Option<Vec<AccessPolicyEntry>>,
}

/// The parameters used to check the availability of the vault name.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VaultCheckNameAvailabilityParameters {
    /// The vault name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The type of resource, Microsoft.KeyVault/vaults
    ///
    /// Field has constant value Microsoft.KeyVault/vaults. Any specified value will be ignored.
    #[serde(
        rename = "type",
        serialize_with = "models_serde::serialize_string_literal_Microsoft_KeyVault_vaults"
    )]
    pub type_prop: Option<String>,
}

/// Parameters for creating or updating a vault
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VaultCreateOrUpdateParameters {
    /// The supported Azure location where the key vault should be created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,

    /// Properties of the vault
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VaultProperties>,

    /// The tags that will be assigned to the key vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// The response of a Vault list operation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct VaultListResult {
    /// The link to the next page of items
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,

    /// The Vault items on this page
    #[serde(default)]
    pub value: Vec<Vault>,
}

/// Parameters for creating or updating a vault
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VaultPatchParameters {
    /// Properties of the vault
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VaultPatchProperties>,

    /// The tags that will be assigned to the key vault.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<HashMap<String, String>>,
}

/// Properties of the vault
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VaultPatchProperties {
    /// An array of 0 to 16 identities that have access to the key vault. All identities in the array must use the same tenant
    /// ID as the key vault's tenant ID.
    #[serde(rename = "accessPolicies", skip_serializing_if = "Option::is_none")]
    pub access_policies: Option<Vec<AccessPolicyEntry>>,

    /// The vault's create mode to indicate whether the vault need to be recovered or not.
    #[serde(rename = "createMode", skip_serializing_if = "Option::is_none")]
    pub create_mode: Option<CreateMode>,

    /// Property specifying whether protection against purge is enabled for this vault. Setting this property to true activates
    /// protection against purge for this vault and its content - only the Key Vault service may initiate a hard, irrecoverable
    /// deletion. The setting is effective only if soft delete is also enabled. Enabling this functionality is irreversible -
    /// that is, the property does not accept false as its value.
    #[serde(
        rename = "enablePurgeProtection",
        skip_serializing_if = "Option::is_none"
    )]
    pub enable_purge_protection: Option<bool>,

    /// Property that controls how data actions are authorized. When true, the key vault will use Role Based Access Control (RBAC)
    /// for authorization of data actions, and the access policies specified in vault properties will be ignored. When false,
    /// the key vault will use the access policies specified in vault properties, and any policy stored on Azure Resource Manager
    /// will be ignored. If null or not specified, the value of this property will not change.
    #[serde(
        rename = "enableRbacAuthorization",
        skip_serializing_if = "Option::is_none"
    )]
    pub enable_rbac_authorization: Option<bool>,

    /// Property to specify whether the 'soft delete' functionality is enabled for this key vault. Once set to true, it cannot
    /// be reverted to false.
    #[serde(rename = "enableSoftDelete", skip_serializing_if = "Option::is_none")]
    pub enable_soft_delete: Option<bool>,

    /// Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key
    /// vault.
    #[serde(
        rename = "enabledForDeployment",
        skip_serializing_if = "Option::is_none"
    )]
    pub enabled_for_deployment: Option<bool>,

    /// Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys.
    #[serde(
        rename = "enabledForDiskEncryption",
        skip_serializing_if = "Option::is_none"
    )]
    pub enabled_for_disk_encryption: Option<bool>,

    /// Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault.
    #[serde(
        rename = "enabledForTemplateDeployment",
        skip_serializing_if = "Option::is_none"
    )]
    pub enabled_for_template_deployment: Option<bool>,

    /// A collection of rules governing the accessibility of the vault from specific network locations.
    #[serde(rename = "networkAcls", skip_serializing_if = "Option::is_none")]
    pub network_acls: Option<NetworkRuleSet>,

    /// Property to specify whether the vault will accept traffic from public internet. If set to 'disabled' all traffic except
    /// private endpoint traffic and that that originates from trusted services will be blocked. This will override the set firewall
    /// rules, meaning that even if the firewall rules are present we will not honor the rules.
    #[serde(
        rename = "publicNetworkAccess",
        skip_serializing_if = "Option::is_none"
    )]
    pub public_network_access: Option<String>,

    /// SKU details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<Sku>,

    /// softDelete data retention days. It accepts >=7 and <=90.
    #[serde(
        rename = "softDeleteRetentionInDays",
        skip_serializing_if = "Option::is_none"
    )]
    pub soft_delete_retention_in_days: Option<i32>,

    /// The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
    #[serde(rename = "tenantId", skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
}

/// Properties of the vault
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VaultProperties {
    /// An array of 0 to 1024 identities that have access to the key vault. All identities in the array must use the same tenant
    /// ID as the key vault's tenant ID. When `createMode` is set to `recover`, access policies are not required. Otherwise, access
    /// policies are required.
    #[serde(rename = "accessPolicies", skip_serializing_if = "Option::is_none")]
    pub access_policies: Option<Vec<AccessPolicyEntry>>,

    /// The vault's create mode to indicate whether the vault need to be recovered or not.
    #[serde(rename = "createMode", skip_serializing_if = "Option::is_none")]
    pub create_mode: Option<CreateMode>,

    /// Property specifying whether protection against purge is enabled for this vault. Setting this property to true activates
    /// protection against purge for this vault and its content - only the Key Vault service may initiate a hard, irrecoverable
    /// deletion. The setting is effective only if soft delete is also enabled. Enabling this functionality is irreversible -
    /// that is, the property does not accept false as its value.
    #[serde(
        rename = "enablePurgeProtection",
        skip_serializing_if = "Option::is_none"
    )]
    pub enable_purge_protection: Option<bool>,

    /// Property that controls how data actions are authorized. When true, the key vault will use Role Based Access Control (RBAC)
    /// for authorization of data actions, and the access policies specified in vault properties will be ignored. When false,
    /// the key vault will use the access policies specified in vault properties, and any policy stored on Azure Resource Manager
    /// will be ignored. If null or not specified, the vault is created with the default value of false. Note that management
    /// actions are always authorized with RBAC.
    #[serde(
        rename = "enableRbacAuthorization",
        skip_serializing_if = "Option::is_none"
    )]
    pub enable_rbac_authorization: Option<bool>,

    /// Property to specify whether the 'soft delete' functionality is enabled for this key vault. If it's not set to any value(true
    /// or false) when creating new key vault, it will be set to true by default. Once set to true, it cannot be reverted to false.
    #[serde(rename = "enableSoftDelete", skip_serializing_if = "Option::is_none")]
    pub enable_soft_delete: Option<bool>,

    /// Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key
    /// vault.
    #[serde(
        rename = "enabledForDeployment",
        skip_serializing_if = "Option::is_none"
    )]
    pub enabled_for_deployment: Option<bool>,

    /// Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys.
    #[serde(
        rename = "enabledForDiskEncryption",
        skip_serializing_if = "Option::is_none"
    )]
    pub enabled_for_disk_encryption: Option<bool>,

    /// Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault.
    #[serde(
        rename = "enabledForTemplateDeployment",
        skip_serializing_if = "Option::is_none"
    )]
    pub enabled_for_template_deployment: Option<bool>,

    /// The resource id of HSM Pool.
    #[serde(rename = "hsmPoolResourceId", skip_serializing_if = "Option::is_none")]
    pub hsm_pool_resource_id: Option<String>,

    /// Rules governing the accessibility of the key vault from specific network locations.
    #[serde(rename = "networkAcls", skip_serializing_if = "Option::is_none")]
    pub network_acls: Option<NetworkRuleSet>,

    /// List of private endpoint connections associated with the key vault.
    #[serde(
        rename = "privateEndpointConnections",
        skip_serializing_if = "Option::is_none"
    )]
    pub private_endpoint_connections: Option<Vec<PrivateEndpointConnectionItem>>,

    /// Provisioning state of the vault.
    #[serde(rename = "provisioningState", skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<VaultProvisioningState>,

    /// Property to specify whether the vault will accept traffic from public internet. If set to 'disabled' all traffic except
    /// private endpoint traffic and that that originates from trusted services will be blocked. This will override the set firewall
    /// rules, meaning that even if the firewall rules are present we will not honor the rules.
    #[serde(
        rename = "publicNetworkAccess",
        skip_serializing_if = "Option::is_none"
    )]
    pub public_network_access: Option<String>,

    /// SKU details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<Sku>,

    /// softDelete data retention days. It accepts >=7 and <=90.
    #[serde(
        rename = "softDeleteRetentionInDays",
        skip_serializing_if = "Option::is_none"
    )]
    pub soft_delete_retention_in_days: Option<i32>,

    /// The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
    #[serde(rename = "tenantId", skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,

    /// The URI of the vault for performing operations on keys and secrets.
    #[serde(rename = "vaultUri", skip_serializing_if = "Option::is_none")]
    pub vault_uri: Option<String>,
}

/// A rule governing the accessibility of a vault from a specific virtual network.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct VirtualNetworkRule {
    /// Full resource id of a vnet subnet, such as '/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Property to specify whether NRP will ignore the check if parent subnet has serviceEndpoints configured.
    #[serde(
        rename = "ignoreMissingVnetServiceEndpoint",
        skip_serializing_if = "Option::is_none"
    )]
    pub ignore_missing_vnet_service_endpoint: Option<bool>,
}
