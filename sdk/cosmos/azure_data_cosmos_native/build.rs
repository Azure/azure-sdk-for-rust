// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// cSpell:ignore SOURCEVERSION, SOURCEBRANCH, BUILDID, BUILDNUMBER, COSMOSCLIENT, cosmosclient, libcosmosclient, cbindgen

use std::collections::HashMap;
use std::io::Write;

fn main() {
    let build_id = format!(
        "$Id: {}, Version: {}, Commit: {}, Branch: {}, Build ID: {}, Build Number: {}, Timestamp: {}$",
        "azurecosmos",
        env!("CARGO_PKG_VERSION"),
        option_env!("BUILD_SOURCEVERSION").unwrap_or("unknown"),
        option_env!("BUILD_SOURCEBRANCH").unwrap_or("unknown"),
        option_env!("BUILD_BUILDID").unwrap_or("unknown"),
        option_env!("BUILD_BUILDNUMBER").unwrap_or("unknown"),
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs(),
    );
    println!("cargo:rustc-env=BUILD_IDENTIFIER={}", build_id);

    let header: String = r"// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// This file is auto-generated by cbindgen. Do not edit manually.
// cSpell: disable"
        .to_string();

    let config = cbindgen::Config {
        language: cbindgen::Language::C,
        header: Some(header),
        after_includes: Some(
            "\n// Specifies the version of cosmosclient this header file was generated from.\n// This should match the version of libcosmosclient you are referencing.\n#define COSMOSCLIENT_H_VERSION \"".to_string()
                + env!("CARGO_PKG_VERSION")
                + "\"",
        ),
        cpp_compat: true,
        parse: cbindgen::ParseConfig {
            parse_deps: true,
            include: Some(vec!["azure_data_cosmos".into()]),
            ..Default::default()
        },
        style: cbindgen::Style::Both,
        enumeration: cbindgen::EnumConfig {
            rename_variants: cbindgen::RenameRule::QualifiedScreamingSnakeCase,
            ..Default::default()
        },
        documentation_length: cbindgen::DocumentationLength::Full,
        documentation_style: cbindgen::DocumentationStyle::Doxy,
        export: cbindgen::ExportConfig {
            prefix: Some("cosmos_".into()),
            exclude: vec!["PartitionKeyValue".into()],

            // From what I can tell, there's no way to set a rename rule for types :(
            rename: HashMap::from([
                ("RuntimeContext".into(), "runtime_context".into()),
                ("CallContext".into(), "call_context".into()),
                ("CosmosError".into(), "error".into()),
                ("CosmosErrorCode".into(), "error_code".into()),
                ("CosmosClient".into(), "client".into()),
                ("DatabaseClient".into(), "database_client".into()),
                ("ContainerClient".into(), "container_client".into()),
                ("ClientOptions".into(), "client_options".into()),
                ("QueryOptions".into(), "query_options".into()),
                ("CreateDatabaseOptions".into(), "create_database_options".into()),
                ("ReadDatabaseOptions".into(), "read_database_options".into()),
                ("DeleteDatabaseOptions".into(), "delete_database_options".into()),
                ("CreateContainerOptions".into(), "create_container_options".into()),
                ("ReadContainerOptions".into(), "read_container_options".into()),
                ("DeleteContainerOptions".into(), "delete_container_options".into()),
                ("ItemOptions".into(), "item_options".into()),
                ("RuntimeOptions".into(), "runtime_options".into()),
                ("CallContextOptions".into(), "call_context_options".into()),
            ]),
            ..Default::default()
        },
        ..Default::default()
    };

    let crate_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let Ok(bindings) = cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_config(config)
        .generate()
    else {
        println!("cargo:error=Failed to generate C bindings for azure_data_cosmos_native");
        return;
    };

    // Don't generate bindings if the target is wasm, as we don't produce C bindings for wasm targets.
    if std::env::var("CARGO_CFG_TARGET_FAMILY").unwrap_or_default() == "wasm" {
        return;
    }
    // Write bindings to a buffer, then collapse runs of 2+ blank lines into one.
    // cbindgen can emit extra blank lines when it skips types that aren't repr(C).
    let mut buf = Vec::new();
    bindings.write(&mut buf);
    let output = String::from_utf8(buf).expect("cbindgen output should be valid UTF-8");

    let mut collapsed = String::with_capacity(output.len());
    let mut consecutive_blank = 0u32;
    for line in output.split('\n') {
        if line.trim().is_empty() {
            consecutive_blank += 1;
            if consecutive_blank <= 1 {
                collapsed.push('\n');
            }
        } else {
            consecutive_blank = 0;
            collapsed.push_str(line);
            collapsed.push('\n');
        }
    }
    // Remove any trailing blank lines so the file ends cleanly.
    let collapsed = collapsed.trim_end_matches('\n');
    // Ensure the file ends with exactly one newline.
    let collapsed = format!("{collapsed}\n");

    let mut file =
        std::fs::File::create("include/azurecosmos.h").expect("failed to create azurecosmos.h");
    file.write_all(collapsed.as_bytes())
        .expect("failed to write azurecosmos.h");
}
