{
  "items": [
    {
      "type": "Mod",
      "attrs": [
        "# [doc = \" Endpoints for Azure Resource Manager in different Azure clouds\"]"
      ],
      "vis": "pub",
      "ident": "resource_manager_endpoint",
      "content": [
        "static_url ! (# [doc = \" Azure Resource Manager China cloud endpoint\"] AZURE_CHINA_CLOUD , \"https://management.chinacloudapi.cn\") ;",
        "static_url ! (# [doc = \" Azure Resource Manager Germany cloud endpoint\"] AZURE_GERMANY_CLOUD , \"https://management.microsoftazure.de\") ;",
        "static_url ! (# [doc = \" Azure Resource Manager public cloud endpoint\"] AZURE_PUBLIC_CLOUD , \"https://management.azure.com\") ;",
        "static_url ! (# [doc = \" Azure Resource Manager US government cloud endpoint\"] AZURE_US_GOVERNMENT_CLOUD , \"https://management.usgovcloudapi.net\") ;"
      ]
    },
    {
      "type": "Mod",
      "attrs": [
        "# [doc = \" A list of known Azure authority hosts\"]"
      ],
      "vis": "pub",
      "ident": "authority_hosts",
      "content": [
        "static_url ! (# [doc = \" China-based Azure Authority Host\"] AZURE_CHINA_CLOUD , \"https://login.chinacloudapi.cn\") ;",
        "static_url ! (# [doc = \" Germany-based Azure Authority Host\"] AZURE_GERMANY_CLOUD , \"https://login.microsoftonline.de\") ;",
        "static_url ! (# [doc = \" US Government Azure Authority Host\"] AZURE_US_GOVERNMENT_CLOUD , \"https://login.microsoftonline.us\") ;",
        "static_url ! (# [doc = \" Public Cloud Azure Authority Host\"] AZURE_PUBLIC_CLOUD , \"https://login.microsoftonline.com\") ;"
      ]
    },
    {
      "type": "Mod",
      "attrs": [
        "# [doc = \" Constants related to the Content-Type header\"]",
        "# [doc = \"\"]",
        "# [doc = \" <https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type>\"]"
      ],
      "vis": "pub",
      "ident": "content_type",
      "content": [
        "use crate :: headers :: HeaderValue ;",
        "pub const MULTIPART_FORM_DATA : HeaderValue = HeaderValue :: from_static (\"multipart/form-data\") ;",
        "pub const APPLICATION_X_WWW_FORM_URLENCODED : HeaderValue = HeaderValue :: from_static (\"application/x-www-form-urlencoded\") ;",
        "pub const APPLICATION_XML : HeaderValue = HeaderValue :: from_static (\"application/xml\") ;",
        "pub const APPLICATION_JSON : HeaderValue = HeaderValue :: from_static (\"application/json\") ;",
        "pub const APPLICATION_OCTET_STREAM : HeaderValue = HeaderValue :: from_static (\"application/octet-stream\") ;",
        "pub const TEXT_PLAIN : HeaderValue = HeaderValue :: from_static (\"text/plain\") ;"
      ]
    },
    {
      "type": "Mod",
      "attrs": [
        "# [doc = \" Constants related to query parameters\"]"
      ],
      "vis": "pub",
      "ident": "query_param",
      "content": [
        "pub const API_VERSION : & str = \"api-version\" ;"
      ]
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "serde :: { Deserialize , Serialize }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: { borrow :: Cow , fmt :: Debug , time :: Duration }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: date :: OffsetDateTime"
    },
    {
      "type": "Static",
      "attrs": [],
      "vis": "pub",
      "ident": "DEFAULT_SCOPE_SUFFIX",
      "ty": "pub static DEFAULT_SCOPE_SUFFIX : & str = \"/.default\" ; . ty",
      "expr": "\"/.default\""
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Clone , Deserialize , Serialize , Eq)]"
      ],
      "vis": "pub",
      "ident": "Secret",
      "fields": [
        "(Cow",
        "<",
        "'static",
        ",",
        "str",
        ">)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Secret { pub fn new < T > (access_token : T) -> Self where T : Into < Cow < 'static , str > > , { Self (access_token . into ()) } pub fn secret (& self) -> & str { & self . 0 } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl PartialEq for Secret { fn eq (& self , other : & Self) -> bool { let a = self . secret () ; let b = other . secret () ; if a . len () != b . len () { return false ; } a . bytes () . zip (b . bytes ()) . fold (0 , | acc , (a , b) | acc | (a ^ b)) == 0 } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < String > for Secret { fn from (access_token : String) -> Self { Self :: new (access_token) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & 'static str > for Secret { fn from (access_token : & 'static str) -> Self { Self :: new (access_token) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Debug for Secret { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { f . write_str (\"Secret\") } }"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [doc = \" Represents an Azure service bearer access token with expiry information.\"]",
        "# [derive (Debug , Clone , Serialize , Deserialize)]"
      ],
      "vis": "pub",
      "ident": "AccessToken",
      "fields": [
        "{",
        "#",
        "[doc",
        "=",
        "\"",
        "Get",
        "the",
        "access",
        "token",
        "value.\"]",
        "pub",
        "token",
        ":",
        "Secret",
        ",",
        "#",
        "[doc",
        "=",
        "\"",
        "Gets",
        "the",
        "time",
        "when",
        "the",
        "provided",
        "token",
        "expires.\"]",
        "pub",
        "expires_on",
        ":",
        "OffsetDateTime",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AccessToken { # [doc = \" Create a new `AccessToken`.\"] pub fn new < T > (token : T , expires_on : OffsetDateTime) -> Self where T : Into < Secret > , { Self { token : token . into () , expires_on , } } # [doc = \" Check if the token is expired within a given duration.\"] # [doc = \"\"] # [doc = \" If no duration is provided, then the default duration of 30 seconds is used.\"] pub fn is_expired (& self , window : Option < Duration >) -> bool { self . expires_on < OffsetDateTime :: now_utc () + window . unwrap_or (Duration :: from_secs (30)) } }"
    },
    {
      "type": "Trait",
      "attrs": [
        "# [doc = \" Represents a credential capable of providing an OAuth token.\"]",
        "# [cfg_attr (target_arch = \"wasm32\" , async_trait :: async_trait (? Send))]",
        "# [cfg_attr (not (target_arch = \"wasm32\") , async_trait :: async_trait)]"
      ],
      "vis": "pub",
      "ident": "TokenCredential",
      "items": [
        "# [doc = \" Gets a `AccessToken` for the specified resource\"] async fn get_token (& self , scopes : & [& str]) -> crate :: Result < AccessToken > ;",
        "# [doc = \" Clear the credential's cache.\"] async fn clear_cache (& self) -> crate :: Result < () > ;"
      ]
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: http :: headers :: *"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "ACCOUNT_KIND",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-account-kind\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "ACL",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-acl\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "ACTIVITY_ID",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-activity-id\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "APP",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-app\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "APPEND_POSITION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-blob-condition-appendpos\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "AZURE_ASYNCOPERATION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"azure-asyncoperation\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "BLOB_ACCESS_TIER",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-access-tier\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "BLOB_CACHE_CONTROL",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-blob-cache-control\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "BLOB_COMMITTED_BLOCK_COUNT",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-blob-committed-block-count\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "BLOB_CONTENT_LENGTH",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-blob-content-length\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "BLOB_PUBLIC_ACCESS",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-blob-public-access\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "BLOB_SEQUENCE_NUMBER",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-blob-sequence-number\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "BLOB_TYPE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-blob-type\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "CLIENT_REQUEST_ID",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-client-request-id\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "CLIENT_VERSION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-client-version\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "CONTENT_DISPOSITION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-blob-content-disposition\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "CONTINUATION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-continuation\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "COPY_COMPLETION_TIME",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-copy-completion-time\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "COPY_PROGRESS",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-copy-progress\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "COPY_SOURCE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-copy-source\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "COPY_STATUS_DESCRIPTION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-copy-status-description\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "COPY_STATUS",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-copy-status\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "CREATION_TIME",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-creation-time\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "DELETE_SNAPSHOTS",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-delete-snapshots\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "DELETE_TYPE_PERMANENT",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-delete-type-permanent\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "ENCRYPTION_ALGORITHM",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-encryption-algorithm\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "ENCRYPTION_KEY_SHA256",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-encryption-key-sha256\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "ENCRYPTION_KEY",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-encryption-key\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "HAS_IMMUTABILITY_POLICY",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-has-immutability-policy\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "HAS_LEGAL_HOLD",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-has-legal-hold\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "IF_SEQUENCE_NUMBER_EQ",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-if-sequence-number-eq\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "IF_SEQUENCE_NUMBER_LE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-if-sequence-number-le\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "IF_SEQUENCE_NUMBER_LT",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-if-sequence-number-lt\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "IF_TAGS",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-if-tags\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "ITEM_COUNT",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-item-count\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "ITEM_TYPE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-item-type\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "LEASE_ACTION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-lease-action\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "LEASE_BREAK_PERIOD",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-lease-break-period\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "LEASE_DURATION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-lease-duration\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "LEASE_ID",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-lease-id\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "LEASE_STATE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-lease-state\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "LEASE_STATUS",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-lease-status\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "LEASE_TIME",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-lease-time\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "MAX_ITEM_COUNT",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-max-item-count\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "META_PREFIX",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-meta-\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "MS_DATE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-date\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "MS_RANGE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-range\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "NAMESPACE_ENABLED",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-namespace-enabled\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "PAGE_WRITE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-page-write\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "PROPERTIES",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-properties\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "PROPOSED_LEASE_ID",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-proposed-lease-id\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "RANGE_GET_CONTENT_CRC64",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-range-get-content-crc64\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "RANGE_GET_CONTENT_MD5",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-range-get-content-md5\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "REQUEST_ID",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-request-id\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "REQUEST_SERVER_ENCRYPTED",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-request-server-encrypted\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "REQUIRES_SYNC",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-requires-sync\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SERVER_ENCRYPTED",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-server-encrypted\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SESSION_TOKEN",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-session-token\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SKU_NAME",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-sku-name\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SOURCE_IF_MATCH",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-source-if-match\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SOURCE_IF_MODIFIED_SINCE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-source-if-modified-since\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SOURCE_IF_NONE_MATCH",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-source-if-none-match\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SOURCE_IF_UNMODIFIED_SINCE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-source-if-unmodified-since\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SOURCE_LEASE_ID",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-source-lease-id\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "SOURCE_RANGE",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-source-range\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "TAGS",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-tags\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "USER",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-user\")"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "pub",
      "ident": "VERSION",
      "generics": "",
      "ty": "HeaderName",
      "expr": "HeaderName :: from_static (\"x-ms-version\")"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: credentials :: Secret"
    },
    {
      "type": "Use",
      "attrs": [
        "# [cfg (any (feature = \"hmac_rust\" , feature = \"hmac_openssl\"))]"
      ],
      "tree": "crate :: { base64 , error :: { ErrorKind , ResultExt } , }"
    },
    {
      "type": "Fn",
      "attrs": [
        "# [doc = \" Tries to create an HMAC SHA256 signature from the given `data` and `key`.\"]",
        "# [doc = \"\"]",
        "# [doc = \" The `key` is expected to be a base64 encoded string and will be decoded\"]",
        "# [doc = \" before using it for signing. The returned signature is also base64 encoded.\"]",
        "# [doc = \"\"]",
        "# [doc = \" If both `hmac_rust` and `hmac_openssl` are enabled, use `hmac_openssl`.\"]",
        "# [doc = \"\"]",
        "# [doc = \" # Errors\"]",
        "# [doc = \" - If the `key` is not a valid base64 encoded string.\"]",
        "# [doc = \" - If it fails to create the HMAC from the `key`.\"]",
        "# [cfg (all (feature = \"hmac_rust\" , not (feature = \"hmac_openssl\")))]"
      ],
      "vis": "pub",
      "ident": "hmac_sha256",
      "inputs": [
        "data : & str . pat: data : & str . ty",
        "key : & Secret . pat: key : & Secret . ty"
      ],
      "output": "crate :: Result < String >",
      "block": "{ use hmac :: { Hmac , Mac } ; use sha2 :: Sha256 ; let key = base64 :: decode (key . secret ()) ? ; let mut hmac = Hmac :: < Sha256 > :: new_from_slice (& key) . with_context (ErrorKind :: DataConversion , | | { \"failed to create hmac from key\" }) ? ; hmac . update (data . as_bytes ()) ; let signature = hmac . finalize () . into_bytes () ; Ok (base64 :: encode (signature)) }"
    },
    {
      "type": "Fn",
      "attrs": [
        "# [cfg (feature = \"hmac_openssl\")]"
      ],
      "vis": "pub",
      "ident": "hmac_sha256",
      "inputs": [
        "data : & str . pat: data : & str . ty",
        "key : & Secret . pat: key : & Secret . ty"
      ],
      "output": "crate :: Result < String >",
      "block": "{ use openssl :: { error :: ErrorStack , hash :: MessageDigest , pkey :: PKey , sign :: Signer } ; let decoded = base64 :: decode (key . secret ()) ? ; let signature = | | -> Result < Vec < u8 > , ErrorStack > { let pkey = PKey :: hmac (& decoded) ? ; let mut signer = Signer :: new (MessageDigest :: sha256 () , & pkey) ? ; signer . update (data . as_bytes ()) ? ; signer . sign_to_vec () } () . with_context (ErrorKind :: DataConversion , | | { \"failed to create hmac from key\" }) ? ; Ok (base64 :: encode (signature)) }"
    },
    {
      "type": "Fn",
      "attrs": [
        "# [cfg (not (any (feature = \"hmac_rust\" , feature = \"hmac_openssl\")))]"
      ],
      "vis": "pub",
      "ident": "hmac_sha256",
      "inputs": [
        "_data : & str . pat: _data : & str . ty",
        "_key : & Secret . pat: _key : & Secret . ty"
      ],
      "output": "crate :: Result < String >",
      "block": "{ unimplemented ! (\"An HMAC signing request was called without an hmac implementation.  Make sure to enable either the `hmac_rust` or `hmac_openssl` feature\") ; }"
    },
    {
      "type": "Mod",
      "attrs": [
        "# [cfg (test)]"
      ],
      "vis": "",
      "ident": "tests",
      "content": [
        "use super :: * ;",
        "# [allow (dead_code)] # [cfg_attr (any (feature = \"hmac_rust\" , feature = \"hmac_openssl\") , test)] fn test_hmac_sign () { let data = \"create hmac signature for data\" ; let key = Secret :: new (\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\") ; let sig = hmac_sha256 (data , & key) . unwrap () ; let expected_sig = \"D/y9XyIEdUzEbdV570h8dou/mfkbMA1lKCOPqPDPAd0=\" ; assert_eq ! (sig , expected_sig) ; }"
      ]
    },
    {
      "type": "Mod",
      "attrs": [
        "# [macro_use]"
      ],
      "vis": "",
      "ident": "macros",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "constants",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "hmac",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "models",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "options",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "pipeline",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "policies",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "credentials",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "headers",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "lro",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "request_options",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [
        "# [cfg (feature = \"test\")]"
      ],
      "vis": "pub",
      "ident": "test",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "tokio",
      "content": null
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "constants :: *"
    },
    {
      "type": "Use",
      "attrs": [
        "# [doc (inline)]"
      ],
      "tree": "models :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "options :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "pipeline :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "policies :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec :: { Error , Result }"
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "error",
      "content": [
        "pub use typespec :: error :: * ;",
        "pub use typespec_client_core :: error :: * ;"
      ]
    },
    {
      "type": "Use",
      "attrs": [
        "# [cfg (feature = \"xml\")]"
      ],
      "tree": "typespec_client_core :: xml"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: { base64 , date , http :: { headers :: Header , new_http_client , response :: { Model , PinnedStream , Response , ResponseBody } , AppendToUrlQuery , Body , Context , HttpClient , Method , Pager , Request , RequestContent , StatusCode , Url , } , json , parsing , sleep :: { self , sleep } , stream :: { BytesStream , SeekableStream } , Uuid , }"
    },
    {
      "type": "Type",
      "attrs": [
        "# [doc = \" A unique identifier for a request.\"]"
      ],
      "vis": "pub",
      "ident": "RequestId",
      "ty": "# [doc = \" A unique identifier for a request.\"] pub type RequestId = Uuid ; . ty"
    },
    {
      "type": "Type",
      "attrs": [
        "# [doc = \" A unique session token.\"]"
      ],
      "vis": "pub",
      "ident": "SessionToken",
      "ty": "# [doc = \" A unique session token.\"] pub type SessionToken = String ; . ty"
    },
    {
      "type": "Const",
      "attrs": [
        "# [doc = \" An empty HTTP body.\"]",
        "# [allow (clippy :: declare_interior_mutable_const)]"
      ],
      "vis": "pub",
      "ident": "EMPTY_BODY",
      "generics": "",
      "ty": "bytes :: Bytes",
      "expr": "bytes :: Bytes :: new ()"
    },
    {
      "type": "Mod",
      "attrs": [
        "# [doc (hidden)]",
        "# [doc = \" Used by macros as an implementation detail\"]"
      ],
      "vis": "pub",
      "ident": "__private",
      "content": [
        "pub use paste :: paste ;"
      ]
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: Headers"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: time :: Duration"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: date :: OffsetDateTime"
    },
    {
      "type": "Const",
      "attrs": [
        "# [doc = \" Default retry time for long running operations if no retry-after header is present\"]",
        "# [doc = \"\"]",
        "# [doc = \" This value is the same as the default used in the Azure SDK for Python.\"]",
        "# [doc = \" Ref: <https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-mgmt-core/azure/mgmt/core/polling/arm_polling.py#L191>\"]"
      ],
      "vis": "",
      "ident": "DEFAULT_RETRY_TIME",
      "generics": "",
      "ty": "Duration",
      "expr": "Duration :: from_secs (30)"
    },
    {
      "type": "Enum",
      "attrs": [
        "# [doc = \" Long Running Operation (LRO) status\"]",
        "# [doc = \"\"]",
        "# [doc = \" Ref: <https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/async-operations#provisioningstate-values>\"]",
        "# [derive (Debug)]"
      ],
      "vis": "pub",
      "ident": "LroStatus",
      "variants": [
        "InProgress",
        "Succeeded",
        "Failed",
        "Canceled",
        "Other"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & str > for LroStatus { fn from (s : & str) -> Self { match s { \"InProgress\" => LroStatus :: InProgress , \"Succeeded\" => LroStatus :: Succeeded , \"Failed\" => LroStatus :: Failed , \"Canceled\" | \"Cancelled\" => LroStatus :: Canceled , _ => LroStatus :: Other (s . to_owned ()) , } } }"
    },
    {
      "type": "Fn",
      "attrs": [],
      "vis": "pub",
      "ident": "get_retry_after",
      "inputs": [
        "headers : & Headers . pat: headers : & Headers . ty"
      ],
      "output": "Duration",
      "block": "{ crate :: get_retry_after (headers , OffsetDateTime :: now_utc) . unwrap_or (DEFAULT_RETRY_TIME) }"
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "location",
      "content": [
        "use crate :: { headers :: { Headers , AZURE_ASYNCOPERATION , LOCATION , OPERATION_LOCATION } , json :: from_json , lro :: LroStatus , Url , } ;",
        "# [derive (Debug , Clone , Copy)] pub enum FinalState { AzureAsyncOperation , Location , OperationLocation , }",
        "pub fn get_location (headers : & Headers , final_state : FinalState) -> crate :: Result < Option < Url > > { match final_state { FinalState :: AzureAsyncOperation => headers . get_optional_as (& AZURE_ASYNCOPERATION) , FinalState :: Location => headers . get_optional_as (& LOCATION) , FinalState :: OperationLocation => headers . get_optional_as (& OPERATION_LOCATION) , } }",
        "pub fn get_provisioning_state (body : & [u8]) -> Option < LroStatus > { # [derive (serde :: Deserialize)] struct Body { status : String , } let body : Body = from_json (body) . ok () ? ; Some (LroStatus :: from (body . status . as_str ())) }"
      ]
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "pub",
      "ident": "body_content",
      "content": [
        "use crate :: json :: { from_json , to_json } ;",
        "use crate :: { lro :: LroStatus , StatusCode } ;",
        "use serde :: { Deserialize , Serialize } ;",
        "# [doc = \" Extract the provisioning state based on the status code and response body\"] # [doc = \"\"] # [doc = \" Ref: <https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/azure/core/polling/base_polling.py>\"] pub fn get_provisioning_state < S > (status_code : StatusCode , body : & S) -> crate :: Result < LroStatus > where S : Serialize , { match status_code { StatusCode :: Accepted => Ok (LroStatus :: InProgress) , StatusCode :: Created => { Ok (get_provisioning_state_from_body (body) . unwrap_or (LroStatus :: InProgress)) } StatusCode :: Ok => { Ok (get_provisioning_state_from_body (body) . unwrap_or (LroStatus :: Succeeded)) } StatusCode :: NoContent => Ok (LroStatus :: Succeeded) , _ => Err (crate :: error :: Error :: from (crate :: error :: ErrorKind :: HttpResponse { status : status_code , error_code : Some (\"invalid status found in LRO response\" . to_owned ()) , } ,)) , } }",
        "# [derive (Deserialize)] # [serde (rename_all = \"snake_case\")] struct Properties { provisioning_state : String , }",
        "# [derive (Deserialize)] struct Body { properties : Properties , }",
        "fn get_provisioning_state_from_body < S > (body : & S) -> Option < LroStatus > where S : Serialize , { let body : Body = from_json (to_json (& body) . ok () ?) . ok () ? ; Some (LroStatus :: from (body . properties . provisioning_state . as_str ())) }"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Declare a `Future` with the given name\"] # [doc = \"\"] # [doc = \" `Future::Output` will be set to `azure_core::Result<$NAMEResponse>`.\"] # [doc = \" The `Future` will be `Send` for all targets but `wasm32`.\"] # [macro_export] macro_rules ! future { ($ name : ident) => { $ crate :: future ! ($ name <>) ; } ; ($ name : ident <$ ($ generic : ident) ?>) => { azure_core :: __private :: paste ! { # [cfg (target_arch = \"wasm32\")] pub type $ name <$ ($ generic) *> = std :: pin :: Pin < std :: boxed :: Box < dyn std :: future :: Future < Output = azure_core :: Result < [<$ name Response >] <$ ($ generic) *>>> + 'static >>; # [cfg (not (target_arch = \"wasm32\"))] pub type $ name <$ ($ generic) *> = futures :: future :: BoxFuture <'static , azure_core :: Result < [<$ name Response >] <$ ($ generic) *>>>; } } ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [macro_export] macro_rules ! static_url { ($ (# [$ outer : meta]) * $ name : ident , $ value : expr) => { $ (# [$ outer]) * pub static $ name : once_cell :: sync :: Lazy <$ crate :: Url > = once_cell :: sync :: Lazy :: new (|| { $ crate :: Url :: parse ($ value) . expect (\"hardcoded URL must parse\") }) ; } ; }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: create_enum"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "create_enum ! (# [doc = \"Lease status of an Azure resource.\"] LeaseStatus , (Locked , \"locked\") , (Unlocked , \"unlocked\")) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "create_enum ! (# [doc = \"State of a lease of an Azure resource.\"] LeaseState , (Available , \"available\") , (Leased , \"leased\") , (Expired , \"expired\") , (Breaking , \"breaking\") , (Broken , \"broken\")) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "create_enum ! (# [doc = \"Lease duration of an Azure resource.\"] LeaseDuration , (Infinite , \"infinite\") , (Fixed , \"fixed\")) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "create_enum ! (# [doc = \"The lease action to perform on an Azure resource.\"] LeaseAction , (Acquire , \"acquire\") , (Renew , \"renew \") , (Change , \"change\") , (Release , \"release \") , (Break , \"break\")) ;"
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "lease",
      "content": null
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "lease :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: http :: Etag"
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "telemetry",
      "content": null
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "telemetry :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: http :: { builders , AsClientMethodOptions , AsClientOptions , ClientMethodOptions , ClientOptions , ExponentialRetryOptions , FixedRetryOptions , RetryOptions , TransportOptions , }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: setters"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [doc = \" Telemetry options.\"]",
        "# [derive (Clone , Debug , Default)]"
      ],
      "vis": "pub",
      "ident": "TelemetryOptions",
      "fields": [
        "{",
        "#",
        "[doc",
        "=",
        "\"",
        "Optional",
        "application",
        "ID",
        "to",
        "telemetry.\"]",
        "pub",
        "(crate)",
        "application_id",
        ":",
        "Option",
        "<",
        "String",
        ">",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl TelemetryOptions { setters ! { # [doc = \"Set the application ID to telemetry.\"] application_id : String => Some (application_id) , } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { TelemetryOptions , TelemetryPolicy }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: { ops :: Deref , sync :: Arc }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: http :: { self , policies :: Policy }"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [doc = \" Execution pipeline.\"]",
        "# [doc = \"\"]",
        "# [doc = \" A pipeline follows a precise flow:\"]",
        "# [doc = \"\"]",
        "# [doc = \" 1. Client library-specified per-call policies are executed. Per-call policies can fail and bail out of the pipeline\"]",
        "# [doc = \"    immediately.\"]",
        "# [doc = \" 2. User-specified per-call policies are executed.\"]",
        "# [doc = \" 3. Telemetry policy.\"]",
        "# [doc = \" 4. Retry policy. It allows to re-execute the following policies.\"]",
        "# [doc = \" 5. Client library-specified per-retry policies. Per-retry polices are always executed at least once but are re-executed\"]",
        "# [doc = \"    in case of retries.\"]",
        "# [doc = \" 6. User-specified per-retry policies are executed.\"]",
        "# [doc = \" 7. Authorization policy. Authorization can depend on the HTTP headers and/or the request body so it\"]",
        "# [doc = \"    must be executed right before sending the request to the transport. Also, the authorization\"]",
        "# [doc = \"    can depend on the current time so it must be executed at every retry.\"]",
        "# [doc = \" 8. Transport policy. Transport policy is always the last policy and is the policy that\"]",
        "# [doc = \"    actually constructs the `Response` to be passed up the pipeline.\"]",
        "# [doc = \"\"]",
        "# [doc = \" A pipeline is immutable. In other words a policy can either succeed and call the following\"]",
        "# [doc = \" policy of fail and return to the calling policy. Arbitrary policy \\\"skip\\\" must be avoided (but\"]",
        "# [doc = \" cannot be enforced by code). All policies except Transport policy can assume there is another following policy (so\"]",
        "# [doc = \" `self.pipeline[0]` is always valid).\"]",
        "# [derive (Debug , Clone)]"
      ],
      "vis": "pub",
      "ident": "Pipeline",
      "fields": [
        "(http",
        "::",
        "Pipeline)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Pipeline { # [doc = \" Creates a new pipeline given the client library crate name and version,\"] # [doc = \" alone with user-specified and client library-specified policies.\"] # [doc = \"\"] # [doc = \" Crates can simply pass `option_env!(\\\"CARGO_PKG_NAME\\\")` and `option_env!(\\\"CARGO_PKG_VERSION\\\")` for the\"] # [doc = \" `crate_name` and `crate_version` arguments respectively.\"] pub fn new (crate_name : Option < & 'static str > , crate_version : Option < & 'static str > , options : http :: ClientOptions , per_call_policies : Vec < Arc < dyn Policy > > , per_retry_policies : Vec < Arc < dyn Policy > > ,) -> Self { let mut per_call_policies = per_call_policies . clone () ; let telemetry_policy = TelemetryPolicy :: new (crate_name , crate_version , & TelemetryOptions :: default () ,) ; per_call_policies . insert (0 , Arc :: new (telemetry_policy)) ; Self (http :: Pipeline :: new (options , per_call_policies , per_retry_policies ,)) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Deref for Pipeline { type Target = http :: Pipeline ; fn deref (& self) -> & Self :: Target { & self . 0 } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { credentials :: { AccessToken , TokenCredential } , error :: { Error , ErrorKind } , headers :: AUTHORIZATION , policies :: { Policy , PolicyResult } , Context , Request , }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "async_lock :: RwLock"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "async_trait :: async_trait"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: sync :: Arc"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: time :: Duration"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone)]"
      ],
      "vis": "pub",
      "ident": "BearerTokenCredentialPolicy",
      "fields": [
        "{",
        "credential",
        ":",
        "Arc",
        "<",
        "dyn",
        "TokenCredential",
        ">",
        ",",
        "scopes",
        ":",
        "Vec",
        "<",
        "String",
        ">",
        ",",
        "access_token",
        ":",
        "Arc",
        "<",
        "RwLock",
        "<",
        "Option",
        "<",
        "AccessToken",
        ">",
        ">",
        ">",
        ",",
        "}"
      ]
    },
    {
      "type": "Const",
      "attrs": [
        "# [doc = \" Default timeout in seconds before refreshing a new token.\"]"
      ],
      "vis": "",
      "ident": "DEFAULT_REFRESH_TIME",
      "generics": "",
      "ty": "Duration",
      "expr": "Duration :: from_secs (120)"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl BearerTokenCredentialPolicy { pub fn new < A , B > (credential : Arc < dyn TokenCredential > , scopes : A) -> Self where A : IntoIterator < Item = B > , B : Into < String > , { Self { credential , scopes : scopes . into_iter () . map (| s | s . into ()) . collect () , access_token : Arc :: new (RwLock :: new (None)) , } } fn scopes (& self) -> Vec < & str > { self . scopes . iter () . map (String :: as_str) . collect :: < Vec < & str > > () } async fn access_token (& self) -> Option < String > { let access_token = self . access_token . read () . await ; access_token . as_ref () . map (| s | s . token . secret () . to_string ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg_attr (target_arch = \"wasm32\" , async_trait (? Send))] # [cfg_attr (not (target_arch = \"wasm32\") , async_trait)] impl Policy for BearerTokenCredentialPolicy { async fn send (& self , ctx : & Context , request : & mut Request , next : & [Arc < dyn Policy >] ,) -> PolicyResult { let access_token = self . access_token . read () . await ; if let Some (token) = & (* access_token) { if token . is_expired (Some (DEFAULT_REFRESH_TIME)) { drop (access_token) ; let mut access_token = self . access_token . write () . await ; * access_token = Some (self . credential . get_token (& self . scopes ()) . await ?) ; } } else { drop (access_token) ; let mut access_token = self . access_token . write () . await ; * access_token = Some (self . credential . get_token (& self . scopes ()) . await ?) ; } let access_token = self . access_token () . await . ok_or_else (| | { Error :: message (ErrorKind :: Credential , \"The request failed due to an error while fetching the access token.\" ,) }) ? ; request . insert_header (AUTHORIZATION , format ! (\"Bearer {}\" , access_token)) ; next [0] . send (ctx , request , & next [1 ..]) . await } }"
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "bearer_token_policy",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "telemetry",
      "content": null
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "bearer_token_policy :: BearerTokenCredentialPolicy"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "telemetry :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: http :: policies :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { HeaderValue , USER_AGENT }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: options :: TelemetryOptions"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { Context , Request }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: env :: consts :: { ARCH , OS }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: sync :: Arc"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: http :: policies :: { Policy , PolicyResult }"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Clone , Debug)]"
      ],
      "vis": "pub",
      "ident": "TelemetryPolicy",
      "fields": [
        "{",
        "header",
        ":",
        "String",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Sets the User-Agent header with useful information in a typical format for Azure SDKs.\"] impl < 'a > TelemetryPolicy { pub fn new (crate_name : Option < & 'a str > , crate_version : Option < & 'a str > , options : & TelemetryOptions ,) -> Self { Self :: new_with_rustc_version (crate_name , crate_version , option_env ! (\"AZSDK_RUSTC_VERSION\") , options ,) } fn new_with_rustc_version (crate_name : Option < & 'a str > , crate_version : Option < & 'a str > , rustc_version : Option < & 'a str > , options : & TelemetryOptions ,) -> Self { const UNKNOWN : & str = \"unknown\" ; let mut crate_name = crate_name . unwrap_or (UNKNOWN) ; let crate_version = crate_version . unwrap_or (UNKNOWN) ; let rustc_version = rustc_version . unwrap_or (UNKNOWN) ; let platform_info = format ! (\"({rustc_version}; {OS}; {ARCH})\" ,) ; if let Some (name) = crate_name . strip_prefix (\"azure_\") { crate_name = name ; } let header = match & options . application_id { Some (application_id) => { format ! (\"{application_id} azsdk-rust-{crate_name}/{crate_version} {platform_info}\") } None => format ! (\"azsdk-rust-{crate_name}/{crate_version} {platform_info}\") , } ; TelemetryPolicy { header } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg_attr (target_arch = \"wasm32\" , async_trait :: async_trait (? Send))] # [cfg_attr (not (target_arch = \"wasm32\") , async_trait :: async_trait)] impl Policy for TelemetryPolicy { async fn send (& self , ctx : & Context , request : & mut Request , next : & [Arc < dyn Policy >] ,) -> PolicyResult { request . insert_header (USER_AGENT , HeaderValue :: from (self . header . to_string ())) ; next [0] . send (ctx , request , & next [1 ..]) . await } }"
    },
    {
      "type": "Mod",
      "attrs": [
        "# [cfg (test)]"
      ],
      "vis": "",
      "ident": "test",
      "content": [
        "use super :: * ;",
        "# [test] fn test_without_application_id () { let policy = TelemetryPolicy :: new_with_rustc_version (Some (\"azure_test\") , Some (\"1.2.3\") , Some (\"4.5.6\") , & TelemetryOptions :: default () ,) ; assert_eq ! (policy . header , format ! (\"azsdk-rust-test/1.2.3 (4.5.6; {OS}; {ARCH})\")) ; }",
        "# [test] fn test_with_application_id () { let options = TelemetryOptions { application_id : Some (\"my_app\" . to_string ()) , } ; let policy = TelemetryPolicy :: new_with_rustc_version (Some (\"test\") , Some (\"1.2.3\") , Some (\"4.5.6\") , & options ,) ; assert_eq ! (policy . header , format ! (\"my_app azsdk-rust-test/1.2.3 (4.5.6; {OS}; {ARCH})\")) ; }",
        "# [test] fn test_missing_env () { let policy = TelemetryPolicy :: new_with_rustc_version (None , None , None , & TelemetryOptions :: default ()) ; assert_eq ! (policy . header , format ! (\"azsdk-rust-unknown/unknown (unknown; {OS}; {ARCH})\")) ; }"
      ]
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: error :: { Error , ErrorKind , ResultExt }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: fmt"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: str :: FromStr"
    },
    {
      "type": "Const",
      "attrs": [],
      "vis": "",
      "ident": "PREFIX",
      "generics": "",
      "ty": "& str",
      "expr": "\"bytes \""
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Copy , Clone , PartialEq , Eq)]"
      ],
      "vis": "pub",
      "ident": "ContentRange",
      "fields": [
        "{",
        "start",
        ":",
        "u64",
        ",",
        "end",
        ":",
        "u64",
        ",",
        "total_length",
        ":",
        "u64",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl ContentRange { pub fn new (start : u64 , end : u64 , total_length : u64) -> ContentRange { ContentRange { start , end , total_length , } } pub fn start (& self) -> u64 { self . start } pub fn end (& self) -> u64 { self . end } pub fn total_length (& self) -> u64 { self . total_length } pub fn is_empty (& self) -> bool { self . end == self . start } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl FromStr for ContentRange { type Err = Error ; fn from_str (s : & str) -> crate :: Result < ContentRange > { let remaining = s . strip_prefix (PREFIX) . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{PREFIX}\\\" not found when parsing ContentRange from \\\"{s}\\\"\") }) }) ? ; if cfg ! (feature = \"azurite_workaround\") && remaining == \"0--1/0\" { return Ok (ContentRange { start : 0 , end : 0 , total_length : 0 , }) ; } let mut split_at_dash = remaining . split ('-') ; let start = split_at_dash . next () . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing ContentRange from \\\"{}\\\"\" , \"-\" , s) }) }) ? . parse () . map_kind (ErrorKind :: DataConversion) ? ; let mut split_at_slash = split_at_dash . next () . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing ContentRange from \\\"{}\\\"\" , \"-\" , s) }) }) ? . split ('/') ; let end = split_at_slash . next () . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing ContentRange from \\\"{}\\\"\" , \"/\" , s) }) }) ? . parse () . map_kind (ErrorKind :: DataConversion) ? ; let total_length = split_at_slash . next () . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing ContentRange from \\\"{}\\\"\" , \"/\" , s) }) }) ? . parse () . map_kind (ErrorKind :: DataConversion) ? ; Ok (ContentRange { start , end , total_length , }) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl fmt :: Display for ContentRange { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { write ! (f , \"{}{}-{}/{}\" , PREFIX , self . start () , self . end () , self . total_length ()) } }"
    },
    {
      "type": "Mod",
      "attrs": [
        "# [cfg (test)]"
      ],
      "vis": "",
      "ident": "test",
      "content": [
        "use super :: * ;",
        "# [cfg (feature = \"azurite_workaround\")] # [test] fn test_azurite_workaround () { let range = \"bytes 0--1/0\" . parse :: < ContentRange > () . unwrap () ; assert_eq ! (range . start () , 0) ; assert_eq ! (range . end () , 0) ; assert_eq ! (range . total_length () , 0) ; }",
        "# [test] fn test_parse () { let range = \"bytes 172032-172489/172490\" . parse :: < ContentRange > () . unwrap () ; assert_eq ! (range . start () , 172032) ; assert_eq ! (range . end () , 172489) ; assert_eq ! (range . total_length () , 172490) ; }",
        "# [test] fn test_parse_no_starting_token () { \"something else\" . parse :: < ContentRange > () . unwrap_err () ; }",
        "# [test] fn test_parse_no_dash () { \"bytes 100\" . parse :: < ContentRange > () . unwrap_err () ; }",
        "# [test] fn test_parse_no_slash () { \"bytes 100-500\" . parse :: < ContentRange > () . unwrap_err () ; }",
        "# [test] fn test_display () { let range = ContentRange { start : 100 , end : 501 , total_length : 5000 , } ; let txt = format ! (\"{range}\") ; assert_eq ! (txt , \"bytes 100-501/5000\") ; }"
      ]
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { headers , Header }"
    },
    {
      "type": "Enum",
      "attrs": [
        "# [doc = \" Conditional request header based on the value of the object's sequence number\"]",
        "# [doc = \"\"]",
        "# [doc = \" Ref: <https://docs.microsoft.com/en-us/rest/api/storageservices/put-page-from-url>\"]",
        "# [derive (Debug , Clone , Copy , PartialEq , Eq)]"
      ],
      "vis": "pub",
      "ident": "IfSequenceNumber",
      "variants": [
        "LessThan",
        "LessOrEqual",
        "Equal"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for IfSequenceNumber { fn name (& self) -> headers :: HeaderName { match self { IfSequenceNumber :: Equal (_) => headers :: IF_SEQUENCE_NUMBER_EQ , IfSequenceNumber :: LessOrEqual (_) => headers :: IF_SEQUENCE_NUMBER_LE , IfSequenceNumber :: LessThan (_) => headers :: IF_SEQUENCE_NUMBER_LT , } } fn value (& self) -> headers :: HeaderValue { match self { IfSequenceNumber :: Equal (val) | IfSequenceNumber :: LessOrEqual (val) | IfSequenceNumber :: LessThan (val) => val . to_string () . into () , } } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { self , Header }"
    },
    {
      "type": "Enum",
      "attrs": [
        "# [derive (Debug , Clone , PartialEq , Eq)]"
      ],
      "vis": "pub",
      "ident": "IfSourceMatchCondition",
      "variants": [
        "Match",
        "NotMatch"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for IfSourceMatchCondition { fn name (& self) -> headers :: HeaderName { match self { IfSourceMatchCondition :: Match (_) => headers :: SOURCE_IF_MATCH , IfSourceMatchCondition :: NotMatch (_) => headers :: SOURCE_IF_NONE_MATCH , } } fn value (& self) -> headers :: HeaderValue { match self . clone () { IfSourceMatchCondition :: Match (etag) | IfSourceMatchCondition :: NotMatch (etag) => { etag . into () } } } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { date , headers :: { self , Header , HeaderName } , }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: date :: OffsetDateTime"
    },
    {
      "type": "Enum",
      "attrs": [
        "# [derive (Debug , Clone , Copy , PartialEq , Eq)]"
      ],
      "vis": "pub",
      "ident": "IfSourceModifiedSinceCondition",
      "variants": [
        "Modified",
        "Unmodified"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for IfSourceModifiedSinceCondition { fn name (& self) -> HeaderName { match self { IfSourceModifiedSinceCondition :: Modified (_) => headers :: SOURCE_IF_MODIFIED_SINCE , IfSourceModifiedSinceCondition :: Unmodified (_) => headers :: SOURCE_IF_UNMODIFIED_SINCE , } } fn value (& self) -> headers :: HeaderValue { match self { IfSourceModifiedSinceCondition :: Modified (date) | IfSourceModifiedSinceCondition :: Unmodified (date) => date :: to_rfc1123 (date) . into () , } } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { self , Header }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: str :: FromStr"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: Uuid"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone , Copy , PartialEq , Eq)]"
      ],
      "vis": "pub",
      "ident": "LeaseId",
      "fields": [
        "(Uuid)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl std :: fmt :: Display for LeaseId { fn fmt (& self , fmt : & mut std :: fmt :: Formatter < '_ >) -> Result < () , std :: fmt :: Error > { self . 0 . fmt (fmt) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < Uuid > for LeaseId { fn from (value : Uuid) -> Self { Self (value) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl std :: str :: FromStr for LeaseId { type Err = < Uuid as FromStr > :: Err ; fn from_str (s : & str) -> Result < Self , Self :: Err > { Ok (Self (Uuid :: from_str (s) ?)) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for LeaseId { fn name (& self) -> headers :: HeaderName { headers :: LEASE_ID } fn value (& self) -> headers :: HeaderValue { format ! (\"{}\" , self . 0) . into () } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { self , Header }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: time :: Duration"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone , Copy)]"
      ],
      "vis": "pub",
      "ident": "LeaseBreakPeriod",
      "fields": [
        "(Duration)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < Duration > for LeaseBreakPeriod { fn from (duration : Duration) -> Self { Self (duration) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for LeaseBreakPeriod { fn name (& self) -> headers :: HeaderName { headers :: LEASE_BREAK_PERIOD } fn value (& self) -> headers :: HeaderValue { format ! (\"{}\" , self . 0 . as_secs ()) . into () } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { self , Header }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: time :: Duration"
    },
    {
      "type": "Enum",
      "attrs": [
        "# [derive (Debug , Clone)]"
      ],
      "vis": "pub",
      "ident": "LeaseDuration",
      "variants": [
        "Infinite",
        "Seconds"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for LeaseDuration { fn name (& self) -> headers :: HeaderName { headers :: LEASE_DURATION } fn value (& self) -> headers :: HeaderValue { match self { LeaseDuration :: Infinite => \"-1\" . to_owned () , LeaseDuration :: Seconds (seconds) => { format ! (\"{seconds}\") } } . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < Duration > for LeaseDuration { fn from (d : Duration) -> Self { LeaseDuration :: Seconds (d . as_secs () as u8) } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { self , Header }"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [doc = \" The max number of items in the collection\"]",
        "# [derive (Debug , Clone , Copy)]"
      ],
      "vis": "pub",
      "ident": "MaxItemCount",
      "fields": [
        "(i32)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl MaxItemCount { # [doc = \" Create a new `MaxItemCount`\"] pub fn new (count : i32) -> Self { Self (count) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for MaxItemCount { fn name (& self) -> headers :: HeaderName { headers :: MAX_ITEM_COUNT } fn value (& self) -> headers :: HeaderValue { let count = if self . 0 <= 0 { - 1 } else { self . 0 } ; format ! (\"{count}\") . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < i32 > for MaxItemCount { fn from (count : i32) -> Self { Self :: new (count) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Default for MaxItemCount { fn default () -> Self { MaxItemCount :: new (- 1) } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { AppendToUrlQuery , Url }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: num :: NonZeroU32"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone , Copy , PartialEq , PartialOrd , Eq , Ord)]"
      ],
      "vis": "pub",
      "ident": "MaxResults",
      "fields": [
        "(NonZeroU32)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl MaxResults { pub fn new (max_results : NonZeroU32) -> Self { Self (max_results) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AppendToUrlQuery for MaxResults { fn append_to_url_query (& self , url : & mut Url) { url . query_pairs_mut () . append_pair (\"maxresults\" , & format ! (\"{}\" , self . 0)) ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < NonZeroU32 > for MaxResults { fn from (max_results : NonZeroU32) -> Self { Self :: new (max_results) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl TryFrom < u32 > for MaxResults { type Error = String ; fn try_from (max_results : u32) -> Result < Self , Self :: Error > { match NonZeroU32 :: new (max_results) { Some (max_results) => Ok (max_results . into ()) , None => Err (format ! (\"number {max_results} is not a valid NonZeroU32 value\")) , } } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: Headers"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: Header"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "bytes :: Bytes"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: collections :: HashMap"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone)]"
      ],
      "vis": "pub",
      "ident": "Metadata",
      "fields": [
        "(HashMap",
        "<",
        "String",
        ",",
        "Bytes",
        ">)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Default for Metadata { fn default () -> Self { Self :: new () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AsMut < HashMap < String , Bytes > > for Metadata { fn as_mut (& mut self) -> & mut HashMap < String , Bytes > { & mut self . 0 } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Metadata { pub fn new () -> Self { Self (HashMap :: new ()) } pub fn insert < K , V > (& mut self , k : K , v : V) -> Option < Bytes > where K : Into < String > , V : Into < Bytes > , { self . 0 . insert (k . into () , v . into ()) } pub fn len (& self) -> usize { self . 0 . len () } pub fn is_empty (& self) -> bool { self . 0 . is_empty () } pub fn get (& self , k : & str) -> Option < Bytes > { self . 0 . get (k) . cloned () } pub fn iter (& self) -> impl Iterator < Item = Metadatum > + '_ { self . 0 . iter () . map (| (key , value) | { Metadatum (key . clone () , std :: str :: from_utf8 (value) . expect (\"non-utf8 header value\") . into () ,) }) } }"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug)]"
      ],
      "vis": "pub",
      "ident": "Metadatum",
      "fields": [
        "(String",
        ",",
        "String)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for Metadatum { fn name (& self) -> headers :: HeaderName { format ! (\"x-ms-meta-{}\" , self . 0) . into () } fn value (& self) -> headers :: HeaderValue { self . 1 . clone () . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & Headers > for Metadata { fn from (header_map : & Headers) -> Self { let mut metadata = Metadata :: new () ; header_map . iter () . for_each (| (name , value) | { let name = name . as_str () ; let value = value . as_str () ; if let Some (name) = name . strip_prefix (\"x-ms-meta-\") { metadata . insert (name . to_owned () , value . to_owned ()) ; } }) ; metadata } }"
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "content_range",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "if_sequence_number",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "if_source_match_condition",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "if_source_modified_since_condition",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "lease",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "lease_break_period",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "lease_duration",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "max_item_count",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "max_results",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "metadata",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "next_marker",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "proposed_lease_id",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "range",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "sequence_number",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "source_lease_id",
      "content": null
    },
    {
      "type": "Mod",
      "attrs": [],
      "vis": "",
      "ident": "timeout",
      "content": null
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { ACTIVITY_ID , APP , CLIENT_REQUEST_ID , CLIENT_VERSION , CONTENT_DISPOSITION , CONTINUATION , IF_TAGS , USER , VERSION , }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "content_range :: ContentRange"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "if_sequence_number :: IfSequenceNumber"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "if_source_match_condition :: IfSourceMatchCondition"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "if_source_modified_since_condition :: IfSourceModifiedSinceCondition"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "lease :: LeaseId"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "lease_break_period :: LeaseBreakPeriod"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "lease_duration :: LeaseDuration"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "max_item_count :: MaxItemCount"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "max_results :: MaxResults"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "metadata :: Metadata"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "next_marker :: NextMarker"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "proposed_lease_id :: ProposedLeaseId"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "range :: Range"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "sequence_number :: SequenceNumber"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "source_lease_id :: SourceLeaseId"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "timeout :: Timeout"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: http :: request :: options :: *"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: { request_header , request_query }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (# [doc = \" The (friendly) version identifier for the client making the request\"] ClientVersion , CLIENT_VERSION) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (# [doc = \" The (friendly) name of the user making the request\"] User , USER ,) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (ActivityId , ACTIVITY_ID) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (App , APP) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (ClientRequestId , CLIENT_REQUEST_ID) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (ContentDisposition , CONTENT_DISPOSITION) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (Continuation , CONTINUATION) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (IfTags , IF_TAGS) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (Version , VERSION) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_query ! (# [doc = \" Set delimiter for the request\"] Delimiter , \"delimiter\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_query ! (Prefix , \"prefix\") ;"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { headers :: { self , Headers } , AppendToUrlQuery , Url , }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "serde :: { Deserialize , Serialize }"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone , PartialEq , Eq , Serialize , Deserialize)]"
      ],
      "vis": "pub",
      "ident": "NextMarker",
      "fields": [
        "(String)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl NextMarker { pub fn new (next_marker : String) -> Self { Self (next_marker) } pub fn from_possibly_empty_string (next_marker : Option < String >) -> Option < Self > { if let Some (\"\") = next_marker . as_deref () { None } else { next_marker . map (Into :: into) } } pub fn as_str (& self) -> & str { & self . 0 } pub fn append_to_url_query_as_continuation (& self , url : & mut Url) { url . query_pairs_mut () . append_pair (\"continuation\" , & self . 0) ; } pub fn from_header_optional (headers : & Headers) -> crate :: Result < Option < Self > > { let header_as_str = headers . get_optional_str (& headers :: CONTINUATION) ; Ok (header_as_str . filter (| h | ! h . is_empty ()) . map (| h | NextMarker :: new (h . to_owned ()))) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AppendToUrlQuery for NextMarker { fn append_to_url_query (& self , url : & mut Url) { url . query_pairs_mut () . append_pair (\"marker\" , & self . 0) ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < String > for NextMarker { fn from (next_marker : String) -> Self { Self :: new (next_marker) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & str > for NextMarker { fn from (next_marker : & str) -> Self { Self :: new (next_marker . to_owned ()) } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "super :: LeaseId"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { headers , Header }"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone , Copy)]"
      ],
      "vis": "pub",
      "ident": "ProposedLeaseId",
      "fields": [
        "(LeaseId)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < LeaseId > for ProposedLeaseId { fn from (lease_id : LeaseId) -> Self { Self (lease_id) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for ProposedLeaseId { fn name (& self) -> headers :: HeaderName { headers :: PROPOSED_LEASE_ID } fn value (& self) -> headers :: HeaderValue { format ! (\"{}\" , self . 0) . into () } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: error :: { Error , ErrorKind , ResultExt }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { self , AsHeaders , HeaderName , HeaderValue }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: fmt"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: ops :: { Range as StdRange , RangeFrom }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: str :: FromStr"
    },
    {
      "type": "Enum",
      "attrs": [
        "# [derive (Debug , Clone , PartialEq , Eq)]"
      ],
      "vis": "pub",
      "ident": "Range",
      "variants": [
        "Range",
        "RangeFrom"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Range { pub fn new (start : u64 , end : u64) -> Range { (start .. end) . into () } fn optional_len (& self) -> Option < u64 > { match self { Range :: Range (r) => Some (r . end - r . start) , Range :: RangeFrom (_) => None , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < StdRange < u64 > > for Range { fn from (r : StdRange < u64 >) -> Self { Self :: Range (r) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < RangeFrom < u64 > > for Range { fn from (r : RangeFrom < u64 >) -> Self { Self :: RangeFrom (r) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < StdRange < usize > > for Range { fn from (r : StdRange < usize >) -> Self { (r . start as u64 .. r . end as u64) . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < RangeFrom < usize > > for Range { fn from (r : RangeFrom < usize >) -> Self { (r . start as u64 ..) . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AsHeaders for Range { type Error = std :: convert :: Infallible ; type Iter = std :: vec :: IntoIter < (HeaderName , HeaderValue) > ; fn as_headers (& self) -> Result < Self :: Iter , Self :: Error > { let mut headers = vec ! [(headers :: MS_RANGE , format ! (\"{self}\") . into ())] ; if let Some (len) = self . optional_len () { if len < 1024 * 1024 * 4 { headers . push ((headers :: RANGE_GET_CONTENT_CRC64 , HeaderValue :: from_static (\"true\") ,)) ; } } Ok (headers . into_iter ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl FromStr for Range { type Err = Error ; fn from_str (s : & str) -> crate :: Result < Range > { let v = s . split ('/') . collect :: < Vec < & str > > () ; if v . len () != 2 { return Err (Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing Range from \\\"{}\\\"\" , \"/\" , s) })) ; } let cp_start = v [0] . parse :: < u64 > () . map_kind (ErrorKind :: DataConversion) ? ; let cp_end = v [1] . parse :: < u64 > () . map_kind (ErrorKind :: DataConversion) ? + 1 ; Ok ((cp_start .. cp_end) . into ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl fmt :: Display for Range { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { match self { Range :: Range (r) => write ! (f , \"bytes={}-{}\" , r . start , r . end - 1) , Range :: RangeFrom (r) => write ! (f , \"bytes={}-\" , r . start) , } } }"
    },
    {
      "type": "Mod",
      "attrs": [
        "# [cfg (test)]"
      ],
      "vis": "",
      "ident": "test",
      "content": [
        "use super :: * ;",
        "# [test] fn test_range_parse () { let range = \"1000/2000\" . parse :: < Range > () . unwrap () ; assert_eq ! (range , Range :: new (1000 , 2001)) ; }",
        "# [test] fn test_range_parse_panic_1 () { \"abba/2000\" . parse :: < Range > () . unwrap_err () ; }",
        "# [test] fn test_range_parse_panic_2 () { \"1000-2000\" . parse :: < Range > () . unwrap_err () ; }",
        "# [test] fn test_range_display () { let range = Range :: new (100 , 501) ; let txt = format ! (\"{range}\") ; assert_eq ! (txt , \"bytes=100-500\") ; }"
      ]
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { self , Header }"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone , Copy , PartialEq , PartialOrd , Eq , Ord)]"
      ],
      "vis": "pub",
      "ident": "SequenceNumber",
      "fields": [
        "(u64)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl SequenceNumber { pub fn new (max_results : u64) -> Self { Self (max_results) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < u64 > for SequenceNumber { fn from (max_results : u64) -> Self { Self :: new (max_results) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for SequenceNumber { fn name (& self) -> headers :: HeaderName { headers :: BLOB_SEQUENCE_NUMBER } fn value (& self) -> headers :: HeaderValue { self . 0 . to_string () . into () } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: headers :: { self , Header }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: str :: FromStr"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "typespec_client_core :: Uuid"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone , Copy , PartialEq , Eq)]"
      ],
      "vis": "pub",
      "ident": "SourceLeaseId",
      "fields": [
        "(Uuid)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl std :: fmt :: Display for SourceLeaseId { fn fmt (& self , fmt : & mut std :: fmt :: Formatter < '_ >) -> Result < () , std :: fmt :: Error > { self . 0 . fmt (fmt) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl std :: str :: FromStr for SourceLeaseId { type Err = < Uuid as FromStr > :: Err ; fn from_str (s : & str) -> Result < Self , Self :: Err > { Ok (Self (Uuid :: from_str (s) ?)) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for SourceLeaseId { fn name (& self) -> headers :: HeaderName { headers :: SOURCE_LEASE_ID } fn value (& self) -> headers :: HeaderValue { self . 0 . to_string () . into () } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: { AppendToUrlQuery , Url }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: time :: Duration"
    },
    {
      "type": "Struct",
      "attrs": [
        "# [derive (Debug , Clone , Copy)]"
      ],
      "vis": "pub",
      "ident": "Timeout",
      "fields": [
        "(Duration)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Timeout { pub fn new (duration : Duration) -> Self { Self (duration) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AppendToUrlQuery for Timeout { fn append_to_url_query (& self , url : & mut Url) { if url . query_pairs () . any (| (k , _) | k == \"timeout\") { return ; } url . query_pairs_mut () . append_pair (\"timeout\" , & format ! (\"{}\" , self . 0 . as_secs ())) ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < Duration > for Timeout { fn from (d : Duration) -> Self { Self (d) } }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "crate :: error :: { Error , ErrorKind }"
    },
    {
      "type": "Use",
      "attrs": [],
      "tree": "std :: { fmt , str :: FromStr }"
    },
    {
      "type": "Enum",
      "attrs": [
        "# [doc = \" Whether to test client methods by playing back recordings, recording live sessions, or executing live sessions without recording.\"]",
        "# [derive (Clone , Copy , Default , PartialEq , Eq , PartialOrd , Ord)]"
      ],
      "vis": "pub",
      "ident": "TestMode",
      "variants": [
        "Playback",
        "Record",
        "Live"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl TestMode { # [doc = \" Gets the `TestMode` from the `AZURE_TEST_MODE` environment variable or returns the default if undefined.\"] pub fn current () -> typespec :: Result < Self > { std :: env :: var (\"AZURE_TEST_MODE\") . map_or_else (| _ | Ok (TestMode :: default ()) , | v | v . parse ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl fmt :: Debug for TestMode { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { f . write_str (self . into ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & TestMode > for & 'static str { fn from (mode : & TestMode) -> Self { match mode { TestMode :: Playback => \"playback\" , TestMode :: Record => \"record\" , TestMode :: Live => \"live\" , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl FromStr for TestMode { type Err = Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { match s . to_ascii_lowercase () . as_str () { \"playback\" => Ok (Self :: Playback) , \"record\" => Ok (Self :: Record) , \"live\" => Ok (Self :: Live) , _ => Err (Error :: message (ErrorKind :: DataConversion , \"expected 'playback', 'record', or 'live'\" ,)) , } } }"
    },
    {
      "type": "Use",
      "attrs": [
        "# [cfg (feature = \"tokio_fs\")]"
      ],
      "tree": "typespec_client_core :: fs :: *"
    }
  ]
}