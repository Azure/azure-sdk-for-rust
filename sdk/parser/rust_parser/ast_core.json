{
  "items": [
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Endpoints for Azure Resource Manager in different Azure clouds\"] pub mod resource_manager_endpoint { static_url ! (# [doc = \" Azure Resource Manager China cloud endpoint\"] AZURE_CHINA_CLOUD , \"https://management.chinacloudapi.cn\") ; static_url ! (# [doc = \" Azure Resource Manager Germany cloud endpoint\"] AZURE_GERMANY_CLOUD , \"https://management.microsoftazure.de\") ; static_url ! (# [doc = \" Azure Resource Manager public cloud endpoint\"] AZURE_PUBLIC_CLOUD , \"https://management.azure.com\") ; static_url ! (# [doc = \" Azure Resource Manager US government cloud endpoint\"] AZURE_US_GOVERNMENT_CLOUD , \"https://management.usgovcloudapi.net\") ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" A list of known Azure authority hosts\"] pub mod authority_hosts { static_url ! (# [doc = \" China-based Azure Authority Host\"] AZURE_CHINA_CLOUD , \"https://login.chinacloudapi.cn\") ; static_url ! (# [doc = \" Germany-based Azure Authority Host\"] AZURE_GERMANY_CLOUD , \"https://login.microsoftonline.de\") ; static_url ! (# [doc = \" US Government Azure Authority Host\"] AZURE_US_GOVERNMENT_CLOUD , \"https://login.microsoftonline.us\") ; static_url ! (# [doc = \" Public Cloud Azure Authority Host\"] AZURE_PUBLIC_CLOUD , \"https://login.microsoftonline.com\") ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Constants related to the Content-Type header\"] # [doc = \"\"] # [doc = \" <https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type>\"] pub mod content_type { use crate :: headers :: HeaderValue ; pub const MULTIPART_FORM_DATA : HeaderValue = HeaderValue :: from_static (\"multipart/form-data\") ; pub const APPLICATION_X_WWW_FORM_URLENCODED : HeaderValue = HeaderValue :: from_static (\"application/x-www-form-urlencoded\") ; pub const APPLICATION_XML : HeaderValue = HeaderValue :: from_static (\"application/xml\") ; pub const APPLICATION_JSON : HeaderValue = HeaderValue :: from_static (\"application/json\") ; pub const APPLICATION_OCTET_STREAM : HeaderValue = HeaderValue :: from_static (\"application/octet-stream\") ; pub const TEXT_PLAIN : HeaderValue = HeaderValue :: from_static (\"text/plain\") ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Constants related to query parameters\"] pub mod query_param { pub const API_VERSION : & str = \"api-version\" ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use serde :: { Deserialize , Serialize } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: { borrow :: Cow , fmt :: Debug , time :: Duration } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: date :: OffsetDateTime ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub static DEFAULT_SCOPE_SUFFIX : & str = \"/.default\" ;"
    },
    {
      "type": "Struct",
      "ident": "Secret",
      "fields": [
        "(Cow",
        "<",
        "'static",
        ",",
        "str",
        ">)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Secret { pub fn new < T > (access_token : T) -> Self where T : Into < Cow < 'static , str > > , { Self (access_token . into ()) } pub fn secret (& self) -> & str { & self . 0 } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl PartialEq for Secret { fn eq (& self , other : & Self) -> bool { let a = self . secret () ; let b = other . secret () ; if a . len () != b . len () { return false ; } a . bytes () . zip (b . bytes ()) . fold (0 , | acc , (a , b) | acc | (a ^ b)) == 0 } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < String > for Secret { fn from (access_token : String) -> Self { Self :: new (access_token) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & 'static str > for Secret { fn from (access_token : & 'static str) -> Self { Self :: new (access_token) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Debug for Secret { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { f . write_str (\"Secret\") } }"
    },
    {
      "type": "Struct",
      "ident": "AccessToken",
      "fields": [
        "{",
        "#",
        "[doc",
        "=",
        "\"",
        "Get",
        "the",
        "access",
        "token",
        "value.\"]",
        "pub",
        "token",
        ":",
        "Secret",
        ",",
        "#",
        "[doc",
        "=",
        "\"",
        "Gets",
        "the",
        "time",
        "when",
        "the",
        "provided",
        "token",
        "expires.\"]",
        "pub",
        "expires_on",
        ":",
        "OffsetDateTime",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AccessToken { # [doc = \" Create a new `AccessToken`.\"] pub fn new < T > (token : T , expires_on : OffsetDateTime) -> Self where T : Into < Secret > , { Self { token : token . into () , expires_on , } } # [doc = \" Check if the token is expired within a given duration.\"] # [doc = \"\"] # [doc = \" If no duration is provided, then the default duration of 30 seconds is used.\"] pub fn is_expired (& self , window : Option < Duration >) -> bool { self . expires_on < OffsetDateTime :: now_utc () + window . unwrap_or (Duration :: from_secs (30)) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Represents a credential capable of providing an OAuth token.\"] # [cfg_attr (target_arch = \"wasm32\" , async_trait :: async_trait (? Send))] # [cfg_attr (not (target_arch = \"wasm32\") , async_trait :: async_trait)] pub trait TokenCredential : Send + Sync + Debug { # [doc = \" Gets a `AccessToken` for the specified resource\"] async fn get_token (& self , scopes : & [& str]) -> crate :: Result < AccessToken > ; # [doc = \" Clear the credential's cache.\"] async fn clear_cache (& self) -> crate :: Result < () > ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use typespec_client_core :: http :: headers :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const ACCOUNT_KIND : HeaderName = HeaderName :: from_static (\"x-ms-account-kind\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const ACL : HeaderName = HeaderName :: from_static (\"x-ms-acl\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const ACTIVITY_ID : HeaderName = HeaderName :: from_static (\"x-ms-activity-id\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const APP : HeaderName = HeaderName :: from_static (\"x-ms-app\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const APPEND_POSITION : HeaderName = HeaderName :: from_static (\"x-ms-blob-condition-appendpos\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const AZURE_ASYNCOPERATION : HeaderName = HeaderName :: from_static (\"azure-asyncoperation\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const BLOB_ACCESS_TIER : HeaderName = HeaderName :: from_static (\"x-ms-access-tier\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const BLOB_CACHE_CONTROL : HeaderName = HeaderName :: from_static (\"x-ms-blob-cache-control\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const BLOB_COMMITTED_BLOCK_COUNT : HeaderName = HeaderName :: from_static (\"x-ms-blob-committed-block-count\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const BLOB_CONTENT_LENGTH : HeaderName = HeaderName :: from_static (\"x-ms-blob-content-length\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const BLOB_PUBLIC_ACCESS : HeaderName = HeaderName :: from_static (\"x-ms-blob-public-access\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const BLOB_SEQUENCE_NUMBER : HeaderName = HeaderName :: from_static (\"x-ms-blob-sequence-number\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const BLOB_TYPE : HeaderName = HeaderName :: from_static (\"x-ms-blob-type\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const CLIENT_REQUEST_ID : HeaderName = HeaderName :: from_static (\"x-ms-client-request-id\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const CLIENT_VERSION : HeaderName = HeaderName :: from_static (\"x-ms-client-version\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const CONTENT_DISPOSITION : HeaderName = HeaderName :: from_static (\"x-ms-blob-content-disposition\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const CONTINUATION : HeaderName = HeaderName :: from_static (\"x-ms-continuation\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const COPY_COMPLETION_TIME : HeaderName = HeaderName :: from_static (\"x-ms-copy-completion-time\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const COPY_PROGRESS : HeaderName = HeaderName :: from_static (\"x-ms-copy-progress\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const COPY_SOURCE : HeaderName = HeaderName :: from_static (\"x-ms-copy-source\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const COPY_STATUS_DESCRIPTION : HeaderName = HeaderName :: from_static (\"x-ms-copy-status-description\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const COPY_STATUS : HeaderName = HeaderName :: from_static (\"x-ms-copy-status\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const CREATION_TIME : HeaderName = HeaderName :: from_static (\"x-ms-creation-time\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const DELETE_SNAPSHOTS : HeaderName = HeaderName :: from_static (\"x-ms-delete-snapshots\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const DELETE_TYPE_PERMANENT : HeaderName = HeaderName :: from_static (\"x-ms-delete-type-permanent\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const ENCRYPTION_ALGORITHM : HeaderName = HeaderName :: from_static (\"x-ms-encryption-algorithm\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const ENCRYPTION_KEY_SHA256 : HeaderName = HeaderName :: from_static (\"x-ms-encryption-key-sha256\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const ENCRYPTION_KEY : HeaderName = HeaderName :: from_static (\"x-ms-encryption-key\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const HAS_IMMUTABILITY_POLICY : HeaderName = HeaderName :: from_static (\"x-ms-has-immutability-policy\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const HAS_LEGAL_HOLD : HeaderName = HeaderName :: from_static (\"x-ms-has-legal-hold\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const IF_SEQUENCE_NUMBER_EQ : HeaderName = HeaderName :: from_static (\"x-ms-if-sequence-number-eq\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const IF_SEQUENCE_NUMBER_LE : HeaderName = HeaderName :: from_static (\"x-ms-if-sequence-number-le\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const IF_SEQUENCE_NUMBER_LT : HeaderName = HeaderName :: from_static (\"x-ms-if-sequence-number-lt\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const IF_TAGS : HeaderName = HeaderName :: from_static (\"x-ms-if-tags\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const ITEM_COUNT : HeaderName = HeaderName :: from_static (\"x-ms-item-count\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const ITEM_TYPE : HeaderName = HeaderName :: from_static (\"x-ms-item-type\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const LEASE_ACTION : HeaderName = HeaderName :: from_static (\"x-ms-lease-action\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const LEASE_BREAK_PERIOD : HeaderName = HeaderName :: from_static (\"x-ms-lease-break-period\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const LEASE_DURATION : HeaderName = HeaderName :: from_static (\"x-ms-lease-duration\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const LEASE_ID : HeaderName = HeaderName :: from_static (\"x-ms-lease-id\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const LEASE_STATE : HeaderName = HeaderName :: from_static (\"x-ms-lease-state\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const LEASE_STATUS : HeaderName = HeaderName :: from_static (\"x-ms-lease-status\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const LEASE_TIME : HeaderName = HeaderName :: from_static (\"x-ms-lease-time\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const MAX_ITEM_COUNT : HeaderName = HeaderName :: from_static (\"x-ms-max-item-count\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const META_PREFIX : HeaderName = HeaderName :: from_static (\"x-ms-meta-\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const MS_DATE : HeaderName = HeaderName :: from_static (\"x-ms-date\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const MS_RANGE : HeaderName = HeaderName :: from_static (\"x-ms-range\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const NAMESPACE_ENABLED : HeaderName = HeaderName :: from_static (\"x-ms-namespace-enabled\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const PAGE_WRITE : HeaderName = HeaderName :: from_static (\"x-ms-page-write\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const PROPERTIES : HeaderName = HeaderName :: from_static (\"x-ms-properties\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const PROPOSED_LEASE_ID : HeaderName = HeaderName :: from_static (\"x-ms-proposed-lease-id\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const RANGE_GET_CONTENT_CRC64 : HeaderName = HeaderName :: from_static (\"x-ms-range-get-content-crc64\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const RANGE_GET_CONTENT_MD5 : HeaderName = HeaderName :: from_static (\"x-ms-range-get-content-md5\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const REQUEST_ID : HeaderName = HeaderName :: from_static (\"x-ms-request-id\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const REQUEST_SERVER_ENCRYPTED : HeaderName = HeaderName :: from_static (\"x-ms-request-server-encrypted\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const REQUIRES_SYNC : HeaderName = HeaderName :: from_static (\"x-ms-requires-sync\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SERVER_ENCRYPTED : HeaderName = HeaderName :: from_static (\"x-ms-server-encrypted\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SESSION_TOKEN : HeaderName = HeaderName :: from_static (\"x-ms-session-token\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SKU_NAME : HeaderName = HeaderName :: from_static (\"x-ms-sku-name\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SOURCE_IF_MATCH : HeaderName = HeaderName :: from_static (\"x-ms-source-if-match\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SOURCE_IF_MODIFIED_SINCE : HeaderName = HeaderName :: from_static (\"x-ms-source-if-modified-since\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SOURCE_IF_NONE_MATCH : HeaderName = HeaderName :: from_static (\"x-ms-source-if-none-match\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SOURCE_IF_UNMODIFIED_SINCE : HeaderName = HeaderName :: from_static (\"x-ms-source-if-unmodified-since\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SOURCE_LEASE_ID : HeaderName = HeaderName :: from_static (\"x-ms-source-lease-id\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const SOURCE_RANGE : HeaderName = HeaderName :: from_static (\"x-ms-source-range\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const TAGS : HeaderName = HeaderName :: from_static (\"x-ms-tags\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const USER : HeaderName = HeaderName :: from_static (\"x-ms-user\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub const VERSION : HeaderName = HeaderName :: from_static (\"x-ms-version\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: credentials :: Secret ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg (any (feature = \"hmac_rust\" , feature = \"hmac_openssl\"))] use crate :: { base64 , error :: { ErrorKind , ResultExt } , } ;"
    },
    {
      "type": "Function",
      "ident": "hmac_sha256",
      "inputs": [
        "data : & str . pat: data : & str . ty",
        "key : & Secret . pat: key : & Secret . ty"
      ],
      "output": "crate :: Result < String >",
      "block": "{ use hmac :: { Hmac , Mac } ; use sha2 :: Sha256 ; let key = base64 :: decode (key . secret ()) ? ; let mut hmac = Hmac :: < Sha256 > :: new_from_slice (& key) . with_context (ErrorKind :: DataConversion , | | { \"failed to create hmac from key\" }) ? ; hmac . update (data . as_bytes ()) ; let signature = hmac . finalize () . into_bytes () ; Ok (base64 :: encode (signature)) }"
    },
    {
      "type": "Function",
      "ident": "hmac_sha256",
      "inputs": [
        "data : & str . pat: data : & str . ty",
        "key : & Secret . pat: key : & Secret . ty"
      ],
      "output": "crate :: Result < String >",
      "block": "{ use openssl :: { error :: ErrorStack , hash :: MessageDigest , pkey :: PKey , sign :: Signer } ; let decoded = base64 :: decode (key . secret ()) ? ; let signature = | | -> Result < Vec < u8 > , ErrorStack > { let pkey = PKey :: hmac (& decoded) ? ; let mut signer = Signer :: new (MessageDigest :: sha256 () , & pkey) ? ; signer . update (data . as_bytes ()) ? ; signer . sign_to_vec () } () . with_context (ErrorKind :: DataConversion , | | { \"failed to create hmac from key\" }) ? ; Ok (base64 :: encode (signature)) }"
    },
    {
      "type": "Function",
      "ident": "hmac_sha256",
      "inputs": [
        "_data : & str . pat: _data : & str . ty",
        "_key : & Secret . pat: _key : & Secret . ty"
      ],
      "output": "crate :: Result < String >",
      "block": "{ unimplemented ! (\"An HMAC signing request was called without an hmac implementation.  Make sure to enable either the `hmac_rust` or `hmac_openssl` feature\") ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg (test)] mod tests { use super :: * ; # [allow (dead_code)] # [cfg_attr (any (feature = \"hmac_rust\" , feature = \"hmac_openssl\") , test)] fn test_hmac_sign () { let data = \"create hmac signature for data\" ; let key = Secret :: new (\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\") ; let sig = hmac_sha256 (data , & key) . unwrap () ; let expected_sig = \"D/y9XyIEdUzEbdV570h8dou/mfkbMA1lKCOPqPDPAd0=\" ; assert_eq ! (sig , expected_sig) ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [macro_use] mod macros ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod constants ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod hmac ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod models ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod options ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod pipeline ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod policies ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod credentials ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod headers ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod lro ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod request_options ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg (feature = \"test\")] pub mod test ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod tokio ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use constants :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc (inline)] pub use models :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use options :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use pipeline :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use policies :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use typespec :: { Error , Result } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod error { pub use typespec :: error :: * ; pub use typespec_client_core :: error :: * ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg (feature = \"xml\")] pub use typespec_client_core :: xml ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use typespec_client_core :: { base64 , date , http :: { headers :: Header , new_http_client , response :: { Model , PinnedStream , Response , ResponseBody } , AppendToUrlQuery , Body , Context , HttpClient , Method , Pager , Request , RequestContent , StatusCode , Url , } , json , parsing , sleep :: { self , sleep } , stream :: { BytesStream , SeekableStream } , Uuid , } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" A unique identifier for a request.\"] pub type RequestId = Uuid ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" A unique session token.\"] pub type SessionToken = String ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" An empty HTTP body.\"] # [allow (clippy :: declare_interior_mutable_const)] pub const EMPTY_BODY : bytes :: Bytes = bytes :: Bytes :: new () ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc (hidden)] # [doc = \" Used by macros as an implementation detail\"] pub mod __private { pub use paste :: paste ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: Headers ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: time :: Duration ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: date :: OffsetDateTime ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Default retry time for long running operations if no retry-after header is present\"] # [doc = \"\"] # [doc = \" This value is the same as the default used in the Azure SDK for Python.\"] # [doc = \" Ref: <https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-mgmt-core/azure/mgmt/core/polling/arm_polling.py#L191>\"] const DEFAULT_RETRY_TIME : Duration = Duration :: from_secs (30) ;"
    },
    {
      "type": "Enum",
      "ident": "LroStatus",
      "variants": [
        "InProgress",
        "Succeeded",
        "Failed",
        "Canceled",
        "Other"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & str > for LroStatus { fn from (s : & str) -> Self { match s { \"InProgress\" => LroStatus :: InProgress , \"Succeeded\" => LroStatus :: Succeeded , \"Failed\" => LroStatus :: Failed , \"Canceled\" | \"Cancelled\" => LroStatus :: Canceled , _ => LroStatus :: Other (s . to_owned ()) , } } }"
    },
    {
      "type": "Function",
      "ident": "get_retry_after",
      "inputs": [
        "headers : & Headers . pat: headers : & Headers . ty"
      ],
      "output": "Duration",
      "block": "{ crate :: get_retry_after (headers , OffsetDateTime :: now_utc) . unwrap_or (DEFAULT_RETRY_TIME) }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod location { use crate :: { headers :: { Headers , AZURE_ASYNCOPERATION , LOCATION , OPERATION_LOCATION } , json :: from_json , lro :: LroStatus , Url , } ; # [derive (Debug , Clone , Copy)] pub enum FinalState { AzureAsyncOperation , Location , OperationLocation , } pub fn get_location (headers : & Headers , final_state : FinalState) -> crate :: Result < Option < Url > > { match final_state { FinalState :: AzureAsyncOperation => headers . get_optional_as (& AZURE_ASYNCOPERATION) , FinalState :: Location => headers . get_optional_as (& LOCATION) , FinalState :: OperationLocation => headers . get_optional_as (& OPERATION_LOCATION) , } } pub fn get_provisioning_state (body : & [u8]) -> Option < LroStatus > { # [derive (serde :: Deserialize)] struct Body { status : String , } let body : Body = from_json (body) . ok () ? ; Some (LroStatus :: from (body . status . as_str ())) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub mod body_content { use crate :: json :: { from_json , to_json } ; use crate :: { lro :: LroStatus , StatusCode } ; use serde :: { Deserialize , Serialize } ; # [doc = \" Extract the provisioning state based on the status code and response body\"] # [doc = \"\"] # [doc = \" Ref: <https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/azure/core/polling/base_polling.py>\"] pub fn get_provisioning_state < S > (status_code : StatusCode , body : & S) -> crate :: Result < LroStatus > where S : Serialize , { match status_code { StatusCode :: Accepted => Ok (LroStatus :: InProgress) , StatusCode :: Created => { Ok (get_provisioning_state_from_body (body) . unwrap_or (LroStatus :: InProgress)) } StatusCode :: Ok => { Ok (get_provisioning_state_from_body (body) . unwrap_or (LroStatus :: Succeeded)) } StatusCode :: NoContent => Ok (LroStatus :: Succeeded) , _ => Err (crate :: error :: Error :: from (crate :: error :: ErrorKind :: HttpResponse { status : status_code , error_code : Some (\"invalid status found in LRO response\" . to_owned ()) , } ,)) , } } # [derive (Deserialize)] # [serde (rename_all = \"snake_case\")] struct Properties { provisioning_state : String , } # [derive (Deserialize)] struct Body { properties : Properties , } fn get_provisioning_state_from_body < S > (body : & S) -> Option < LroStatus > where S : Serialize , { let body : Body = from_json (to_json (& body) . ok () ?) . ok () ? ; Some (LroStatus :: from (body . properties . provisioning_state . as_str ())) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Declare a `Future` with the given name\"] # [doc = \"\"] # [doc = \" `Future::Output` will be set to `azure_core::Result<$NAMEResponse>`.\"] # [doc = \" The `Future` will be `Send` for all targets but `wasm32`.\"] # [macro_export] macro_rules ! future { ($ name : ident) => { $ crate :: future ! ($ name <>) ; } ; ($ name : ident <$ ($ generic : ident) ?>) => { azure_core :: __private :: paste ! { # [cfg (target_arch = \"wasm32\")] pub type $ name <$ ($ generic) *> = std :: pin :: Pin < std :: boxed :: Box < dyn std :: future :: Future < Output = azure_core :: Result < [<$ name Response >] <$ ($ generic) *>>> + 'static >>; # [cfg (not (target_arch = \"wasm32\"))] pub type $ name <$ ($ generic) *> = futures :: future :: BoxFuture <'static , azure_core :: Result < [<$ name Response >] <$ ($ generic) *>>>; } } ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [macro_export] macro_rules ! static_url { ($ (# [$ outer : meta]) * $ name : ident , $ value : expr) => { $ (# [$ outer]) * pub static $ name : once_cell :: sync :: Lazy <$ crate :: Url > = once_cell :: sync :: Lazy :: new (|| { $ crate :: Url :: parse ($ value) . expect (\"hardcoded URL must parse\") }) ; } ; }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: create_enum ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "create_enum ! (# [doc = \"Lease status of an Azure resource.\"] LeaseStatus , (Locked , \"locked\") , (Unlocked , \"unlocked\")) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "create_enum ! (# [doc = \"State of a lease of an Azure resource.\"] LeaseState , (Available , \"available\") , (Leased , \"leased\") , (Expired , \"expired\") , (Breaking , \"breaking\") , (Broken , \"broken\")) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "create_enum ! (# [doc = \"Lease duration of an Azure resource.\"] LeaseDuration , (Infinite , \"infinite\") , (Fixed , \"fixed\")) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "create_enum ! (# [doc = \"The lease action to perform on an Azure resource.\"] LeaseAction , (Acquire , \"acquire\") , (Renew , \"renew \") , (Change , \"change\") , (Release , \"release \") , (Break , \"break\")) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod lease ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use lease :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use typespec_client_core :: http :: Etag ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod telemetry ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use telemetry :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use typespec_client_core :: http :: { builders , AsClientMethodOptions , AsClientOptions , ClientMethodOptions , ClientOptions , ExponentialRetryOptions , FixedRetryOptions , RetryOptions , TransportOptions , } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: setters ;"
    },
    {
      "type": "Struct",
      "ident": "TelemetryOptions",
      "fields": [
        "{",
        "#",
        "[doc",
        "=",
        "\"",
        "Optional",
        "application",
        "ID",
        "to",
        "telemetry.\"]",
        "pub",
        "(crate)",
        "application_id",
        ":",
        "Option",
        "<",
        "String",
        ">",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl TelemetryOptions { setters ! { # [doc = \"Set the application ID to telemetry.\"] application_id : String => Some (application_id) , } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { TelemetryOptions , TelemetryPolicy } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: { ops :: Deref , sync :: Arc } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: http :: { self , policies :: Policy } ;"
    },
    {
      "type": "Struct",
      "ident": "Pipeline",
      "fields": [
        "(http",
        "::",
        "Pipeline)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Pipeline { # [doc = \" Creates a new pipeline given the client library crate name and version,\"] # [doc = \" alone with user-specified and client library-specified policies.\"] # [doc = \"\"] # [doc = \" Crates can simply pass `option_env!(\\\"CARGO_PKG_NAME\\\")` and `option_env!(\\\"CARGO_PKG_VERSION\\\")` for the\"] # [doc = \" `crate_name` and `crate_version` arguments respectively.\"] pub fn new (crate_name : Option < & 'static str > , crate_version : Option < & 'static str > , options : http :: ClientOptions , per_call_policies : Vec < Arc < dyn Policy > > , per_retry_policies : Vec < Arc < dyn Policy > > ,) -> Self { let mut per_call_policies = per_call_policies . clone () ; let telemetry_policy = TelemetryPolicy :: new (crate_name , crate_version , & TelemetryOptions :: default () ,) ; per_call_policies . insert (0 , Arc :: new (telemetry_policy)) ; Self (http :: Pipeline :: new (options , per_call_policies , per_retry_policies ,)) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Deref for Pipeline { type Target = http :: Pipeline ; fn deref (& self) -> & Self :: Target { & self . 0 } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { credentials :: { AccessToken , TokenCredential } , error :: { Error , ErrorKind } , headers :: AUTHORIZATION , policies :: { Policy , PolicyResult } , Context , Request , } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use async_lock :: RwLock ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use async_trait :: async_trait ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: sync :: Arc ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: time :: Duration ;"
    },
    {
      "type": "Struct",
      "ident": "BearerTokenCredentialPolicy",
      "fields": [
        "{",
        "credential",
        ":",
        "Arc",
        "<",
        "dyn",
        "TokenCredential",
        ">",
        ",",
        "scopes",
        ":",
        "Vec",
        "<",
        "String",
        ">",
        ",",
        "access_token",
        ":",
        "Arc",
        "<",
        "RwLock",
        "<",
        "Option",
        "<",
        "AccessToken",
        ">",
        ">",
        ">",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Default timeout in seconds before refreshing a new token.\"] const DEFAULT_REFRESH_TIME : Duration = Duration :: from_secs (120) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl BearerTokenCredentialPolicy { pub fn new < A , B > (credential : Arc < dyn TokenCredential > , scopes : A) -> Self where A : IntoIterator < Item = B > , B : Into < String > , { Self { credential , scopes : scopes . into_iter () . map (| s | s . into ()) . collect () , access_token : Arc :: new (RwLock :: new (None)) , } } fn scopes (& self) -> Vec < & str > { self . scopes . iter () . map (String :: as_str) . collect :: < Vec < & str > > () } async fn access_token (& self) -> Option < String > { let access_token = self . access_token . read () . await ; access_token . as_ref () . map (| s | s . token . secret () . to_string ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg_attr (target_arch = \"wasm32\" , async_trait (? Send))] # [cfg_attr (not (target_arch = \"wasm32\") , async_trait)] impl Policy for BearerTokenCredentialPolicy { async fn send (& self , ctx : & Context , request : & mut Request , next : & [Arc < dyn Policy >] ,) -> PolicyResult { let access_token = self . access_token . read () . await ; if let Some (token) = & (* access_token) { if token . is_expired (Some (DEFAULT_REFRESH_TIME)) { drop (access_token) ; let mut access_token = self . access_token . write () . await ; * access_token = Some (self . credential . get_token (& self . scopes ()) . await ?) ; } } else { drop (access_token) ; let mut access_token = self . access_token . write () . await ; * access_token = Some (self . credential . get_token (& self . scopes ()) . await ?) ; } let access_token = self . access_token () . await . ok_or_else (| | { Error :: message (ErrorKind :: Credential , \"The request failed due to an error while fetching the access token.\" ,) }) ? ; request . insert_header (AUTHORIZATION , format ! (\"Bearer {}\" , access_token)) ; next [0] . send (ctx , request , & next [1 ..]) . await } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod bearer_token_policy ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod telemetry ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use bearer_token_policy :: BearerTokenCredentialPolicy ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use telemetry :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use typespec_client_core :: http :: policies :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { HeaderValue , USER_AGENT } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: options :: TelemetryOptions ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { Context , Request } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: env :: consts :: { ARCH , OS } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: sync :: Arc ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: http :: policies :: { Policy , PolicyResult } ;"
    },
    {
      "type": "Struct",
      "ident": "TelemetryPolicy",
      "fields": [
        "{",
        "header",
        ":",
        "String",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [doc = \" Sets the User-Agent header with useful information in a typical format for Azure SDKs.\"] impl < 'a > TelemetryPolicy { pub fn new (crate_name : Option < & 'a str > , crate_version : Option < & 'a str > , options : & TelemetryOptions ,) -> Self { Self :: new_with_rustc_version (crate_name , crate_version , option_env ! (\"AZSDK_RUSTC_VERSION\") , options ,) } fn new_with_rustc_version (crate_name : Option < & 'a str > , crate_version : Option < & 'a str > , rustc_version : Option < & 'a str > , options : & TelemetryOptions ,) -> Self { const UNKNOWN : & str = \"unknown\" ; let mut crate_name = crate_name . unwrap_or (UNKNOWN) ; let crate_version = crate_version . unwrap_or (UNKNOWN) ; let rustc_version = rustc_version . unwrap_or (UNKNOWN) ; let platform_info = format ! (\"({rustc_version}; {OS}; {ARCH})\" ,) ; if let Some (name) = crate_name . strip_prefix (\"azure_\") { crate_name = name ; } let header = match & options . application_id { Some (application_id) => { format ! (\"{application_id} azsdk-rust-{crate_name}/{crate_version} {platform_info}\") } None => format ! (\"azsdk-rust-{crate_name}/{crate_version} {platform_info}\") , } ; TelemetryPolicy { header } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg_attr (target_arch = \"wasm32\" , async_trait :: async_trait (? Send))] # [cfg_attr (not (target_arch = \"wasm32\") , async_trait :: async_trait)] impl Policy for TelemetryPolicy { async fn send (& self , ctx : & Context , request : & mut Request , next : & [Arc < dyn Policy >] ,) -> PolicyResult { request . insert_header (USER_AGENT , HeaderValue :: from (self . header . to_string ())) ; next [0] . send (ctx , request , & next [1 ..]) . await } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg (test)] mod test { use super :: * ; # [test] fn test_without_application_id () { let policy = TelemetryPolicy :: new_with_rustc_version (Some (\"azure_test\") , Some (\"1.2.3\") , Some (\"4.5.6\") , & TelemetryOptions :: default () ,) ; assert_eq ! (policy . header , format ! (\"azsdk-rust-test/1.2.3 (4.5.6; {OS}; {ARCH})\")) ; } # [test] fn test_with_application_id () { let options = TelemetryOptions { application_id : Some (\"my_app\" . to_string ()) , } ; let policy = TelemetryPolicy :: new_with_rustc_version (Some (\"test\") , Some (\"1.2.3\") , Some (\"4.5.6\") , & options ,) ; assert_eq ! (policy . header , format ! (\"my_app azsdk-rust-test/1.2.3 (4.5.6; {OS}; {ARCH})\")) ; } # [test] fn test_missing_env () { let policy = TelemetryPolicy :: new_with_rustc_version (None , None , None , & TelemetryOptions :: default ()) ; assert_eq ! (policy . header , format ! (\"azsdk-rust-unknown/unknown (unknown; {OS}; {ARCH})\")) ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: error :: { Error , ErrorKind , ResultExt } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: fmt ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: str :: FromStr ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "const PREFIX : & str = \"bytes \" ;"
    },
    {
      "type": "Struct",
      "ident": "ContentRange",
      "fields": [
        "{",
        "start",
        ":",
        "u64",
        ",",
        "end",
        ":",
        "u64",
        ",",
        "total_length",
        ":",
        "u64",
        ",",
        "}"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl ContentRange { pub fn new (start : u64 , end : u64 , total_length : u64) -> ContentRange { ContentRange { start , end , total_length , } } pub fn start (& self) -> u64 { self . start } pub fn end (& self) -> u64 { self . end } pub fn total_length (& self) -> u64 { self . total_length } pub fn is_empty (& self) -> bool { self . end == self . start } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl FromStr for ContentRange { type Err = Error ; fn from_str (s : & str) -> crate :: Result < ContentRange > { let remaining = s . strip_prefix (PREFIX) . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{PREFIX}\\\" not found when parsing ContentRange from \\\"{s}\\\"\") }) }) ? ; if cfg ! (feature = \"azurite_workaround\") && remaining == \"0--1/0\" { return Ok (ContentRange { start : 0 , end : 0 , total_length : 0 , }) ; } let mut split_at_dash = remaining . split ('-') ; let start = split_at_dash . next () . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing ContentRange from \\\"{}\\\"\" , \"-\" , s) }) }) ? . parse () . map_kind (ErrorKind :: DataConversion) ? ; let mut split_at_slash = split_at_dash . next () . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing ContentRange from \\\"{}\\\"\" , \"-\" , s) }) }) ? . split ('/') ; let end = split_at_slash . next () . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing ContentRange from \\\"{}\\\"\" , \"/\" , s) }) }) ? . parse () . map_kind (ErrorKind :: DataConversion) ? ; let total_length = split_at_slash . next () . ok_or_else (| | { Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing ContentRange from \\\"{}\\\"\" , \"/\" , s) }) }) ? . parse () . map_kind (ErrorKind :: DataConversion) ? ; Ok (ContentRange { start , end , total_length , }) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl fmt :: Display for ContentRange { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { write ! (f , \"{}{}-{}/{}\" , PREFIX , self . start () , self . end () , self . total_length ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg (test)] mod test { use super :: * ; # [cfg (feature = \"azurite_workaround\")] # [test] fn test_azurite_workaround () { let range = \"bytes 0--1/0\" . parse :: < ContentRange > () . unwrap () ; assert_eq ! (range . start () , 0) ; assert_eq ! (range . end () , 0) ; assert_eq ! (range . total_length () , 0) ; } # [test] fn test_parse () { let range = \"bytes 172032-172489/172490\" . parse :: < ContentRange > () . unwrap () ; assert_eq ! (range . start () , 172032) ; assert_eq ! (range . end () , 172489) ; assert_eq ! (range . total_length () , 172490) ; } # [test] fn test_parse_no_starting_token () { \"something else\" . parse :: < ContentRange > () . unwrap_err () ; } # [test] fn test_parse_no_dash () { \"bytes 100\" . parse :: < ContentRange > () . unwrap_err () ; } # [test] fn test_parse_no_slash () { \"bytes 100-500\" . parse :: < ContentRange > () . unwrap_err () ; } # [test] fn test_display () { let range = ContentRange { start : 100 , end : 501 , total_length : 5000 , } ; let txt = format ! (\"{range}\") ; assert_eq ! (txt , \"bytes 100-501/5000\") ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { headers , Header } ;"
    },
    {
      "type": "Enum",
      "ident": "IfSequenceNumber",
      "variants": [
        "LessThan",
        "LessOrEqual",
        "Equal"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for IfSequenceNumber { fn name (& self) -> headers :: HeaderName { match self { IfSequenceNumber :: Equal (_) => headers :: IF_SEQUENCE_NUMBER_EQ , IfSequenceNumber :: LessOrEqual (_) => headers :: IF_SEQUENCE_NUMBER_LE , IfSequenceNumber :: LessThan (_) => headers :: IF_SEQUENCE_NUMBER_LT , } } fn value (& self) -> headers :: HeaderValue { match self { IfSequenceNumber :: Equal (val) | IfSequenceNumber :: LessOrEqual (val) | IfSequenceNumber :: LessThan (val) => val . to_string () . into () , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { self , Header } ;"
    },
    {
      "type": "Enum",
      "ident": "IfSourceMatchCondition",
      "variants": [
        "Match",
        "NotMatch"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for IfSourceMatchCondition { fn name (& self) -> headers :: HeaderName { match self { IfSourceMatchCondition :: Match (_) => headers :: SOURCE_IF_MATCH , IfSourceMatchCondition :: NotMatch (_) => headers :: SOURCE_IF_NONE_MATCH , } } fn value (& self) -> headers :: HeaderValue { match self . clone () { IfSourceMatchCondition :: Match (etag) | IfSourceMatchCondition :: NotMatch (etag) => { etag . into () } } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { date , headers :: { self , Header , HeaderName } , } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: date :: OffsetDateTime ;"
    },
    {
      "type": "Enum",
      "ident": "IfSourceModifiedSinceCondition",
      "variants": [
        "Modified",
        "Unmodified"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for IfSourceModifiedSinceCondition { fn name (& self) -> HeaderName { match self { IfSourceModifiedSinceCondition :: Modified (_) => headers :: SOURCE_IF_MODIFIED_SINCE , IfSourceModifiedSinceCondition :: Unmodified (_) => headers :: SOURCE_IF_UNMODIFIED_SINCE , } } fn value (& self) -> headers :: HeaderValue { match self { IfSourceModifiedSinceCondition :: Modified (date) | IfSourceModifiedSinceCondition :: Unmodified (date) => date :: to_rfc1123 (date) . into () , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { self , Header } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: str :: FromStr ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: Uuid ;"
    },
    {
      "type": "Struct",
      "ident": "LeaseId",
      "fields": [
        "(Uuid)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl std :: fmt :: Display for LeaseId { fn fmt (& self , fmt : & mut std :: fmt :: Formatter < '_ >) -> Result < () , std :: fmt :: Error > { self . 0 . fmt (fmt) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < Uuid > for LeaseId { fn from (value : Uuid) -> Self { Self (value) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl std :: str :: FromStr for LeaseId { type Err = < Uuid as FromStr > :: Err ; fn from_str (s : & str) -> Result < Self , Self :: Err > { Ok (Self (Uuid :: from_str (s) ?)) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for LeaseId { fn name (& self) -> headers :: HeaderName { headers :: LEASE_ID } fn value (& self) -> headers :: HeaderValue { format ! (\"{}\" , self . 0) . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { self , Header } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: time :: Duration ;"
    },
    {
      "type": "Struct",
      "ident": "LeaseBreakPeriod",
      "fields": [
        "(Duration)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < Duration > for LeaseBreakPeriod { fn from (duration : Duration) -> Self { Self (duration) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for LeaseBreakPeriod { fn name (& self) -> headers :: HeaderName { headers :: LEASE_BREAK_PERIOD } fn value (& self) -> headers :: HeaderValue { format ! (\"{}\" , self . 0 . as_secs ()) . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { self , Header } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: time :: Duration ;"
    },
    {
      "type": "Enum",
      "ident": "LeaseDuration",
      "variants": [
        "Infinite",
        "Seconds"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for LeaseDuration { fn name (& self) -> headers :: HeaderName { headers :: LEASE_DURATION } fn value (& self) -> headers :: HeaderValue { match self { LeaseDuration :: Infinite => \"-1\" . to_owned () , LeaseDuration :: Seconds (seconds) => { format ! (\"{seconds}\") } } . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < Duration > for LeaseDuration { fn from (d : Duration) -> Self { LeaseDuration :: Seconds (d . as_secs () as u8) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { self , Header } ;"
    },
    {
      "type": "Struct",
      "ident": "MaxItemCount",
      "fields": [
        "(i32)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl MaxItemCount { # [doc = \" Create a new `MaxItemCount`\"] pub fn new (count : i32) -> Self { Self (count) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for MaxItemCount { fn name (& self) -> headers :: HeaderName { headers :: MAX_ITEM_COUNT } fn value (& self) -> headers :: HeaderValue { let count = if self . 0 <= 0 { - 1 } else { self . 0 } ; format ! (\"{count}\") . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < i32 > for MaxItemCount { fn from (count : i32) -> Self { Self :: new (count) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Default for MaxItemCount { fn default () -> Self { MaxItemCount :: new (- 1) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { AppendToUrlQuery , Url } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: num :: NonZeroU32 ;"
    },
    {
      "type": "Struct",
      "ident": "MaxResults",
      "fields": [
        "(NonZeroU32)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl MaxResults { pub fn new (max_results : NonZeroU32) -> Self { Self (max_results) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AppendToUrlQuery for MaxResults { fn append_to_url_query (& self , url : & mut Url) { url . query_pairs_mut () . append_pair (\"maxresults\" , & format ! (\"{}\" , self . 0)) ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < NonZeroU32 > for MaxResults { fn from (max_results : NonZeroU32) -> Self { Self :: new (max_results) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl TryFrom < u32 > for MaxResults { type Error = String ; fn try_from (max_results : u32) -> Result < Self , Self :: Error > { match NonZeroU32 :: new (max_results) { Some (max_results) => Ok (max_results . into ()) , None => Err (format ! (\"number {max_results} is not a valid NonZeroU32 value\")) , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: Headers ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: Header ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use bytes :: Bytes ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: collections :: HashMap ;"
    },
    {
      "type": "Struct",
      "ident": "Metadata",
      "fields": [
        "(HashMap",
        "<",
        "String",
        ",",
        "Bytes",
        ">)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Default for Metadata { fn default () -> Self { Self :: new () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AsMut < HashMap < String , Bytes > > for Metadata { fn as_mut (& mut self) -> & mut HashMap < String , Bytes > { & mut self . 0 } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Metadata { pub fn new () -> Self { Self (HashMap :: new ()) } pub fn insert < K , V > (& mut self , k : K , v : V) -> Option < Bytes > where K : Into < String > , V : Into < Bytes > , { self . 0 . insert (k . into () , v . into ()) } pub fn len (& self) -> usize { self . 0 . len () } pub fn is_empty (& self) -> bool { self . 0 . is_empty () } pub fn get (& self , k : & str) -> Option < Bytes > { self . 0 . get (k) . cloned () } pub fn iter (& self) -> impl Iterator < Item = Metadatum > + '_ { self . 0 . iter () . map (| (key , value) | { Metadatum (key . clone () , std :: str :: from_utf8 (value) . expect (\"non-utf8 header value\") . into () ,) }) } }"
    },
    {
      "type": "Struct",
      "ident": "Metadatum",
      "fields": [
        "(String",
        ",",
        "String)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for Metadatum { fn name (& self) -> headers :: HeaderName { format ! (\"x-ms-meta-{}\" , self . 0) . into () } fn value (& self) -> headers :: HeaderValue { self . 1 . clone () . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & Headers > for Metadata { fn from (header_map : & Headers) -> Self { let mut metadata = Metadata :: new () ; header_map . iter () . for_each (| (name , value) | { let name = name . as_str () ; let value = value . as_str () ; if let Some (name) = name . strip_prefix (\"x-ms-meta-\") { metadata . insert (name . to_owned () , value . to_owned ()) ; } }) ; metadata } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod content_range ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod if_sequence_number ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod if_source_match_condition ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod if_source_modified_since_condition ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod lease ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod lease_break_period ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod lease_duration ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod max_item_count ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod max_results ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod metadata ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod next_marker ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod proposed_lease_id ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod range ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod sequence_number ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod source_lease_id ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "mod timeout ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { ACTIVITY_ID , APP , CLIENT_REQUEST_ID , CLIENT_VERSION , CONTENT_DISPOSITION , CONTINUATION , IF_TAGS , USER , VERSION , } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use content_range :: ContentRange ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use if_sequence_number :: IfSequenceNumber ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use if_source_match_condition :: IfSourceMatchCondition ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use if_source_modified_since_condition :: IfSourceModifiedSinceCondition ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use lease :: LeaseId ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use lease_break_period :: LeaseBreakPeriod ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use lease_duration :: LeaseDuration ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use max_item_count :: MaxItemCount ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use max_results :: MaxResults ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use metadata :: Metadata ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use next_marker :: NextMarker ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use proposed_lease_id :: ProposedLeaseId ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use range :: Range ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use sequence_number :: SequenceNumber ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use source_lease_id :: SourceLeaseId ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use timeout :: Timeout ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "pub use typespec_client_core :: http :: request :: options :: * ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: { request_header , request_query } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (# [doc = \" The (friendly) version identifier for the client making the request\"] ClientVersion , CLIENT_VERSION) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (# [doc = \" The (friendly) name of the user making the request\"] User , USER ,) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (ActivityId , ACTIVITY_ID) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (App , APP) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (ClientRequestId , CLIENT_REQUEST_ID) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (ContentDisposition , CONTENT_DISPOSITION) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (Continuation , CONTINUATION) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (IfTags , IF_TAGS) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_header ! (Version , VERSION) ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_query ! (# [doc = \" Set delimiter for the request\"] Delimiter , \"delimiter\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "request_query ! (Prefix , \"prefix\") ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { headers :: { self , Headers } , AppendToUrlQuery , Url , } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use serde :: { Deserialize , Serialize } ;"
    },
    {
      "type": "Struct",
      "ident": "NextMarker",
      "fields": [
        "(String)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl NextMarker { pub fn new (next_marker : String) -> Self { Self (next_marker) } pub fn from_possibly_empty_string (next_marker : Option < String >) -> Option < Self > { if let Some (\"\") = next_marker . as_deref () { None } else { next_marker . map (Into :: into) } } pub fn as_str (& self) -> & str { & self . 0 } pub fn append_to_url_query_as_continuation (& self , url : & mut Url) { url . query_pairs_mut () . append_pair (\"continuation\" , & self . 0) ; } pub fn from_header_optional (headers : & Headers) -> crate :: Result < Option < Self > > { let header_as_str = headers . get_optional_str (& headers :: CONTINUATION) ; Ok (header_as_str . filter (| h | ! h . is_empty ()) . map (| h | NextMarker :: new (h . to_owned ()))) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AppendToUrlQuery for NextMarker { fn append_to_url_query (& self , url : & mut Url) { url . query_pairs_mut () . append_pair (\"marker\" , & self . 0) ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < String > for NextMarker { fn from (next_marker : String) -> Self { Self :: new (next_marker) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & str > for NextMarker { fn from (next_marker : & str) -> Self { Self :: new (next_marker . to_owned ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use super :: LeaseId ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { headers , Header } ;"
    },
    {
      "type": "Struct",
      "ident": "ProposedLeaseId",
      "fields": [
        "(LeaseId)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < LeaseId > for ProposedLeaseId { fn from (lease_id : LeaseId) -> Self { Self (lease_id) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for ProposedLeaseId { fn name (& self) -> headers :: HeaderName { headers :: PROPOSED_LEASE_ID } fn value (& self) -> headers :: HeaderValue { format ! (\"{}\" , self . 0) . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: error :: { Error , ErrorKind , ResultExt } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { self , AsHeaders , HeaderName , HeaderValue } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: fmt ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: ops :: { Range as StdRange , RangeFrom } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: str :: FromStr ;"
    },
    {
      "type": "Enum",
      "ident": "Range",
      "variants": [
        "Range",
        "RangeFrom"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Range { pub fn new (start : u64 , end : u64) -> Range { (start .. end) . into () } fn optional_len (& self) -> Option < u64 > { match self { Range :: Range (r) => Some (r . end - r . start) , Range :: RangeFrom (_) => None , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < StdRange < u64 > > for Range { fn from (r : StdRange < u64 >) -> Self { Self :: Range (r) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < RangeFrom < u64 > > for Range { fn from (r : RangeFrom < u64 >) -> Self { Self :: RangeFrom (r) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < StdRange < usize > > for Range { fn from (r : StdRange < usize >) -> Self { (r . start as u64 .. r . end as u64) . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < RangeFrom < usize > > for Range { fn from (r : RangeFrom < usize >) -> Self { (r . start as u64 ..) . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AsHeaders for Range { type Error = std :: convert :: Infallible ; type Iter = std :: vec :: IntoIter < (HeaderName , HeaderValue) > ; fn as_headers (& self) -> Result < Self :: Iter , Self :: Error > { let mut headers = vec ! [(headers :: MS_RANGE , format ! (\"{self}\") . into ())] ; if let Some (len) = self . optional_len () { if len < 1024 * 1024 * 4 { headers . push ((headers :: RANGE_GET_CONTENT_CRC64 , HeaderValue :: from_static (\"true\") ,)) ; } } Ok (headers . into_iter ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl FromStr for Range { type Err = Error ; fn from_str (s : & str) -> crate :: Result < Range > { let v = s . split ('/') . collect :: < Vec < & str > > () ; if v . len () != 2 { return Err (Error :: with_message (ErrorKind :: Other , | | { format ! (\"expected token \\\"{}\\\" not found when parsing Range from \\\"{}\\\"\" , \"/\" , s) })) ; } let cp_start = v [0] . parse :: < u64 > () . map_kind (ErrorKind :: DataConversion) ? ; let cp_end = v [1] . parse :: < u64 > () . map_kind (ErrorKind :: DataConversion) ? + 1 ; Ok ((cp_start .. cp_end) . into ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl fmt :: Display for Range { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { match self { Range :: Range (r) => write ! (f , \"bytes={}-{}\" , r . start , r . end - 1) , Range :: RangeFrom (r) => write ! (f , \"bytes={}-\" , r . start) , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg (test)] mod test { use super :: * ; # [test] fn test_range_parse () { let range = \"1000/2000\" . parse :: < Range > () . unwrap () ; assert_eq ! (range , Range :: new (1000 , 2001)) ; } # [test] fn test_range_parse_panic_1 () { \"abba/2000\" . parse :: < Range > () . unwrap_err () ; } # [test] fn test_range_parse_panic_2 () { \"1000-2000\" . parse :: < Range > () . unwrap_err () ; } # [test] fn test_range_display () { let range = Range :: new (100 , 501) ; let txt = format ! (\"{range}\") ; assert_eq ! (txt , \"bytes=100-500\") ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { self , Header } ;"
    },
    {
      "type": "Struct",
      "ident": "SequenceNumber",
      "fields": [
        "(u64)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl SequenceNumber { pub fn new (max_results : u64) -> Self { Self (max_results) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < u64 > for SequenceNumber { fn from (max_results : u64) -> Self { Self :: new (max_results) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for SequenceNumber { fn name (& self) -> headers :: HeaderName { headers :: BLOB_SEQUENCE_NUMBER } fn value (& self) -> headers :: HeaderValue { self . 0 . to_string () . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: headers :: { self , Header } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: str :: FromStr ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use typespec_client_core :: Uuid ;"
    },
    {
      "type": "Struct",
      "ident": "SourceLeaseId",
      "fields": [
        "(Uuid)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl std :: fmt :: Display for SourceLeaseId { fn fmt (& self , fmt : & mut std :: fmt :: Formatter < '_ >) -> Result < () , std :: fmt :: Error > { self . 0 . fmt (fmt) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl std :: str :: FromStr for SourceLeaseId { type Err = < Uuid as FromStr > :: Err ; fn from_str (s : & str) -> Result < Self , Self :: Err > { Ok (Self (Uuid :: from_str (s) ?)) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Header for SourceLeaseId { fn name (& self) -> headers :: HeaderName { headers :: SOURCE_LEASE_ID } fn value (& self) -> headers :: HeaderValue { self . 0 . to_string () . into () } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: { AppendToUrlQuery , Url } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: time :: Duration ;"
    },
    {
      "type": "Struct",
      "ident": "Timeout",
      "fields": [
        "(Duration)"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl Timeout { pub fn new (duration : Duration) -> Self { Self (duration) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl AppendToUrlQuery for Timeout { fn append_to_url_query (& self , url : & mut Url) { if url . query_pairs () . any (| (k , _) | k == \"timeout\") { return ; } url . query_pairs_mut () . append_pair (\"timeout\" , & format ! (\"{}\" , self . 0 . as_secs ())) ; } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < Duration > for Timeout { fn from (d : Duration) -> Self { Self (d) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use crate :: error :: { Error , ErrorKind } ;"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "use std :: { fmt , str :: FromStr } ;"
    },
    {
      "type": "Enum",
      "ident": "TestMode",
      "variants": [
        "Playback",
        "Record",
        "Live"
      ]
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl TestMode { # [doc = \" Gets the `TestMode` from the `AZURE_TEST_MODE` environment variable or returns the default if undefined.\"] pub fn current () -> typespec :: Result < Self > { std :: env :: var (\"AZURE_TEST_MODE\") . map_or_else (| _ | Ok (TestMode :: default ()) , | v | v . parse ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl fmt :: Debug for TestMode { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { f . write_str (self . into ()) } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl From < & TestMode > for & 'static str { fn from (mode : & TestMode) -> Self { match mode { TestMode :: Playback => \"playback\" , TestMode :: Record => \"record\" , TestMode :: Live => \"live\" , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "impl FromStr for TestMode { type Err = Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { match s . to_ascii_lowercase () . as_str () { \"playback\" => Ok (Self :: Playback) , \"record\" => Ok (Self :: Record) , \"live\" => Ok (Self :: Live) , _ => Err (Error :: message (ErrorKind :: DataConversion , \"expected 'playback', 'record', or 'live'\" ,)) , } } }"
    },
    {
      "type": "Other",
      "kind": "unknown",
      "content": "# [cfg (feature = \"tokio_fs\")] pub use typespec_client_core :: fs :: * ;"
    }
  ]
}