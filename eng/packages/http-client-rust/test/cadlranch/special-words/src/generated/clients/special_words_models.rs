// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    And, As, Assert, Async, Await, Break, Class, Constructor, Continue, Def, Del, Elif, Else,
    Except, Exec, Finally, For, From, Global, If, Import, In, Is, Lambda, Not, Or, Pass, Raise,
    Return, Try, While, With, Yield,
};
use azure_core::builders::ClientMethodOptionsBuilder;
use azure_core::{
    AsClientMethodOptions, ClientMethodOptions, Context, Method, Pipeline, Request, RequestContent,
    Response, Result, Url,
};

pub struct SpecialWordsModels {
    pub(in crate::generated::clients) endpoint: Url,
    pub(in crate::generated::clients) pipeline: Pipeline,
}

impl SpecialWordsModels {
    pub async fn with_and(
        &self,
        body: RequestContent<And>,
        options: Option<SpecialWordsModelsWithAndOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/and");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_as(
        &self,
        body: RequestContent<As>,
        options: Option<SpecialWordsModelsWithAsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/as");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_assert(
        &self,
        body: RequestContent<Assert>,
        options: Option<SpecialWordsModelsWithAssertOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/assert");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_async(
        &self,
        body: RequestContent<Async>,
        options: Option<SpecialWordsModelsWithAsyncOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/async");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_await(
        &self,
        body: RequestContent<Await>,
        options: Option<SpecialWordsModelsWithAwaitOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/await");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_break(
        &self,
        body: RequestContent<Break>,
        options: Option<SpecialWordsModelsWithBreakOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/break");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_class(
        &self,
        body: RequestContent<Class>,
        options: Option<SpecialWordsModelsWithClassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/class");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_constructor(
        &self,
        body: RequestContent<Constructor>,
        options: Option<SpecialWordsModelsWithConstructorOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/constructor");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_continue(
        &self,
        body: RequestContent<Continue>,
        options: Option<SpecialWordsModelsWithContinueOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/continue");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_def(
        &self,
        body: RequestContent<Def>,
        options: Option<SpecialWordsModelsWithDefOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/def");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_del(
        &self,
        body: RequestContent<Del>,
        options: Option<SpecialWordsModelsWithDelOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/del");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_elif(
        &self,
        body: RequestContent<Elif>,
        options: Option<SpecialWordsModelsWithElifOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/elif");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_else(
        &self,
        body: RequestContent<Else>,
        options: Option<SpecialWordsModelsWithElseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/else");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_except(
        &self,
        body: RequestContent<Except>,
        options: Option<SpecialWordsModelsWithExceptOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/except");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_exec(
        &self,
        body: RequestContent<Exec>,
        options: Option<SpecialWordsModelsWithExecOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/exec");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_finally(
        &self,
        body: RequestContent<Finally>,
        options: Option<SpecialWordsModelsWithFinallyOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/finally");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_for(
        &self,
        body: RequestContent<For>,
        options: Option<SpecialWordsModelsWithForOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/for");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_from(
        &self,
        body: RequestContent<From>,
        options: Option<SpecialWordsModelsWithFromOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/from");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_global(
        &self,
        body: RequestContent<Global>,
        options: Option<SpecialWordsModelsWithGlobalOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/global");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_if(
        &self,
        body: RequestContent<If>,
        options: Option<SpecialWordsModelsWithIfOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/if");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_import(
        &self,
        body: RequestContent<Import>,
        options: Option<SpecialWordsModelsWithImportOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/import");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_in(
        &self,
        body: RequestContent<In>,
        options: Option<SpecialWordsModelsWithInOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/in");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_is(
        &self,
        body: RequestContent<Is>,
        options: Option<SpecialWordsModelsWithIsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/is");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_lambda(
        &self,
        body: RequestContent<Lambda>,
        options: Option<SpecialWordsModelsWithLambdaOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/lambda");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_not(
        &self,
        body: RequestContent<Not>,
        options: Option<SpecialWordsModelsWithNotOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/not");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_or(
        &self,
        body: RequestContent<Or>,
        options: Option<SpecialWordsModelsWithOrOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/or");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_pass(
        &self,
        body: RequestContent<Pass>,
        options: Option<SpecialWordsModelsWithPassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/pass");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_raise(
        &self,
        body: RequestContent<Raise>,
        options: Option<SpecialWordsModelsWithRaiseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/raise");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_return(
        &self,
        body: RequestContent<Return>,
        options: Option<SpecialWordsModelsWithReturnOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/return");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_try(
        &self,
        body: RequestContent<Try>,
        options: Option<SpecialWordsModelsWithTryOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/try");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_while(
        &self,
        body: RequestContent<While>,
        options: Option<SpecialWordsModelsWithWhileOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/while");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_with(
        &self,
        body: RequestContent<With>,
        options: Option<SpecialWordsModelsWithOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/with");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_yield(
        &self,
        body: RequestContent<Yield>,
        options: Option<SpecialWordsModelsWithYieldOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/yield");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithAndOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithAndOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithAndOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithAndOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithAsOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithAsOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithAsOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithAsOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithAssertOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithAssertOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithAssertOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithAssertOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithAsyncOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithAsyncOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithAsyncOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithAsyncOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithAwaitOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithAwaitOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithAwaitOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithAwaitOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithBreakOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithBreakOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithBreakOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithBreakOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithClassOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithClassOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithClassOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithClassOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithConstructorOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithConstructorOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithConstructorOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithConstructorOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithContinueOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithContinueOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithContinueOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithContinueOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithDefOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithDefOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithDefOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithDefOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithDelOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithDelOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithDelOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithDelOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithElifOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithElifOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithElifOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithElifOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithElseOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithElseOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithElseOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithElseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithExceptOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithExceptOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithExceptOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithExceptOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithExecOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithExecOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithExecOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithExecOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithFinallyOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithFinallyOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithFinallyOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithFinallyOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithForOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithForOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithForOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithForOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithFromOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithFromOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithFromOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithFromOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithGlobalOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithGlobalOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithGlobalOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithGlobalOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithIfOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithIfOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithIfOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithIfOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithImportOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithImportOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithImportOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithImportOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithInOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithInOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithInOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithInOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithIsOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithIsOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithIsOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithIsOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithLambdaOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithLambdaOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithLambdaOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithLambdaOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithNotOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithNotOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithNotOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithNotOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithOrOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithOrOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithOrOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithOrOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithPassOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithPassOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithPassOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithPassOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithRaiseOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithRaiseOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithRaiseOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithRaiseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithReturnOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithReturnOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithReturnOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithReturnOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithTryOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithTryOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithTryOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithTryOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithWhileOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithWhileOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithWhileOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithWhileOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsWithYieldOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsWithYieldOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsWithYieldOptionsBuilder<'a> {
        builders::SpecialWordsModelsWithYieldOptionsBuilder::new()
    }
}

pub mod builders {
    use super::*;

    pub struct SpecialWordsModelsWithAndOptionsBuilder<'a> {
        options: SpecialWordsModelsWithAndOptions<'a>,
    }

    impl SpecialWordsModelsWithAndOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithAndOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithAndOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithAndOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithAsOptionsBuilder<'a> {
        options: SpecialWordsModelsWithAsOptions<'a>,
    }

    impl SpecialWordsModelsWithAsOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithAsOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithAsOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithAsOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithAssertOptionsBuilder<'a> {
        options: SpecialWordsModelsWithAssertOptions<'a>,
    }

    impl SpecialWordsModelsWithAssertOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithAssertOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithAssertOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithAssertOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithAsyncOptionsBuilder<'a> {
        options: SpecialWordsModelsWithAsyncOptions<'a>,
    }

    impl SpecialWordsModelsWithAsyncOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithAsyncOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithAsyncOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithAsyncOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithAwaitOptionsBuilder<'a> {
        options: SpecialWordsModelsWithAwaitOptions<'a>,
    }

    impl SpecialWordsModelsWithAwaitOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithAwaitOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithAwaitOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithAwaitOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithBreakOptionsBuilder<'a> {
        options: SpecialWordsModelsWithBreakOptions<'a>,
    }

    impl SpecialWordsModelsWithBreakOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithBreakOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithBreakOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithBreakOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithClassOptionsBuilder<'a> {
        options: SpecialWordsModelsWithClassOptions<'a>,
    }

    impl SpecialWordsModelsWithClassOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithClassOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithClassOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithClassOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithConstructorOptionsBuilder<'a> {
        options: SpecialWordsModelsWithConstructorOptions<'a>,
    }

    impl SpecialWordsModelsWithConstructorOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithConstructorOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithConstructorOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithConstructorOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithContinueOptionsBuilder<'a> {
        options: SpecialWordsModelsWithContinueOptions<'a>,
    }

    impl SpecialWordsModelsWithContinueOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithContinueOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithContinueOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithContinueOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithDefOptionsBuilder<'a> {
        options: SpecialWordsModelsWithDefOptions<'a>,
    }

    impl SpecialWordsModelsWithDefOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithDefOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithDefOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithDefOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithDelOptionsBuilder<'a> {
        options: SpecialWordsModelsWithDelOptions<'a>,
    }

    impl SpecialWordsModelsWithDelOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithDelOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithDelOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithDelOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithElifOptionsBuilder<'a> {
        options: SpecialWordsModelsWithElifOptions<'a>,
    }

    impl SpecialWordsModelsWithElifOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithElifOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithElifOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithElifOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithElseOptionsBuilder<'a> {
        options: SpecialWordsModelsWithElseOptions<'a>,
    }

    impl SpecialWordsModelsWithElseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithElseOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithElseOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithElseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithExceptOptionsBuilder<'a> {
        options: SpecialWordsModelsWithExceptOptions<'a>,
    }

    impl SpecialWordsModelsWithExceptOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithExceptOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithExceptOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithExceptOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithExecOptionsBuilder<'a> {
        options: SpecialWordsModelsWithExecOptions<'a>,
    }

    impl SpecialWordsModelsWithExecOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithExecOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithExecOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithExecOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithFinallyOptionsBuilder<'a> {
        options: SpecialWordsModelsWithFinallyOptions<'a>,
    }

    impl SpecialWordsModelsWithFinallyOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithFinallyOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithFinallyOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithFinallyOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithForOptionsBuilder<'a> {
        options: SpecialWordsModelsWithForOptions<'a>,
    }

    impl SpecialWordsModelsWithForOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithForOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithForOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithForOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithFromOptionsBuilder<'a> {
        options: SpecialWordsModelsWithFromOptions<'a>,
    }

    impl SpecialWordsModelsWithFromOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithFromOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithFromOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithFromOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithGlobalOptionsBuilder<'a> {
        options: SpecialWordsModelsWithGlobalOptions<'a>,
    }

    impl SpecialWordsModelsWithGlobalOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithGlobalOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithGlobalOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithGlobalOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithIfOptionsBuilder<'a> {
        options: SpecialWordsModelsWithIfOptions<'a>,
    }

    impl SpecialWordsModelsWithIfOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithIfOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithIfOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithIfOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithImportOptionsBuilder<'a> {
        options: SpecialWordsModelsWithImportOptions<'a>,
    }

    impl SpecialWordsModelsWithImportOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithImportOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithImportOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithImportOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithInOptionsBuilder<'a> {
        options: SpecialWordsModelsWithInOptions<'a>,
    }

    impl SpecialWordsModelsWithInOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithInOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithInOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithInOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithIsOptionsBuilder<'a> {
        options: SpecialWordsModelsWithIsOptions<'a>,
    }

    impl SpecialWordsModelsWithIsOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithIsOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithIsOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithIsOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithLambdaOptionsBuilder<'a> {
        options: SpecialWordsModelsWithLambdaOptions<'a>,
    }

    impl SpecialWordsModelsWithLambdaOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithLambdaOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithLambdaOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithLambdaOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithNotOptionsBuilder<'a> {
        options: SpecialWordsModelsWithNotOptions<'a>,
    }

    impl SpecialWordsModelsWithNotOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithNotOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithNotOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithNotOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithOrOptionsBuilder<'a> {
        options: SpecialWordsModelsWithOrOptions<'a>,
    }

    impl SpecialWordsModelsWithOrOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithOrOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithOrOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithOrOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithPassOptionsBuilder<'a> {
        options: SpecialWordsModelsWithPassOptions<'a>,
    }

    impl SpecialWordsModelsWithPassOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithPassOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithPassOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithPassOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithRaiseOptionsBuilder<'a> {
        options: SpecialWordsModelsWithRaiseOptions<'a>,
    }

    impl SpecialWordsModelsWithRaiseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithRaiseOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithRaiseOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithRaiseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithReturnOptionsBuilder<'a> {
        options: SpecialWordsModelsWithReturnOptions<'a>,
    }

    impl SpecialWordsModelsWithReturnOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithReturnOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithReturnOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithReturnOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithTryOptionsBuilder<'a> {
        options: SpecialWordsModelsWithTryOptions<'a>,
    }

    impl SpecialWordsModelsWithTryOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithTryOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithTryOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithTryOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithWhileOptionsBuilder<'a> {
        options: SpecialWordsModelsWithWhileOptions<'a>,
    }

    impl SpecialWordsModelsWithWhileOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithWhileOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithWhileOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithWhileOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithOptionsBuilder<'a> {
        options: SpecialWordsModelsWithOptions<'a>,
    }

    impl SpecialWordsModelsWithOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsWithYieldOptionsBuilder<'a> {
        options: SpecialWordsModelsWithYieldOptions<'a>,
    }

    impl SpecialWordsModelsWithYieldOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsWithYieldOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsWithYieldOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsWithYieldOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }
}
