// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::RequestContent;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct And {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct As {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Assert {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Async {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Await {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Break {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Class {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Constructor {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Continue {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Def {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Del {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Elif {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Else {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Except {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Exec {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Finally {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct For {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct From {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Global {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct If {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Import {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct In {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Is {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Lambda {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Not {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Or {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Pass {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Raise {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Return {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct SameAsModel {
    #[serde(rename = "SameAsModel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub same_as_model: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Try {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct While {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct With {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[non_exhaustive]
pub struct Yield {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl TryFrom<And> for RequestContent<And> {
    type Error = azure_core::Error;
    fn try_from(value: And) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<As> for RequestContent<As> {
    type Error = azure_core::Error;
    fn try_from(value: As) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Assert> for RequestContent<Assert> {
    type Error = azure_core::Error;
    fn try_from(value: Assert) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Async> for RequestContent<Async> {
    type Error = azure_core::Error;
    fn try_from(value: Async) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Await> for RequestContent<Await> {
    type Error = azure_core::Error;
    fn try_from(value: Await) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Break> for RequestContent<Break> {
    type Error = azure_core::Error;
    fn try_from(value: Break) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Class> for RequestContent<Class> {
    type Error = azure_core::Error;
    fn try_from(value: Class) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Constructor> for RequestContent<Constructor> {
    type Error = azure_core::Error;
    fn try_from(value: Constructor) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Continue> for RequestContent<Continue> {
    type Error = azure_core::Error;
    fn try_from(value: Continue) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Def> for RequestContent<Def> {
    type Error = azure_core::Error;
    fn try_from(value: Def) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Del> for RequestContent<Del> {
    type Error = azure_core::Error;
    fn try_from(value: Del) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Elif> for RequestContent<Elif> {
    type Error = azure_core::Error;
    fn try_from(value: Elif) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Else> for RequestContent<Else> {
    type Error = azure_core::Error;
    fn try_from(value: Else) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Except> for RequestContent<Except> {
    type Error = azure_core::Error;
    fn try_from(value: Except) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Exec> for RequestContent<Exec> {
    type Error = azure_core::Error;
    fn try_from(value: Exec) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Finally> for RequestContent<Finally> {
    type Error = azure_core::Error;
    fn try_from(value: Finally) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<For> for RequestContent<For> {
    type Error = azure_core::Error;
    fn try_from(value: For) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<From> for RequestContent<From> {
    type Error = azure_core::Error;
    fn try_from(value: From) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Global> for RequestContent<Global> {
    type Error = azure_core::Error;
    fn try_from(value: Global) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<If> for RequestContent<If> {
    type Error = azure_core::Error;
    fn try_from(value: If) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Import> for RequestContent<Import> {
    type Error = azure_core::Error;
    fn try_from(value: Import) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<In> for RequestContent<In> {
    type Error = azure_core::Error;
    fn try_from(value: In) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Is> for RequestContent<Is> {
    type Error = azure_core::Error;
    fn try_from(value: Is) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Lambda> for RequestContent<Lambda> {
    type Error = azure_core::Error;
    fn try_from(value: Lambda) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Not> for RequestContent<Not> {
    type Error = azure_core::Error;
    fn try_from(value: Not) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Or> for RequestContent<Or> {
    type Error = azure_core::Error;
    fn try_from(value: Or) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Pass> for RequestContent<Pass> {
    type Error = azure_core::Error;
    fn try_from(value: Pass) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Raise> for RequestContent<Raise> {
    type Error = azure_core::Error;
    fn try_from(value: Raise) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Return> for RequestContent<Return> {
    type Error = azure_core::Error;
    fn try_from(value: Return) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<SameAsModel> for RequestContent<SameAsModel> {
    type Error = azure_core::Error;
    fn try_from(value: SameAsModel) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Try> for RequestContent<Try> {
    type Error = azure_core::Error;
    fn try_from(value: Try) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<While> for RequestContent<While> {
    type Error = azure_core::Error;
    fn try_from(value: While) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<With> for RequestContent<With> {
    type Error = azure_core::Error;
    fn try_from(value: With) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Yield> for RequestContent<Yield> {
    type Error = azure_core::Error;
    fn try_from(value: Yield) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}
