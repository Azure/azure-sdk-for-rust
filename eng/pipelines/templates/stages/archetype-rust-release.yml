parameters:
- name: Artifacts
  type: object
- name: TestPipeline
  type: boolean
  default: false
- name: PipelineArtifactName
  type: string
- name: ServiceDirectory
  type: string
- name: DependsOn
  type: string
  default: Build
- name: DevFeedName
  type: string
  default: 'public/azure-sdk-for-rust'

stages:
- ${{ if eq(variables['System.TeamProject'], 'internal') }}:
  - ${{ if in(variables['Build.Reason'], 'Manual', '') }}:
    - stage: Release_Batch
      displayName: "Releasing: ${{length(parameters.Artifacts)}} crates"
      dependsOn: ${{parameters.DependsOn}}
      condition: and(succeeded(), ne(variables['SetDevVersion'], 'true'), ne(variables['Skip.Release'], 'true'), ne(variables['Build.Repository.Name'], 'Azure/azure-sdk-for-rust-pr'))
      variables:
      - template: /eng/pipelines/templates/variables/globals.yml
      - template: /eng/pipelines/templates/variables/image.yml
      - template: /eng/pipelines/templates/variables/rust.yml

      pool:
        name: $(LINUXPOOL)
        image: $(LINUXVMIMAGE)
        os: linux

      jobs:
      # TODO: Ensure that CHANGELOG is properly processed
      - job: TagRepository
        displayName: "Create release tag"
        condition: and(succeeded(), ne(variables['Skip.TagRepository'], 'true'))

        steps:
        - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml

        - download: current
          displayName: Download ${{parameters.PipelineArtifactName}} artifact
          artifact: ${{parameters.PipelineArtifactName}}

        - template: /eng/common/pipelines/templates/steps/retain-run.yml

        - ${{ each artifact in parameters.Artifacts }}:
          - script: |
              echo "##vso[build.addbuildtag]${{artifact.name}}"
            displayName: Add build tag '${{artifact.name}}'

          - template: /eng/common/pipelines/templates/steps/create-tags-and-git-release.yml
            parameters:
              ArtifactLocation: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}/${{artifact.name}}
              PackageRepository: Crates.io
              ReleaseSha: $(Build.SourceVersion)
              WorkingDirectory: $(Pipeline.Workspace)/_work

      - deployment: PublishPackage
        displayName: "Publish to Crates.io"
        condition: and(succeeded(), ne(variables['Skip.PublishPackage'], 'true'))
        templateContext:
          type: releaseJob  # Required, this indicates this deployment job is a release job
          isProduction: true  # Required, must be 'true' or 'false'
          inputs:  # All input build artifacts must be declared here
          - input: pipelineArtifact  # Required, type of the input artifact
            artifactName: ${{parameters.PipelineArtifactName}}  # Required, name of the pipeline artifact
            targetPath: $(Pipeline.Workspace)/drop  # Optional, specifies where the artifact is downloaded to
        ${{if parameters.TestPipeline}}:
          environment: none
        ${{else}}:
          environment: cratesio
        # This timeout shouldn't be necessary once we're able to parallelize better. Right now,
        # this is here to ensure larger areas (30+) libraries don't time out.
        timeoutInMinutes: 120
        dependsOn: TagRepository
        pool:
          name: azsdk-pool
          image: ubuntu-24.04
          os: linux
        strategy:
          runOnce:
            deploy:
              steps:
                - ${{ each artifact in parameters.Artifacts }}:
                  - pwsh: |
                      $ArtifactName = '${{artifact.name}}'
                      $ArtifactRootPath = '$(Pipeline.Workspace)/drop'
                      $OutDir = '$(Pipeline.Workspace)/esrp-release'

                      Write-Host "Cleaning output directory: $OutDir"
                      if (Test-Path $OutDir) {
                        Remove-Item -Path $OutDir -Recurse -Force
                      }
                      New-Item -ItemType Directory -Path $OutDir -Force | Out-Null

                      Write-Host "Artifact name: $ArtifactName"

                      $packageMetadataPath = "$ArtifactRootPath/PackageInfo/$ArtifactName.json"
                      if (!(Test-Path $packageMetadataPath)) {
                        Write-Error "Package metadata file not found: $packageMetadataPath"
                        exit 1
                      }

                      $packageMetadata = Get-Content -Raw $packageMetadataPath | ConvertFrom-Json
                      $packageVersion = $packageMetadata.version
                      Write-Host "Package version: $packageVersion"

                      $cratePath = "$ArtifactRootPath/$ArtifactName/$ArtifactName-$packageVersion.crate"
                      Get-ChildItem "$ArtifactRootPath" -Recurse | ForEach-Object { Write-Host $_.FullName }
                      Copy-Item `
                        -Path $cratePath `
                        -Destination $OutDir
                      Write-Host "Contents of $OutDir"
                      Get-ChildItem -Path $OutDir | ForEach-Object { Write-Host $_.FullName }
                    displayName: 'Copy crate for ESRP: ${{artifact.name}}'
                  
                  - task: EsrpRelease@10
                    displayName: 'ESRP Release: ${{artifact.name}}'
                    inputs:
                      connectedservicename: 'Azure SDK PME Managed Identity'
                      ClientId: '5f81938c-2544-4f1f-9251-dd9de5b8a81b'
                      DomainTenantId: '975f013f-7f24-47e8-a7d3-abc4752bf346'
                      Usemanagedidentity: true
                      KeyVaultName: 'kv-azuresdk-codesign'
                      SignCertName: 'azure-sdk-esrp-release-certificate'
                      intent: 'packagedistribution'
                      contenttype: 'Rust'
                      contentsource: 'Folder'
                      folderlocation: '$(Pipeline.Workspace)/esrp-release'
                      waitforreleasecompletion: true
                      owners: ${{ coalesce(variables['Build.RequestedForEmail'], 'azuresdk@microsoft.com') }}
                      approvers: ${{ coalesce(variables['Build.RequestedForEmail'], 'azuresdk@microsoft.com') }}
                      serviceendpointurl: 'https://api.esrp.microsoft.com/'
                      mainpublisher: 'ESRPRELPACMANTEST'

      - job: UpdatePackageVersion
        displayName: "API Review and Package Version Update"
        condition: and(succeeded(), ne(variables['Skip.UpdatePackageVersion'], 'true'))
        dependsOn: PublishPackage
        steps:
        - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml
          parameters:
            paths:
            - "/*"

        - template: /eng/pipelines/templates/steps/use-rust.yml@self
          parameters:
            Toolchain: nightly

        - download: current
          displayName: Download ${{parameters.PipelineArtifactName}} artifact
          artifact: ${{parameters.PipelineArtifactName}}

        - ${{each artifact in parameters.Artifacts }}:
          - template: /eng/common/pipelines/templates/steps/create-apireview.yml
            parameters:
              ArtifactPath: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}
              Artifacts: ${{parameters.Artifacts}}
              ConfigFileDir: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}/PackageInfo
              MarkPackageAsShipped: true
              ArtifactName: ${{parameters.PipelineArtifactName}}
              SourceRootPath: $(System.DefaultWorkingDirectory)
              PackageName: ${{artifact.name}}

          # Apply the version increment to each library, which updates the Cargo.toml and changelog files.
          - task: PowerShell@2
            displayName: Increment ${{artifact.name}} version
            inputs:
              targetType: filePath
              filePath: $(Build.SourcesDirectory)/eng/scripts/Update-PackageVersion.ps1
              arguments: >
                -ServiceDirectory '${{parameters.ServiceDirectory}}'
                -PackageName '${{artifact.name}}'

          - template: /eng/common/pipelines/templates/steps/create-pull-request.yml
            parameters:
              PRBranchName: increment-package-version-${{parameters.ServiceDirectory}}-$(Build.BuildId)
              CommitMsg: "Increment package version after release of ${{ artifact.name }}"
              PRTitle: "Increment versions for ${{parameters.ServiceDirectory}} releases"
              CloseAfterOpenForTesting: '${{parameters.TestPipeline}}'
              ${{ if startsWith(variables['Build.SourceBranch'], 'refs/pull/') }}:
                BaseBranchName: main
