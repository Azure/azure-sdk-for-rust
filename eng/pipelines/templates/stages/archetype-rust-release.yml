parameters:
- name: Artifacts
  type: object
- name: TestPipeline
  type: boolean
  default: false
- name: PipelineArtifactName
  type: string
- name: ServiceDirectory
  type: string
- name: DependsOn
  type: string
  default: Build
- name: DevFeedName
  type: string
  default: 'public/azure-sdk-for-rust'
- name: Environment
  type: string
  default: 'cratesio'

stages:
- ${{ if eq(variables['System.TeamProject'], 'internal') }}:
  - ${{ if in(variables['Build.Reason'], 'Manual', '') }}:
    - ${{ each artifact in parameters.Artifacts }}:
      - stage: Release_${{artifact.safeName}}
        displayName: "Release: ${{artifact.name}}"
        dependsOn: ${{parameters.DependsOn}}
        condition: and(succeeded(), ne(variables['SetDevVersion'], 'true'), ne(variables['Skip.Release'], 'true'), ne(variables['Build.Repository.Name'], 'Azure/azure-sdk-for-rust-pr'))
        variables:
        - template: /eng/pipelines/templates/variables/globals.yml
        - template: /eng/pipelines/templates/variables/image.yml
        - template: /eng/pipelines/templates/variables/rust.yml

        pool:
          name: $(LINUXPOOL)
          image: $(LINUXVMIMAGE)
          os: linux

        jobs:
        # TODO: Ensure that CHANGELOG is properly processed
        # - job: TagRepository
        #   displayName: "Create release tag"
        #   condition: and(succeeded(), ne(variables['Skip.TagRepository'], 'true'))

        #   steps:
        #   - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml

        #   - download: current
        #     displayName: Download ${{parameters.PipelineArtifactName}} artifact
        #     artifact: ${{parameters.PipelineArtifactName}}

        #   - template: /eng/common/pipelines/templates/steps/retain-run.yml

        #   - script: |
        #       echo "##vso[build.addbuildtag]${{artifact.name}}"
        #     displayName: Add build tag '${{artifact.name}}'

        #   - template: /eng/common/pipelines/templates/steps/create-tags-and-git-release.yml
        #     parameters:
        #       ArtifactLocation: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}/${{artifact.name}}
        #       PackageRepository: Crates.io
        #       ReleaseSha: $(Build.SourceVersion)
        #       WorkingDirectory: $(Pipeline.Workspace)/_work

        - deployment: PublishPackage
          displayName: "Publish to Crates.io"
          condition: and(succeeded(), ne(variables['Skip.PublishPackage'], 'true'))
          templateContext:
            type: releaseJob  # Required, this indicates this deployment job is a release job
            isProduction: true  # Required, must be 'true' or 'false'
            inputs:  # All input build artifacts must be declared here
            - input: pipelineArtifact  # Required, type of the input artifact
              artifactName: ${{parameters.PipelineArtifactName}}  # Required, name of the pipeline artifact
              targetPath: $(Pipeline.Workspace)/drop  # Optional, specifies where the artifact is downloaded to
          environment: ${{parameters.Environment}}
          # This timeout shouldn't be necessary once we're able to parallelize better. Right now,
          # this is here to ensure larger areas (30+) libraries don't time out.
          timeoutInMinutes: 120
          # dependsOn: TagRepository
          pool:
            name: azsdk-pool
            image: ubuntu-24.04
            os: linux
          strategy:
            runOnce:
              deploy:
                steps:
                  - template: /eng/pipelines/templates/steps/use-rust.yml@self
                    parameters:
                      Toolchain: stable

                  - pwsh: |
                      $ArtifactName = '${{artifact.name}}'
                      $ArtifactRootPath = '$(Pipeline.Workspace)/drop'
                      $OutDir = '$(Pipeline.Workspace)/esrp-release'

                      Write-Host "Artifact name: $ArtifactName"

                      $packageMetadataPath = "$ArtifactRootPath/PackageInfo/$ArtifactName.json"
                      if (!(Test-Path $packageMetadataPath)) {
                        Write-Error "Package metadata file not found: $packageMetadataPath"
                        exit 1
                      }

                      $packageMetadata = Get-Content -Raw $packageMetadataPath | ConvertFrom-Json
                      $packageVersion = $packageMetadata.version
                      Write-Host "Package version: $packageVersion"

                      New-Item -ItemType Directory -Path $OutDir -Force | Out-Null
                      Compress-Archive `
                        -Path "$ArtifactRootPath/$ArtifactName/$ArtifactName-$packageVersion.crate" `
                        -DestinationPath "$OutDir/release.zip"

                      Write-Host "Contents of $OutDir"
                      Get-ChildItem -Path $OutDir | ForEach-Object { Write-Host $_.FullName }

                    displayName: Compress Crate for ESRP

                  - task: EsrpRelease@10
                    displayName: 'ESRP Release'
                    inputs:
                      connectedservicename: 'Azure SDK PME Managed Identity'
                      ClientId: '5f81938c-2544-4f1f-9251-dd9de5b8a81b'
                      DomainTenantId: '975f013f-7f24-47e8-a7d3-abc4752bf346'
                      Usemanagedidentity: true
                      intent: 'packagedistribution'
                      contenttype: 'Rust'
                      contentsource: 'Folder'
                      folderlocation: '$(Pipeline.Workspace)/esrp-release'
                      waitforreleasecompletion: true
                      owners: ${{ coalesce(variables['Build.RequestedForEmail'], 'azuresdk@microsoft.com') }}
                      approvers: ${{ coalesce(variables['Build.RequestedForEmail'], 'azuresdk@microsoft.com') }}
                      serviceendpointurl: 'https://api.esrp.microsoft.com/'
                      mainpublisher: 'ESRPRELPACMAN'
                      domaintenantid: '72f988bf-86f1-41af-91ab-2d7cd011db47'

                # - pwsh: |
                #     $additionalOwners = @('heaths', 'hallipr')
                #     $token = $env:CARGO_REGISTRY_TOKEN
                #     $crateName = '${{artifact.name}}'

                #     $manifestPath = "$(Pipeline.Workspace)/drop/$crateName/contents/Cargo.toml"
                #     Write-Host "> cargo publish --manifest-path `"$manifestPath`""
                #     cargo publish --manifest-path $manifestPath
                #     if (!$?) {
                #       Write-Error "Failed to publish package: '$crateName'"
                #       exit 1
                #     }

                #     $existingOwners = (cargo owner --list $crateName) -replace " \(.*", ""
                #     $missingOwners = $additionalOwners | Where-Object { $existingOwners -notcontains $_ }

                #     foreach ($owner in $missingOwners) {
                #       Write-Host "> cargo owner --add $owner $crateName"
                #       cargo owner --add $owner $crateName
                #     }
                #   displayName: Publish Crate
                #   env:
                #     CARGO_REGISTRY_TOKEN: $(azure-sdk-cratesio-token)

        - job: UpdatePackageVersion
          displayName: "API Review and Package Version Update"
          condition: and(succeeded(), ne(variables['Skip.UpdatePackageVersion'], 'true'))
          dependsOn: PublishPackage
          steps:
          - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml
            parameters:
              paths:
              - "/*"

          - template: /eng/pipelines/templates/steps/use-rust.yml@self
            parameters:
              Toolchain: nightly

          - download: current
            displayName: Download ${{parameters.PipelineArtifactName}} artifact
            artifact: ${{parameters.PipelineArtifactName}}

          - template: /eng/common/pipelines/templates/steps/create-apireview.yml
            parameters:
              ArtifactPath: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}
              Artifacts: ${{parameters.Artifacts}}
              ConfigFileDir: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}/PackageInfo
              MarkPackageAsShipped: true
              ArtifactName: ${{parameters.PipelineArtifactName}}
              SourceRootPath: $(System.DefaultWorkingDirectory)
              PackageName: ${{artifact.name}}

          # Apply the version increment to each library, which updates the Cargo.toml and changelog files.
          - task: PowerShell@2
            displayName: Increment ${{artifact.name}} version
            inputs:
              targetType: filePath
              filePath: $(Build.SourcesDirectory)/eng/scripts/Update-PackageVersion.ps1
              arguments: >
                -ServiceDirectory '${{parameters.ServiceDirectory}}'
                -PackageName '${{artifact.name}}'

          - template: /eng/common/pipelines/templates/steps/create-pull-request.yml
            parameters:
              PRBranchName: increment-package-version-${{parameters.ServiceDirectory}}-$(Build.BuildId)
              CommitMsg: "Increment package version after release of ${{ artifact.name }}"
              PRTitle: "Increment versions for ${{parameters.ServiceDirectory}} releases"
              CloseAfterOpenForTesting: '${{parameters.TestPipeline}}'
              ${{ if startsWith(variables['Build.SourceBranch'], 'refs/pull/') }}:
                BaseBranchName: main
