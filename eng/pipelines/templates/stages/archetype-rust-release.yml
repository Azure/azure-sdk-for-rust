parameters:
- name: Artifacts
  type: object
- name: TestPipeline
  type: boolean
  default: false
- name: PipelineArtifactName
  type: string
- name: ServiceDirectory
  type: string
- name: DependsOn
  type: string
  default: Build
- name: DevFeedName
  type: string
  default: 'public/azure-sdk-for-rust'

stages:
- ${{ if eq(variables['System.TeamProject'], 'internal') }}:
  - ${{ if in(variables['Build.Reason'], 'Manual', '') }}:
    - ${{ if gt(length(parameters.Artifacts), 0) }}:
      - stage: Release_Batch
        displayName: "Releasing: ${{length(parameters.Artifacts)}} crates"
        dependsOn: ${{parameters.DependsOn}}
        condition: and(succeeded(), ne(variables['SetDevVersion'], 'true'), ne(variables['Skip.Release'], 'true'), ne(variables['Build.Repository.Name'], 'Azure/azure-sdk-for-rust-pr'))
        variables:
        - template: /eng/pipelines/templates/variables/globals.yml
        - template: /eng/pipelines/templates/variables/image.yml
        - template: /eng/pipelines/templates/variables/rust.yml

        pool:
          name: $(LINUXPOOL)
          image: $(LINUXVMIMAGE)
          os: linux

        jobs:
        - job: TagRepository
          displayName: "Create release tag"
          condition: and(succeeded(), ne(variables['Skip.TagRepository'], 'true'))

          steps:
          - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml

          - download: current
            displayName: Download ${{parameters.PipelineArtifactName}} artifact
            artifact: ${{parameters.PipelineArtifactName}}

          - template: /eng/common/pipelines/templates/steps/retain-run.yml

          - ${{ each artifact in parameters.Artifacts }}:
            - script: |
                echo "##vso[build.addbuildtag]${{artifact.name}}"
              displayName: Add build tag '${{artifact.name}}'

            - template: /eng/common/pipelines/templates/steps/create-tags-and-git-release.yml
              parameters:
                ArtifactLocation: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}/${{artifact.name}}
                PackageRepository: Crates.io
                ReleaseSha: $(Build.SourceVersion)
                WorkingDirectory: $(Pipeline.Workspace)/_work

        - deployment: PublishPackage
          displayName: "Publish to Crates.io"
          condition: and(succeeded(), ne(variables['Skip.PublishPackage'], 'true'))
          templateContext:
            type: releaseJob  # Required, this indicates this deployment job is a release job
            isProduction: true  # Required, must be 'true' or 'false'
            inputs:  # All input build artifacts must be declared here
            - input: pipelineArtifact  # Required, type of the input artifact
              artifactName: ${{parameters.PipelineArtifactName}}  # Required, name of the pipeline artifact
              targetPath: $(Pipeline.Workspace)/drop  # Optional, specifies where the artifact is downloaded to
          ${{if parameters.TestPipeline}}:
            environment: none
          ${{else}}:
            environment: package-publish
          # This timeout shouldn't be necessary once we're able to parallelize better. Right now,
          # this is here to ensure larger areas (30+) libraries don't time out.
          timeoutInMinutes: 120
          dependsOn: TagRepository
          pool:
            name: azsdk-pool
            image: ubuntu-24.04
            os: linux
          strategy:
            runOnce:
              deploy:
                steps:
                  - pwsh: |
                      Write-Host "Setting ArtifactName to empty"
                      Write-Host "##vso[task.setvariable variable=ArtifactName;]"
                    displayName: Initialize ArtifactName variable

                  # This loop over the artifacts never uses `artifact` directly.
                  # It is instead used to generate the correct number of tasks
                  # for publishing each artifact in an order specified in the
                  # release-order.json file.
                  - ${{ each artifact in parameters.Artifacts }}:
                    - pwsh: |
                        $artifacts = Get-Content '$(Pipeline.Workspace)/drop/release-order.json' | ConvertFrom-Json

                        # Force $artifacts to be an array (PowerShell unrolls single-item arrays)
                        if ($artifacts -isnot [Array]) {
                          $artifacts = @($artifacts)
                        }

                        $artifactName = '$(ArtifactName)'
                        if (!$artifactName) {
                            $artifactName = $artifacts[0]
                        }

                        Write-Host "Releasing artifact: $artifactName"

                        $artifactRootPath = '$(Pipeline.Workspace)/drop'
                        $outDir = '$(Pipeline.Workspace)/esrp-release'

                        if (Test-Path $outDir) {
                          Write-Host "Cleaning output directory: $outDir"
                          Remove-Item -Path $outDir -Recurse -Force
                        }
                        New-Item -ItemType Directory -Path $outDir -Force | Out-Null

                        $packageMetadataPath = "$artifactRootPath/PackageInfo/$artifactName.json"
                        if (!(Test-Path $packageMetadataPath)) {
                          Write-Error "Package metadata file not found: $packageMetadataPath"
                          exit 1
                        }

                        $packageMetadata = Get-Content -Raw $packageMetadataPath | ConvertFrom-Json
                        $packageVersion = $packageMetadata.version
                        Write-Host "Package version: $packageVersion"

                        $cratePath = "$artifactRootPath/$artifactName/$artifactName-$packageVersion.crate"
                        Copy-Item `
                          -Path $cratePath `
                          -Destination $outDir
                        Write-Host "Contents of $outDir"
                        Get-ChildItem -Path $outDir | ForEach-Object { Write-Host $_.FullName }

                        # Set next artifact to release by
                        $artifactIndex = $artifacts.IndexOf($artifactName)
                        $nextArtifactName = $artifacts[$artifactIndex + 1]
                        Write-Host "Next artifact to release: $nextArtifactName"
                        Write-Host "##vso[task.setvariable variable=ArtifactName]$nextArtifactName"
                      displayName: 'Copy crate for ESRP'

                    - task: EsrpRelease@10
                      displayName: 'ESRP Release'
                      inputs:
                        connectedservicename: 'Azure SDK PME Managed Identity'
                        ClientId: '5f81938c-2544-4f1f-9251-dd9de5b8a81b'
                        DomainTenantId: '975f013f-7f24-47e8-a7d3-abc4752bf346'
                        Usemanagedidentity: true
                        KeyVaultName: 'kv-azuresdk-codesign'
                        SignCertName: 'azure-sdk-esrp-release-certificate'
                        intent: 'packagedistribution'
                        contenttype: 'Rust'
                        contentsource: 'Folder'
                        folderlocation: '$(Pipeline.Workspace)/esrp-release'
                        waitforreleasecompletion: true
                        owners: ${{ coalesce(variables['Build.RequestedForEmail'], 'azuresdk@microsoft.com') }}
                        approvers: ${{ coalesce(variables['Build.RequestedForEmail'], 'azuresdk@microsoft.com') }}
                        serviceendpointurl: 'https://api.esrp.microsoft.com/'
                        mainpublisher: 'ESRPRELPACMANTEST'

        - job: UpdatePackageVersion
          displayName: "API Review and Package Version Update"
          condition: and(succeeded(), ne(variables['Skip.UpdatePackageVersion'], 'true'))
          dependsOn: PublishPackage
          steps:
          - template: /eng/common/pipelines/templates/steps/sparse-checkout.yml
            parameters:
              paths:
              - "/*"

          - template: /eng/pipelines/templates/steps/use-rust.yml@self
            parameters:
              Toolchain: nightly

          - download: current
            displayName: Download ${{parameters.PipelineArtifactName}} artifact
            artifact: ${{parameters.PipelineArtifactName}}

          - ${{ each artifact in parameters.Artifacts }}:
            - template: /eng/common/pipelines/templates/steps/create-apireview.yml
              parameters:
                ArtifactPath: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}
                Artifacts: ${{parameters.Artifacts}}
                ConfigFileDir: $(Pipeline.Workspace)/${{parameters.PipelineArtifactName}}/PackageInfo
                MarkPackageAsShipped: true
                ArtifactName: ${{parameters.PipelineArtifactName}}
                SourceRootPath: $(System.DefaultWorkingDirectory)
                PackageName: ${{artifact.name}}

            # Apply the version increment to each library, which updates the Cargo.toml and changelog files.
            - task: PowerShell@2
              displayName: Increment ${{artifact.name}} version
              inputs:
                targetType: filePath
                filePath: $(Build.SourcesDirectory)/eng/scripts/Update-PackageVersion.ps1
                arguments: >
                  -ServiceDirectory '${{parameters.ServiceDirectory}}'
                  -PackageName '${{artifact.name}}'

          - template: /eng/common/pipelines/templates/steps/create-pull-request.yml
            parameters:
              PRBranchName: increment-package-version-${{parameters.ServiceDirectory}}-$(Build.BuildId)
              CommitMsg: "Increment package version after release of ${{ join(', ', parameters.Artifacts.*.name) }}"
              PRTitle: "Increment versions for ${{parameters.ServiceDirectory}} releases"
              CloseAfterOpenForTesting: '${{parameters.TestPipeline}}'
              ${{ if startsWith(variables['Build.SourceBranch'], 'refs/pull/') }}:
                BaseBranchName: main
