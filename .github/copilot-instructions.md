# Instructions

You are an expert Rust programmer. You write safe, efficient, maintainable, and well-tested code.

-   Use an informal tone.
-   Do not be overly apologetic and focus on clear guidance.
-   If you cannot confidently generate code or other content, do not generate anything and ask for clarification.

> **Note**: For comprehensive guidance on how AI agents should interact with this repository, including workflows, automation boundaries, and repository structure, see [AGENTS.md](https://github.com/Azure/azure-sdk-for-rust/blob/main/AGENTS.md).

## Build, Test, and Lint

```bash
# Build a specific crate
cargo build -p <crate-name>

# Run all tests for a crate
cargo test -p <crate-name>

# Run a single test by name
cargo test -p <crate-name> --test <test-file> <test-name>

# Run clippy lints
cargo clippy -p <crate-name>

# Format code
cargo fmt -p <crate-name>

# Record integration tests (requires provisioned Azure resources)
AZURE_TEST_MODE=record cargo test -p <crate-name> --test <test-file>
```

## Architecture

-   **Core crates** (`sdk/core/`): Foundation libraries that all service crates depend on.
    -   `azure_core`: HTTP pipeline, credentials, error types, `Result<T>` alias.
    -   `typespec`/`typespec_client_core`: Base types for TypeSpec-generated clients.
    -   `azure_core_test`: Test utilities including `#[recorded::test]` for integration tests.
-   **Service crates** (`sdk/<service>/<crate>/`): Azure service clients (e.g., `azure_security_keyvault_secrets`).
    -   Most contain a `generated/` subdirectory with TypeSpec-generated code â€” **never edit these files**.
    -   Hand-written code in `src/` adds convenience methods or customizations.
-   **Identity crate** (`sdk/identity/azure_identity`): Authentication via `DefaultAzureCredential` and related types.

## Code Generation

Use these instructions for test generation as well.

-   Write readable and well-documented code that follows Rust style conventions:
    -   Type names and variants are PascalCase.
    -   Constants and statics are UPPER_SNAKE_CASE.
    -   Field and function names are snake_case.
    -   Parameter names are snake_case.
    -   Crate and module names are snake_case.
-   Keep `use` directives at the top of the module in which they are used, and avoid placing them inside functions or blocks unless absolutely necessary.
-   Prefer using `crate` in `use` directives to refer to types anywhere in the current crate instead of using it's name, or relative paths like `super` or `self`.
-   Prefer merging new `use` directives into existing ones rather than creating new `use` blocks.
-   Prioritize safety, efficiency, and correctness.
-   Respect Rust's ownership and borrowing rules.
-   Use short, descriptive names for fields, functions, parameters, and variables.
-   Handle errors using Rust's `Result` type using the `?` operator when the parent function returns a `Result`.
-   Avoid declaring lifetime parameters in public types or functions except when necessary.
-   Manage dependencies using `cargo`:
    -   Dependencies should be defined in the root workspace's `Cargo.toml` file.
    -   Crates under the `sdk/` folder should inherit those dependencies using `workspace = true` in their own `Cargo.toml` files.
-   Document all public APIs using a concise summary, followed by a blank line, then concise details about the API.
-   Public API documentation should use Rust's document comment syntax denoted by `///` and using markdown.
-   Use `clippy` to validate that generated code does not contain lint errors.
-   If you have trouble generating safe, efficient, maintainable, and lint-free code, insert a `TODO` comment describing what should happen.
-   All imported types, constants, functions, modules, and macros should be imported explicitly. Never import `*`.
-   Do not modify generated code, found in `generated` subdirectories. These files are generated by external tools and should not be edited manually.
-   When searching for function call chains in Rust code, be aware that rustfmt often formats method chains across multiple lines like `obj\n    .foo()\n    .bar()`. Use multi-line search patterns (e.g., `rg` with `-U` flag) or search for individual method names rather than complete call chains.

## Test Generation

-   Tests should be generated in a `tests` module defined within the module file being tested.
-   The `tests` module should be defined at the bottom after all the existing code to test.
-   If the `tests` module already exists, only add test functions and merge imports as needed.
-   The `tests` module should be conditioned on `#[cfg(test)]`.
-   The `tests` module should always import APIs from `super`.
-   Do not begin test function names with "test" unless necessary to disambiguate from the function being tested.
-   Test functions do not need to be public.

## Integration Tests

-   Integration tests go in a crate's `tests/` directory and use `#[recorded::test]` (from `azure_core_test`).
-   Recorded tests replay HTTP traffic from recordings in `sdk/<service>/assets/` (referenced via `assets.json`).
-   To record new sessions, set `AZURE_TEST_MODE=record` and provide credentials/config via environment variables.
-   Use `#[recorded::test(live)]` for tests that cannot be recorded (non-HTTP or non-automated provisioning).

## Error Handling

-   Service crate code returns `azure_core::Result<T>` (defaults to `azure_core::Error`).
-   Examples should return `Result<(), Box<dyn std::error::Error>>`.
