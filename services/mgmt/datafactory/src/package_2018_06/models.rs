#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Resource {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(rename = "eTag", skip_serializing)]
    pub e_tag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubResource {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubResourceDebugResource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Expression {
    #[serde(rename = "type")]
    pub type_: expression::Type,
    pub value: String,
}
pub mod expression {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Expression,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecureString {
    #[serde(flatten)]
    pub secret_base: SecretBase,
    pub value: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureKeyVaultSecretReference {
    #[serde(flatten)]
    pub secret_base: SecretBase,
    pub store: LinkedServiceReference,
    #[serde(rename = "secretName")]
    pub secret_name: serde_json::Value,
    #[serde(rename = "secretVersion", skip_serializing_if = "Option::is_none")]
    pub secret_version: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecretBase {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FactoryListResponse {
    pub value: Vec<Factory>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeListResponse {
    pub value: Vec<IntegrationRuntimeResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeReference {
    #[serde(rename = "type")]
    pub type_: integration_runtime_reference::Type,
    #[serde(rename = "referenceName")]
    pub reference_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<ParameterValueSpecification>,
}
pub mod integration_runtime_reference {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        IntegrationRuntimeReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: IntegrationRuntime,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeDebugResource {
    #[serde(flatten)]
    pub sub_resource_debug_resource: SubResourceDebugResource,
    pub properties: IntegrationRuntime,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeStatusResponse {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    pub properties: IntegrationRuntimeStatus,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeStatusListResponse {
    pub value: Vec<IntegrationRuntimeStatusResponse>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UpdateIntegrationRuntimeRequest {
    #[serde(rename = "autoUpdate", skip_serializing_if = "Option::is_none")]
    pub auto_update: Option<IntegrationRuntimeAutoUpdate>,
    #[serde(rename = "updateDelayOffset", skip_serializing_if = "Option::is_none")]
    pub update_delay_offset: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UpdateIntegrationRuntimeNodeRequest {
    #[serde(rename = "concurrentJobsLimit", skip_serializing_if = "Option::is_none")]
    pub concurrent_jobs_limit: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntimeRequest {
    #[serde(rename = "factoryName")]
    pub factory_name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CreateLinkedIntegrationRuntimeRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "subscriptionId", skip_serializing_if = "Option::is_none")]
    pub subscription_id: Option<String>,
    #[serde(rename = "dataFactoryName", skip_serializing_if = "Option::is_none")]
    pub data_factory_name: Option<String>,
    #[serde(rename = "dataFactoryLocation", skip_serializing_if = "Option::is_none")]
    pub data_factory_location: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedServiceListResponse {
    pub value: Vec<LinkedServiceResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetListResponse {
    pub value: Vec<DatasetResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineListResponse {
    pub value: Vec<PipelineResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerQueryResponse {
    pub value: Vec<TriggerResource>,
    #[serde(rename = "continuationToken", skip_serializing_if = "Option::is_none")]
    pub continuation_token: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerListResponse {
    pub value: Vec<TriggerResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CreateRunResponse {
    #[serde(rename = "runId")]
    pub run_id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudError {
    pub error: CloudErrorBody,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudErrorBody {
    pub code: String,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<CloudError>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerSubscriptionOperationStatus {
    #[serde(rename = "triggerName", skip_serializing)]
    pub trigger_name: Option<String>,
    #[serde(skip_serializing)]
    pub status: Option<trigger_subscription_operation_status::Status>,
}
pub mod trigger_subscription_operation_status {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Enabled,
        Provisioning,
        Deprovisioning,
        Disabled,
        Unknown,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VariableDefinitionSpecification {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VariableSpecification {
    #[serde(rename = "type")]
    pub type_: variable_specification::Type,
    #[serde(rename = "defaultValue", skip_serializing_if = "Option::is_none")]
    pub default_value: Option<serde_json::Value>,
}
pub mod variable_specification {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        String,
        Bool,
        Array,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParameterDefinitionSpecification {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParameterSpecification {
    #[serde(rename = "type")]
    pub type_: parameter_specification::Type,
    #[serde(rename = "defaultValue", skip_serializing_if = "Option::is_none")]
    pub default_value: Option<serde_json::Value>,
}
pub mod parameter_specification {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Object,
        String,
        Int,
        Float,
        Bool,
        Array,
        SecureString,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParameterValueSpecification {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FactoryRepoConfiguration {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "accountName")]
    pub account_name: String,
    #[serde(rename = "repositoryName")]
    pub repository_name: String,
    #[serde(rename = "collaborationBranch")]
    pub collaboration_branch: String,
    #[serde(rename = "rootFolder")]
    pub root_folder: String,
    #[serde(rename = "lastCommitId", skip_serializing_if = "Option::is_none")]
    pub last_commit_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FactoryVstsConfiguration {
    #[serde(flatten)]
    pub factory_repo_configuration: FactoryRepoConfiguration,
    #[serde(rename = "projectName")]
    pub project_name: String,
    #[serde(rename = "tenantId", skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FactoryGitHubConfiguration {
    #[serde(flatten)]
    pub factory_repo_configuration: FactoryRepoConfiguration,
    #[serde(rename = "hostName", skip_serializing_if = "Option::is_none")]
    pub host_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FactoryRepoUpdate {
    #[serde(rename = "factoryResourceId", skip_serializing_if = "Option::is_none")]
    pub factory_resource_id: Option<String>,
    #[serde(rename = "repoConfiguration", skip_serializing_if = "Option::is_none")]
    pub repo_configuration: Option<FactoryRepoConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GitHubAccessTokenRequest {
    #[serde(rename = "gitHubAccessCode")]
    pub git_hub_access_code: String,
    #[serde(rename = "gitHubClientId", skip_serializing_if = "Option::is_none")]
    pub git_hub_client_id: Option<String>,
    #[serde(rename = "gitHubAccessTokenBaseUrl")]
    pub git_hub_access_token_base_url: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GitHubAccessTokenResponse {
    #[serde(rename = "gitHubAccessToken", skip_serializing_if = "Option::is_none")]
    pub git_hub_access_token: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UserAccessPolicy {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub permissions: Option<String>,
    #[serde(rename = "accessResourcePath", skip_serializing_if = "Option::is_none")]
    pub access_resource_path: Option<String>,
    #[serde(rename = "profileName", skip_serializing_if = "Option::is_none")]
    pub profile_name: Option<String>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "expireTime", skip_serializing_if = "Option::is_none")]
    pub expire_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AccessPolicyResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy: Option<UserAccessPolicy>,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    pub access_token: Option<String>,
    #[serde(rename = "dataPlaneUrl", skip_serializing_if = "Option::is_none")]
    pub data_plane_url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FactoryProperties {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
    #[serde(rename = "createTime", skip_serializing)]
    pub create_time: Option<String>,
    #[serde(skip_serializing)]
    pub version: Option<String>,
    #[serde(rename = "repoConfiguration", skip_serializing_if = "Option::is_none")]
    pub repo_configuration: Option<FactoryRepoConfiguration>,
    #[serde(rename = "globalParameters", skip_serializing_if = "Option::is_none")]
    pub global_parameters: Option<GlobalParameterDefinitionSpecification>,
    #[serde(rename = "publicNetworkAccess", skip_serializing_if = "Option::is_none")]
    pub public_network_access: Option<factory_properties::PublicNetworkAccess>,
}
pub mod factory_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PublicNetworkAccess {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GlobalParameterDefinitionSpecification {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GlobalParameterSpecification {
    #[serde(rename = "type")]
    pub type_: global_parameter_specification::Type,
    pub value: serde_json::Value,
}
pub mod global_parameter_specification {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Object,
        String,
        Int,
        Float,
        Bool,
        Array,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: Pipeline,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineReference {
    #[serde(rename = "type")]
    pub type_: pipeline_reference::Type,
    #[serde(rename = "referenceName")]
    pub reference_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
pub mod pipeline_reference {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        PipelineReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerPipelineReference {
    #[serde(rename = "pipelineReference", skip_serializing_if = "Option::is_none")]
    pub pipeline_reference: Option<PipelineReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<ParameterValueSpecification>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: Trigger,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Factory {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<FactoryIdentity>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<FactoryProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FactoryUpdateParameters {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<FactoryIdentity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FactoryIdentity {
    #[serde(rename = "type")]
    pub type_: factory_identity::Type,
    #[serde(rename = "principalId", skip_serializing)]
    pub principal_id: Option<String>,
    #[serde(rename = "tenantId", skip_serializing)]
    pub tenant_id: Option<String>,
}
pub mod factory_identity {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        SystemAssigned,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetReference {
    #[serde(rename = "type")]
    pub type_: dataset_reference::Type,
    #[serde(rename = "referenceName")]
    pub reference_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<ParameterValueSpecification>,
}
pub mod dataset_reference {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        DatasetReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: Dataset,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetDebugResource {
    #[serde(flatten)]
    pub sub_resource_debug_resource: SubResourceDebugResource,
    pub properties: Dataset,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedServiceReference {
    #[serde(rename = "type")]
    pub type_: linked_service_reference::Type,
    #[serde(rename = "referenceName")]
    pub reference_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<ParameterValueSpecification>,
}
pub mod linked_service_reference {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        LinkedServiceReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedServiceResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: LinkedService,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedServiceDebugResource {
    #[serde(flatten)]
    pub sub_resource_debug_resource: SubResourceDebugResource,
    pub properties: LinkedService,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerFilterParameters {
    #[serde(rename = "continuationToken", skip_serializing_if = "Option::is_none")]
    pub continuation_token: Option<String>,
    #[serde(rename = "parentTriggerName", skip_serializing_if = "Option::is_none")]
    pub parent_trigger_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RunFilterParameters {
    #[serde(rename = "continuationToken", skip_serializing_if = "Option::is_none")]
    pub continuation_token: Option<String>,
    #[serde(rename = "lastUpdatedAfter")]
    pub last_updated_after: String,
    #[serde(rename = "lastUpdatedBefore")]
    pub last_updated_before: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub filters: Vec<RunQueryFilter>,
    #[serde(rename = "orderBy", skip_serializing_if = "Vec::is_empty")]
    pub order_by: Vec<RunQueryOrderBy>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RunQueryFilter {
    pub operand: run_query_filter::Operand,
    pub operator: run_query_filter::Operator,
    pub values: Vec<String>,
}
pub mod run_query_filter {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Operand {
        PipelineName,
        Status,
        RunStart,
        RunEnd,
        ActivityName,
        ActivityRunStart,
        ActivityRunEnd,
        ActivityType,
        TriggerName,
        TriggerRunTimestamp,
        RunGroupId,
        LatestOnly,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Operator {
        Equals,
        NotEquals,
        In,
        NotIn,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RunQueryOrderBy {
    #[serde(rename = "orderBy")]
    pub order_by: run_query_order_by::OrderBy,
    pub order: run_query_order_by::Order,
}
pub mod run_query_order_by {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OrderBy {
        RunStart,
        RunEnd,
        PipelineName,
        Status,
        ActivityName,
        ActivityRunStart,
        ActivityRunEnd,
        TriggerName,
        TriggerRunTimestamp,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Order {
        #[serde(rename = "ASC")]
        Asc,
        #[serde(rename = "DESC")]
        Desc,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineRunsQueryResponse {
    pub value: Vec<PipelineRun>,
    #[serde(rename = "continuationToken", skip_serializing_if = "Option::is_none")]
    pub continuation_token: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineRun {
    #[serde(rename = "runId", skip_serializing)]
    pub run_id: Option<String>,
    #[serde(rename = "runGroupId", skip_serializing)]
    pub run_group_id: Option<String>,
    #[serde(rename = "isLatest", skip_serializing)]
    pub is_latest: Option<bool>,
    #[serde(rename = "pipelineName", skip_serializing)]
    pub pipeline_name: Option<String>,
    #[serde(skip_serializing)]
    pub parameters: Option<serde_json::Value>,
    #[serde(rename = "runDimensions", skip_serializing)]
    pub run_dimensions: Option<serde_json::Value>,
    #[serde(rename = "invokedBy", skip_serializing_if = "Option::is_none")]
    pub invoked_by: Option<PipelineRunInvokedBy>,
    #[serde(rename = "lastUpdated", skip_serializing)]
    pub last_updated: Option<String>,
    #[serde(rename = "runStart", skip_serializing)]
    pub run_start: Option<String>,
    #[serde(rename = "runEnd", skip_serializing)]
    pub run_end: Option<String>,
    #[serde(rename = "durationInMs", skip_serializing)]
    pub duration_in_ms: Option<i64>,
    #[serde(skip_serializing)]
    pub status: Option<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineRunInvokedBy {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(rename = "invokedByType", skip_serializing)]
    pub invoked_by_type: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ActivityRunsQueryResponse {
    pub value: Vec<ActivityRun>,
    #[serde(rename = "continuationToken", skip_serializing_if = "Option::is_none")]
    pub continuation_token: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ActivityRun {
    #[serde(rename = "pipelineName", skip_serializing)]
    pub pipeline_name: Option<String>,
    #[serde(rename = "pipelineRunId", skip_serializing)]
    pub pipeline_run_id: Option<String>,
    #[serde(rename = "activityName", skip_serializing)]
    pub activity_name: Option<String>,
    #[serde(rename = "activityType", skip_serializing)]
    pub activity_type: Option<String>,
    #[serde(rename = "activityRunId", skip_serializing)]
    pub activity_run_id: Option<String>,
    #[serde(rename = "linkedServiceName", skip_serializing)]
    pub linked_service_name: Option<String>,
    #[serde(skip_serializing)]
    pub status: Option<String>,
    #[serde(rename = "activityRunStart", skip_serializing)]
    pub activity_run_start: Option<String>,
    #[serde(rename = "activityRunEnd", skip_serializing)]
    pub activity_run_end: Option<String>,
    #[serde(rename = "durationInMs", skip_serializing)]
    pub duration_in_ms: Option<i64>,
    #[serde(skip_serializing)]
    pub input: Option<serde_json::Value>,
    #[serde(skip_serializing)]
    pub output: Option<serde_json::Value>,
    #[serde(skip_serializing)]
    pub error: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerRunsQueryResponse {
    pub value: Vec<TriggerRun>,
    #[serde(rename = "continuationToken", skip_serializing_if = "Option::is_none")]
    pub continuation_token: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerRun {
    #[serde(rename = "triggerRunId", skip_serializing)]
    pub trigger_run_id: Option<String>,
    #[serde(rename = "triggerName", skip_serializing)]
    pub trigger_name: Option<String>,
    #[serde(rename = "triggerType", skip_serializing)]
    pub trigger_type: Option<String>,
    #[serde(rename = "triggerRunTimestamp", skip_serializing)]
    pub trigger_run_timestamp: Option<String>,
    #[serde(skip_serializing)]
    pub status: Option<trigger_run::Status>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
    #[serde(skip_serializing)]
    pub properties: Option<serde_json::Value>,
    #[serde(rename = "triggeredPipelines", skip_serializing)]
    pub triggered_pipelines: Option<serde_json::Value>,
    #[serde(rename = "runDimension", skip_serializing)]
    pub run_dimension: Option<serde_json::Value>,
    #[serde(rename = "dependencyStatus", skip_serializing)]
    pub dependency_status: Option<serde_json::Value>,
}
pub mod trigger_run {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Succeeded,
        Failed,
        Inprogress,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationListResponse {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Operation>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Operation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display: Option<operation::Display>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<OperationProperties>,
}
pub mod operation {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct Display {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub provider: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub resource: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub operation: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationProperties {
    #[serde(rename = "serviceSpecification", skip_serializing_if = "Option::is_none")]
    pub service_specification: Option<OperationServiceSpecification>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationServiceSpecification {
    #[serde(rename = "logSpecifications", skip_serializing_if = "Vec::is_empty")]
    pub log_specifications: Vec<OperationLogSpecification>,
    #[serde(rename = "metricSpecifications", skip_serializing_if = "Vec::is_empty")]
    pub metric_specifications: Vec<OperationMetricSpecification>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationLogSpecification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "blobDuration", skip_serializing_if = "Option::is_none")]
    pub blob_duration: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationMetricSpecification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "displayDescription", skip_serializing_if = "Option::is_none")]
    pub display_description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    #[serde(rename = "aggregationType", skip_serializing_if = "Option::is_none")]
    pub aggregation_type: Option<String>,
    #[serde(rename = "enableRegionalMdmAccount", skip_serializing_if = "Option::is_none")]
    pub enable_regional_mdm_account: Option<String>,
    #[serde(rename = "sourceMdmAccount", skip_serializing_if = "Option::is_none")]
    pub source_mdm_account: Option<String>,
    #[serde(rename = "sourceMdmNamespace", skip_serializing_if = "Option::is_none")]
    pub source_mdm_namespace: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub availabilities: Vec<OperationMetricAvailability>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub dimensions: Vec<OperationMetricDimension>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationMetricAvailability {
    #[serde(rename = "timeGrain", skip_serializing_if = "Option::is_none")]
    pub time_grain: Option<String>,
    #[serde(rename = "blobDuration", skip_serializing_if = "Option::is_none")]
    pub blob_duration: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationMetricDimension {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "toBeExportedForShoebox", skip_serializing_if = "Option::is_none")]
    pub to_be_exported_for_shoebox: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GetSsisObjectMetadataRequest {
    #[serde(rename = "metadataPath", skip_serializing_if = "Option::is_none")]
    pub metadata_path: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisObjectMetadataStatusResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExposureControlBatchRequest {
    #[serde(rename = "exposureControlRequests")]
    pub exposure_control_requests: Vec<ExposureControlRequest>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExposureControlRequest {
    #[serde(rename = "featureName", skip_serializing_if = "Option::is_none")]
    pub feature_name: Option<String>,
    #[serde(rename = "featureType", skip_serializing_if = "Option::is_none")]
    pub feature_type: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExposureControlBatchResponse {
    #[serde(rename = "exposureControlResponses")]
    pub exposure_control_responses: Vec<ExposureControlResponse>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExposureControlResponse {
    #[serde(rename = "featureName", skip_serializing)]
    pub feature_name: Option<String>,
    #[serde(skip_serializing)]
    pub value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowListResponse {
    pub value: Vec<DataFlowResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CreateDataFlowDebugSessionRequest {
    #[serde(rename = "computeType", skip_serializing_if = "Option::is_none")]
    pub compute_type: Option<String>,
    #[serde(rename = "coreCount", skip_serializing_if = "Option::is_none")]
    pub core_count: Option<i64>,
    #[serde(rename = "timeToLive", skip_serializing_if = "Option::is_none")]
    pub time_to_live: Option<i64>,
    #[serde(rename = "integrationRuntime", skip_serializing_if = "Option::is_none")]
    pub integration_runtime: Option<IntegrationRuntimeDebugResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CreateDataFlowDebugSessionResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowSourceSetting {
    #[serde(rename = "sourceName", skip_serializing_if = "Option::is_none")]
    pub source_name: Option<String>,
    #[serde(rename = "rowLimit", skip_serializing_if = "Option::is_none")]
    pub row_limit: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowStagingInfo {
    #[serde(rename = "linkedService", skip_serializing_if = "Option::is_none")]
    pub linked_service: Option<LinkedServiceReference>,
    #[serde(rename = "folderPath", skip_serializing_if = "Option::is_none")]
    pub folder_path: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowDebugPackage {
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
    #[serde(rename = "dataFlow", skip_serializing_if = "Option::is_none")]
    pub data_flow: Option<DataFlowDebugResource>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub datasets: Vec<DatasetDebugResource>,
    #[serde(rename = "linkedServices", skip_serializing_if = "Vec::is_empty")]
    pub linked_services: Vec<LinkedServiceDebugResource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub staging: Option<DataFlowStagingInfo>,
    #[serde(rename = "debugSettings", skip_serializing_if = "Option::is_none")]
    pub debug_settings: Option<data_flow_debug_package::DebugSettings>,
}
pub mod data_flow_debug_package {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct DebugSettings {
        #[serde(rename = "sourceSettings", skip_serializing_if = "Vec::is_empty")]
        pub source_settings: Vec<DataFlowSourceSetting>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub parameters: Option<ParameterValueSpecification>,
        #[serde(rename = "datasetParameters", skip_serializing_if = "Option::is_none")]
        pub dataset_parameters: Option<serde_json::Value>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AddDataFlowToDebugSessionResponse {
    #[serde(rename = "jobVersion", skip_serializing_if = "Option::is_none")]
    pub job_version: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DeleteDataFlowDebugSessionRequest {
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowDebugCommandPayload {
    #[serde(rename = "streamName")]
    pub stream_name: String,
    #[serde(rename = "rowLimits", skip_serializing_if = "Option::is_none")]
    pub row_limits: Option<i64>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub columns: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowDebugCommandRequest {
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub command: Option<data_flow_debug_command_request::Command>,
    #[serde(rename = "commandPayload", skip_serializing_if = "Option::is_none")]
    pub command_payload: Option<DataFlowDebugCommandPayload>,
}
pub mod data_flow_debug_command_request {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Command {
        #[serde(rename = "executePreviewQuery")]
        ExecutePreviewQuery,
        #[serde(rename = "executeStatisticsQuery")]
        ExecuteStatisticsQuery,
        #[serde(rename = "executeExpressionQuery")]
        ExecuteExpressionQuery,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowDebugCommandResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QueryDataFlowDebugSessionsResponse {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<DataFlowDebugSessionInfo>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowDebugSessionInfo {
    #[serde(rename = "dataFlowName", skip_serializing_if = "Option::is_none")]
    pub data_flow_name: Option<String>,
    #[serde(rename = "computeType", skip_serializing_if = "Option::is_none")]
    pub compute_type: Option<String>,
    #[serde(rename = "coreCount", skip_serializing_if = "Option::is_none")]
    pub core_count: Option<i64>,
    #[serde(rename = "nodeCount", skip_serializing_if = "Option::is_none")]
    pub node_count: Option<i64>,
    #[serde(rename = "integrationRuntimeName", skip_serializing_if = "Option::is_none")]
    pub integration_runtime_name: Option<String>,
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "timeToLiveInMinutes", skip_serializing_if = "Option::is_none")]
    pub time_to_live_in_minutes: Option<i64>,
    #[serde(rename = "lastActivityTime", skip_serializing_if = "Option::is_none")]
    pub last_activity_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GetDataFactoryOperationStatusResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: DataFlow,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowDebugResource {
    #[serde(flatten)]
    pub sub_resource_debug_resource: SubResourceDebugResource,
    pub properties: DataFlow,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowReference {
    #[serde(rename = "type")]
    pub type_: data_flow_reference::Type,
    #[serde(rename = "referenceName")]
    pub reference_name: String,
    #[serde(rename = "datasetParameters", skip_serializing_if = "Option::is_none")]
    pub dataset_parameters: Option<serde_json::Value>,
}
pub mod data_flow_reference {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        DataFlowReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedPrivateEndpointListResponse {
    pub value: Vec<ManagedPrivateEndpointResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedPrivateEndpointResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: ManagedPrivateEndpoint,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedVirtualNetworkListResponse {
    pub value: Vec<ManagedVirtualNetworkResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedVirtualNetworkResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: ManagedVirtualNetwork,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntime {
    #[serde(rename = "type")]
    pub type_: IntegrationRuntimeType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IntegrationRuntimeType {
    Managed,
    SelfHosted,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntime {
    #[serde(flatten)]
    pub integration_runtime: IntegrationRuntime,
    #[serde(skip_serializing)]
    pub state: Option<IntegrationRuntimeState>,
    #[serde(rename = "typeProperties")]
    pub type_properties: ManagedIntegrationRuntimeTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeTypeProperties {
    #[serde(rename = "computeProperties", skip_serializing_if = "Option::is_none")]
    pub compute_properties: Option<IntegrationRuntimeComputeProperties>,
    #[serde(rename = "ssisProperties", skip_serializing_if = "Option::is_none")]
    pub ssis_properties: Option<IntegrationRuntimeSsisProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeComputeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(rename = "nodeSize", skip_serializing_if = "Option::is_none")]
    pub node_size: Option<String>,
    #[serde(rename = "numberOfNodes", skip_serializing_if = "Option::is_none")]
    pub number_of_nodes: Option<i64>,
    #[serde(rename = "maxParallelExecutionsPerNode", skip_serializing_if = "Option::is_none")]
    pub max_parallel_executions_per_node: Option<i64>,
    #[serde(rename = "dataFlowProperties", skip_serializing_if = "Option::is_none")]
    pub data_flow_properties: Option<IntegrationRuntimeDataFlowProperties>,
    #[serde(rename = "vNetProperties", skip_serializing_if = "Option::is_none")]
    pub v_net_properties: Option<IntegrationRuntimeVNetProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeDataFlowProperties {
    #[serde(rename = "computeType", skip_serializing_if = "Option::is_none")]
    pub compute_type: Option<integration_runtime_data_flow_properties::ComputeType>,
    #[serde(rename = "coreCount", skip_serializing_if = "Option::is_none")]
    pub core_count: Option<i64>,
    #[serde(rename = "timeToLive", skip_serializing_if = "Option::is_none")]
    pub time_to_live: Option<i64>,
}
pub mod integration_runtime_data_flow_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ComputeType {
        General,
        MemoryOptimized,
        ComputeOptimized,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeVNetProperties {
    #[serde(rename = "vNetId", skip_serializing_if = "Option::is_none")]
    pub v_net_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<String>,
    #[serde(rename = "publicIPs", skip_serializing_if = "Vec::is_empty")]
    pub public_i_ps: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeSsisProperties {
    #[serde(rename = "catalogInfo", skip_serializing_if = "Option::is_none")]
    pub catalog_info: Option<IntegrationRuntimeSsisCatalogInfo>,
    #[serde(rename = "licenseType", skip_serializing_if = "Option::is_none")]
    pub license_type: Option<integration_runtime_ssis_properties::LicenseType>,
    #[serde(rename = "customSetupScriptProperties", skip_serializing_if = "Option::is_none")]
    pub custom_setup_script_properties: Option<IntegrationRuntimeCustomSetupScriptProperties>,
    #[serde(rename = "dataProxyProperties", skip_serializing_if = "Option::is_none")]
    pub data_proxy_properties: Option<IntegrationRuntimeDataProxyProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edition: Option<integration_runtime_ssis_properties::Edition>,
    #[serde(rename = "expressCustomSetupProperties", skip_serializing_if = "Vec::is_empty")]
    pub express_custom_setup_properties: Vec<CustomSetupBase>,
    #[serde(rename = "packageStores", skip_serializing_if = "Vec::is_empty")]
    pub package_stores: Vec<PackageStore>,
}
pub mod integration_runtime_ssis_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LicenseType {
        BasePrice,
        LicenseIncluded,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Edition {
        Standard,
        Enterprise,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeSsisCatalogInfo {
    #[serde(rename = "catalogServerEndpoint", skip_serializing_if = "Option::is_none")]
    pub catalog_server_endpoint: Option<String>,
    #[serde(rename = "catalogAdminUserName", skip_serializing_if = "Option::is_none")]
    pub catalog_admin_user_name: Option<String>,
    #[serde(rename = "catalogAdminPassword", skip_serializing_if = "Option::is_none")]
    pub catalog_admin_password: Option<SecureString>,
    #[serde(rename = "catalogPricingTier", skip_serializing_if = "Option::is_none")]
    pub catalog_pricing_tier: Option<integration_runtime_ssis_catalog_info::CatalogPricingTier>,
}
pub mod integration_runtime_ssis_catalog_info {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum CatalogPricingTier {
        Basic,
        Standard,
        Premium,
        #[serde(rename = "PremiumRS")]
        PremiumRs,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeCustomSetupScriptProperties {
    #[serde(rename = "blobContainerUri", skip_serializing_if = "Option::is_none")]
    pub blob_container_uri: Option<String>,
    #[serde(rename = "sasToken", skip_serializing_if = "Option::is_none")]
    pub sas_token: Option<SecureString>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeDataProxyProperties {
    #[serde(rename = "connectVia", skip_serializing_if = "Option::is_none")]
    pub connect_via: Option<EntityReference>,
    #[serde(rename = "stagingLinkedService", skip_serializing_if = "Option::is_none")]
    pub staging_linked_service: Option<EntityReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PackageStore {
    pub name: String,
    #[serde(rename = "packageStoreLinkedService")]
    pub package_store_linked_service: EntityReference,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomSetupBase {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CmdkeySetup {
    #[serde(flatten)]
    pub custom_setup_base: CustomSetupBase,
    #[serde(rename = "typeProperties")]
    pub type_properties: CmdkeySetupTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CmdkeySetupTypeProperties {
    #[serde(rename = "targetName")]
    pub target_name: serde_json::Value,
    #[serde(rename = "userName")]
    pub user_name: serde_json::Value,
    pub password: SecretBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EnvironmentVariableSetup {
    #[serde(flatten)]
    pub custom_setup_base: CustomSetupBase,
    #[serde(rename = "typeProperties")]
    pub type_properties: EnvironmentVariableSetupTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EnvironmentVariableSetupTypeProperties {
    #[serde(rename = "variableName")]
    pub variable_name: String,
    #[serde(rename = "variableValue")]
    pub variable_value: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ComponentSetup {
    #[serde(flatten)]
    pub custom_setup_base: CustomSetupBase,
    #[serde(rename = "typeProperties")]
    pub type_properties: LicensedComponentSetupTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LicensedComponentSetupTypeProperties {
    #[serde(rename = "componentName")]
    pub component_name: String,
    #[serde(rename = "licenseKey", skip_serializing_if = "Option::is_none")]
    pub license_key: Option<SecretBase>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzPowerShellSetup {
    #[serde(flatten)]
    pub custom_setup_base: CustomSetupBase,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzPowerShellSetupTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzPowerShellSetupTypeProperties {
    pub version: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EntityReference {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<entity_reference::Type>,
    #[serde(rename = "referenceName", skip_serializing_if = "Option::is_none")]
    pub reference_name: Option<String>,
}
pub mod entity_reference {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        IntegrationRuntimeReference,
        LinkedServiceReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntime {
    #[serde(flatten)]
    pub integration_runtime: IntegrationRuntime,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SelfHostedIntegrationRuntimeTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntimeTypeProperties {
    #[serde(rename = "linkedInfo", skip_serializing_if = "Option::is_none")]
    pub linked_info: Option<LinkedIntegrationRuntimeType>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntimeType {
    #[serde(rename = "authorizationType")]
    pub authorization_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntimeKeyAuthorization {
    #[serde(flatten)]
    pub linked_integration_runtime_type: LinkedIntegrationRuntimeType,
    pub key: SecureString,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntimeRbacAuthorization {
    #[serde(flatten)]
    pub linked_integration_runtime_type: LinkedIntegrationRuntimeType,
    #[serde(rename = "resourceId")]
    pub resource_id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeStatus {
    #[serde(rename = "type")]
    pub type_: IntegrationRuntimeType,
    #[serde(rename = "dataFactoryName", skip_serializing)]
    pub data_factory_name: Option<String>,
    #[serde(skip_serializing)]
    pub state: Option<IntegrationRuntimeState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IntegrationRuntimeState {
    Initial,
    Stopped,
    Started,
    Starting,
    Stopping,
    NeedRegistration,
    Online,
    Limited,
    Offline,
    AccessDenied,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeStatus {
    #[serde(flatten)]
    pub integration_runtime_status: IntegrationRuntimeStatus,
    #[serde(rename = "typeProperties")]
    pub type_properties: ManagedIntegrationRuntimeStatusTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeStatusTypeProperties {
    #[serde(rename = "createTime", skip_serializing)]
    pub create_time: Option<String>,
    #[serde(skip_serializing)]
    pub nodes: Vec<ManagedIntegrationRuntimeNode>,
    #[serde(rename = "otherErrors", skip_serializing)]
    pub other_errors: Vec<ManagedIntegrationRuntimeError>,
    #[serde(rename = "lastOperation", skip_serializing_if = "Option::is_none")]
    pub last_operation: Option<ManagedIntegrationRuntimeOperationResult>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeOperationResult {
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(skip_serializing)]
    pub result: Option<String>,
    #[serde(rename = "errorCode", skip_serializing)]
    pub error_code: Option<String>,
    #[serde(skip_serializing)]
    pub parameters: Vec<String>,
    #[serde(rename = "activityId", skip_serializing)]
    pub activity_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeNode {
    #[serde(rename = "nodeId", skip_serializing)]
    pub node_id: Option<String>,
    #[serde(skip_serializing)]
    pub status: Option<managed_integration_runtime_node::Status>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub errors: Vec<ManagedIntegrationRuntimeError>,
}
pub mod managed_integration_runtime_node {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Starting,
        Available,
        Recycling,
        Unavailable,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeError {
    #[serde(skip_serializing)]
    pub time: Option<String>,
    #[serde(skip_serializing)]
    pub code: Option<String>,
    #[serde(skip_serializing)]
    pub parameters: Vec<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntimeStatus {
    #[serde(flatten)]
    pub integration_runtime_status: IntegrationRuntimeStatus,
    #[serde(rename = "typeProperties")]
    pub type_properties: SelfHostedIntegrationRuntimeStatusTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntimeStatusTypeProperties {
    #[serde(rename = "createTime", skip_serializing)]
    pub create_time: Option<String>,
    #[serde(rename = "taskQueueId", skip_serializing)]
    pub task_queue_id: Option<String>,
    #[serde(rename = "internalChannelEncryption", skip_serializing)]
    pub internal_channel_encryption: Option<self_hosted_integration_runtime_status_type_properties::InternalChannelEncryption>,
    #[serde(skip_serializing)]
    pub version: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub nodes: Vec<SelfHostedIntegrationRuntimeNode>,
    #[serde(rename = "scheduledUpdateDate", skip_serializing)]
    pub scheduled_update_date: Option<String>,
    #[serde(rename = "updateDelayOffset", skip_serializing)]
    pub update_delay_offset: Option<String>,
    #[serde(rename = "localTimeZoneOffset", skip_serializing)]
    pub local_time_zone_offset: Option<String>,
    #[serde(skip_serializing)]
    pub capabilities: Option<serde_json::Value>,
    #[serde(rename = "serviceUrls", skip_serializing)]
    pub service_urls: Vec<String>,
    #[serde(rename = "autoUpdate", skip_serializing_if = "Option::is_none")]
    pub auto_update: Option<IntegrationRuntimeAutoUpdate>,
    #[serde(rename = "versionStatus", skip_serializing)]
    pub version_status: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub links: Vec<LinkedIntegrationRuntime>,
    #[serde(rename = "pushedVersion", skip_serializing)]
    pub pushed_version: Option<String>,
    #[serde(rename = "latestVersion", skip_serializing)]
    pub latest_version: Option<String>,
    #[serde(rename = "autoUpdateETA", skip_serializing)]
    pub auto_update_eta: Option<String>,
}
pub mod self_hosted_integration_runtime_status_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum InternalChannelEncryption {
        NotSet,
        SslEncrypted,
        NotEncrypted,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IntegrationRuntimeAutoUpdate {
    On,
    Off,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntime {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "subscriptionId", skip_serializing)]
    pub subscription_id: Option<String>,
    #[serde(rename = "dataFactoryName", skip_serializing)]
    pub data_factory_name: Option<String>,
    #[serde(rename = "dataFactoryLocation", skip_serializing)]
    pub data_factory_location: Option<String>,
    #[serde(rename = "createTime", skip_serializing)]
    pub create_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntimeNode {
    #[serde(rename = "nodeName", skip_serializing)]
    pub node_name: Option<String>,
    #[serde(rename = "machineName", skip_serializing)]
    pub machine_name: Option<String>,
    #[serde(rename = "hostServiceUri", skip_serializing)]
    pub host_service_uri: Option<String>,
    #[serde(skip_serializing)]
    pub status: Option<self_hosted_integration_runtime_node::Status>,
    #[serde(skip_serializing)]
    pub capabilities: Option<serde_json::Value>,
    #[serde(rename = "versionStatus", skip_serializing)]
    pub version_status: Option<String>,
    #[serde(skip_serializing)]
    pub version: Option<String>,
    #[serde(rename = "registerTime", skip_serializing)]
    pub register_time: Option<String>,
    #[serde(rename = "lastConnectTime", skip_serializing)]
    pub last_connect_time: Option<String>,
    #[serde(rename = "expiryTime", skip_serializing)]
    pub expiry_time: Option<String>,
    #[serde(rename = "lastStartTime", skip_serializing)]
    pub last_start_time: Option<String>,
    #[serde(rename = "lastStopTime", skip_serializing)]
    pub last_stop_time: Option<String>,
    #[serde(rename = "lastUpdateResult", skip_serializing)]
    pub last_update_result: Option<self_hosted_integration_runtime_node::LastUpdateResult>,
    #[serde(rename = "lastStartUpdateTime", skip_serializing)]
    pub last_start_update_time: Option<String>,
    #[serde(rename = "lastEndUpdateTime", skip_serializing)]
    pub last_end_update_time: Option<String>,
    #[serde(rename = "isActiveDispatcher", skip_serializing)]
    pub is_active_dispatcher: Option<bool>,
    #[serde(rename = "concurrentJobsLimit", skip_serializing)]
    pub concurrent_jobs_limit: Option<i64>,
    #[serde(rename = "maxConcurrentJobs", skip_serializing)]
    pub max_concurrent_jobs: Option<i64>,
}
pub mod self_hosted_integration_runtime_node {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        NeedRegistration,
        Online,
        Limited,
        Offline,
        Upgrading,
        Initializing,
        InitializeFailed,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LastUpdateResult {
        None,
        Succeed,
        Fail,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeConnectionInfo {
    #[serde(rename = "serviceToken", skip_serializing)]
    pub service_token: Option<String>,
    #[serde(rename = "identityCertThumbprint", skip_serializing)]
    pub identity_cert_thumbprint: Option<String>,
    #[serde(rename = "hostServiceUri", skip_serializing)]
    pub host_service_uri: Option<String>,
    #[serde(skip_serializing)]
    pub version: Option<String>,
    #[serde(rename = "publicKey", skip_serializing)]
    pub public_key: Option<String>,
    #[serde(rename = "isIdentityCertExprired", skip_serializing)]
    pub is_identity_cert_exprired: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeRegenerateKeyParameters {
    #[serde(rename = "keyName", skip_serializing_if = "Option::is_none")]
    pub key_name: Option<integration_runtime_regenerate_key_parameters::KeyName>,
}
pub mod integration_runtime_regenerate_key_parameters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum KeyName {
        #[serde(rename = "authKey1")]
        AuthKey1,
        #[serde(rename = "authKey2")]
        AuthKey2,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeAuthKeys {
    #[serde(rename = "authKey1", skip_serializing_if = "Option::is_none")]
    pub auth_key1: Option<String>,
    #[serde(rename = "authKey2", skip_serializing_if = "Option::is_none")]
    pub auth_key2: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeMonitoringData {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub nodes: Vec<IntegrationRuntimeNodeMonitoringData>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeNodeMonitoringData {
    #[serde(rename = "nodeName", skip_serializing)]
    pub node_name: Option<String>,
    #[serde(rename = "availableMemoryInMB", skip_serializing)]
    pub available_memory_in_mb: Option<i64>,
    #[serde(rename = "cpuUtilization", skip_serializing)]
    pub cpu_utilization: Option<i64>,
    #[serde(rename = "concurrentJobsLimit", skip_serializing)]
    pub concurrent_jobs_limit: Option<i64>,
    #[serde(rename = "concurrentJobsRunning", skip_serializing)]
    pub concurrent_jobs_running: Option<i64>,
    #[serde(rename = "maxConcurrentJobs", skip_serializing)]
    pub max_concurrent_jobs: Option<i64>,
    #[serde(rename = "sentBytes", skip_serializing)]
    pub sent_bytes: Option<f64>,
    #[serde(rename = "receivedBytes", skip_serializing)]
    pub received_bytes: Option<f64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeNodeIpAddress {
    #[serde(rename = "ipAddress", skip_serializing)]
    pub ip_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisObjectMetadataListResponse {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<SsisObjectMetadata>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisObjectMetadata {
    #[serde(rename = "type")]
    pub type_: SsisObjectMetadataType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SsisObjectMetadataType {
    Folder,
    Project,
    Package,
    Environment,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisFolder {
    #[serde(flatten)]
    pub ssis_object_metadata: SsisObjectMetadata,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisProject {
    #[serde(flatten)]
    pub ssis_object_metadata: SsisObjectMetadata,
    #[serde(rename = "folderId", skip_serializing_if = "Option::is_none")]
    pub folder_id: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
    #[serde(rename = "environmentRefs", skip_serializing_if = "Vec::is_empty")]
    pub environment_refs: Vec<SsisEnvironmentReference>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<SsisParameter>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisPackage {
    #[serde(flatten)]
    pub ssis_object_metadata: SsisObjectMetadata,
    #[serde(rename = "folderId", skip_serializing_if = "Option::is_none")]
    pub folder_id: Option<i64>,
    #[serde(rename = "projectVersion", skip_serializing_if = "Option::is_none")]
    pub project_version: Option<i64>,
    #[serde(rename = "projectId", skip_serializing_if = "Option::is_none")]
    pub project_id: Option<i64>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<SsisParameter>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisEnvironment {
    #[serde(flatten)]
    pub ssis_object_metadata: SsisObjectMetadata,
    #[serde(rename = "folderId", skip_serializing_if = "Option::is_none")]
    pub folder_id: Option<i64>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub variables: Vec<SsisVariable>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisParameter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "dataType", skip_serializing_if = "Option::is_none")]
    pub data_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sensitive: Option<bool>,
    #[serde(rename = "designDefaultValue", skip_serializing_if = "Option::is_none")]
    pub design_default_value: Option<String>,
    #[serde(rename = "defaultValue", skip_serializing_if = "Option::is_none")]
    pub default_value: Option<String>,
    #[serde(rename = "sensitiveDefaultValue", skip_serializing_if = "Option::is_none")]
    pub sensitive_default_value: Option<String>,
    #[serde(rename = "valueType", skip_serializing_if = "Option::is_none")]
    pub value_type: Option<String>,
    #[serde(rename = "valueSet", skip_serializing_if = "Option::is_none")]
    pub value_set: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variable: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisVariable {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "dataType", skip_serializing_if = "Option::is_none")]
    pub data_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sensitive: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(rename = "sensitiveValue", skip_serializing_if = "Option::is_none")]
    pub sensitive_value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisEnvironmentReference {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(rename = "environmentFolderName", skip_serializing_if = "Option::is_none")]
    pub environment_folder_name: Option<String>,
    #[serde(rename = "environmentName", skip_serializing_if = "Option::is_none")]
    pub environment_name: Option<String>,
    #[serde(rename = "referenceType", skip_serializing_if = "Option::is_none")]
    pub reference_type: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Pipeline {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub activities: Vec<Activity>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<ParameterDefinitionSpecification>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variables: Option<VariableDefinitionSpecification>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub concurrency: Option<i64>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<serde_json::Value>,
    #[serde(rename = "runDimensions", skip_serializing_if = "Option::is_none")]
    pub run_dimensions: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub folder: Option<pipeline::Folder>,
}
pub mod pipeline {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct Folder {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Activity {
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "dependsOn", skip_serializing_if = "Vec::is_empty")]
    pub depends_on: Vec<ActivityDependency>,
    #[serde(rename = "userProperties", skip_serializing_if = "Vec::is_empty")]
    pub user_properties: Vec<UserProperty>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UserProperty {
    pub name: String,
    pub value: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ActivityDependency {
    pub activity: String,
    #[serde(rename = "dependencyConditions")]
    pub dependency_conditions: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ControlActivity {
    #[serde(flatten)]
    pub activity: Activity,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExecutionActivity {
    #[serde(flatten)]
    pub activity: Activity,
    #[serde(rename = "linkedServiceName", skip_serializing_if = "Option::is_none")]
    pub linked_service_name: Option<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy: Option<ActivityPolicy>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ActivityPolicy {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retry: Option<serde_json::Value>,
    #[serde(rename = "retryIntervalInSeconds", skip_serializing_if = "Option::is_none")]
    pub retry_interval_in_seconds: Option<i64>,
    #[serde(rename = "secureInput", skip_serializing_if = "Option::is_none")]
    pub secure_input: Option<bool>,
    #[serde(rename = "secureOutput", skip_serializing_if = "Option::is_none")]
    pub secure_output: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoreReadSettings {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "maxConcurrentConnections", skip_serializing_if = "Option::is_none")]
    pub max_concurrent_connections: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobStorageReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "listAfter", skip_serializing_if = "Option::is_none")]
    pub list_after: Option<serde_json::Value>,
    #[serde(rename = "listBefore", skip_serializing_if = "Option::is_none")]
    pub list_before: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonS3ReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileServerReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
    #[serde(rename = "fileFilter", skip_serializing_if = "Option::is_none")]
    pub file_filter: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFileStorageReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SftpWriteSettings {
    #[serde(flatten)]
    pub store_write_settings: StoreWriteSettings,
    #[serde(rename = "operationTimeout", skip_serializing_if = "Option::is_none")]
    pub operation_timeout: Option<serde_json::Value>,
    #[serde(rename = "useTempFileRename", skip_serializing_if = "Option::is_none")]
    pub use_temp_file_rename: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleCloudStorageReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FtpReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "useBinaryTransfer", skip_serializing_if = "Option::is_none")]
    pub use_binary_transfer: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SftpReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(rename = "requestMethod", skip_serializing_if = "Option::is_none")]
    pub request_method: Option<serde_json::Value>,
    #[serde(rename = "requestBody", skip_serializing_if = "Option::is_none")]
    pub request_body: Option<serde_json::Value>,
    #[serde(rename = "additionalHeaders", skip_serializing_if = "Option::is_none")]
    pub additional_headers: Option<serde_json::Value>,
    #[serde(rename = "requestTimeout", skip_serializing_if = "Option::is_none")]
    pub request_timeout: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdfsReadSettings {
    #[serde(flatten)]
    pub store_read_settings: StoreReadSettings,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "wildcardFolderPath", skip_serializing_if = "Option::is_none")]
    pub wildcard_folder_path: Option<serde_json::Value>,
    #[serde(rename = "wildcardFileName", skip_serializing_if = "Option::is_none")]
    pub wildcard_file_name: Option<serde_json::Value>,
    #[serde(rename = "fileListPath", skip_serializing_if = "Option::is_none")]
    pub file_list_path: Option<serde_json::Value>,
    #[serde(rename = "enablePartitionDiscovery", skip_serializing_if = "Option::is_none")]
    pub enable_partition_discovery: Option<bool>,
    #[serde(rename = "partitionRootPath", skip_serializing_if = "Option::is_none")]
    pub partition_root_path: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
    #[serde(rename = "distcpSettings", skip_serializing_if = "Option::is_none")]
    pub distcp_settings: Option<DistcpSettings>,
    #[serde(rename = "deleteFilesAfterCompletion", skip_serializing_if = "Option::is_none")]
    pub delete_files_after_completion: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoreWriteSettings {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "maxConcurrentConnections", skip_serializing_if = "Option::is_none")]
    pub max_concurrent_connections: Option<serde_json::Value>,
    #[serde(rename = "copyBehavior", skip_serializing_if = "Option::is_none")]
    pub copy_behavior: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobStorageWriteSettings {
    #[serde(flatten)]
    pub store_write_settings: StoreWriteSettings,
    #[serde(rename = "blockSizeInMB", skip_serializing_if = "Option::is_none")]
    pub block_size_in_mb: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsWriteSettings {
    #[serde(flatten)]
    pub store_write_settings: StoreWriteSettings,
    #[serde(rename = "blockSizeInMB", skip_serializing_if = "Option::is_none")]
    pub block_size_in_mb: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreWriteSettings {
    #[serde(flatten)]
    pub store_write_settings: StoreWriteSettings,
    #[serde(rename = "expiryDateTime", skip_serializing_if = "Option::is_none")]
    pub expiry_date_time: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileServerWriteSettings {
    #[serde(flatten)]
    pub store_write_settings: StoreWriteSettings,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFileStorageWriteSettings {
    #[serde(flatten)]
    pub store_write_settings: StoreWriteSettings,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FormatReadSettings {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CompressionReadSettings {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ZipDeflateReadSettings {
    #[serde(flatten)]
    pub compression_read_settings: CompressionReadSettings,
    #[serde(rename = "preserveZipFileNameAsFolder", skip_serializing_if = "Option::is_none")]
    pub preserve_zip_file_name_as_folder: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TarReadSettings {
    #[serde(flatten)]
    pub compression_read_settings: CompressionReadSettings,
    #[serde(rename = "preserveCompressionFileNameAsFolder", skip_serializing_if = "Option::is_none")]
    pub preserve_compression_file_name_as_folder: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TarGZipReadSettings {
    #[serde(flatten)]
    pub compression_read_settings: CompressionReadSettings,
    #[serde(rename = "preserveCompressionFileNameAsFolder", skip_serializing_if = "Option::is_none")]
    pub preserve_compression_file_name_as_folder: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DelimitedTextReadSettings {
    #[serde(flatten)]
    pub format_read_settings: FormatReadSettings,
    #[serde(rename = "skipLineCount", skip_serializing_if = "Option::is_none")]
    pub skip_line_count: Option<serde_json::Value>,
    #[serde(rename = "compressionProperties", skip_serializing_if = "Option::is_none")]
    pub compression_properties: Option<CompressionReadSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsonReadSettings {
    #[serde(flatten)]
    pub format_read_settings: FormatReadSettings,
    #[serde(rename = "compressionProperties", skip_serializing_if = "Option::is_none")]
    pub compression_properties: Option<CompressionReadSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct XmlReadSettings {
    #[serde(flatten)]
    pub format_read_settings: FormatReadSettings,
    #[serde(rename = "compressionProperties", skip_serializing_if = "Option::is_none")]
    pub compression_properties: Option<CompressionReadSettings>,
    #[serde(rename = "validationMode", skip_serializing_if = "Option::is_none")]
    pub validation_mode: Option<serde_json::Value>,
    #[serde(rename = "detectDataType", skip_serializing_if = "Option::is_none")]
    pub detect_data_type: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<serde_json::Value>,
    #[serde(rename = "namespacePrefixes", skip_serializing_if = "Option::is_none")]
    pub namespace_prefixes: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BinaryReadSettings {
    #[serde(flatten)]
    pub format_read_settings: FormatReadSettings,
    #[serde(rename = "compressionProperties", skip_serializing_if = "Option::is_none")]
    pub compression_properties: Option<CompressionReadSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FormatWriteSettings {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvroWriteSettings {
    #[serde(flatten)]
    pub format_write_settings: FormatWriteSettings,
    #[serde(rename = "recordName", skip_serializing_if = "Option::is_none")]
    pub record_name: Option<String>,
    #[serde(rename = "recordNamespace", skip_serializing_if = "Option::is_none")]
    pub record_namespace: Option<String>,
    #[serde(rename = "maxRowsPerFile", skip_serializing_if = "Option::is_none")]
    pub max_rows_per_file: Option<serde_json::Value>,
    #[serde(rename = "fileNamePrefix", skip_serializing_if = "Option::is_none")]
    pub file_name_prefix: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrcWriteSettings {
    #[serde(flatten)]
    pub format_write_settings: FormatWriteSettings,
    #[serde(rename = "maxRowsPerFile", skip_serializing_if = "Option::is_none")]
    pub max_rows_per_file: Option<serde_json::Value>,
    #[serde(rename = "fileNamePrefix", skip_serializing_if = "Option::is_none")]
    pub file_name_prefix: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParquetWriteSettings {
    #[serde(flatten)]
    pub format_write_settings: FormatWriteSettings,
    #[serde(rename = "maxRowsPerFile", skip_serializing_if = "Option::is_none")]
    pub max_rows_per_file: Option<serde_json::Value>,
    #[serde(rename = "fileNamePrefix", skip_serializing_if = "Option::is_none")]
    pub file_name_prefix: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DelimitedTextWriteSettings {
    #[serde(flatten)]
    pub format_write_settings: FormatWriteSettings,
    #[serde(rename = "quoteAllText", skip_serializing_if = "Option::is_none")]
    pub quote_all_text: Option<serde_json::Value>,
    #[serde(rename = "fileExtension")]
    pub file_extension: serde_json::Value,
    #[serde(rename = "maxRowsPerFile", skip_serializing_if = "Option::is_none")]
    pub max_rows_per_file: Option<serde_json::Value>,
    #[serde(rename = "fileNamePrefix", skip_serializing_if = "Option::is_none")]
    pub file_name_prefix: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsonWriteSettings {
    #[serde(flatten)]
    pub format_write_settings: FormatWriteSettings,
    #[serde(rename = "filePattern", skip_serializing_if = "Option::is_none")]
    pub file_pattern: Option<json_write_settings::FilePattern>,
}
pub mod json_write_settings {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum FilePattern {
        #[serde(rename = "setOfObjects")]
        SetOfObjects,
        #[serde(rename = "arrayOfObjects")]
        ArrayOfObjects,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvroSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExcelSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParquetSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DelimitedTextSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<DelimitedTextReadSettings>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsonSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<JsonReadSettings>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct XmlSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<XmlReadSettings>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrcSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DelimitedTextSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreWriteSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<DelimitedTextWriteSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsonSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreWriteSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<JsonWriteSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrcSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreWriteSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<OrcWriteSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopyActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: CopyActivityTypeProperties,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub inputs: Vec<DatasetReference>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub outputs: Vec<DatasetReference>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopyActivityTypeProperties {
    pub source: CopySource,
    pub sink: CopySink,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub translator: Option<serde_json::Value>,
    #[serde(rename = "enableStaging", skip_serializing_if = "Option::is_none")]
    pub enable_staging: Option<serde_json::Value>,
    #[serde(rename = "stagingSettings", skip_serializing_if = "Option::is_none")]
    pub staging_settings: Option<StagingSettings>,
    #[serde(rename = "parallelCopies", skip_serializing_if = "Option::is_none")]
    pub parallel_copies: Option<serde_json::Value>,
    #[serde(rename = "dataIntegrationUnits", skip_serializing_if = "Option::is_none")]
    pub data_integration_units: Option<serde_json::Value>,
    #[serde(rename = "enableSkipIncompatibleRow", skip_serializing_if = "Option::is_none")]
    pub enable_skip_incompatible_row: Option<serde_json::Value>,
    #[serde(rename = "redirectIncompatibleRowSettings", skip_serializing_if = "Option::is_none")]
    pub redirect_incompatible_row_settings: Option<RedirectIncompatibleRowSettings>,
    #[serde(rename = "logStorageSettings", skip_serializing_if = "Option::is_none")]
    pub log_storage_settings: Option<LogStorageSettings>,
    #[serde(rename = "logSettings", skip_serializing_if = "Option::is_none")]
    pub log_settings: Option<LogSettings>,
    #[serde(rename = "preserveRules", skip_serializing_if = "Vec::is_empty")]
    pub preserve_rules: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub preserve: Vec<serde_json::Value>,
    #[serde(rename = "validateDataConsistency", skip_serializing_if = "Option::is_none")]
    pub validate_data_consistency: Option<serde_json::Value>,
    #[serde(rename = "skipErrorFile", skip_serializing_if = "Option::is_none")]
    pub skip_error_file: Option<SkipErrorFile>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopySource {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "sourceRetryCount", skip_serializing_if = "Option::is_none")]
    pub source_retry_count: Option<serde_json::Value>,
    #[serde(rename = "sourceRetryWait", skip_serializing_if = "Option::is_none")]
    pub source_retry_wait: Option<serde_json::Value>,
    #[serde(rename = "maxConcurrentConnections", skip_serializing_if = "Option::is_none")]
    pub max_concurrent_connections: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BinarySource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<BinaryReadSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TabularSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "queryTimeout", skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureTableSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(rename = "azureTableSourceQuery", skip_serializing_if = "Option::is_none")]
    pub azure_table_source_query: Option<serde_json::Value>,
    #[serde(rename = "azureTableSourceIgnoreTableNotFound", skip_serializing_if = "Option::is_none")]
    pub azure_table_source_ignore_table_not_found: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BlobSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "treatEmptyAsNull", skip_serializing_if = "Option::is_none")]
    pub treat_empty_as_null: Option<serde_json::Value>,
    #[serde(rename = "skipHeaderLineCount", skip_serializing_if = "Option::is_none")]
    pub skip_header_line_count: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DocumentDbCollectionSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "nestingSeparator", skip_serializing_if = "Option::is_none")]
    pub nesting_separator: Option<serde_json::Value>,
    #[serde(rename = "queryTimeout", skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbSqlApiSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "pageSize", skip_serializing_if = "Option::is_none")]
    pub page_size: Option<serde_json::Value>,
    #[serde(rename = "preferredRegions", skip_serializing_if = "Option::is_none")]
    pub preferred_regions: Option<serde_json::Value>,
    #[serde(rename = "detectDatetime", skip_serializing_if = "Option::is_none")]
    pub detect_datetime: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsCrmSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommonDataServiceForAppsSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RelationalSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InformixSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MicrosoftAccessSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Db2Source {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OdbcSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MySqlSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PostgreSqlSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SybaseSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapBwSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ODataSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "readBehavior", skip_serializing_if = "Option::is_none")]
    pub read_behavior: Option<salesforce_source::ReadBehavior>,
}
pub mod salesforce_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ReadBehavior {
        Query,
        QueryAll,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceServiceCloudSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "readBehavior", skip_serializing_if = "Option::is_none")]
    pub read_behavior: Option<salesforce_service_cloud_source::ReadBehavior>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
pub mod salesforce_service_cloud_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ReadBehavior {
        Query,
        QueryAll,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapCloudForCustomerSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapEccSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapHanaSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "packetSize", skip_serializing_if = "Option::is_none")]
    pub packet_size: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<sap_hana_source::PartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<SapHanaPartitionSettings>,
}
pub mod sap_hana_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PartitionOption {
        None,
        PhysicalPartitionsOfTable,
        SapHanaDynamicRange,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapHanaPartitionSettings {
    #[serde(rename = "partitionColumnName", skip_serializing_if = "Option::is_none")]
    pub partition_column_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapOpenHubSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(rename = "excludeLastRequest", skip_serializing_if = "Option::is_none")]
    pub exclude_last_request: Option<serde_json::Value>,
    #[serde(rename = "baseRequestId", skip_serializing_if = "Option::is_none")]
    pub base_request_id: Option<serde_json::Value>,
    #[serde(rename = "customRfcReadTableFunctionModule", skip_serializing_if = "Option::is_none")]
    pub custom_rfc_read_table_function_module: Option<serde_json::Value>,
    #[serde(rename = "sapDataColumnDelimiter", skip_serializing_if = "Option::is_none")]
    pub sap_data_column_delimiter: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapTableSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(rename = "rowCount", skip_serializing_if = "Option::is_none")]
    pub row_count: Option<serde_json::Value>,
    #[serde(rename = "rowSkips", skip_serializing_if = "Option::is_none")]
    pub row_skips: Option<serde_json::Value>,
    #[serde(rename = "rfcTableFields", skip_serializing_if = "Option::is_none")]
    pub rfc_table_fields: Option<serde_json::Value>,
    #[serde(rename = "rfcTableOptions", skip_serializing_if = "Option::is_none")]
    pub rfc_table_options: Option<serde_json::Value>,
    #[serde(rename = "batchSize", skip_serializing_if = "Option::is_none")]
    pub batch_size: Option<serde_json::Value>,
    #[serde(rename = "customRfcReadTableFunctionModule", skip_serializing_if = "Option::is_none")]
    pub custom_rfc_read_table_function_module: Option<serde_json::Value>,
    #[serde(rename = "sapDataColumnDelimiter", skip_serializing_if = "Option::is_none")]
    pub sap_data_column_delimiter: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<sap_table_source::PartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<SapTablePartitionSettings>,
}
pub mod sap_table_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PartitionOption {
        None,
        PartitionOnInt,
        PartitionOnCalendarYear,
        PartitionOnCalendarMonth,
        PartitionOnCalendarDate,
        PartitionOnTime,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapTablePartitionSettings {
    #[serde(rename = "partitionColumnName", skip_serializing_if = "Option::is_none")]
    pub partition_column_name: Option<serde_json::Value>,
    #[serde(rename = "partitionUpperBound", skip_serializing_if = "Option::is_none")]
    pub partition_upper_bound: Option<serde_json::Value>,
    #[serde(rename = "partitionLowerBound", skip_serializing_if = "Option::is_none")]
    pub partition_lower_bound: Option<serde_json::Value>,
    #[serde(rename = "maxPartitionsNumber", skip_serializing_if = "Option::is_none")]
    pub max_partitions_number: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "requestMethod", skip_serializing_if = "Option::is_none")]
    pub request_method: Option<serde_json::Value>,
    #[serde(rename = "additionalHeaders", skip_serializing_if = "Option::is_none")]
    pub additional_headers: Option<serde_json::Value>,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
    #[serde(rename = "requestInterval", skip_serializing_if = "Option::is_none")]
    pub request_interval: Option<serde_json::Value>,
    #[serde(rename = "httpCompressionType", skip_serializing_if = "Option::is_none")]
    pub http_compression_type: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "requestMethod", skip_serializing_if = "Option::is_none")]
    pub request_method: Option<serde_json::Value>,
    #[serde(rename = "requestBody", skip_serializing_if = "Option::is_none")]
    pub request_body: Option<serde_json::Value>,
    #[serde(rename = "additionalHeaders", skip_serializing_if = "Option::is_none")]
    pub additional_headers: Option<serde_json::Value>,
    #[serde(rename = "paginationRules", skip_serializing_if = "Option::is_none")]
    pub pagination_rules: Option<serde_json::Value>,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
    #[serde(rename = "requestInterval", skip_serializing_if = "Option::is_none")]
    pub request_interval: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(rename = "sqlReaderQuery", skip_serializing_if = "Option::is_none")]
    pub sql_reader_query: Option<serde_json::Value>,
    #[serde(rename = "sqlReaderStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_reader_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "isolationLevel", skip_serializing_if = "Option::is_none")]
    pub isolation_level: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<SqlPartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<SqlPartitionSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlServerSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(rename = "sqlReaderQuery", skip_serializing_if = "Option::is_none")]
    pub sql_reader_query: Option<serde_json::Value>,
    #[serde(rename = "sqlReaderStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_reader_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "produceAdditionalTypes", skip_serializing_if = "Option::is_none")]
    pub produce_additional_types: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<SqlPartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<SqlPartitionSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(rename = "sqlReaderQuery", skip_serializing_if = "Option::is_none")]
    pub sql_reader_query: Option<serde_json::Value>,
    #[serde(rename = "sqlReaderStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_reader_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "produceAdditionalTypes", skip_serializing_if = "Option::is_none")]
    pub produce_additional_types: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<SqlPartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<SqlPartitionSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlMiSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(rename = "sqlReaderQuery", skip_serializing_if = "Option::is_none")]
    pub sql_reader_query: Option<serde_json::Value>,
    #[serde(rename = "sqlReaderStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_reader_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "produceAdditionalTypes", skip_serializing_if = "Option::is_none")]
    pub produce_additional_types: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<SqlPartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<SqlPartitionSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlDwSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(rename = "sqlReaderQuery", skip_serializing_if = "Option::is_none")]
    pub sql_reader_query: Option<serde_json::Value>,
    #[serde(rename = "sqlReaderStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_reader_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<SqlPartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<SqlPartitionSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPartitionSettings {
    #[serde(rename = "partitionColumnName", skip_serializing_if = "Option::is_none")]
    pub partition_column_name: Option<serde_json::Value>,
    #[serde(rename = "partitionUpperBound", skip_serializing_if = "Option::is_none")]
    pub partition_upper_bound: Option<serde_json::Value>,
    #[serde(rename = "partitionLowerBound", skip_serializing_if = "Option::is_none")]
    pub partition_lower_bound: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SqlPartitionOption {
    None,
    PhysicalPartitionsOfTable,
    DynamicRange,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileSystemSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdfsSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "distcpSettings", skip_serializing_if = "Option::is_none")]
    pub distcp_settings: Option<DistcpSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DistcpSettings {
    #[serde(rename = "resourceManagerEndpoint")]
    pub resource_manager_endpoint: serde_json::Value,
    #[serde(rename = "tempScriptPath")]
    pub temp_script_path: serde_json::Value,
    #[serde(rename = "distcpOptions", skip_serializing_if = "Option::is_none")]
    pub distcp_options: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMySqlSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataExplorerSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    pub query: serde_json::Value,
    #[serde(rename = "noTruncation", skip_serializing_if = "Option::is_none")]
    pub no_truncation: Option<serde_json::Value>,
    #[serde(rename = "queryTimeout", skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "oracleReaderQuery", skip_serializing_if = "Option::is_none")]
    pub oracle_reader_query: Option<serde_json::Value>,
    #[serde(rename = "queryTimeout", skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<oracle_source::PartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<OraclePartitionSettings>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
pub mod oracle_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PartitionOption {
        None,
        PhysicalPartitionsOfTable,
        DynamicRange,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OraclePartitionSettings {
    #[serde(rename = "partitionNames", skip_serializing_if = "Option::is_none")]
    pub partition_names: Option<serde_json::Value>,
    #[serde(rename = "partitionColumnName", skip_serializing_if = "Option::is_none")]
    pub partition_column_name: Option<serde_json::Value>,
    #[serde(rename = "partitionUpperBound", skip_serializing_if = "Option::is_none")]
    pub partition_upper_bound: Option<serde_json::Value>,
    #[serde(rename = "partitionLowerBound", skip_serializing_if = "Option::is_none")]
    pub partition_lower_bound: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TeradataSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<teradata_source::PartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<TeradataPartitionSettings>,
}
pub mod teradata_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PartitionOption {
        None,
        Hash,
        DynamicRange,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TeradataPartitionSettings {
    #[serde(rename = "partitionColumnName", skip_serializing_if = "Option::is_none")]
    pub partition_column_name: Option<serde_json::Value>,
    #[serde(rename = "partitionUpperBound", skip_serializing_if = "Option::is_none")]
    pub partition_upper_bound: Option<serde_json::Value>,
    #[serde(rename = "partitionLowerBound", skip_serializing_if = "Option::is_none")]
    pub partition_lower_bound: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CassandraSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "consistencyLevel", skip_serializing_if = "Option::is_none")]
    pub consistency_level: Option<cassandra_source::ConsistencyLevel>,
}
pub mod cassandra_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ConsistencyLevel {
        #[serde(rename = "ALL")]
        All,
        #[serde(rename = "EACH_QUORUM")]
        EachQuorum,
        #[serde(rename = "QUORUM")]
        Quorum,
        #[serde(rename = "LOCAL_QUORUM")]
        LocalQuorum,
        #[serde(rename = "ONE")]
        One,
        #[serde(rename = "TWO")]
        Two,
        #[serde(rename = "THREE")]
        Three,
        #[serde(rename = "LOCAL_ONE")]
        LocalOne,
        #[serde(rename = "SERIAL")]
        Serial,
        #[serde(rename = "LOCAL_SERIAL")]
        LocalSerial,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbAtlasSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filter: Option<serde_json::Value>,
    #[serde(rename = "cursorMethods", skip_serializing_if = "Option::is_none")]
    pub cursor_methods: Option<MongoDbCursorMethodsProperties>,
    #[serde(rename = "batchSize", skip_serializing_if = "Option::is_none")]
    pub batch_size: Option<serde_json::Value>,
    #[serde(rename = "queryTimeout", skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbV2Source {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filter: Option<serde_json::Value>,
    #[serde(rename = "cursorMethods", skip_serializing_if = "Option::is_none")]
    pub cursor_methods: Option<MongoDbCursorMethodsProperties>,
    #[serde(rename = "batchSize", skip_serializing_if = "Option::is_none")]
    pub batch_size: Option<serde_json::Value>,
    #[serde(rename = "queryTimeout", skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbMongoDbApiSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filter: Option<serde_json::Value>,
    #[serde(rename = "cursorMethods", skip_serializing_if = "Option::is_none")]
    pub cursor_methods: Option<MongoDbCursorMethodsProperties>,
    #[serde(rename = "batchSize", skip_serializing_if = "Option::is_none")]
    pub batch_size: Option<serde_json::Value>,
    #[serde(rename = "queryTimeout", skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<serde_json::Value>,
    #[serde(rename = "additionalColumns", skip_serializing_if = "Vec::is_empty")]
    pub additional_columns: Vec<AdditionalColumns>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbCursorMethodsProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub project: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub skip: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Office365Source {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "allowedGroups", skip_serializing_if = "Option::is_none")]
    pub allowed_groups: Option<serde_json::Value>,
    #[serde(rename = "userScopeFilterUri", skip_serializing_if = "Option::is_none")]
    pub user_scope_filter_uri: Option<serde_json::Value>,
    #[serde(rename = "dateFilterColumn", skip_serializing_if = "Option::is_none")]
    pub date_filter_column: Option<serde_json::Value>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<serde_json::Value>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<serde_json::Value>,
    #[serde(rename = "outputColumns", skip_serializing_if = "Option::is_none")]
    pub output_columns: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "treatEmptyAsNull", skip_serializing_if = "Option::is_none")]
    pub treat_empty_as_null: Option<serde_json::Value>,
    #[serde(rename = "skipHeaderLineCount", skip_serializing_if = "Option::is_none")]
    pub skip_header_line_count: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonMwsSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzurePostgreSqlSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzurePostgreSqlSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMySqlSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConcurSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CouchbaseSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DrillSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EloquaSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleBigQuerySource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GreenplumSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HBaseSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HiveSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubspotSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImpalaSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JiraSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MagentoSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MariaDbSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMariaDbSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MarketoSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PaypalSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PhoenixSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrestoSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QuickBooksSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceNowSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ShopifySource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SparkSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SquareSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct XeroSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ZohoSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetezzaSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "partitionOption", skip_serializing_if = "Option::is_none")]
    pub partition_option: Option<netezza_source::PartitionOption>,
    #[serde(rename = "partitionSettings", skip_serializing_if = "Option::is_none")]
    pub partition_settings: Option<NetezzaPartitionSettings>,
}
pub mod netezza_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PartitionOption {
        None,
        DataSlice,
        DynamicRange,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetezzaPartitionSettings {
    #[serde(rename = "partitionColumnName", skip_serializing_if = "Option::is_none")]
    pub partition_column_name: Option<serde_json::Value>,
    #[serde(rename = "partitionUpperBound", skip_serializing_if = "Option::is_none")]
    pub partition_upper_bound: Option<serde_json::Value>,
    #[serde(rename = "partitionLowerBound", skip_serializing_if = "Option::is_none")]
    pub partition_lower_bound: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VerticaSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceMarketingCloudSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResponsysSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsAxSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleServiceCloudSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleAdWordsSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonRedshiftSource {
    #[serde(flatten)]
    pub tabular_source: TabularSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "redshiftUnloadSettings", skip_serializing_if = "Option::is_none")]
    pub redshift_unload_settings: Option<RedshiftUnloadSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RedshiftUnloadSettings {
    #[serde(rename = "s3LinkedServiceName")]
    pub s3_linked_service_name: LinkedServiceReference,
    #[serde(rename = "bucketName")]
    pub bucket_name: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SnowflakeSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "exportSettings", skip_serializing_if = "Option::is_none")]
    pub export_settings: Option<SnowflakeExportCopyCommand>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExportSettings {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SnowflakeExportCopyCommand {
    #[serde(flatten)]
    pub export_settings: ExportSettings,
    #[serde(rename = "additionalCopyOptions", skip_serializing_if = "Option::is_none")]
    pub additional_copy_options: Option<serde_json::Value>,
    #[serde(rename = "additionalFormatOptions", skip_serializing_if = "Option::is_none")]
    pub additional_format_options: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksDeltaLakeSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "exportSettings", skip_serializing_if = "Option::is_none")]
    pub export_settings: Option<AzureDatabricksDeltaLakeExportCommand>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksDeltaLakeExportCommand {
    #[serde(flatten)]
    pub export_settings: ExportSettings,
    #[serde(rename = "dateFormat", skip_serializing_if = "Option::is_none")]
    pub date_format: Option<serde_json::Value>,
    #[serde(rename = "timestampFormat", skip_serializing_if = "Option::is_none")]
    pub timestamp_format: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksDeltaLakeSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
    #[serde(rename = "importSettings", skip_serializing_if = "Option::is_none")]
    pub import_settings: Option<AzureDatabricksDeltaLakeImportCommand>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksDeltaLakeImportCommand {
    #[serde(flatten)]
    pub import_settings: ImportSettings,
    #[serde(rename = "dateFormat", skip_serializing_if = "Option::is_none")]
    pub date_format: Option<serde_json::Value>,
    #[serde(rename = "timestampFormat", skip_serializing_if = "Option::is_none")]
    pub timestamp_format: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoredProcedureParameter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<StoredProcedureParameterType>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum StoredProcedureParameterType {
    String,
    Int,
    Int64,
    Decimal,
    Guid,
    Boolean,
    Date,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopySink {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "writeBatchSize", skip_serializing_if = "Option::is_none")]
    pub write_batch_size: Option<serde_json::Value>,
    #[serde(rename = "writeBatchTimeout", skip_serializing_if = "Option::is_none")]
    pub write_batch_timeout: Option<serde_json::Value>,
    #[serde(rename = "sinkRetryCount", skip_serializing_if = "Option::is_none")]
    pub sink_retry_count: Option<serde_json::Value>,
    #[serde(rename = "sinkRetryWait", skip_serializing_if = "Option::is_none")]
    pub sink_retry_wait: Option<serde_json::Value>,
    #[serde(rename = "maxConcurrentConnections", skip_serializing_if = "Option::is_none")]
    pub max_concurrent_connections: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapCloudForCustomerSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior", skip_serializing_if = "Option::is_none")]
    pub write_behavior: Option<sap_cloud_for_customer_sink::WriteBehavior>,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
}
pub mod sap_cloud_for_customer_sink {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum WriteBehavior {
        Insert,
        Update,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureQueueSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum CopyBehaviorType {
    PreserveHierarchy,
    FlattenHierarchy,
    MergeFiles,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureTableSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "azureTableDefaultPartitionKeyValue", skip_serializing_if = "Option::is_none")]
    pub azure_table_default_partition_key_value: Option<serde_json::Value>,
    #[serde(rename = "azureTablePartitionKeyName", skip_serializing_if = "Option::is_none")]
    pub azure_table_partition_key_name: Option<serde_json::Value>,
    #[serde(rename = "azureTableRowKeyName", skip_serializing_if = "Option::is_none")]
    pub azure_table_row_key_name: Option<serde_json::Value>,
    #[serde(rename = "azureTableInsertType", skip_serializing_if = "Option::is_none")]
    pub azure_table_insert_type: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvroSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreWriteSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<AvroWriteSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParquetSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreWriteSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<ParquetWriteSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BinarySink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreWriteSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BlobSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "blobWriterOverwriteFiles", skip_serializing_if = "Option::is_none")]
    pub blob_writer_overwrite_files: Option<serde_json::Value>,
    #[serde(rename = "blobWriterDateTimeFormat", skip_serializing_if = "Option::is_none")]
    pub blob_writer_date_time_format: Option<serde_json::Value>,
    #[serde(rename = "blobWriterAddHeader", skip_serializing_if = "Option::is_none")]
    pub blob_writer_add_header: Option<serde_json::Value>,
    #[serde(rename = "copyBehavior", skip_serializing_if = "Option::is_none")]
    pub copy_behavior: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileSystemSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "copyBehavior", skip_serializing_if = "Option::is_none")]
    pub copy_behavior: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DocumentDbCollectionSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "nestingSeparator", skip_serializing_if = "Option::is_none")]
    pub nesting_separator: Option<serde_json::Value>,
    #[serde(rename = "writeBehavior", skip_serializing_if = "Option::is_none")]
    pub write_behavior: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbSqlApiSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior", skip_serializing_if = "Option::is_none")]
    pub write_behavior: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "sqlWriterStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_writer_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "sqlWriterTableType", skip_serializing_if = "Option::is_none")]
    pub sql_writer_table_type: Option<serde_json::Value>,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureTableTypeParameterName", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_table_type_parameter_name: Option<serde_json::Value>,
    #[serde(rename = "tableOption", skip_serializing_if = "Option::is_none")]
    pub table_option: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlServerSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "sqlWriterStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_writer_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "sqlWriterTableType", skip_serializing_if = "Option::is_none")]
    pub sql_writer_table_type: Option<serde_json::Value>,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureTableTypeParameterName", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_table_type_parameter_name: Option<serde_json::Value>,
    #[serde(rename = "tableOption", skip_serializing_if = "Option::is_none")]
    pub table_option: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "sqlWriterStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_writer_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "sqlWriterTableType", skip_serializing_if = "Option::is_none")]
    pub sql_writer_table_type: Option<serde_json::Value>,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureTableTypeParameterName", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_table_type_parameter_name: Option<serde_json::Value>,
    #[serde(rename = "tableOption", skip_serializing_if = "Option::is_none")]
    pub table_option: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlMiSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "sqlWriterStoredProcedureName", skip_serializing_if = "Option::is_none")]
    pub sql_writer_stored_procedure_name: Option<serde_json::Value>,
    #[serde(rename = "sqlWriterTableType", skip_serializing_if = "Option::is_none")]
    pub sql_writer_table_type: Option<serde_json::Value>,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
    #[serde(rename = "storedProcedureTableTypeParameterName", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_table_type_parameter_name: Option<serde_json::Value>,
    #[serde(rename = "tableOption", skip_serializing_if = "Option::is_none")]
    pub table_option: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlDwSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
    #[serde(rename = "allowPolyBase", skip_serializing_if = "Option::is_none")]
    pub allow_poly_base: Option<serde_json::Value>,
    #[serde(rename = "polyBaseSettings", skip_serializing_if = "Option::is_none")]
    pub poly_base_settings: Option<PolybaseSettings>,
    #[serde(rename = "allowCopyCommand", skip_serializing_if = "Option::is_none")]
    pub allow_copy_command: Option<serde_json::Value>,
    #[serde(rename = "copyCommandSettings", skip_serializing_if = "Option::is_none")]
    pub copy_command_settings: Option<DwCopyCommandSettings>,
    #[serde(rename = "tableOption", skip_serializing_if = "Option::is_none")]
    pub table_option: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PolybaseSettings {
    #[serde(rename = "rejectType", skip_serializing_if = "Option::is_none")]
    pub reject_type: Option<PolybaseSettingsRejectType>,
    #[serde(rename = "rejectValue", skip_serializing_if = "Option::is_none")]
    pub reject_value: Option<serde_json::Value>,
    #[serde(rename = "rejectSampleValue", skip_serializing_if = "Option::is_none")]
    pub reject_sample_value: Option<serde_json::Value>,
    #[serde(rename = "useTypeDefault", skip_serializing_if = "Option::is_none")]
    pub use_type_default: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum PolybaseSettingsRejectType {
    #[serde(rename = "value")]
    Value,
    #[serde(rename = "percentage")]
    Percentage,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DwCopyCommandSettings {
    #[serde(rename = "defaultValues", skip_serializing_if = "Vec::is_empty")]
    pub default_values: Vec<DwCopyCommandDefaultValue>,
    #[serde(rename = "additionalOptions", skip_serializing_if = "Option::is_none")]
    pub additional_options: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DwCopyCommandDefaultValue {
    #[serde(rename = "columnName", skip_serializing_if = "Option::is_none")]
    pub column_name: Option<serde_json::Value>,
    #[serde(rename = "defaultValue", skip_serializing_if = "Option::is_none")]
    pub default_value: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SnowflakeSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
    #[serde(rename = "importSettings", skip_serializing_if = "Option::is_none")]
    pub import_settings: Option<SnowflakeImportCopyCommand>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImportSettings {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SnowflakeImportCopyCommand {
    #[serde(flatten)]
    pub import_settings: ImportSettings,
    #[serde(rename = "additionalCopyOptions", skip_serializing_if = "Option::is_none")]
    pub additional_copy_options: Option<serde_json::Value>,
    #[serde(rename = "additionalFormatOptions", skip_serializing_if = "Option::is_none")]
    pub additional_format_options: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LogStorageSettings {
    #[serde(rename = "linkedServiceName")]
    pub linked_service_name: LinkedServiceReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<serde_json::Value>,
    #[serde(rename = "logLevel", skip_serializing_if = "Option::is_none")]
    pub log_level: Option<serde_json::Value>,
    #[serde(rename = "enableReliableLogging", skip_serializing_if = "Option::is_none")]
    pub enable_reliable_logging: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LogSettings {
    #[serde(rename = "enableCopyActivityLog", skip_serializing_if = "Option::is_none")]
    pub enable_copy_activity_log: Option<serde_json::Value>,
    #[serde(rename = "copyActivityLogSettings", skip_serializing_if = "Option::is_none")]
    pub copy_activity_log_settings: Option<CopyActivityLogSettings>,
    #[serde(rename = "logLocationSettings")]
    pub log_location_settings: LogLocationSettings,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LogLocationSettings {
    #[serde(rename = "linkedServiceName")]
    pub linked_service_name: LinkedServiceReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopyActivityLogSettings {
    #[serde(rename = "logLevel", skip_serializing_if = "Option::is_none")]
    pub log_level: Option<serde_json::Value>,
    #[serde(rename = "enableReliableLogging", skip_serializing_if = "Option::is_none")]
    pub enable_reliable_logging: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StagingSettings {
    #[serde(rename = "linkedServiceName")]
    pub linked_service_name: LinkedServiceReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<serde_json::Value>,
    #[serde(rename = "enableCompression", skip_serializing_if = "Option::is_none")]
    pub enable_compression: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RedirectIncompatibleRowSettings {
    #[serde(rename = "linkedServiceName")]
    pub linked_service_name: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SkipErrorFile {
    #[serde(rename = "fileMissing", skip_serializing_if = "Option::is_none")]
    pub file_missing: Option<serde_json::Value>,
    #[serde(rename = "dataInconsistency", skip_serializing_if = "Option::is_none")]
    pub data_inconsistency: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AdditionalColumns {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "copyBehavior", skip_serializing_if = "Option::is_none")]
    pub copy_behavior: Option<serde_json::Value>,
    #[serde(rename = "enableAdlsSingleFileParallel", skip_serializing_if = "Option::is_none")]
    pub enable_adls_single_file_parallel: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "copyBehavior", skip_serializing_if = "Option::is_none")]
    pub copy_behavior: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSearchIndexSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior", skip_serializing_if = "Option::is_none")]
    pub write_behavior: Option<azure_search_index_sink::WriteBehavior>,
}
pub mod azure_search_index_sink {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum WriteBehavior {
        Merge,
        Upload,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OdbcSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InformixSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MicrosoftAccessSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "preCopyScript", skip_serializing_if = "Option::is_none")]
    pub pre_copy_script: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum DynamicsSinkWriteBehavior {
    Upsert,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior")]
    pub write_behavior: DynamicsSinkWriteBehavior,
    #[serde(rename = "ignoreNullValues", skip_serializing_if = "Option::is_none")]
    pub ignore_null_values: Option<serde_json::Value>,
    #[serde(rename = "alternateKeyName", skip_serializing_if = "Option::is_none")]
    pub alternate_key_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsCrmSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior")]
    pub write_behavior: DynamicsSinkWriteBehavior,
    #[serde(rename = "ignoreNullValues", skip_serializing_if = "Option::is_none")]
    pub ignore_null_values: Option<serde_json::Value>,
    #[serde(rename = "alternateKeyName", skip_serializing_if = "Option::is_none")]
    pub alternate_key_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommonDataServiceForAppsSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior")]
    pub write_behavior: DynamicsSinkWriteBehavior,
    #[serde(rename = "ignoreNullValues", skip_serializing_if = "Option::is_none")]
    pub ignore_null_values: Option<serde_json::Value>,
    #[serde(rename = "alternateKeyName", skip_serializing_if = "Option::is_none")]
    pub alternate_key_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataExplorerSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "ingestionMappingName", skip_serializing_if = "Option::is_none")]
    pub ingestion_mapping_name: Option<serde_json::Value>,
    #[serde(rename = "ingestionMappingAsJson", skip_serializing_if = "Option::is_none")]
    pub ingestion_mapping_as_json: Option<serde_json::Value>,
    #[serde(rename = "flushImmediately", skip_serializing_if = "Option::is_none")]
    pub flush_immediately: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior", skip_serializing_if = "Option::is_none")]
    pub write_behavior: Option<salesforce_sink::WriteBehavior>,
    #[serde(rename = "externalIdFieldName", skip_serializing_if = "Option::is_none")]
    pub external_id_field_name: Option<serde_json::Value>,
    #[serde(rename = "ignoreNullValues", skip_serializing_if = "Option::is_none")]
    pub ignore_null_values: Option<serde_json::Value>,
}
pub mod salesforce_sink {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum WriteBehavior {
        Insert,
        Upsert,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceServiceCloudSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior", skip_serializing_if = "Option::is_none")]
    pub write_behavior: Option<salesforce_service_cloud_sink::WriteBehavior>,
    #[serde(rename = "externalIdFieldName", skip_serializing_if = "Option::is_none")]
    pub external_id_field_name: Option<serde_json::Value>,
    #[serde(rename = "ignoreNullValues", skip_serializing_if = "Option::is_none")]
    pub ignore_null_values: Option<serde_json::Value>,
}
pub mod salesforce_service_cloud_sink {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum WriteBehavior {
        Insert,
        Upsert,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbMongoDbApiSink {
    #[serde(flatten)]
    pub copy_sink: CopySink,
    #[serde(rename = "writeBehavior", skip_serializing_if = "Option::is_none")]
    pub write_behavior: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopyTranslator {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TabularTranslator {
    #[serde(flatten)]
    pub copy_translator: CopyTranslator,
    #[serde(rename = "columnMappings", skip_serializing_if = "Option::is_none")]
    pub column_mappings: Option<serde_json::Value>,
    #[serde(rename = "schemaMapping", skip_serializing_if = "Option::is_none")]
    pub schema_mapping: Option<serde_json::Value>,
    #[serde(rename = "collectionReference", skip_serializing_if = "Option::is_none")]
    pub collection_reference: Option<serde_json::Value>,
    #[serde(rename = "mapComplexValuesToString", skip_serializing_if = "Option::is_none")]
    pub map_complex_values_to_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mappings: Option<serde_json::Value>,
    #[serde(rename = "typeConversion", skip_serializing_if = "Option::is_none")]
    pub type_conversion: Option<serde_json::Value>,
    #[serde(rename = "typeConversionSettings", skip_serializing_if = "Option::is_none")]
    pub type_conversion_settings: Option<TypeConversionSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TypeConversionSettings {
    #[serde(rename = "allowDataTruncation", skip_serializing_if = "Option::is_none")]
    pub allow_data_truncation: Option<serde_json::Value>,
    #[serde(rename = "treatBooleanAsNumber", skip_serializing_if = "Option::is_none")]
    pub treat_boolean_as_number: Option<serde_json::Value>,
    #[serde(rename = "dateTimeFormat", skip_serializing_if = "Option::is_none")]
    pub date_time_format: Option<serde_json::Value>,
    #[serde(rename = "dateTimeOffsetFormat", skip_serializing_if = "Option::is_none")]
    pub date_time_offset_format: Option<serde_json::Value>,
    #[serde(rename = "timeSpanFormat", skip_serializing_if = "Option::is_none")]
    pub time_span_format: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub culture: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightHiveActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: HdInsightHiveActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightHiveActivityTypeProperties {
    #[serde(rename = "storageLinkedServices", skip_serializing_if = "Vec::is_empty")]
    pub storage_linked_services: Vec<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub arguments: Vec<serde_json::Value>,
    #[serde(rename = "getDebugInfo", skip_serializing_if = "Option::is_none")]
    pub get_debug_info: Option<HdInsightActivityDebugInfoOption>,
    #[serde(rename = "scriptPath", skip_serializing_if = "Option::is_none")]
    pub script_path: Option<serde_json::Value>,
    #[serde(rename = "scriptLinkedService", skip_serializing_if = "Option::is_none")]
    pub script_linked_service: Option<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub defines: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub variables: Vec<serde_json::Value>,
    #[serde(rename = "queryTimeout", skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum HdInsightActivityDebugInfoOption {
    None,
    Always,
    Failure,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightPigActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: HdInsightPigActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightPigActivityTypeProperties {
    #[serde(rename = "storageLinkedServices", skip_serializing_if = "Vec::is_empty")]
    pub storage_linked_services: Vec<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<serde_json::Value>,
    #[serde(rename = "getDebugInfo", skip_serializing_if = "Option::is_none")]
    pub get_debug_info: Option<HdInsightActivityDebugInfoOption>,
    #[serde(rename = "scriptPath", skip_serializing_if = "Option::is_none")]
    pub script_path: Option<serde_json::Value>,
    #[serde(rename = "scriptLinkedService", skip_serializing_if = "Option::is_none")]
    pub script_linked_service: Option<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub defines: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightMapReduceActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: HdInsightMapReduceActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightMapReduceActivityTypeProperties {
    #[serde(rename = "storageLinkedServices", skip_serializing_if = "Vec::is_empty")]
    pub storage_linked_services: Vec<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub arguments: Vec<serde_json::Value>,
    #[serde(rename = "getDebugInfo", skip_serializing_if = "Option::is_none")]
    pub get_debug_info: Option<HdInsightActivityDebugInfoOption>,
    #[serde(rename = "className")]
    pub class_name: serde_json::Value,
    #[serde(rename = "jarFilePath")]
    pub jar_file_path: serde_json::Value,
    #[serde(rename = "jarLinkedService", skip_serializing_if = "Option::is_none")]
    pub jar_linked_service: Option<LinkedServiceReference>,
    #[serde(rename = "jarLibs", skip_serializing_if = "Vec::is_empty")]
    pub jar_libs: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub defines: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightStreamingActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: HdInsightStreamingActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightStreamingActivityTypeProperties {
    #[serde(rename = "storageLinkedServices", skip_serializing_if = "Vec::is_empty")]
    pub storage_linked_services: Vec<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub arguments: Vec<serde_json::Value>,
    #[serde(rename = "getDebugInfo", skip_serializing_if = "Option::is_none")]
    pub get_debug_info: Option<HdInsightActivityDebugInfoOption>,
    pub mapper: serde_json::Value,
    pub reducer: serde_json::Value,
    pub input: serde_json::Value,
    pub output: serde_json::Value,
    #[serde(rename = "filePaths")]
    pub file_paths: Vec<serde_json::Value>,
    #[serde(rename = "fileLinkedService", skip_serializing_if = "Option::is_none")]
    pub file_linked_service: Option<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub combiner: Option<serde_json::Value>,
    #[serde(rename = "commandEnvironment", skip_serializing_if = "Vec::is_empty")]
    pub command_environment: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub defines: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightSparkActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: HdInsightSparkActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightSparkActivityTypeProperties {
    #[serde(rename = "rootPath")]
    pub root_path: serde_json::Value,
    #[serde(rename = "entryFilePath")]
    pub entry_file_path: serde_json::Value,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub arguments: Vec<serde_json::Value>,
    #[serde(rename = "getDebugInfo", skip_serializing_if = "Option::is_none")]
    pub get_debug_info: Option<HdInsightActivityDebugInfoOption>,
    #[serde(rename = "sparkJobLinkedService", skip_serializing_if = "Option::is_none")]
    pub spark_job_linked_service: Option<LinkedServiceReference>,
    #[serde(rename = "className", skip_serializing_if = "Option::is_none")]
    pub class_name: Option<String>,
    #[serde(rename = "proxyUser", skip_serializing_if = "Option::is_none")]
    pub proxy_user: Option<serde_json::Value>,
    #[serde(rename = "sparkConfig", skip_serializing_if = "Option::is_none")]
    pub spark_config: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExecuteSsisPackageActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: ExecuteSsisPackageActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExecuteSsisPackageActivityTypeProperties {
    #[serde(rename = "packageLocation")]
    pub package_location: SsisPackageLocation,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub runtime: Option<serde_json::Value>,
    #[serde(rename = "loggingLevel", skip_serializing_if = "Option::is_none")]
    pub logging_level: Option<serde_json::Value>,
    #[serde(rename = "environmentPath", skip_serializing_if = "Option::is_none")]
    pub environment_path: Option<serde_json::Value>,
    #[serde(rename = "executionCredential", skip_serializing_if = "Option::is_none")]
    pub execution_credential: Option<SsisExecutionCredential>,
    #[serde(rename = "connectVia")]
    pub connect_via: IntegrationRuntimeReference,
    #[serde(rename = "projectParameters", skip_serializing_if = "Option::is_none")]
    pub project_parameters: Option<serde_json::Value>,
    #[serde(rename = "packageParameters", skip_serializing_if = "Option::is_none")]
    pub package_parameters: Option<serde_json::Value>,
    #[serde(rename = "projectConnectionManagers", skip_serializing_if = "Option::is_none")]
    pub project_connection_managers: Option<serde_json::Value>,
    #[serde(rename = "packageConnectionManagers", skip_serializing_if = "Option::is_none")]
    pub package_connection_managers: Option<serde_json::Value>,
    #[serde(rename = "propertyOverrides", skip_serializing_if = "Option::is_none")]
    pub property_overrides: Option<serde_json::Value>,
    #[serde(rename = "logLocation", skip_serializing_if = "Option::is_none")]
    pub log_location: Option<SsisLogLocation>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisPackageLocation {
    #[serde(rename = "packagePath", skip_serializing_if = "Option::is_none")]
    pub package_path: Option<serde_json::Value>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<ssis_package_location::Type>,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SsisPackageLocationTypeProperties>,
}
pub mod ssis_package_location {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        #[serde(rename = "SSISDB")]
        Ssisdb,
        File,
        InlinePackage,
        PackageStore,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisPackageLocationTypeProperties {
    #[serde(rename = "packagePassword", skip_serializing_if = "Option::is_none")]
    pub package_password: Option<SecretBase>,
    #[serde(rename = "accessCredential", skip_serializing_if = "Option::is_none")]
    pub access_credential: Option<SsisAccessCredential>,
    #[serde(rename = "configurationPath", skip_serializing_if = "Option::is_none")]
    pub configuration_path: Option<serde_json::Value>,
    #[serde(rename = "configurationAccessCredential", skip_serializing_if = "Option::is_none")]
    pub configuration_access_credential: Option<SsisAccessCredential>,
    #[serde(rename = "packageName", skip_serializing_if = "Option::is_none")]
    pub package_name: Option<String>,
    #[serde(rename = "packageContent", skip_serializing_if = "Option::is_none")]
    pub package_content: Option<serde_json::Value>,
    #[serde(rename = "packageLastModifiedDate", skip_serializing_if = "Option::is_none")]
    pub package_last_modified_date: Option<String>,
    #[serde(rename = "childPackages", skip_serializing_if = "Vec::is_empty")]
    pub child_packages: Vec<SsisChildPackage>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisConnectionManager {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisExecutionParameter {
    pub value: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisPropertyOverride {
    pub value: serde_json::Value,
    #[serde(rename = "isSensitive", skip_serializing_if = "Option::is_none")]
    pub is_sensitive: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisExecutionCredential {
    pub domain: serde_json::Value,
    #[serde(rename = "userName")]
    pub user_name: serde_json::Value,
    pub password: SecureString,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisAccessCredential {
    pub domain: serde_json::Value,
    #[serde(rename = "userName")]
    pub user_name: serde_json::Value,
    pub password: SecretBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisChildPackage {
    #[serde(rename = "packagePath")]
    pub package_path: serde_json::Value,
    #[serde(rename = "packageName", skip_serializing_if = "Option::is_none")]
    pub package_name: Option<String>,
    #[serde(rename = "packageContent")]
    pub package_content: serde_json::Value,
    #[serde(rename = "packageLastModifiedDate", skip_serializing_if = "Option::is_none")]
    pub package_last_modified_date: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisLogLocation {
    #[serde(rename = "logPath")]
    pub log_path: serde_json::Value,
    #[serde(rename = "type")]
    pub type_: ssis_log_location::Type,
    #[serde(rename = "typeProperties")]
    pub type_properties: SsisLogLocationTypeProperties,
}
pub mod ssis_log_location {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        File,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisLogLocationTypeProperties {
    #[serde(rename = "accessCredential", skip_serializing_if = "Option::is_none")]
    pub access_credential: Option<SsisAccessCredential>,
    #[serde(rename = "logRefreshInterval", skip_serializing_if = "Option::is_none")]
    pub log_refresh_interval: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: CustomActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomActivityTypeProperties {
    pub command: serde_json::Value,
    #[serde(rename = "resourceLinkedService", skip_serializing_if = "Option::is_none")]
    pub resource_linked_service: Option<LinkedServiceReference>,
    #[serde(rename = "folderPath", skip_serializing_if = "Option::is_none")]
    pub folder_path: Option<serde_json::Value>,
    #[serde(rename = "referenceObjects", skip_serializing_if = "Option::is_none")]
    pub reference_objects: Option<CustomActivityReferenceObject>,
    #[serde(rename = "extendedProperties", skip_serializing_if = "Option::is_none")]
    pub extended_properties: Option<serde_json::Value>,
    #[serde(rename = "retentionTimeInDays", skip_serializing_if = "Option::is_none")]
    pub retention_time_in_days: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomActivityReferenceObject {
    #[serde(rename = "linkedServices", skip_serializing_if = "Vec::is_empty")]
    pub linked_services: Vec<LinkedServiceReference>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub datasets: Vec<DatasetReference>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlServerStoredProcedureActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: SqlServerStoredProcedureActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlServerStoredProcedureActivityTypeProperties {
    #[serde(rename = "storedProcedureName")]
    pub stored_procedure_name: serde_json::Value,
    #[serde(rename = "storedProcedureParameters", skip_serializing_if = "Option::is_none")]
    pub stored_procedure_parameters: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExecutePipelineActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: ExecutePipelineActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExecutePipelineActivityTypeProperties {
    pub pipeline: PipelineReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<ParameterValueSpecification>,
    #[serde(rename = "waitOnCompletion", skip_serializing_if = "Option::is_none")]
    pub wait_on_completion: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DeleteActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: DeleteActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DeleteActivityTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<serde_json::Value>,
    #[serde(rename = "maxConcurrentConnections", skip_serializing_if = "Option::is_none")]
    pub max_concurrent_connections: Option<i64>,
    #[serde(rename = "enableLogging", skip_serializing_if = "Option::is_none")]
    pub enable_logging: Option<serde_json::Value>,
    #[serde(rename = "logStorageSettings", skip_serializing_if = "Option::is_none")]
    pub log_storage_settings: Option<LogStorageSettings>,
    pub dataset: DatasetReference,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataExplorerCommandActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureDataExplorerCommandActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataExplorerCommandActivityTypeProperties {
    pub command: serde_json::Value,
    #[serde(rename = "commandTimeout", skip_serializing_if = "Option::is_none")]
    pub command_timeout: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LookupActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: LookupActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LookupActivityTypeProperties {
    pub source: CopySource,
    pub dataset: DatasetReference,
    #[serde(rename = "firstRowOnly", skip_serializing_if = "Option::is_none")]
    pub first_row_only: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum WebActivityMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: WebActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebActivityAuthentication {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pfx: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebActivityTypeProperties {
    pub method: WebActivityMethod,
    pub url: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authentication: Option<WebActivityAuthentication>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub datasets: Vec<DatasetReference>,
    #[serde(rename = "linkedServices", skip_serializing_if = "Vec::is_empty")]
    pub linked_services: Vec<LinkedServiceReference>,
    #[serde(rename = "connectVia", skip_serializing_if = "Option::is_none")]
    pub connect_via: Option<IntegrationRuntimeReference>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GetMetadataActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: GetMetadataActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GetMetadataActivityTypeProperties {
    pub dataset: DatasetReference,
    #[serde(rename = "fieldList", skip_serializing_if = "Vec::is_empty")]
    pub field_list: Vec<serde_json::Value>,
    #[serde(rename = "storeSettings", skip_serializing_if = "Option::is_none")]
    pub store_settings: Option<StoreReadSettings>,
    #[serde(rename = "formatSettings", skip_serializing_if = "Option::is_none")]
    pub format_settings: Option<FormatReadSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IfConditionActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: IfConditionActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IfConditionActivityTypeProperties {
    pub expression: Expression,
    #[serde(rename = "ifTrueActivities", skip_serializing_if = "Vec::is_empty")]
    pub if_true_activities: Vec<Activity>,
    #[serde(rename = "ifFalseActivities", skip_serializing_if = "Vec::is_empty")]
    pub if_false_activities: Vec<Activity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SwitchActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: SwitchActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SwitchActivityTypeProperties {
    pub on: Expression,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub cases: Vec<SwitchCase>,
    #[serde(rename = "defaultActivities", skip_serializing_if = "Vec::is_empty")]
    pub default_activities: Vec<Activity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SwitchCase {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub activities: Vec<Activity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ForEachActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: ForEachActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ForEachActivityTypeProperties {
    #[serde(rename = "isSequential", skip_serializing_if = "Option::is_none")]
    pub is_sequential: Option<bool>,
    #[serde(rename = "batchCount", skip_serializing_if = "Option::is_none")]
    pub batch_count: Option<i64>,
    pub items: Expression,
    pub activities: Vec<Activity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlBatchExecutionActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureMlBatchExecutionActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlBatchExecutionActivityTypeProperties {
    #[serde(rename = "globalParameters", skip_serializing_if = "Option::is_none")]
    pub global_parameters: Option<serde_json::Value>,
    #[serde(rename = "webServiceOutputs", skip_serializing_if = "Option::is_none")]
    pub web_service_outputs: Option<serde_json::Value>,
    #[serde(rename = "webServiceInputs", skip_serializing_if = "Option::is_none")]
    pub web_service_inputs: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlWebServiceFile {
    #[serde(rename = "filePath")]
    pub file_path: serde_json::Value,
    #[serde(rename = "linkedServiceName")]
    pub linked_service_name: LinkedServiceReference,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlUpdateResourceActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureMlUpdateResourceActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlUpdateResourceActivityTypeProperties {
    #[serde(rename = "trainedModelName")]
    pub trained_model_name: serde_json::Value,
    #[serde(rename = "trainedModelLinkedServiceName")]
    pub trained_model_linked_service_name: LinkedServiceReference,
    #[serde(rename = "trainedModelFilePath")]
    pub trained_model_file_path: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlExecutePipelineActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureMlExecutePipelineActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlExecutePipelineActivityTypeProperties {
    #[serde(rename = "mlPipelineId")]
    pub ml_pipeline_id: serde_json::Value,
    #[serde(rename = "experimentName", skip_serializing_if = "Option::is_none")]
    pub experiment_name: Option<serde_json::Value>,
    #[serde(rename = "mlPipelineParameters", skip_serializing_if = "Option::is_none")]
    pub ml_pipeline_parameters: Option<serde_json::Value>,
    #[serde(rename = "mlParentRunId", skip_serializing_if = "Option::is_none")]
    pub ml_parent_run_id: Option<serde_json::Value>,
    #[serde(rename = "continueOnStepFailure", skip_serializing_if = "Option::is_none")]
    pub continue_on_step_failure: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlPipelineParameters {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataLakeAnalyticsUsqlActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: DataLakeAnalyticsUsqlActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataLakeAnalyticsUsqlActivityTypeProperties {
    #[serde(rename = "scriptPath")]
    pub script_path: serde_json::Value,
    #[serde(rename = "scriptLinkedService")]
    pub script_linked_service: LinkedServiceReference,
    #[serde(rename = "degreeOfParallelism", skip_serializing_if = "Option::is_none")]
    pub degree_of_parallelism: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,
    #[serde(rename = "runtimeVersion", skip_serializing_if = "Option::is_none")]
    pub runtime_version: Option<serde_json::Value>,
    #[serde(rename = "compilationMode", skip_serializing_if = "Option::is_none")]
    pub compilation_mode: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WaitActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: WaitActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WaitActivityTypeProperties {
    #[serde(rename = "waitTimeInSeconds")]
    pub wait_time_in_seconds: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UntilActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: UntilActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UntilActivityTypeProperties {
    pub expression: Expression,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<serde_json::Value>,
    pub activities: Vec<Activity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ValidationActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: ValidationActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ValidationActivityTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sleep: Option<serde_json::Value>,
    #[serde(rename = "minimumSize", skip_serializing_if = "Option::is_none")]
    pub minimum_size: Option<serde_json::Value>,
    #[serde(rename = "childItems", skip_serializing_if = "Option::is_none")]
    pub child_items: Option<serde_json::Value>,
    pub dataset: DatasetReference,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FilterActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: FilterActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FilterActivityTypeProperties {
    pub items: Expression,
    pub condition: Expression,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatabricksNotebookActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: DatabricksNotebookActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatabricksNotebookActivityTypeProperties {
    #[serde(rename = "notebookPath")]
    pub notebook_path: serde_json::Value,
    #[serde(rename = "baseParameters", skip_serializing_if = "Option::is_none")]
    pub base_parameters: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub libraries: Vec<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatabricksSparkJarActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: DatabricksSparkJarActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatabricksSparkJarActivityTypeProperties {
    #[serde(rename = "mainClassName")]
    pub main_class_name: serde_json::Value,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub libraries: Vec<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatabricksSparkPythonActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: DatabricksSparkPythonActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatabricksSparkPythonActivityTypeProperties {
    #[serde(rename = "pythonFile")]
    pub python_file: serde_json::Value,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub libraries: Vec<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SetVariableActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: SetVariableActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SetVariableActivityTypeProperties {
    #[serde(rename = "variableName", skip_serializing_if = "Option::is_none")]
    pub variable_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AppendVariableActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: AppendVariableActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AppendVariableActivityTypeProperties {
    #[serde(rename = "variableName", skip_serializing_if = "Option::is_none")]
    pub variable_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AzureFunctionActivityMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "TRACE")]
    Trace,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFunctionActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureFunctionActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFunctionActivityTypeProperties {
    pub method: AzureFunctionActivityMethod,
    #[serde(rename = "functionName")]
    pub function_name: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebHookActivity {
    #[serde(flatten)]
    pub control_activity: ControlActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: WebHookActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum WebHookActivityMethod {
    #[serde(rename = "POST")]
    Post,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebHookActivityTypeProperties {
    pub method: WebHookActivityMethod,
    pub url: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authentication: Option<WebActivityAuthentication>,
    #[serde(rename = "reportStatusOnCallBack", skip_serializing_if = "Option::is_none")]
    pub report_status_on_call_back: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExecuteDataFlowActivity {
    #[serde(flatten)]
    pub execution_activity: ExecutionActivity,
    #[serde(rename = "typeProperties")]
    pub type_properties: ExecuteDataFlowActivityTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExecuteDataFlowActivityTypeProperties {
    #[serde(rename = "dataFlow")]
    pub data_flow: DataFlowReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub staging: Option<DataFlowStagingInfo>,
    #[serde(rename = "integrationRuntime", skip_serializing_if = "Option::is_none")]
    pub integration_runtime: Option<IntegrationRuntimeReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compute: Option<execute_data_flow_activity_type_properties::Compute>,
}
pub mod execute_data_flow_activity_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct Compute {
        #[serde(rename = "computeType", skip_serializing_if = "Option::is_none")]
        pub compute_type: Option<serde_json::Value>,
        #[serde(rename = "coreCount", skip_serializing_if = "Option::is_none")]
        pub core_count: Option<serde_json::Value>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SharePointOnlineListSource {
    #[serde(flatten)]
    pub copy_source: CopySource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query: Option<serde_json::Value>,
    #[serde(rename = "httpRequestTimeout", skip_serializing_if = "Option::is_none")]
    pub http_request_timeout: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Trigger {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "runtimeState", skip_serializing_if = "Option::is_none")]
    pub runtime_state: Option<TriggerRuntimeState>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum TriggerRuntimeState {
    Started,
    Stopped,
    Disabled,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MultiplePipelineTrigger {
    #[serde(flatten)]
    pub trigger: Trigger,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub pipelines: Vec<TriggerPipelineReference>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ScheduleTrigger {
    #[serde(flatten)]
    pub multiple_pipeline_trigger: MultiplePipelineTrigger,
    #[serde(rename = "typeProperties")]
    pub type_properties: schedule_trigger::TypeProperties,
}
pub mod schedule_trigger {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct TypeProperties {
        pub recurrence: ScheduleTriggerRecurrence,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ScheduleTriggerRecurrence {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<RecurrenceFrequency>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interval: Option<i32>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "timeZone", skip_serializing_if = "Option::is_none")]
    pub time_zone: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schedule: Option<RecurrenceSchedule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum RecurrenceFrequency {
    NotSpecified,
    Minute,
    Hour,
    Day,
    Week,
    Month,
    Year,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RecurrenceSchedule {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub minutes: Vec<i32>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub hours: Vec<i32>,
    #[serde(rename = "weekDays", skip_serializing_if = "Vec::is_empty")]
    pub week_days: Vec<String>,
    #[serde(rename = "monthDays", skip_serializing_if = "Vec::is_empty")]
    pub month_days: Vec<i32>,
    #[serde(rename = "monthlyOccurrences", skip_serializing_if = "Vec::is_empty")]
    pub monthly_occurrences: Vec<RecurrenceScheduleOccurrence>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RecurrenceScheduleOccurrence {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day: Option<DayOfWeek>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub occurrence: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum DayOfWeek {
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BlobTrigger {
    #[serde(flatten)]
    pub multiple_pipeline_trigger: MultiplePipelineTrigger,
    #[serde(rename = "typeProperties")]
    pub type_properties: blob_trigger::TypeProperties,
}
pub mod blob_trigger {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct TypeProperties {
        #[serde(rename = "folderPath")]
        pub folder_path: String,
        #[serde(rename = "maxConcurrency")]
        pub max_concurrency: i64,
        #[serde(rename = "linkedService")]
        pub linked_service: LinkedServiceReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BlobEventsTrigger {
    #[serde(flatten)]
    pub multiple_pipeline_trigger: MultiplePipelineTrigger,
    #[serde(rename = "typeProperties")]
    pub type_properties: blob_events_trigger::TypeProperties,
}
pub mod blob_events_trigger {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct TypeProperties {
        #[serde(rename = "blobPathBeginsWith", skip_serializing_if = "Option::is_none")]
        pub blob_path_begins_with: Option<String>,
        #[serde(rename = "blobPathEndsWith", skip_serializing_if = "Option::is_none")]
        pub blob_path_ends_with: Option<String>,
        #[serde(rename = "ignoreEmptyBlobs", skip_serializing_if = "Option::is_none")]
        pub ignore_empty_blobs: Option<bool>,
        pub events: BlobEventTypes,
        pub scope: String,
    }
}
pub type BlobEventTypes = Vec<String>;
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TumblingWindowTrigger {
    #[serde(flatten)]
    pub trigger: Trigger,
    pub pipeline: TriggerPipelineReference,
    #[serde(rename = "typeProperties")]
    pub type_properties: tumbling_window_trigger::TypeProperties,
}
pub mod tumbling_window_trigger {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct TypeProperties {
        pub frequency: TumblingWindowFrequency,
        pub interval: i32,
        #[serde(rename = "startTime")]
        pub start_time: String,
        #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
        pub end_time: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub delay: Option<serde_json::Value>,
        #[serde(rename = "maxConcurrency")]
        pub max_concurrency: i64,
        #[serde(rename = "retryPolicy", skip_serializing_if = "Option::is_none")]
        pub retry_policy: Option<RetryPolicy>,
        #[serde(rename = "dependsOn", skip_serializing_if = "Vec::is_empty")]
        pub depends_on: Vec<DependencyReference>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum TumblingWindowFrequency {
    Minute,
    Hour,
    Month,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RetryPolicy {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<serde_json::Value>,
    #[serde(rename = "intervalInSeconds", skip_serializing_if = "Option::is_none")]
    pub interval_in_seconds: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerReference {
    #[serde(rename = "type")]
    pub type_: trigger_reference::Type,
    #[serde(rename = "referenceName")]
    pub reference_name: String,
}
pub mod trigger_reference {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        TriggerReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DependencyReference {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TriggerDependencyReference {
    #[serde(flatten)]
    pub dependency_reference: DependencyReference,
    #[serde(rename = "referenceTrigger")]
    pub reference_trigger: TriggerReference,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TumblingWindowTriggerDependencyReference {
    #[serde(flatten)]
    pub trigger_dependency_reference: TriggerDependencyReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfDependencyTumblingWindowTriggerReference {
    #[serde(flatten)]
    pub dependency_reference: DependencyReference,
    pub offset: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RerunTumblingWindowTrigger {
    #[serde(flatten)]
    pub trigger: Trigger,
    #[serde(rename = "typeProperties")]
    pub type_properties: rerun_tumbling_window_trigger::TypeProperties,
}
pub mod rerun_tumbling_window_trigger {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct TypeProperties {
        #[serde(rename = "parentTrigger")]
        pub parent_trigger: serde_json::Value,
        #[serde(rename = "requestedStartTime")]
        pub requested_start_time: String,
        #[serde(rename = "requestedEndTime")]
        pub requested_end_time: String,
        #[serde(rename = "rerunConcurrency")]
        pub rerun_concurrency: i64,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ChainingTrigger {
    #[serde(flatten)]
    pub trigger: Trigger,
    pub pipeline: TriggerPipelineReference,
    #[serde(rename = "typeProperties")]
    pub type_properties: chaining_trigger::TypeProperties,
}
pub mod chaining_trigger {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct TypeProperties {
        #[serde(rename = "dependsOn")]
        pub depends_on: Vec<PipelineReference>,
        #[serde(rename = "runDimension")]
        pub run_dimension: String,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Dataset {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub structure: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(rename = "linkedServiceName")]
    pub linked_service_name: LinkedServiceReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<ParameterDefinitionSpecification>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub folder: Option<dataset::Folder>,
}
pub mod dataset {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct Folder {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetLocation {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "folderPath", skip_serializing_if = "Option::is_none")]
    pub folder_path: Option<serde_json::Value>,
    #[serde(rename = "fileName", skip_serializing_if = "Option::is_none")]
    pub file_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobStorageLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub container: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
    #[serde(rename = "fileSystem", skip_serializing_if = "Option::is_none")]
    pub file_system: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonS3Location {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
    #[serde(rename = "bucketName", skip_serializing_if = "Option::is_none")]
    pub bucket_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileServerLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFileStorageLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleCloudStorageLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
    #[serde(rename = "bucketName", skip_serializing_if = "Option::is_none")]
    pub bucket_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FtpServerLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SftpLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpServerLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
    #[serde(rename = "relativeUrl", skip_serializing_if = "Option::is_none")]
    pub relative_url: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdfsLocation {
    #[serde(flatten)]
    pub dataset_location: DatasetLocation,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetDataElement {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<serde_json::Value>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetSchemaDataElement {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<serde_json::Value>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetStorageFormat {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serializer: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deserializer: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TextFormat {
    #[serde(flatten)]
    pub dataset_storage_format: DatasetStorageFormat,
    #[serde(rename = "columnDelimiter", skip_serializing_if = "Option::is_none")]
    pub column_delimiter: Option<serde_json::Value>,
    #[serde(rename = "rowDelimiter", skip_serializing_if = "Option::is_none")]
    pub row_delimiter: Option<serde_json::Value>,
    #[serde(rename = "escapeChar", skip_serializing_if = "Option::is_none")]
    pub escape_char: Option<serde_json::Value>,
    #[serde(rename = "quoteChar", skip_serializing_if = "Option::is_none")]
    pub quote_char: Option<serde_json::Value>,
    #[serde(rename = "nullValue", skip_serializing_if = "Option::is_none")]
    pub null_value: Option<serde_json::Value>,
    #[serde(rename = "encodingName", skip_serializing_if = "Option::is_none")]
    pub encoding_name: Option<serde_json::Value>,
    #[serde(rename = "treatEmptyAsNull", skip_serializing_if = "Option::is_none")]
    pub treat_empty_as_null: Option<serde_json::Value>,
    #[serde(rename = "skipLineCount", skip_serializing_if = "Option::is_none")]
    pub skip_line_count: Option<serde_json::Value>,
    #[serde(rename = "firstRowAsHeader", skip_serializing_if = "Option::is_none")]
    pub first_row_as_header: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsonFormat {
    #[serde(flatten)]
    pub dataset_storage_format: DatasetStorageFormat,
    #[serde(rename = "filePattern", skip_serializing_if = "Option::is_none")]
    pub file_pattern: Option<JsonFormatFilePattern>,
    #[serde(rename = "nestingSeparator", skip_serializing_if = "Option::is_none")]
    pub nesting_separator: Option<serde_json::Value>,
    #[serde(rename = "encodingName", skip_serializing_if = "Option::is_none")]
    pub encoding_name: Option<serde_json::Value>,
    #[serde(rename = "jsonNodeReference", skip_serializing_if = "Option::is_none")]
    pub json_node_reference: Option<serde_json::Value>,
    #[serde(rename = "jsonPathDefinition", skip_serializing_if = "Option::is_none")]
    pub json_path_definition: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum JsonFormatFilePattern {
    #[serde(rename = "setOfObjects")]
    SetOfObjects,
    #[serde(rename = "arrayOfObjects")]
    ArrayOfObjects,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvroFormat {
    #[serde(flatten)]
    pub dataset_storage_format: DatasetStorageFormat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrcFormat {
    #[serde(flatten)]
    pub dataset_storage_format: DatasetStorageFormat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParquetFormat {
    #[serde(flatten)]
    pub dataset_storage_format: DatasetStorageFormat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetCompression {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetBZip2Compression {
    #[serde(flatten)]
    pub dataset_compression: DatasetCompression,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetGZipCompression {
    #[serde(flatten)]
    pub dataset_compression: DatasetCompression,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub level: Option<CompressionLevel>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetDeflateCompression {
    #[serde(flatten)]
    pub dataset_compression: DatasetCompression,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub level: Option<CompressionLevel>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetZipDeflateCompression {
    #[serde(flatten)]
    pub dataset_compression: DatasetCompression,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub level: Option<CompressionLevel>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetTarCompression {
    #[serde(flatten)]
    pub dataset_compression: DatasetCompression,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DatasetTarGZipCompression {
    #[serde(flatten)]
    pub dataset_compression: DatasetCompression,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub level: Option<CompressionLevel>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum CompressionLevel {
    Optimal,
    Fastest,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonS3Dataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: AmazonS3DatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonS3DatasetTypeProperties {
    #[serde(rename = "bucketName")]
    pub bucket_name: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DatasetStorageFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvroDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AvroDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvroDatasetTypeProperties {
    pub location: DatasetLocation,
    #[serde(rename = "avroCompressionCodec", skip_serializing_if = "Option::is_none")]
    pub avro_compression_codec: Option<avro_dataset_type_properties::AvroCompressionCodec>,
    #[serde(rename = "avroCompressionLevel", skip_serializing_if = "Option::is_none")]
    pub avro_compression_level: Option<i64>,
}
pub mod avro_dataset_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AvroCompressionCodec {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "deflate")]
        Deflate,
        #[serde(rename = "snappy")]
        Snappy,
        #[serde(rename = "xz")]
        Xz,
        #[serde(rename = "bzip2")]
        Bzip2,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExcelDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<ExcelDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExcelDatasetTypeProperties {
    pub location: DatasetLocation,
    #[serde(rename = "sheetName")]
    pub sheet_name: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range: Option<serde_json::Value>,
    #[serde(rename = "firstRowAsHeader", skip_serializing_if = "Option::is_none")]
    pub first_row_as_header: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
    #[serde(rename = "nullValue", skip_serializing_if = "Option::is_none")]
    pub null_value: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParquetDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<ParquetDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParquetDatasetTypeProperties {
    pub location: DatasetLocation,
    #[serde(rename = "compressionCodec", skip_serializing_if = "Option::is_none")]
    pub compression_codec: Option<parquet_dataset_type_properties::CompressionCodec>,
}
pub mod parquet_dataset_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum CompressionCodec {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "gzip")]
        Gzip,
        #[serde(rename = "snappy")]
        Snappy,
        #[serde(rename = "lzo")]
        Lzo,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DelimitedTextDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<DelimitedTextDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DelimitedTextDatasetTypeProperties {
    pub location: DatasetLocation,
    #[serde(rename = "columnDelimiter", skip_serializing_if = "Option::is_none")]
    pub column_delimiter: Option<serde_json::Value>,
    #[serde(rename = "rowDelimiter", skip_serializing_if = "Option::is_none")]
    pub row_delimiter: Option<serde_json::Value>,
    #[serde(rename = "encodingName", skip_serializing_if = "Option::is_none")]
    pub encoding_name: Option<serde_json::Value>,
    #[serde(rename = "compressionCodec", skip_serializing_if = "Option::is_none")]
    pub compression_codec: Option<delimited_text_dataset_type_properties::CompressionCodec>,
    #[serde(rename = "compressionLevel", skip_serializing_if = "Option::is_none")]
    pub compression_level: Option<CompressionLevel>,
    #[serde(rename = "quoteChar", skip_serializing_if = "Option::is_none")]
    pub quote_char: Option<serde_json::Value>,
    #[serde(rename = "escapeChar", skip_serializing_if = "Option::is_none")]
    pub escape_char: Option<serde_json::Value>,
    #[serde(rename = "firstRowAsHeader", skip_serializing_if = "Option::is_none")]
    pub first_row_as_header: Option<serde_json::Value>,
    #[serde(rename = "nullValue", skip_serializing_if = "Option::is_none")]
    pub null_value: Option<serde_json::Value>,
}
pub mod delimited_text_dataset_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum CompressionCodec {
        #[serde(rename = "bzip2")]
        Bzip2,
        #[serde(rename = "gzip")]
        Gzip,
        #[serde(rename = "deflate")]
        Deflate,
        #[serde(rename = "zipDeflate")]
        ZipDeflate,
        #[serde(rename = "snappy")]
        Snappy,
        #[serde(rename = "lz4")]
        Lz4,
        #[serde(rename = "tar")]
        Tar,
        #[serde(rename = "tarGZip")]
        TarGZip,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsonDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<JsonDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsonDatasetTypeProperties {
    pub location: DatasetLocation,
    #[serde(rename = "encodingName", skip_serializing_if = "Option::is_none")]
    pub encoding_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct XmlDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<XmlDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct XmlDatasetTypeProperties {
    pub location: DatasetLocation,
    #[serde(rename = "encodingName", skip_serializing_if = "Option::is_none")]
    pub encoding_name: Option<serde_json::Value>,
    #[serde(rename = "nullValue", skip_serializing_if = "Option::is_none")]
    pub null_value: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrcDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<OrcDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrcDatasetTypeProperties {
    pub location: DatasetLocation,
    #[serde(rename = "orcCompressionCodec", skip_serializing_if = "Option::is_none")]
    pub orc_compression_codec: Option<orc_dataset_type_properties::OrcCompressionCodec>,
}
pub mod orc_dataset_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OrcCompressionCodec {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "zlib")]
        Zlib,
        #[serde(rename = "snappy")]
        Snappy,
        #[serde(rename = "lzo")]
        Lzo,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BinaryDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<BinaryDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BinaryDatasetTypeProperties {
    pub location: DatasetLocation,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AzureBlobDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobDatasetTypeProperties {
    #[serde(rename = "folderPath", skip_serializing_if = "Option::is_none")]
    pub folder_path: Option<serde_json::Value>,
    #[serde(rename = "tableRootLocation", skip_serializing_if = "Option::is_none")]
    pub table_root_location: Option<serde_json::Value>,
    #[serde(rename = "fileName", skip_serializing_if = "Option::is_none")]
    pub file_name: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DatasetStorageFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureTableDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureTableDatasetTypeProperties {
    #[serde(rename = "tableName")]
    pub table_name: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AzureSqlTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlMiTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AzureSqlMiTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlMiTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlDwTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AzureSqlDwTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlDwTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CassandraTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<CassandraTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CassandraTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keyspace: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbSqlApiCollectionDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: CosmosDbSqlApiCollectionDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbSqlApiCollectionDatasetTypeProperties {
    #[serde(rename = "collectionName")]
    pub collection_name: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DocumentDbCollectionDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: DocumentDbCollectionDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DocumentDbCollectionDatasetTypeProperties {
    #[serde(rename = "collectionName")]
    pub collection_name: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsEntityDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<DynamicsEntityDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsEntityDatasetTypeProperties {
    #[serde(rename = "entityName", skip_serializing_if = "Option::is_none")]
    pub entity_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsCrmEntityDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<DynamicsCrmEntityDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsCrmEntityDatasetTypeProperties {
    #[serde(rename = "entityName", skip_serializing_if = "Option::is_none")]
    pub entity_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommonDataServiceForAppsEntityDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<CommonDataServiceForAppsEntityDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommonDataServiceForAppsEntityDatasetTypeProperties {
    #[serde(rename = "entityName", skip_serializing_if = "Option::is_none")]
    pub entity_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AzureDataLakeStoreDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreDatasetTypeProperties {
    #[serde(rename = "folderPath", skip_serializing_if = "Option::is_none")]
    pub folder_path: Option<serde_json::Value>,
    #[serde(rename = "fileName", skip_serializing_if = "Option::is_none")]
    pub file_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DatasetStorageFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AzureBlobFsDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsDatasetTypeProperties {
    #[serde(rename = "folderPath", skip_serializing_if = "Option::is_none")]
    pub folder_path: Option<serde_json::Value>,
    #[serde(rename = "fileName", skip_serializing_if = "Option::is_none")]
    pub file_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DatasetStorageFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Office365Dataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: Office365DatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Office365DatasetTypeProperties {
    #[serde(rename = "tableName")]
    pub table_name: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub predicate: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileShareDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<FileShareDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileShareDatasetTypeProperties {
    #[serde(rename = "folderPath", skip_serializing_if = "Option::is_none")]
    pub folder_path: Option<serde_json::Value>,
    #[serde(rename = "fileName", skip_serializing_if = "Option::is_none")]
    pub file_name: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeStart", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_start: Option<serde_json::Value>,
    #[serde(rename = "modifiedDatetimeEnd", skip_serializing_if = "Option::is_none")]
    pub modified_datetime_end: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DatasetStorageFormat>,
    #[serde(rename = "fileFilter", skip_serializing_if = "Option::is_none")]
    pub file_filter: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbCollectionDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: MongoDbCollectionDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbCollectionDatasetTypeProperties {
    #[serde(rename = "collectionName")]
    pub collection_name: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbAtlasCollectionDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: MongoDbAtlasCollectionDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbAtlasCollectionDatasetTypeProperties {
    pub collection: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbV2CollectionDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: MongoDbV2CollectionDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbV2CollectionDatasetTypeProperties {
    pub collection: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbMongoDbApiCollectionDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: CosmosDbMongoDbApiCollectionDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbMongoDbApiCollectionDatasetTypeProperties {
    pub collection: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ODataResourceDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<ODataResourceDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ODataResourceDatasetTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<OracleTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TeradataTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<TeradataTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TeradataTableDatasetTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub database: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMySqlTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureMySqlTableDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMySqlTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonRedshiftTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AmazonRedshiftTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonRedshiftTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Db2TableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<Db2TableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Db2TableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RelationalTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<RelationalTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RelationalTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InformixTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<InformixTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InformixTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OdbcTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<OdbcTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OdbcTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MySqlTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<MySqlTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MySqlTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PostgreSqlTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<PostgreSqlTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PostgreSqlTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MicrosoftAccessTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<MicrosoftAccessTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MicrosoftAccessTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SalesforceObjectDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceObjectDatasetTypeProperties {
    #[serde(rename = "objectApiName", skip_serializing_if = "Option::is_none")]
    pub object_api_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceServiceCloudObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SalesforceServiceCloudObjectDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceServiceCloudObjectDatasetTypeProperties {
    #[serde(rename = "objectApiName", skip_serializing_if = "Option::is_none")]
    pub object_api_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SybaseTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SybaseTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SybaseTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapBwCubeDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapCloudForCustomerResourceDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapCloudForCustomerResourceDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapCloudForCustomerResourceDatasetTypeProperties {
    pub path: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapEccResourceDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapEccResourceDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapEccResourceDatasetTypeProperties {
    pub path: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapHanaTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SapHanaTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapHanaTableDatasetTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapOpenHubTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapOpenHubTableDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapOpenHubTableDatasetTypeProperties {
    #[serde(rename = "openHubDestinationName")]
    pub open_hub_destination_name: serde_json::Value,
    #[serde(rename = "excludeLastRequest", skip_serializing_if = "Option::is_none")]
    pub exclude_last_request: Option<serde_json::Value>,
    #[serde(rename = "baseRequestId", skip_serializing_if = "Option::is_none")]
    pub base_request_id: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlServerTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SqlServerTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlServerTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestResourceDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<RestResourceDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestResourceDatasetTypeProperties {
    #[serde(rename = "relativeUrl", skip_serializing_if = "Option::is_none")]
    pub relative_url: Option<serde_json::Value>,
    #[serde(rename = "requestMethod", skip_serializing_if = "Option::is_none")]
    pub request_method: Option<serde_json::Value>,
    #[serde(rename = "requestBody", skip_serializing_if = "Option::is_none")]
    pub request_body: Option<serde_json::Value>,
    #[serde(rename = "additionalHeaders", skip_serializing_if = "Option::is_none")]
    pub additional_headers: Option<serde_json::Value>,
    #[serde(rename = "paginationRules", skip_serializing_if = "Option::is_none")]
    pub pagination_rules: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapTableResourceDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapTableResourceDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapTableResourceDatasetTypeProperties {
    #[serde(rename = "tableName")]
    pub table_name: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: WebTableDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebTableDatasetTypeProperties {
    pub index: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSearchIndexDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureSearchIndexDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSearchIndexDatasetTypeProperties {
    #[serde(rename = "indexName")]
    pub index_name: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<HttpDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpDatasetTypeProperties {
    #[serde(rename = "relativeUrl", skip_serializing_if = "Option::is_none")]
    pub relative_url: Option<serde_json::Value>,
    #[serde(rename = "requestMethod", skip_serializing_if = "Option::is_none")]
    pub request_method: Option<serde_json::Value>,
    #[serde(rename = "requestBody", skip_serializing_if = "Option::is_none")]
    pub request_body: Option<serde_json::Value>,
    #[serde(rename = "additionalHeaders", skip_serializing_if = "Option::is_none")]
    pub additional_headers: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DatasetStorageFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: Option<DatasetCompression>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GenericDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonMwsObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzurePostgreSqlTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AzurePostgreSqlTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzurePostgreSqlTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConcurObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CouchbaseTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DrillTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<DrillDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DrillDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EloquaObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleBigQueryObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GoogleBigQueryDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleBigQueryDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dataset: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GreenplumTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GreenplumDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GreenplumDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HBaseObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HiveObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<HiveDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HiveDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubspotObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImpalaObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<ImpalaDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImpalaDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JiraObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MagentoObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MariaDbTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMariaDbTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MarketoObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PaypalObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PhoenixObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<PhoenixDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PhoenixDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrestoObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<PrestoDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrestoDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QuickBooksObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceNowObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ShopifyObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SparkObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SparkDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SparkDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SquareObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct XeroObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ZohoObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetezzaTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<NetezzaTableDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetezzaTableDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VerticaTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<VerticaDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VerticaDatasetTypeProperties {
    #[serde(rename = "tableName", skip_serializing_if = "Option::is_none")]
    pub table_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceMarketingCloudObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResponsysObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsAxResourceDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: DynamicsAxResourceDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsAxResourceDatasetTypeProperties {
    pub path: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleServiceCloudObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataExplorerTableDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureDataExplorerDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataExplorerDatasetTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleAdWordsObjectDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<GenericDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SnowflakeDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties")]
    pub type_properties: SnowflakeDatasetTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SnowflakeDatasetTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SharePointOnlineListResourceDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SharePointOnlineListDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SharePointOnlineListDatasetTypeProperties {
    #[serde(rename = "listName", skip_serializing_if = "Option::is_none")]
    pub list_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksDeltaLakeDataset {
    #[serde(flatten)]
    pub dataset: Dataset,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<AzureDatabricksDeltaLakeDatasetTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksDeltaLakeDatasetTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub database: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedService {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "connectVia", skip_serializing_if = "Option::is_none")]
    pub connect_via: Option<IntegrationRuntimeReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<ParameterDefinitionSpecification>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureStorageLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureStorageLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobStorageLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureBlobStorageLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureTableStorageLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureStorageLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureStorageLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(rename = "accountKey", skip_serializing_if = "Option::is_none")]
    pub account_key: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "sasUri", skip_serializing_if = "Option::is_none")]
    pub sas_uri: Option<serde_json::Value>,
    #[serde(rename = "sasToken", skip_serializing_if = "Option::is_none")]
    pub sas_token: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobStorageLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(rename = "accountKey", skip_serializing_if = "Option::is_none")]
    pub account_key: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "sasUri", skip_serializing_if = "Option::is_none")]
    pub sas_uri: Option<serde_json::Value>,
    #[serde(rename = "sasToken", skip_serializing_if = "Option::is_none")]
    pub sas_token: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "serviceEndpoint", skip_serializing_if = "Option::is_none")]
    pub service_endpoint: Option<String>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "azureCloudType", skip_serializing_if = "Option::is_none")]
    pub azure_cloud_type: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlDwLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureSqlDwLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlDwLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "azureCloudType", skip_serializing_if = "Option::is_none")]
    pub azure_cloud_type: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlServerLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SqlServerLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlServerLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlDatabaseLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureSqlDatabaseLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlDatabaseLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "azureCloudType", skip_serializing_if = "Option::is_none")]
    pub azure_cloud_type: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlMiLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureSqlMiLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSqlMiLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "azureCloudType", skip_serializing_if = "Option::is_none")]
    pub azure_cloud_type: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBatchLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureBatchLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBatchLinkedServiceTypeProperties {
    #[serde(rename = "accountName")]
    pub account_name: serde_json::Value,
    #[serde(rename = "accessKey", skip_serializing_if = "Option::is_none")]
    pub access_key: Option<SecretBase>,
    #[serde(rename = "batchUri")]
    pub batch_uri: serde_json::Value,
    #[serde(rename = "poolName")]
    pub pool_name: serde_json::Value,
    #[serde(rename = "linkedServiceName")]
    pub linked_service_name: LinkedServiceReference,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureKeyVaultLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureKeyVaultLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureKeyVaultLinkedServiceTypeProperties {
    #[serde(rename = "baseUrl")]
    pub base_url: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: CosmosDbLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(rename = "accountEndpoint", skip_serializing_if = "Option::is_none")]
    pub account_endpoint: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub database: Option<serde_json::Value>,
    #[serde(rename = "accountKey", skip_serializing_if = "Option::is_none")]
    pub account_key: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: DynamicsLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsLinkedServiceTypeProperties {
    #[serde(rename = "deploymentType")]
    pub deployment_type: dynamics_linked_service_type_properties::DeploymentType,
    #[serde(rename = "hostName", skip_serializing_if = "Option::is_none")]
    pub host_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "serviceUri", skip_serializing_if = "Option::is_none")]
    pub service_uri: Option<serde_json::Value>,
    #[serde(rename = "organizationName", skip_serializing_if = "Option::is_none")]
    pub organization_name: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: dynamics_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalCredentialType", skip_serializing_if = "Option::is_none")]
    pub service_principal_credential_type: Option<dynamics_linked_service_type_properties::ServicePrincipalCredentialType>,
    #[serde(rename = "servicePrincipalCredential", skip_serializing_if = "Option::is_none")]
    pub service_principal_credential: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod dynamics_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum DeploymentType {
        Online,
        OnPremisesWithIfd,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Office365,
        Ifd,
        #[serde(rename = "AADServicePrincipal")]
        AadServicePrincipal,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ServicePrincipalCredentialType {
        ServicePrincipalKey,
        ServicePrincipalCert,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsCrmLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: DynamicsCrmLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsCrmLinkedServiceTypeProperties {
    #[serde(rename = "deploymentType")]
    pub deployment_type: dynamics_crm_linked_service_type_properties::DeploymentType,
    #[serde(rename = "hostName", skip_serializing_if = "Option::is_none")]
    pub host_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "serviceUri", skip_serializing_if = "Option::is_none")]
    pub service_uri: Option<serde_json::Value>,
    #[serde(rename = "organizationName", skip_serializing_if = "Option::is_none")]
    pub organization_name: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: dynamics_crm_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalCredentialType", skip_serializing_if = "Option::is_none")]
    pub service_principal_credential_type: Option<dynamics_crm_linked_service_type_properties::ServicePrincipalCredentialType>,
    #[serde(rename = "servicePrincipalCredential", skip_serializing_if = "Option::is_none")]
    pub service_principal_credential: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod dynamics_crm_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum DeploymentType {
        Online,
        OnPremisesWithIfd,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Office365,
        Ifd,
        #[serde(rename = "AADServicePrincipal")]
        AadServicePrincipal,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ServicePrincipalCredentialType {
        ServicePrincipalKey,
        ServicePrincipalCert,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommonDataServiceForAppsLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: CommonDataServiceForAppsLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommonDataServiceForAppsLinkedServiceTypeProperties {
    #[serde(rename = "deploymentType")]
    pub deployment_type: common_data_service_for_apps_linked_service_type_properties::DeploymentType,
    #[serde(rename = "hostName", skip_serializing_if = "Option::is_none")]
    pub host_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "serviceUri", skip_serializing_if = "Option::is_none")]
    pub service_uri: Option<serde_json::Value>,
    #[serde(rename = "organizationName", skip_serializing_if = "Option::is_none")]
    pub organization_name: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: common_data_service_for_apps_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalCredentialType", skip_serializing_if = "Option::is_none")]
    pub service_principal_credential_type:
        Option<common_data_service_for_apps_linked_service_type_properties::ServicePrincipalCredentialType>,
    #[serde(rename = "servicePrincipalCredential", skip_serializing_if = "Option::is_none")]
    pub service_principal_credential: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod common_data_service_for_apps_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum DeploymentType {
        Online,
        OnPremisesWithIfd,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Office365,
        Ifd,
        #[serde(rename = "AADServicePrincipal")]
        AadServicePrincipal,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ServicePrincipalCredentialType {
        ServicePrincipalKey,
        ServicePrincipalCert,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: HdInsightLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightLinkedServiceTypeProperties {
    #[serde(rename = "clusterUri")]
    pub cluster_uri: serde_json::Value,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "linkedServiceName", skip_serializing_if = "Option::is_none")]
    pub linked_service_name: Option<LinkedServiceReference>,
    #[serde(rename = "hcatalogLinkedServiceName", skip_serializing_if = "Option::is_none")]
    pub hcatalog_linked_service_name: Option<LinkedServiceReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
    #[serde(rename = "isEspEnabled", skip_serializing_if = "Option::is_none")]
    pub is_esp_enabled: Option<serde_json::Value>,
    #[serde(rename = "fileSystem", skip_serializing_if = "Option::is_none")]
    pub file_system: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileServerLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: FileServerLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileServerLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(rename = "userId", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFileStorageLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureFileStorageLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFileStorageLinkedServiceTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub host: Option<serde_json::Value>,
    #[serde(rename = "userId", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(rename = "accountKey", skip_serializing_if = "Option::is_none")]
    pub account_key: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "sasUri", skip_serializing_if = "Option::is_none")]
    pub sas_uri: Option<serde_json::Value>,
    #[serde(rename = "sasToken", skip_serializing_if = "Option::is_none")]
    pub sas_token: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "fileShare", skip_serializing_if = "Option::is_none")]
    pub file_share: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snapshot: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleCloudStorageLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: GoogleCloudStorageLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleCloudStorageLinkedServiceTypeProperties {
    #[serde(rename = "accessKeyId", skip_serializing_if = "Option::is_none")]
    pub access_key_id: Option<serde_json::Value>,
    #[serde(rename = "secretAccessKey", skip_serializing_if = "Option::is_none")]
    pub secret_access_key: Option<SecretBase>,
    #[serde(rename = "serviceUrl", skip_serializing_if = "Option::is_none")]
    pub service_url: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: OracleLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMySqlLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureMySqlLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMySqlLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MySqlLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: MySqlLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MySqlLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PostgreSqlLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: PostgreSqlLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PostgreSqlLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SybaseLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SybaseLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SybaseLinkedServiceTypeProperties {
    pub server: serde_json::Value,
    pub database: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<serde_json::Value>,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<sybase_linked_service_type_properties::AuthenticationType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod sybase_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        Windows,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Db2LinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: Db2LinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Db2LinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub database: Option<serde_json::Value>,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<db2_linked_service_type_properties::AuthenticationType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "packageCollection", skip_serializing_if = "Option::is_none")]
    pub package_collection: Option<serde_json::Value>,
    #[serde(rename = "certificateCommonName", skip_serializing_if = "Option::is_none")]
    pub certificate_common_name: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod db2_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TeradataLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: TeradataLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TeradataLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server: Option<serde_json::Value>,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<teradata_linked_service_type_properties::AuthenticationType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod teradata_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        Windows,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureMlLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlLinkedServiceTypeProperties {
    #[serde(rename = "mlEndpoint")]
    pub ml_endpoint: serde_json::Value,
    #[serde(rename = "apiKey")]
    pub api_key: SecretBase,
    #[serde(rename = "updateResourceEndpoint", skip_serializing_if = "Option::is_none")]
    pub update_resource_endpoint: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlServiceLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureMlServiceLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMlServiceLinkedServiceTypeProperties {
    #[serde(rename = "subscriptionId")]
    pub subscription_id: serde_json::Value,
    #[serde(rename = "resourceGroupName")]
    pub resource_group_name: serde_json::Value,
    #[serde(rename = "mlWorkspaceName")]
    pub ml_workspace_name: serde_json::Value,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OdbcLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: OdbcLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OdbcLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential: Option<SecretBase>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InformixLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: InformixLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InformixLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential: Option<SecretBase>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MicrosoftAccessLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: MicrosoftAccessLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MicrosoftAccessLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential: Option<SecretBase>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdfsLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: HdfsLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdfsLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ODataLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: ODataLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ODataLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<o_data_linked_service_type_properties::AuthenticationType>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "azureCloudType", skip_serializing_if = "Option::is_none")]
    pub azure_cloud_type: Option<serde_json::Value>,
    #[serde(rename = "aadResourceId", skip_serializing_if = "Option::is_none")]
    pub aad_resource_id: Option<serde_json::Value>,
    #[serde(rename = "aadServicePrincipalCredentialType", skip_serializing_if = "Option::is_none")]
    pub aad_service_principal_credential_type: Option<o_data_linked_service_type_properties::AadServicePrincipalCredentialType>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(rename = "servicePrincipalEmbeddedCert", skip_serializing_if = "Option::is_none")]
    pub service_principal_embedded_cert: Option<SecretBase>,
    #[serde(rename = "servicePrincipalEmbeddedCertPassword", skip_serializing_if = "Option::is_none")]
    pub service_principal_embedded_cert_password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod o_data_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        Anonymous,
        Windows,
        AadServicePrincipal,
        ManagedServiceIdentity,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AadServicePrincipalCredentialType {
        ServicePrincipalKey,
        ServicePrincipalCert,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: WebLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(rename = "authenticationType")]
    pub authentication_type: web_linked_service_type_properties::AuthenticationType,
}
pub mod web_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        Anonymous,
        ClientCertificate,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebAnonymousAuthentication {
    #[serde(flatten)]
    pub web_linked_service_type_properties: WebLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebBasicAuthentication {
    #[serde(flatten)]
    pub web_linked_service_type_properties: WebLinkedServiceTypeProperties,
    pub username: serde_json::Value,
    pub password: SecretBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebClientCertificateAuthentication {
    #[serde(flatten)]
    pub web_linked_service_type_properties: WebLinkedServiceTypeProperties,
    pub pfx: SecretBase,
    pub password: SecretBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CassandraLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: CassandraLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CassandraLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: MongoDbLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbLinkedServiceTypeProperties {
    pub server: serde_json::Value,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<mongo_db_linked_service_type_properties::AuthenticationType>,
    #[serde(rename = "databaseName")]
    pub database_name: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "authSource", skip_serializing_if = "Option::is_none")]
    pub auth_source: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "enableSsl", skip_serializing_if = "Option::is_none")]
    pub enable_ssl: Option<serde_json::Value>,
    #[serde(rename = "allowSelfSignedServerCert", skip_serializing_if = "Option::is_none")]
    pub allow_self_signed_server_cert: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod mongo_db_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        Anonymous,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbAtlasLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: MongoDbAtlasLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbAtlasLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    pub database: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbV2LinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: MongoDbV2LinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MongoDbV2LinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    pub database: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbMongoDbApiLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: CosmosDbMongoDbApiLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CosmosDbMongoDbApiLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    pub database: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureDataLakeStoreLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeStoreLinkedServiceTypeProperties {
    #[serde(rename = "dataLakeStoreUri")]
    pub data_lake_store_uri: serde_json::Value,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "azureCloudType", skip_serializing_if = "Option::is_none")]
    pub azure_cloud_type: Option<serde_json::Value>,
    #[serde(rename = "accountName", skip_serializing_if = "Option::is_none")]
    pub account_name: Option<serde_json::Value>,
    #[serde(rename = "subscriptionId", skip_serializing_if = "Option::is_none")]
    pub subscription_id: Option<serde_json::Value>,
    #[serde(rename = "resourceGroupName", skip_serializing_if = "Option::is_none")]
    pub resource_group_name: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureBlobFsLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureBlobFsLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(rename = "accountKey", skip_serializing_if = "Option::is_none")]
    pub account_key: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "azureCloudType", skip_serializing_if = "Option::is_none")]
    pub azure_cloud_type: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Office365LinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: Office365LinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Office365LinkedServiceTypeProperties {
    #[serde(rename = "office365TenantId")]
    pub office365_tenant_id: serde_json::Value,
    #[serde(rename = "servicePrincipalTenantId")]
    pub service_principal_tenant_id: serde_json::Value,
    #[serde(rename = "servicePrincipalId")]
    pub service_principal_id: serde_json::Value,
    #[serde(rename = "servicePrincipalKey")]
    pub service_principal_key: SecretBase,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SalesforceLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceLinkedServiceTypeProperties {
    #[serde(rename = "environmentUrl", skip_serializing_if = "Option::is_none")]
    pub environment_url: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "securityToken", skip_serializing_if = "Option::is_none")]
    pub security_token: Option<SecretBase>,
    #[serde(rename = "apiVersion", skip_serializing_if = "Option::is_none")]
    pub api_version: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceServiceCloudLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SalesforceServiceCloudLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceServiceCloudLinkedServiceTypeProperties {
    #[serde(rename = "environmentUrl", skip_serializing_if = "Option::is_none")]
    pub environment_url: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "securityToken", skip_serializing_if = "Option::is_none")]
    pub security_token: Option<SecretBase>,
    #[serde(rename = "apiVersion", skip_serializing_if = "Option::is_none")]
    pub api_version: Option<serde_json::Value>,
    #[serde(rename = "extendedProperties", skip_serializing_if = "Option::is_none")]
    pub extended_properties: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapCloudForCustomerLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapCloudForCustomerLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapCloudForCustomerLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapEccLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapEccLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapEccLinkedServiceTypeProperties {
    pub url: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapOpenHubLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapOpenHubLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapOpenHubLinkedServiceTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server: Option<serde_json::Value>,
    #[serde(rename = "systemNumber", skip_serializing_if = "Option::is_none")]
    pub system_number: Option<serde_json::Value>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    pub client_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub language: Option<serde_json::Value>,
    #[serde(rename = "systemId", skip_serializing_if = "Option::is_none")]
    pub system_id: Option<serde_json::Value>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "messageServer", skip_serializing_if = "Option::is_none")]
    pub message_server: Option<serde_json::Value>,
    #[serde(rename = "messageServerService", skip_serializing_if = "Option::is_none")]
    pub message_server_service: Option<serde_json::Value>,
    #[serde(rename = "logonGroup", skip_serializing_if = "Option::is_none")]
    pub logon_group: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestServiceLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: RestServiceLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestServiceLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(rename = "enableServerCertificateValidation", skip_serializing_if = "Option::is_none")]
    pub enable_server_certificate_validation: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: rest_service_linked_service_type_properties::AuthenticationType,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant: Option<serde_json::Value>,
    #[serde(rename = "azureCloudType", skip_serializing_if = "Option::is_none")]
    pub azure_cloud_type: Option<serde_json::Value>,
    #[serde(rename = "aadResourceId", skip_serializing_if = "Option::is_none")]
    pub aad_resource_id: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod rest_service_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Anonymous,
        Basic,
        AadServicePrincipal,
        ManagedServiceIdentity,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonS3LinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AmazonS3LinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonS3LinkedServiceTypeProperties {
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<serde_json::Value>,
    #[serde(rename = "accessKeyId", skip_serializing_if = "Option::is_none")]
    pub access_key_id: Option<serde_json::Value>,
    #[serde(rename = "secretAccessKey", skip_serializing_if = "Option::is_none")]
    pub secret_access_key: Option<SecretBase>,
    #[serde(rename = "serviceUrl", skip_serializing_if = "Option::is_none")]
    pub service_url: Option<serde_json::Value>,
    #[serde(rename = "sessionToken", skip_serializing_if = "Option::is_none")]
    pub session_token: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonRedshiftLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AmazonRedshiftLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonRedshiftLinkedServiceTypeProperties {
    pub server: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    pub database: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomDataSourceLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSearchLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureSearchLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureSearchLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: HttpLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<http_linked_service_type_properties::AuthenticationType>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "embeddedCertData", skip_serializing_if = "Option::is_none")]
    pub embedded_cert_data: Option<serde_json::Value>,
    #[serde(rename = "certThumbprint", skip_serializing_if = "Option::is_none")]
    pub cert_thumbprint: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
    #[serde(rename = "enableServerCertificateValidation", skip_serializing_if = "Option::is_none")]
    pub enable_server_certificate_validation: Option<serde_json::Value>,
}
pub mod http_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        Anonymous,
        Digest,
        Windows,
        ClientCertificate,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FtpServerLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: FtpServerLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FtpServerLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<ftp_server_linked_service_type_properties::AuthenticationType>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
    #[serde(rename = "enableSsl", skip_serializing_if = "Option::is_none")]
    pub enable_ssl: Option<serde_json::Value>,
    #[serde(rename = "enableServerCertificateValidation", skip_serializing_if = "Option::is_none")]
    pub enable_server_certificate_validation: Option<serde_json::Value>,
}
pub mod ftp_server_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        Anonymous,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SftpServerLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SftpServerLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SftpServerLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<sftp_server_linked_service_type_properties::AuthenticationType>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
    #[serde(rename = "privateKeyPath", skip_serializing_if = "Option::is_none")]
    pub private_key_path: Option<serde_json::Value>,
    #[serde(rename = "privateKeyContent", skip_serializing_if = "Option::is_none")]
    pub private_key_content: Option<SecretBase>,
    #[serde(rename = "passPhrase", skip_serializing_if = "Option::is_none")]
    pub pass_phrase: Option<SecretBase>,
    #[serde(rename = "skipHostKeyValidation", skip_serializing_if = "Option::is_none")]
    pub skip_host_key_validation: Option<serde_json::Value>,
    #[serde(rename = "hostKeyFingerprint", skip_serializing_if = "Option::is_none")]
    pub host_key_fingerprint: Option<serde_json::Value>,
}
pub mod sftp_server_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        SshPublicKey,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapBwLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapBwLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapBwLinkedServiceTypeProperties {
    pub server: serde_json::Value,
    #[serde(rename = "systemNumber")]
    pub system_number: serde_json::Value,
    #[serde(rename = "clientId")]
    pub client_id: serde_json::Value,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapHanaLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapHanaLinkedServiceProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapHanaLinkedServiceProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server: Option<serde_json::Value>,
    #[serde(rename = "authenticationType", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<sap_hana_linked_service_properties::AuthenticationType>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod sap_hana_linked_service_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        Windows,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonMwsLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AmazonMwsLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AmazonMwsLinkedServiceTypeProperties {
    pub endpoint: serde_json::Value,
    #[serde(rename = "marketplaceID")]
    pub marketplace_id: serde_json::Value,
    #[serde(rename = "sellerID")]
    pub seller_id: serde_json::Value,
    #[serde(rename = "mwsAuthToken", skip_serializing_if = "Option::is_none")]
    pub mws_auth_token: Option<SecretBase>,
    #[serde(rename = "accessKeyId")]
    pub access_key_id: serde_json::Value,
    #[serde(rename = "secretKey", skip_serializing_if = "Option::is_none")]
    pub secret_key: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzurePostgreSqlLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzurePostgreSqlLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzurePostgreSqlLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConcurLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: ConcurLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConcurLinkedServiceTypeProperties {
    #[serde(rename = "connectionProperties", skip_serializing_if = "Option::is_none")]
    pub connection_properties: Option<serde_json::Value>,
    #[serde(rename = "clientId")]
    pub client_id: serde_json::Value,
    pub username: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CouchbaseLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: CouchbaseLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CouchbaseLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(rename = "credString", skip_serializing_if = "Option::is_none")]
    pub cred_string: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DrillLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: DrillLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DrillLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pwd: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EloquaLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: EloquaLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EloquaLinkedServiceTypeProperties {
    pub endpoint: serde_json::Value,
    pub username: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleBigQueryLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: GoogleBigQueryLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleBigQueryLinkedServiceTypeProperties {
    pub project: serde_json::Value,
    #[serde(rename = "additionalProjects", skip_serializing_if = "Option::is_none")]
    pub additional_projects: Option<serde_json::Value>,
    #[serde(rename = "requestGoogleDriveScope", skip_serializing_if = "Option::is_none")]
    pub request_google_drive_scope: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: google_big_query_linked_service_type_properties::AuthenticationType,
    #[serde(rename = "refreshToken", skip_serializing_if = "Option::is_none")]
    pub refresh_token: Option<SecretBase>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    pub client_id: Option<serde_json::Value>,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<serde_json::Value>,
    #[serde(rename = "keyFilePath", skip_serializing_if = "Option::is_none")]
    pub key_file_path: Option<serde_json::Value>,
    #[serde(rename = "trustedCertPath", skip_serializing_if = "Option::is_none")]
    pub trusted_cert_path: Option<serde_json::Value>,
    #[serde(rename = "useSystemTrustStore", skip_serializing_if = "Option::is_none")]
    pub use_system_trust_store: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod google_big_query_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        ServiceAuthentication,
        UserAuthentication,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GreenplumLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: GreenplumLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GreenplumLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pwd: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HBaseLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: HBaseLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HBaseLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "httpPath", skip_serializing_if = "Option::is_none")]
    pub http_path: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: h_base_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "enableSsl", skip_serializing_if = "Option::is_none")]
    pub enable_ssl: Option<serde_json::Value>,
    #[serde(rename = "trustedCertPath", skip_serializing_if = "Option::is_none")]
    pub trusted_cert_path: Option<serde_json::Value>,
    #[serde(rename = "allowHostNameCNMismatch", skip_serializing_if = "Option::is_none")]
    pub allow_host_name_cn_mismatch: Option<serde_json::Value>,
    #[serde(rename = "allowSelfSignedServerCert", skip_serializing_if = "Option::is_none")]
    pub allow_self_signed_server_cert: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod h_base_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Anonymous,
        Basic,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HiveLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: HiveLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HiveLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "serverType", skip_serializing_if = "Option::is_none")]
    pub server_type: Option<hive_linked_service_type_properties::ServerType>,
    #[serde(rename = "thriftTransportProtocol", skip_serializing_if = "Option::is_none")]
    pub thrift_transport_protocol: Option<hive_linked_service_type_properties::ThriftTransportProtocol>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: hive_linked_service_type_properties::AuthenticationType,
    #[serde(rename = "serviceDiscoveryMode", skip_serializing_if = "Option::is_none")]
    pub service_discovery_mode: Option<serde_json::Value>,
    #[serde(rename = "zooKeeperNameSpace", skip_serializing_if = "Option::is_none")]
    pub zoo_keeper_name_space: Option<serde_json::Value>,
    #[serde(rename = "useNativeQuery", skip_serializing_if = "Option::is_none")]
    pub use_native_query: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "httpPath", skip_serializing_if = "Option::is_none")]
    pub http_path: Option<serde_json::Value>,
    #[serde(rename = "enableSsl", skip_serializing_if = "Option::is_none")]
    pub enable_ssl: Option<serde_json::Value>,
    #[serde(rename = "trustedCertPath", skip_serializing_if = "Option::is_none")]
    pub trusted_cert_path: Option<serde_json::Value>,
    #[serde(rename = "useSystemTrustStore", skip_serializing_if = "Option::is_none")]
    pub use_system_trust_store: Option<serde_json::Value>,
    #[serde(rename = "allowHostNameCNMismatch", skip_serializing_if = "Option::is_none")]
    pub allow_host_name_cn_mismatch: Option<serde_json::Value>,
    #[serde(rename = "allowSelfSignedServerCert", skip_serializing_if = "Option::is_none")]
    pub allow_self_signed_server_cert: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod hive_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ServerType {
        HiveServer1,
        HiveServer2,
        HiveThriftServer,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ThriftTransportProtocol {
        Binary,
        #[serde(rename = "SASL")]
        Sasl,
        #[serde(rename = "HTTP ")]
        Http,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Anonymous,
        Username,
        UsernameAndPassword,
        #[serde(rename = "WindowsAzureHDInsightService")]
        WindowsAzureHdInsightService,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubspotLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: HubspotLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubspotLinkedServiceTypeProperties {
    #[serde(rename = "clientId")]
    pub client_id: serde_json::Value,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    pub access_token: Option<SecretBase>,
    #[serde(rename = "refreshToken", skip_serializing_if = "Option::is_none")]
    pub refresh_token: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImpalaLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: ImpalaLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImpalaLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: impala_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "enableSsl", skip_serializing_if = "Option::is_none")]
    pub enable_ssl: Option<serde_json::Value>,
    #[serde(rename = "trustedCertPath", skip_serializing_if = "Option::is_none")]
    pub trusted_cert_path: Option<serde_json::Value>,
    #[serde(rename = "useSystemTrustStore", skip_serializing_if = "Option::is_none")]
    pub use_system_trust_store: Option<serde_json::Value>,
    #[serde(rename = "allowHostNameCNMismatch", skip_serializing_if = "Option::is_none")]
    pub allow_host_name_cn_mismatch: Option<serde_json::Value>,
    #[serde(rename = "allowSelfSignedServerCert", skip_serializing_if = "Option::is_none")]
    pub allow_self_signed_server_cert: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod impala_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Anonymous,
        #[serde(rename = "SASLUsername")]
        SaslUsername,
        UsernameAndPassword,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JiraLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: JiraLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JiraLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    pub username: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MagentoLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: MagentoLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MagentoLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    pub access_token: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MariaDbLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: MariaDbLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MariaDbLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pwd: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMariaDbLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureMariaDbLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMariaDbLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pwd: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MarketoLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: MarketoLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MarketoLinkedServiceTypeProperties {
    pub endpoint: serde_json::Value,
    #[serde(rename = "clientId")]
    pub client_id: serde_json::Value,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PaypalLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: PaypalLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PaypalLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(rename = "clientId")]
    pub client_id: serde_json::Value,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PhoenixLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: PhoenixLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PhoenixLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "httpPath", skip_serializing_if = "Option::is_none")]
    pub http_path: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: phoenix_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "enableSsl", skip_serializing_if = "Option::is_none")]
    pub enable_ssl: Option<serde_json::Value>,
    #[serde(rename = "trustedCertPath", skip_serializing_if = "Option::is_none")]
    pub trusted_cert_path: Option<serde_json::Value>,
    #[serde(rename = "useSystemTrustStore", skip_serializing_if = "Option::is_none")]
    pub use_system_trust_store: Option<serde_json::Value>,
    #[serde(rename = "allowHostNameCNMismatch", skip_serializing_if = "Option::is_none")]
    pub allow_host_name_cn_mismatch: Option<serde_json::Value>,
    #[serde(rename = "allowSelfSignedServerCert", skip_serializing_if = "Option::is_none")]
    pub allow_self_signed_server_cert: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod phoenix_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Anonymous,
        UsernameAndPassword,
        #[serde(rename = "WindowsAzureHDInsightService")]
        WindowsAzureHdInsightService,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrestoLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: PrestoLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrestoLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(rename = "serverVersion")]
    pub server_version: serde_json::Value,
    pub catalog: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<serde_json::Value>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: presto_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "enableSsl", skip_serializing_if = "Option::is_none")]
    pub enable_ssl: Option<serde_json::Value>,
    #[serde(rename = "trustedCertPath", skip_serializing_if = "Option::is_none")]
    pub trusted_cert_path: Option<serde_json::Value>,
    #[serde(rename = "useSystemTrustStore", skip_serializing_if = "Option::is_none")]
    pub use_system_trust_store: Option<serde_json::Value>,
    #[serde(rename = "allowHostNameCNMismatch", skip_serializing_if = "Option::is_none")]
    pub allow_host_name_cn_mismatch: Option<serde_json::Value>,
    #[serde(rename = "allowSelfSignedServerCert", skip_serializing_if = "Option::is_none")]
    pub allow_self_signed_server_cert: Option<serde_json::Value>,
    #[serde(rename = "timeZoneID", skip_serializing_if = "Option::is_none")]
    pub time_zone_id: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod presto_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Anonymous,
        #[serde(rename = "LDAP")]
        Ldap,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QuickBooksLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: QuickBooksLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QuickBooksLinkedServiceTypeProperties {
    #[serde(rename = "connectionProperties", skip_serializing_if = "Option::is_none")]
    pub connection_properties: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<serde_json::Value>,
    #[serde(rename = "companyId", skip_serializing_if = "Option::is_none")]
    pub company_id: Option<serde_json::Value>,
    #[serde(rename = "consumerKey", skip_serializing_if = "Option::is_none")]
    pub consumer_key: Option<serde_json::Value>,
    #[serde(rename = "consumerSecret", skip_serializing_if = "Option::is_none")]
    pub consumer_secret: Option<SecretBase>,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    pub access_token: Option<SecretBase>,
    #[serde(rename = "accessTokenSecret", skip_serializing_if = "Option::is_none")]
    pub access_token_secret: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceNowLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: ServiceNowLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceNowLinkedServiceTypeProperties {
    pub endpoint: serde_json::Value,
    #[serde(rename = "authenticationType")]
    pub authentication_type: service_now_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    pub client_id: Option<serde_json::Value>,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod service_now_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Basic,
        OAuth2,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ShopifyLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: ShopifyLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ShopifyLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    pub access_token: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SparkLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SparkLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SparkLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    pub port: serde_json::Value,
    #[serde(rename = "serverType", skip_serializing_if = "Option::is_none")]
    pub server_type: Option<spark_linked_service_type_properties::ServerType>,
    #[serde(rename = "thriftTransportProtocol", skip_serializing_if = "Option::is_none")]
    pub thrift_transport_protocol: Option<spark_linked_service_type_properties::ThriftTransportProtocol>,
    #[serde(rename = "authenticationType")]
    pub authentication_type: spark_linked_service_type_properties::AuthenticationType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "httpPath", skip_serializing_if = "Option::is_none")]
    pub http_path: Option<serde_json::Value>,
    #[serde(rename = "enableSsl", skip_serializing_if = "Option::is_none")]
    pub enable_ssl: Option<serde_json::Value>,
    #[serde(rename = "trustedCertPath", skip_serializing_if = "Option::is_none")]
    pub trusted_cert_path: Option<serde_json::Value>,
    #[serde(rename = "useSystemTrustStore", skip_serializing_if = "Option::is_none")]
    pub use_system_trust_store: Option<serde_json::Value>,
    #[serde(rename = "allowHostNameCNMismatch", skip_serializing_if = "Option::is_none")]
    pub allow_host_name_cn_mismatch: Option<serde_json::Value>,
    #[serde(rename = "allowSelfSignedServerCert", skip_serializing_if = "Option::is_none")]
    pub allow_self_signed_server_cert: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod spark_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ServerType {
        SharkServer,
        SharkServer2,
        SparkThriftServer,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ThriftTransportProtocol {
        Binary,
        #[serde(rename = "SASL")]
        Sasl,
        #[serde(rename = "HTTP ")]
        Http,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        Anonymous,
        Username,
        UsernameAndPassword,
        #[serde(rename = "WindowsAzureHDInsightService")]
        WindowsAzureHdInsightService,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SquareLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SquareLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SquareLinkedServiceTypeProperties {
    #[serde(rename = "connectionProperties", skip_serializing_if = "Option::is_none")]
    pub connection_properties: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub host: Option<serde_json::Value>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    pub client_id: Option<serde_json::Value>,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(rename = "redirectUri", skip_serializing_if = "Option::is_none")]
    pub redirect_uri: Option<serde_json::Value>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct XeroLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: XeroLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct XeroLinkedServiceTypeProperties {
    #[serde(rename = "connectionProperties", skip_serializing_if = "Option::is_none")]
    pub connection_properties: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub host: Option<serde_json::Value>,
    #[serde(rename = "consumerKey", skip_serializing_if = "Option::is_none")]
    pub consumer_key: Option<SecretBase>,
    #[serde(rename = "privateKey", skip_serializing_if = "Option::is_none")]
    pub private_key: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ZohoLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: ZohoLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ZohoLinkedServiceTypeProperties {
    #[serde(rename = "connectionProperties", skip_serializing_if = "Option::is_none")]
    pub connection_properties: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<serde_json::Value>,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    pub access_token: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VerticaLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: VerticaLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VerticaLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pwd: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetezzaLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: NetezzaLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetezzaLinkedServiceTypeProperties {
    #[serde(rename = "connectionString", skip_serializing_if = "Option::is_none")]
    pub connection_string: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pwd: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceMarketingCloudLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SalesforceMarketingCloudLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SalesforceMarketingCloudLinkedServiceTypeProperties {
    #[serde(rename = "connectionProperties", skip_serializing_if = "Option::is_none")]
    pub connection_properties: Option<serde_json::Value>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    pub client_id: Option<serde_json::Value>,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightOnDemandLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: HdInsightOnDemandLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HdInsightOnDemandLinkedServiceTypeProperties {
    #[serde(rename = "clusterSize")]
    pub cluster_size: serde_json::Value,
    #[serde(rename = "timeToLive")]
    pub time_to_live: serde_json::Value,
    pub version: serde_json::Value,
    #[serde(rename = "linkedServiceName")]
    pub linked_service_name: LinkedServiceReference,
    #[serde(rename = "hostSubscriptionId")]
    pub host_subscription_id: serde_json::Value,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    pub tenant: serde_json::Value,
    #[serde(rename = "clusterResourceGroup")]
    pub cluster_resource_group: serde_json::Value,
    #[serde(rename = "clusterNamePrefix", skip_serializing_if = "Option::is_none")]
    pub cluster_name_prefix: Option<serde_json::Value>,
    #[serde(rename = "clusterUserName", skip_serializing_if = "Option::is_none")]
    pub cluster_user_name: Option<serde_json::Value>,
    #[serde(rename = "clusterPassword", skip_serializing_if = "Option::is_none")]
    pub cluster_password: Option<SecretBase>,
    #[serde(rename = "clusterSshUserName", skip_serializing_if = "Option::is_none")]
    pub cluster_ssh_user_name: Option<serde_json::Value>,
    #[serde(rename = "clusterSshPassword", skip_serializing_if = "Option::is_none")]
    pub cluster_ssh_password: Option<SecretBase>,
    #[serde(rename = "additionalLinkedServiceNames", skip_serializing_if = "Vec::is_empty")]
    pub additional_linked_service_names: Vec<LinkedServiceReference>,
    #[serde(rename = "hcatalogLinkedServiceName", skip_serializing_if = "Option::is_none")]
    pub hcatalog_linked_service_name: Option<LinkedServiceReference>,
    #[serde(rename = "clusterType", skip_serializing_if = "Option::is_none")]
    pub cluster_type: Option<serde_json::Value>,
    #[serde(rename = "sparkVersion", skip_serializing_if = "Option::is_none")]
    pub spark_version: Option<serde_json::Value>,
    #[serde(rename = "coreConfiguration", skip_serializing_if = "Option::is_none")]
    pub core_configuration: Option<serde_json::Value>,
    #[serde(rename = "hBaseConfiguration", skip_serializing_if = "Option::is_none")]
    pub h_base_configuration: Option<serde_json::Value>,
    #[serde(rename = "hdfsConfiguration", skip_serializing_if = "Option::is_none")]
    pub hdfs_configuration: Option<serde_json::Value>,
    #[serde(rename = "hiveConfiguration", skip_serializing_if = "Option::is_none")]
    pub hive_configuration: Option<serde_json::Value>,
    #[serde(rename = "mapReduceConfiguration", skip_serializing_if = "Option::is_none")]
    pub map_reduce_configuration: Option<serde_json::Value>,
    #[serde(rename = "oozieConfiguration", skip_serializing_if = "Option::is_none")]
    pub oozie_configuration: Option<serde_json::Value>,
    #[serde(rename = "stormConfiguration", skip_serializing_if = "Option::is_none")]
    pub storm_configuration: Option<serde_json::Value>,
    #[serde(rename = "yarnConfiguration", skip_serializing_if = "Option::is_none")]
    pub yarn_configuration: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
    #[serde(rename = "headNodeSize", skip_serializing_if = "Option::is_none")]
    pub head_node_size: Option<serde_json::Value>,
    #[serde(rename = "dataNodeSize", skip_serializing_if = "Option::is_none")]
    pub data_node_size: Option<serde_json::Value>,
    #[serde(rename = "zookeeperNodeSize", skip_serializing_if = "Option::is_none")]
    pub zookeeper_node_size: Option<serde_json::Value>,
    #[serde(rename = "scriptActions", skip_serializing_if = "Vec::is_empty")]
    pub script_actions: Vec<ScriptAction>,
    #[serde(rename = "virtualNetworkId", skip_serializing_if = "Option::is_none")]
    pub virtual_network_id: Option<serde_json::Value>,
    #[serde(rename = "subnetName", skip_serializing_if = "Option::is_none")]
    pub subnet_name: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ScriptAction {
    pub name: String,
    pub uri: String,
    pub roles: script_action::Roles,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<String>,
}
pub mod script_action {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Roles {
        Headnode,
        Workernode,
        Zookeeper,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeAnalyticsLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureDataLakeAnalyticsLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataLakeAnalyticsLinkedServiceTypeProperties {
    #[serde(rename = "accountName")]
    pub account_name: serde_json::Value,
    #[serde(rename = "servicePrincipalId", skip_serializing_if = "Option::is_none")]
    pub service_principal_id: Option<serde_json::Value>,
    #[serde(rename = "servicePrincipalKey", skip_serializing_if = "Option::is_none")]
    pub service_principal_key: Option<SecretBase>,
    pub tenant: serde_json::Value,
    #[serde(rename = "subscriptionId", skip_serializing_if = "Option::is_none")]
    pub subscription_id: Option<serde_json::Value>,
    #[serde(rename = "resourceGroupName", skip_serializing_if = "Option::is_none")]
    pub resource_group_name: Option<serde_json::Value>,
    #[serde(rename = "dataLakeAnalyticsUri", skip_serializing_if = "Option::is_none")]
    pub data_lake_analytics_uri: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureDatabricksLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksLinkedServiceTypeProperties {
    pub domain: serde_json::Value,
    #[serde(rename = "accessToken")]
    pub access_token: SecretBase,
    #[serde(rename = "existingClusterId", skip_serializing_if = "Option::is_none")]
    pub existing_cluster_id: Option<serde_json::Value>,
    #[serde(rename = "instancePoolId", skip_serializing_if = "Option::is_none")]
    pub instance_pool_id: Option<serde_json::Value>,
    #[serde(rename = "newClusterVersion", skip_serializing_if = "Option::is_none")]
    pub new_cluster_version: Option<serde_json::Value>,
    #[serde(rename = "newClusterNumOfWorker", skip_serializing_if = "Option::is_none")]
    pub new_cluster_num_of_worker: Option<serde_json::Value>,
    #[serde(rename = "newClusterNodeType", skip_serializing_if = "Option::is_none")]
    pub new_cluster_node_type: Option<serde_json::Value>,
    #[serde(rename = "newClusterSparkConf", skip_serializing_if = "Option::is_none")]
    pub new_cluster_spark_conf: Option<serde_json::Value>,
    #[serde(rename = "newClusterSparkEnvVars", skip_serializing_if = "Option::is_none")]
    pub new_cluster_spark_env_vars: Option<serde_json::Value>,
    #[serde(rename = "newClusterCustomTags", skip_serializing_if = "Option::is_none")]
    pub new_cluster_custom_tags: Option<serde_json::Value>,
    #[serde(rename = "newClusterLogDestination", skip_serializing_if = "Option::is_none")]
    pub new_cluster_log_destination: Option<serde_json::Value>,
    #[serde(rename = "newClusterDriverNodeType", skip_serializing_if = "Option::is_none")]
    pub new_cluster_driver_node_type: Option<serde_json::Value>,
    #[serde(rename = "newClusterInitScripts", skip_serializing_if = "Option::is_none")]
    pub new_cluster_init_scripts: Option<serde_json::Value>,
    #[serde(rename = "newClusterEnableElasticDisk", skip_serializing_if = "Option::is_none")]
    pub new_cluster_enable_elastic_disk: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksDeltaLakeLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureDatabricksDetltaLakeLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDatabricksDetltaLakeLinkedServiceTypeProperties {
    pub domain: serde_json::Value,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    pub access_token: Option<SecretBase>,
    #[serde(rename = "clusterId", skip_serializing_if = "Option::is_none")]
    pub cluster_id: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResponsysLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: ResponsysLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResponsysLinkedServiceTypeProperties {
    pub endpoint: serde_json::Value,
    #[serde(rename = "clientId")]
    pub client_id: serde_json::Value,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsAxLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: DynamicsAxLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DynamicsAxLinkedServiceTypeProperties {
    pub url: serde_json::Value,
    #[serde(rename = "servicePrincipalId")]
    pub service_principal_id: serde_json::Value,
    #[serde(rename = "servicePrincipalKey")]
    pub service_principal_key: SecretBase,
    pub tenant: serde_json::Value,
    #[serde(rename = "aadResourceId")]
    pub aad_resource_id: serde_json::Value,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleServiceCloudLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: OracleServiceCloudLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OracleServiceCloudLinkedServiceTypeProperties {
    pub host: serde_json::Value,
    pub username: serde_json::Value,
    pub password: SecretBase,
    #[serde(rename = "useEncryptedEndpoints", skip_serializing_if = "Option::is_none")]
    pub use_encrypted_endpoints: Option<serde_json::Value>,
    #[serde(rename = "useHostVerification", skip_serializing_if = "Option::is_none")]
    pub use_host_verification: Option<serde_json::Value>,
    #[serde(rename = "usePeerVerification", skip_serializing_if = "Option::is_none")]
    pub use_peer_verification: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleAdWordsLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: GoogleAdWordsLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GoogleAdWordsLinkedServiceTypeProperties {
    #[serde(rename = "clientCustomerID")]
    pub client_customer_id: serde_json::Value,
    #[serde(rename = "developerToken")]
    pub developer_token: SecretBase,
    #[serde(rename = "authenticationType")]
    pub authentication_type: google_ad_words_linked_service_type_properties::AuthenticationType,
    #[serde(rename = "refreshToken", skip_serializing_if = "Option::is_none")]
    pub refresh_token: Option<SecretBase>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    pub client_id: Option<serde_json::Value>,
    #[serde(rename = "clientSecret", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<SecretBase>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<serde_json::Value>,
    #[serde(rename = "keyFilePath", skip_serializing_if = "Option::is_none")]
    pub key_file_path: Option<serde_json::Value>,
    #[serde(rename = "trustedCertPath", skip_serializing_if = "Option::is_none")]
    pub trusted_cert_path: Option<serde_json::Value>,
    #[serde(rename = "useSystemTrustStore", skip_serializing_if = "Option::is_none")]
    pub use_system_trust_store: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
pub mod google_ad_words_linked_service_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthenticationType {
        ServiceAuthentication,
        UserAuthentication,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapTableLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SapTableLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SapTableLinkedServiceTypeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server: Option<serde_json::Value>,
    #[serde(rename = "systemNumber", skip_serializing_if = "Option::is_none")]
    pub system_number: Option<serde_json::Value>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    pub client_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub language: Option<serde_json::Value>,
    #[serde(rename = "systemId", skip_serializing_if = "Option::is_none")]
    pub system_id: Option<serde_json::Value>,
    #[serde(rename = "userName", skip_serializing_if = "Option::is_none")]
    pub user_name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<SecretBase>,
    #[serde(rename = "messageServer", skip_serializing_if = "Option::is_none")]
    pub message_server: Option<serde_json::Value>,
    #[serde(rename = "messageServerService", skip_serializing_if = "Option::is_none")]
    pub message_server_service: Option<serde_json::Value>,
    #[serde(rename = "sncMode", skip_serializing_if = "Option::is_none")]
    pub snc_mode: Option<serde_json::Value>,
    #[serde(rename = "sncMyName", skip_serializing_if = "Option::is_none")]
    pub snc_my_name: Option<serde_json::Value>,
    #[serde(rename = "sncPartnerName", skip_serializing_if = "Option::is_none")]
    pub snc_partner_name: Option<serde_json::Value>,
    #[serde(rename = "sncLibraryPath", skip_serializing_if = "Option::is_none")]
    pub snc_library_path: Option<serde_json::Value>,
    #[serde(rename = "sncQop", skip_serializing_if = "Option::is_none")]
    pub snc_qop: Option<serde_json::Value>,
    #[serde(rename = "logonGroup", skip_serializing_if = "Option::is_none")]
    pub logon_group: Option<serde_json::Value>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataExplorerLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureDataExplorerLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureDataExplorerLinkedServiceTypeProperties {
    pub endpoint: serde_json::Value,
    #[serde(rename = "servicePrincipalId")]
    pub service_principal_id: serde_json::Value,
    #[serde(rename = "servicePrincipalKey")]
    pub service_principal_key: SecretBase,
    pub database: serde_json::Value,
    pub tenant: serde_json::Value,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFunctionLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: AzureFunctionLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFunctionLinkedServiceTypeProperties {
    #[serde(rename = "functionAppUrl")]
    pub function_app_url: serde_json::Value,
    #[serde(rename = "functionKey", skip_serializing_if = "Option::is_none")]
    pub function_key: Option<SecretBase>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SnowflakeLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SnowflakeLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SnowflakeLinkedServiceTypeProperties {
    #[serde(rename = "connectionString")]
    pub connection_string: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<AzureKeyVaultSecretReference>,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SharePointOnlineListLinkedService {
    #[serde(flatten)]
    pub linked_service: LinkedService,
    #[serde(rename = "typeProperties")]
    pub type_properties: SharePointOnlineListLinkedServiceTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SharePointOnlineListLinkedServiceTypeProperties {
    #[serde(rename = "siteUrl")]
    pub site_url: serde_json::Value,
    #[serde(rename = "tenantId")]
    pub tenant_id: serde_json::Value,
    #[serde(rename = "servicePrincipalId")]
    pub service_principal_id: serde_json::Value,
    #[serde(rename = "servicePrincipalKey")]
    pub service_principal_key: SecretBase,
    #[serde(rename = "encryptedCredential", skip_serializing_if = "Option::is_none")]
    pub encrypted_credential: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlow {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub annotations: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub folder: Option<data_flow::Folder>,
}
pub mod data_flow {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct Folder {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MappingDataFlow {
    #[serde(flatten)]
    pub data_flow: DataFlow,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<MappingDataFlowTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MappingDataFlowTypeProperties {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub sources: Vec<DataFlowSource>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub sinks: Vec<DataFlowSink>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub transformations: Vec<Transformation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub script: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Transformation {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowSource {
    #[serde(flatten)]
    pub transformation: Transformation,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dataset: Option<DatasetReference>,
    #[serde(rename = "linkedService", skip_serializing_if = "Option::is_none")]
    pub linked_service: Option<LinkedServiceReference>,
    #[serde(rename = "schemaLinkedService", skip_serializing_if = "Option::is_none")]
    pub schema_linked_service: Option<LinkedServiceReference>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlowSink {
    #[serde(flatten)]
    pub transformation: Transformation,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dataset: Option<DatasetReference>,
    #[serde(rename = "linkedService", skip_serializing_if = "Option::is_none")]
    pub linked_service: Option<LinkedServiceReference>,
    #[serde(rename = "schemaLinkedService", skip_serializing_if = "Option::is_none")]
    pub schema_linked_service: Option<LinkedServiceReference>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedPrivateEndpoint {
    #[serde(rename = "connectionState", skip_serializing_if = "Option::is_none")]
    pub connection_state: Option<ConnectionStateProperties>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub fqdns: Vec<String>,
    #[serde(rename = "groupId", skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,
    #[serde(rename = "isReserved", skip_serializing)]
    pub is_reserved: Option<bool>,
    #[serde(rename = "privateLinkResourceId", skip_serializing_if = "Option::is_none")]
    pub private_link_resource_id: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionStateProperties {
    #[serde(rename = "actionsRequired", skip_serializing)]
    pub actions_required: Option<String>,
    #[serde(skip_serializing)]
    pub description: Option<String>,
    #[serde(skip_serializing)]
    pub status: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedVirtualNetwork {
    #[serde(rename = "vNetId", skip_serializing)]
    pub v_net_id: Option<String>,
    #[serde(skip_serializing)]
    pub alias: Option<String>,
}
