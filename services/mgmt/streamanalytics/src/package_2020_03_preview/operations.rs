#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use crate::models::*;
use reqwest::StatusCode;
use snafu::{ResultExt, Snafu};
pub mod functions {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        function_name: &str,
    ) -> std::result::Result<Function, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/functions/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            function_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Function = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                get::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_replace(
        operation_config: &crate::OperationConfig,
        function: &Function,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        function_name: &str,
    ) -> std::result::Result<create_or_replace::Response, create_or_replace::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/functions/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            function_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_replace::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(function);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req = req_builder.build().context(create_or_replace::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_replace::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: Function = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: Function = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                create_or_replace::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_or_replace {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Function),
            Created201(Function),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        function: &Function,
        if_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        function_name: &str,
    ) -> std::result::Result<Function, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/functions/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            function_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(function);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Function = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                update::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        function_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/functions/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            function_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                delete::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_by_streaming_job(
        operation_config: &crate::OperationConfig,
        select: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<FunctionListResult, list_by_streaming_job::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/functions",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_streaming_job::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(select) = select {
            req_builder = req_builder.query(&[("$select", select)]);
        }
        let req = req_builder.build().context(list_by_streaming_job::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_streaming_job::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_streaming_job::ResponseBytesError)?;
                let rsp_value: FunctionListResult =
                    serde_json::from_slice(&body).context(list_by_streaming_job::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_streaming_job::ResponseBytesError)?;
                list_by_streaming_job::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_by_streaming_job {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn test(
        operation_config: &crate::OperationConfig,
        function: Option<&Function>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        function_name: &str,
    ) -> std::result::Result<test::Response, test::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/functions/{}/test",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            function_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(test::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(function) = function {
            req_builder = req_builder.json(function);
        }
        let req = req_builder.build().context(test::BuildRequestError)?;
        let rsp = client.execute(req).await.context(test::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(test::ResponseBytesError)?;
                let rsp_value: ResourceTestStatus = serde_json::from_slice(&body).context(test::DeserializeError { body })?;
                Ok(test::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(test::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(test::ResponseBytesError)?;
                test::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod test {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(ResourceTestStatus),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn retrieve_default_definition(
        operation_config: &crate::OperationConfig,
        function_retrieve_default_definition_parameters: Option<&FunctionRetrieveDefaultDefinitionParameters>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        function_name: &str,
    ) -> std::result::Result<Function, retrieve_default_definition::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/functions/{}/RetrieveDefaultDefinition" , operation_config . base_path () , subscription_id , resource_group_name , job_name , function_name) ;
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(retrieve_default_definition::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(function_retrieve_default_definition_parameters) = function_retrieve_default_definition_parameters {
            req_builder = req_builder.json(function_retrieve_default_definition_parameters);
        }
        let req = req_builder.build().context(retrieve_default_definition::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(retrieve_default_definition::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(retrieve_default_definition::ResponseBytesError)?;
                let rsp_value: Function = serde_json::from_slice(&body).context(retrieve_default_definition::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(retrieve_default_definition::ResponseBytesError)?;
                retrieve_default_definition::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod retrieve_default_definition {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod inputs {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        input_name: &str,
    ) -> std::result::Result<Input, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/inputs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            input_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Input = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                get::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_replace(
        operation_config: &crate::OperationConfig,
        input: &Input,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        input_name: &str,
    ) -> std::result::Result<create_or_replace::Response, create_or_replace::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/inputs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            input_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_replace::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(input);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req = req_builder.build().context(create_or_replace::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_replace::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: Input = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: Input = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                create_or_replace::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_or_replace {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Input),
            Created201(Input),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        input: &Input,
        if_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        input_name: &str,
    ) -> std::result::Result<Input, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/inputs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            input_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(input);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Input = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                update::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        input_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/inputs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            input_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                delete::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_by_streaming_job(
        operation_config: &crate::OperationConfig,
        select: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<InputListResult, list_by_streaming_job::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/inputs",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_streaming_job::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(select) = select {
            req_builder = req_builder.query(&[("$select", select)]);
        }
        let req = req_builder.build().context(list_by_streaming_job::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_streaming_job::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_streaming_job::ResponseBytesError)?;
                let rsp_value: InputListResult = serde_json::from_slice(&body).context(list_by_streaming_job::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_streaming_job::ResponseBytesError)?;
                list_by_streaming_job::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_by_streaming_job {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn test(
        operation_config: &crate::OperationConfig,
        input: Option<&Input>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        input_name: &str,
    ) -> std::result::Result<test::Response, test::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/inputs/{}/test",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            input_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(test::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(input) = input {
            req_builder = req_builder.json(input);
        }
        let req = req_builder.build().context(test::BuildRequestError)?;
        let rsp = client.execute(req).await.context(test::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(test::ResponseBytesError)?;
                let rsp_value: ResourceTestStatus = serde_json::from_slice(&body).context(test::DeserializeError { body })?;
                Ok(test::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(test::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(test::ResponseBytesError)?;
                test::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod test {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(ResourceTestStatus),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod outputs {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        output_name: &str,
    ) -> std::result::Result<Output, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/outputs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            output_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Output = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                get::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_replace(
        operation_config: &crate::OperationConfig,
        output: &Output,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        output_name: &str,
    ) -> std::result::Result<create_or_replace::Response, create_or_replace::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/outputs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            output_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_replace::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(output);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req = req_builder.build().context(create_or_replace::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_replace::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: Output = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: Output = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                create_or_replace::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_or_replace {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Output),
            Created201(Output),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        output: &Output,
        if_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        output_name: &str,
    ) -> std::result::Result<Output, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/outputs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            output_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(output);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Output = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                update::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        output_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/outputs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            output_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                delete::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_by_streaming_job(
        operation_config: &crate::OperationConfig,
        select: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<OutputListResult, list_by_streaming_job::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/outputs",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_streaming_job::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(select) = select {
            req_builder = req_builder.query(&[("$select", select)]);
        }
        let req = req_builder.build().context(list_by_streaming_job::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_streaming_job::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_streaming_job::ResponseBytesError)?;
                let rsp_value: OutputListResult =
                    serde_json::from_slice(&body).context(list_by_streaming_job::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_streaming_job::ResponseBytesError)?;
                list_by_streaming_job::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_by_streaming_job {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn test(
        operation_config: &crate::OperationConfig,
        output: Option<&Output>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        output_name: &str,
    ) -> std::result::Result<test::Response, test::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/outputs/{}/test",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            output_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(test::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(output) = output {
            req_builder = req_builder.json(output);
        }
        let req = req_builder.build().context(test::BuildRequestError)?;
        let rsp = client.execute(req).await.context(test::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(test::ResponseBytesError)?;
                let rsp_value: ResourceTestStatus = serde_json::from_slice(&body).context(test::DeserializeError { body })?;
                Ok(test::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(test::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(test::ResponseBytesError)?;
                test::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod test {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(ResourceTestStatus),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod streaming_jobs {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        expand: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<StreamingJob, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(expand) = expand {
            req_builder = req_builder.query(&[("$expand", expand)]);
        }
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: StreamingJob = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                get::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_replace(
        operation_config: &crate::OperationConfig,
        streaming_job: &StreamingJob,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<create_or_replace::Response, create_or_replace::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_replace::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(streaming_job);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req = req_builder.build().context(create_or_replace::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_replace::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: StreamingJob = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: StreamingJob = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                create_or_replace::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_or_replace {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(StreamingJob),
            Created201(StreamingJob),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        streaming_job: &StreamingJob,
        if_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<StreamingJob, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(streaming_job);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: StreamingJob = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                update::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                delete::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_by_resource_group(
        operation_config: &crate::OperationConfig,
        expand: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
    ) -> std::result::Result<StreamingJobListResult, list_by_resource_group::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs",
            operation_config.base_path(),
            subscription_id,
            resource_group_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_resource_group::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(expand) = expand {
            req_builder = req_builder.query(&[("$expand", expand)]);
        }
        let req = req_builder.build().context(list_by_resource_group::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_resource_group::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_resource_group::ResponseBytesError)?;
                let rsp_value: StreamingJobListResult =
                    serde_json::from_slice(&body).context(list_by_resource_group::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_resource_group::ResponseBytesError)?;
                list_by_resource_group::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_by_resource_group {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        expand: Option<&str>,
        subscription_id: &str,
    ) -> std::result::Result<StreamingJobListResult, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/providers/Microsoft.StreamAnalytics/streamingjobs",
            operation_config.base_path(),
            subscription_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(expand) = expand {
            req_builder = req_builder.query(&[("$expand", expand)]);
        }
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: StreamingJobListResult = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                list::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn start(
        operation_config: &crate::OperationConfig,
        start_job_parameters: Option<&StartStreamingJobParameters>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<start::Response, start::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/start",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(start::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(start_job_parameters) = start_job_parameters {
            req_builder = req_builder.json(start_job_parameters);
        }
        let req = req_builder.build().context(start::BuildRequestError)?;
        let rsp = client.execute(req).await.context(start::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(start::Response::Ok200),
            StatusCode::ACCEPTED => Ok(start::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(start::ResponseBytesError)?;
                start::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod start {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn stop(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
    ) -> std::result::Result<stop::Response, stop::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/stop",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(stop::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(stop::BuildRequestError)?;
        let rsp = client.execute(req).await.context(stop::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(stop::Response::Ok200),
            StatusCode::ACCEPTED => Ok(stop::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(stop::ResponseBytesError)?;
                stop::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod stop {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod transformations {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        transformation_name: &str,
    ) -> std::result::Result<Transformation, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/transformations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            transformation_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Transformation = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                get::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_replace(
        operation_config: &crate::OperationConfig,
        transformation: &Transformation,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        transformation_name: &str,
    ) -> std::result::Result<create_or_replace::Response, create_or_replace::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/transformations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            transformation_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_replace::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(transformation);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req = req_builder.build().context(create_or_replace::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_replace::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: Transformation = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                let rsp_value: Transformation = serde_json::from_slice(&body).context(create_or_replace::DeserializeError { body })?;
                Ok(create_or_replace::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_replace::ResponseBytesError)?;
                create_or_replace::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_or_replace {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Transformation),
            Created201(Transformation),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        transformation: &Transformation,
        if_match: Option<&str>,
        subscription_id: &str,
        resource_group_name: &str,
        job_name: &str,
        transformation_name: &str,
    ) -> std::result::Result<Transformation, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourcegroups/{}/providers/Microsoft.StreamAnalytics/streamingjobs/{}/transformations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            job_name,
            transformation_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(transformation);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Transformation = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                update::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod subscriptions {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_quotas(
        operation_config: &crate::OperationConfig,
        location: &str,
        subscription_id: &str,
    ) -> std::result::Result<SubscriptionQuotasListResult, list_quotas::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/providers/Microsoft.StreamAnalytics/locations/{}/quotas",
            operation_config.base_path(),
            subscription_id,
            location
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_quotas::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_quotas::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_quotas::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_quotas::ResponseBytesError)?;
                let rsp_value: SubscriptionQuotasListResult =
                    serde_json::from_slice(&body).context(list_quotas::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_quotas::ResponseBytesError)?;
                list_quotas::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_quotas {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod operations {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(operation_config: &crate::OperationConfig) -> std::result::Result<OperationListResult, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!("{}/providers/Microsoft.StreamAnalytics/operations", operation_config.base_path(),);
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: OperationListResult = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                list::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod clusters {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
    ) -> std::result::Result<Cluster, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        cluster: &Cluster,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(cluster);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Cluster),
            Created201(Cluster),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        cluster: &Cluster,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
        if_match: Option<&str>,
    ) -> std::result::Result<update::Response, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(cluster);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(update::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(update::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Cluster),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_by_subscription(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
    ) -> std::result::Result<ClusterListResult, list_by_subscription::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/providers/Microsoft.StreamAnalytics/clusters",
            operation_config.base_path(),
            subscription_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_subscription::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_by_subscription::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_subscription::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_subscription::ResponseBytesError)?;
                let rsp_value: ClusterListResult =
                    serde_json::from_slice(&body).context(list_by_subscription::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_subscription::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(list_by_subscription::DeserializeError { body })?;
                list_by_subscription::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_by_subscription {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_by_resource_group(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
    ) -> std::result::Result<ClusterListResult, list_by_resource_group::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters",
            operation_config.base_path(),
            subscription_id,
            resource_group_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_resource_group::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_by_resource_group::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_resource_group::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_resource_group::ResponseBytesError)?;
                let rsp_value: ClusterListResult =
                    serde_json::from_slice(&body).context(list_by_resource_group::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_resource_group::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(list_by_resource_group::DeserializeError { body })?;
                list_by_resource_group::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_by_resource_group {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_streaming_jobs(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
    ) -> std::result::Result<ClusterJobListResult, list_streaming_jobs::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}/listStreamingJobs",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_streaming_jobs::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(list_streaming_jobs::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_streaming_jobs::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_streaming_jobs::ResponseBytesError)?;
                let rsp_value: ClusterJobListResult =
                    serde_json::from_slice(&body).context(list_streaming_jobs::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_streaming_jobs::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(list_streaming_jobs::DeserializeError { body })?;
                list_streaming_jobs::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_streaming_jobs {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod private_endpoints {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
        private_endpoint_name: &str,
    ) -> std::result::Result<PrivateEndpoint, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}/privateEndpoints/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name,
            private_endpoint_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: PrivateEndpoint = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        private_endpoint: &PrivateEndpoint,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
        private_endpoint_name: &str,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}/privateEndpoints/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name,
            private_endpoint_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(private_endpoint);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: PrivateEndpoint = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: PrivateEndpoint = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(PrivateEndpoint),
            Created201(PrivateEndpoint),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
        private_endpoint_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}/privateEndpoints/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name,
            private_endpoint_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_by_cluster(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        cluster_name: &str,
    ) -> std::result::Result<PrivateEndpointListResult, list_by_cluster::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.StreamAnalytics/clusters/{}/privateEndpoints",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            cluster_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_cluster::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_by_cluster::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_cluster::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_cluster::ResponseBytesError)?;
                let rsp_value: PrivateEndpointListResult =
                    serde_json::from_slice(&body).context(list_by_cluster::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_cluster::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(list_by_cluster::DeserializeError { body })?;
                list_by_cluster::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_by_cluster {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
