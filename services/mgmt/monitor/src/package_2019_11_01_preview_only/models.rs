#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleAssociation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "dataCollectionRuleId")]
    pub data_collection_rule_id: String,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<data_collection_rule_association::ProvisioningState>,
}
pub mod data_collection_rule_association {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProvisioningState {
        Creating,
        Updating,
        Deleting,
        Succeeded,
        Failed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleAssociationProxyOnlyResource {
    pub properties: serde_json::Value,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleAssociationProxyOnlyResourceListResult {
    pub value: Vec<DataCollectionRuleAssociationProxyOnlyResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorAdditionalInfo {
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub info: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorDetails {
    #[serde(skip_serializing)]
    pub code: Option<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
    #[serde(skip_serializing)]
    pub target: Option<String>,
    #[serde(skip_serializing)]
    pub details: Vec<ErrorDetails>,
    #[serde(rename = "additionalInfo", skip_serializing)]
    pub additional_info: Vec<ErrorAdditionalInfo>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorResponse {
    #[serde(skip_serializing)]
    pub error: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PerfCounterDataSource {
    pub streams: Vec<String>,
    #[serde(rename = "scheduledTransferPeriod")]
    pub scheduled_transfer_period: perf_counter_data_source::ScheduledTransferPeriod,
    #[serde(rename = "samplingFrequencyInSeconds")]
    pub sampling_frequency_in_seconds: i32,
    #[serde(rename = "counterSpecifiers")]
    pub counter_specifiers: Vec<String>,
    pub name: String,
}
pub mod perf_counter_data_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ScheduledTransferPeriod {
        #[serde(rename = "PT1M")]
        Pt1m,
        #[serde(rename = "PT5M")]
        Pt5m,
        #[serde(rename = "PT15M")]
        Pt15m,
        #[serde(rename = "PT30M")]
        Pt30m,
        #[serde(rename = "PT60M")]
        Pt60m,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WindowsEventLogDataSource {
    pub streams: Vec<String>,
    #[serde(rename = "scheduledTransferPeriod")]
    pub scheduled_transfer_period: windows_event_log_data_source::ScheduledTransferPeriod,
    #[serde(rename = "xPathQueries")]
    pub x_path_queries: Vec<String>,
    pub name: String,
}
pub mod windows_event_log_data_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ScheduledTransferPeriod {
        #[serde(rename = "PT1M")]
        Pt1m,
        #[serde(rename = "PT5M")]
        Pt5m,
        #[serde(rename = "PT15M")]
        Pt15m,
        #[serde(rename = "PT30M")]
        Pt30m,
        #[serde(rename = "PT60M")]
        Pt60m,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SyslogDataSource {
    pub streams: Vec<String>,
    #[serde(rename = "facilityNames")]
    pub facility_names: Vec<String>,
    #[serde(rename = "logLevels", skip_serializing_if = "Vec::is_empty")]
    pub log_levels: Vec<String>,
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExtensionDataSource {
    pub streams: Vec<String>,
    #[serde(rename = "extensionName")]
    pub extension_name: String,
    #[serde(rename = "extensionSettings", skip_serializing_if = "Option::is_none")]
    pub extension_settings: Option<serde_json::Value>,
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataSourcesSpec {
    #[serde(rename = "performanceCounters", skip_serializing_if = "Vec::is_empty")]
    pub performance_counters: Vec<PerfCounterDataSource>,
    #[serde(rename = "windowsEventLogs", skip_serializing_if = "Vec::is_empty")]
    pub windows_event_logs: Vec<WindowsEventLogDataSource>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub syslog: Vec<SyslogDataSource>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub extensions: Vec<ExtensionDataSource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LogAnalyticsDestination {
    #[serde(rename = "workspaceResourceId")]
    pub workspace_resource_id: String,
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMonitorMetricsDestination {
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DestinationsSpec {
    #[serde(rename = "logAnalytics", skip_serializing_if = "Vec::is_empty")]
    pub log_analytics: Vec<LogAnalyticsDestination>,
    #[serde(rename = "azureMonitorMetrics", skip_serializing_if = "Option::is_none")]
    pub azure_monitor_metrics: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlow {
    pub streams: Vec<String>,
    pub destinations: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "dataSources", skip_serializing_if = "Option::is_none")]
    pub data_sources: Option<serde_json::Value>,
    pub destinations: serde_json::Value,
    #[serde(rename = "dataFlows")]
    pub data_flows: Vec<DataFlow>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<data_collection_rule::ProvisioningState>,
}
pub mod data_collection_rule {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProvisioningState {
        Creating,
        Updating,
        Deleting,
        Succeeded,
        Failed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleResource {
    pub properties: serde_json::Value,
    pub location: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleResourceListResult {
    pub value: Vec<DataCollectionRuleResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResourceForUpdate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
