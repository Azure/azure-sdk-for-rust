#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleAssociation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "dataCollectionRuleId", skip_serializing_if = "Option::is_none")]
    pub data_collection_rule_id: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<data_collection_rule_association::ProvisioningState>,
}
pub mod data_collection_rule_association {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProvisioningState {
        Creating,
        Updating,
        Deleting,
        Succeeded,
        Failed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleAssociationProxyOnlyResource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<serde_json::Value>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleAssociationProxyOnlyResourceListResult {
    pub value: Vec<DataCollectionRuleAssociationProxyOnlyResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PerfCounterDataSource {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub streams: Vec<String>,
    #[serde(rename = "samplingFrequencyInSeconds", skip_serializing_if = "Option::is_none")]
    pub sampling_frequency_in_seconds: Option<i32>,
    #[serde(rename = "counterSpecifiers", skip_serializing_if = "Vec::is_empty")]
    pub counter_specifiers: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WindowsEventLogDataSource {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub streams: Vec<String>,
    #[serde(rename = "xPathQueries", skip_serializing_if = "Vec::is_empty")]
    pub x_path_queries: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SyslogDataSource {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub streams: Vec<String>,
    #[serde(rename = "facilityNames", skip_serializing_if = "Vec::is_empty")]
    pub facility_names: Vec<String>,
    #[serde(rename = "logLevels", skip_serializing_if = "Vec::is_empty")]
    pub log_levels: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExtensionDataSource {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub streams: Vec<String>,
    #[serde(rename = "extensionName")]
    pub extension_name: String,
    #[serde(rename = "extensionSettings", skip_serializing_if = "Option::is_none")]
    pub extension_settings: Option<serde_json::Value>,
    #[serde(rename = "inputDataSources", skip_serializing_if = "Vec::is_empty")]
    pub input_data_sources: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataSourcesSpec {
    #[serde(rename = "performanceCounters", skip_serializing_if = "Vec::is_empty")]
    pub performance_counters: Vec<PerfCounterDataSource>,
    #[serde(rename = "windowsEventLogs", skip_serializing_if = "Vec::is_empty")]
    pub windows_event_logs: Vec<WindowsEventLogDataSource>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub syslog: Vec<SyslogDataSource>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub extensions: Vec<ExtensionDataSource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LogAnalyticsDestination {
    #[serde(rename = "workspaceResourceId", skip_serializing_if = "Option::is_none")]
    pub workspace_resource_id: Option<String>,
    #[serde(rename = "workspaceId", skip_serializing)]
    pub workspace_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureMonitorMetricsDestination {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DestinationsSpec {
    #[serde(rename = "logAnalytics", skip_serializing_if = "Vec::is_empty")]
    pub log_analytics: Vec<LogAnalyticsDestination>,
    #[serde(rename = "azureMonitorMetrics", skip_serializing_if = "Option::is_none")]
    pub azure_monitor_metrics: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataFlow {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub streams: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub destinations: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "immutableId", skip_serializing)]
    pub immutable_id: Option<String>,
    #[serde(rename = "dataSources", skip_serializing_if = "Option::is_none")]
    pub data_sources: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destinations: Option<serde_json::Value>,
    #[serde(rename = "dataFlows", skip_serializing_if = "Vec::is_empty")]
    pub data_flows: Vec<DataFlow>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<data_collection_rule::ProvisioningState>,
}
pub mod data_collection_rule {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProvisioningState {
        Creating,
        Updating,
        Deleting,
        Succeeded,
        Failed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleResource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<serde_json::Value>,
    pub location: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<data_collection_rule_resource::Kind>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
pub mod data_collection_rule_resource {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Kind {
        Linux,
        Windows,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataCollectionRuleResourceListResult {
    pub value: Vec<DataCollectionRuleResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResourceForUpdate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorDetail {
    #[serde(skip_serializing)]
    pub code: Option<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
    #[serde(skip_serializing)]
    pub target: Option<String>,
    #[serde(skip_serializing)]
    pub details: Vec<ErrorDetail>,
    #[serde(rename = "additionalInfo", skip_serializing)]
    pub additional_info: Vec<ErrorAdditionalInfo>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorAdditionalInfo {
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub info: Option<serde_json::Value>,
}
