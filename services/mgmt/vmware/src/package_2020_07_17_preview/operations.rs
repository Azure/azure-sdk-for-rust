#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use crate::models::*;
use reqwest::StatusCode;
use snafu::{ResultExt, Snafu};
pub mod operations {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(operation_config: &crate::OperationConfig) -> std::result::Result<OperationList, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!("{}/providers/Microsoft.AVS/operations", operation_config.base_path(),);
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: OperationList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod locations {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn check_trial_availability(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        location: &str,
    ) -> std::result::Result<Trial, check_trial_availability::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/providers/Microsoft.AVS/locations/{}/checkTrialAvailability",
            operation_config.base_path(),
            subscription_id,
            location
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(check_trial_availability::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(check_trial_availability::BuildRequestError)?;
        let rsp = client.execute(req).await.context(check_trial_availability::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(check_trial_availability::ResponseBytesError)?;
                let rsp_value: Trial = serde_json::from_slice(&body).context(check_trial_availability::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(check_trial_availability::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(check_trial_availability::DeserializeError { body })?;
                check_trial_availability::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod check_trial_availability {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn check_quota_availability(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        location: &str,
    ) -> std::result::Result<Quota, check_quota_availability::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/providers/Microsoft.AVS/locations/{}/checkQuotaAvailability",
            operation_config.base_path(),
            subscription_id,
            location
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(check_quota_availability::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(check_quota_availability::BuildRequestError)?;
        let rsp = client.execute(req).await.context(check_quota_availability::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(check_quota_availability::ResponseBytesError)?;
                let rsp_value: Quota = serde_json::from_slice(&body).context(check_quota_availability::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(check_quota_availability::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(check_quota_availability::DeserializeError { body })?;
                check_quota_availability::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod check_quota_availability {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod private_clouds {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
    ) -> std::result::Result<PrivateCloudList, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds",
            operation_config.base_path(),
            subscription_id,
            resource_group_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: PrivateCloudList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_in_subscription(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
    ) -> std::result::Result<PrivateCloudList, list_in_subscription::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/providers/Microsoft.AVS/privateClouds",
            operation_config.base_path(),
            subscription_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_in_subscription::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_in_subscription::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_in_subscription::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_in_subscription::ResponseBytesError)?;
                let rsp_value: PrivateCloudList = serde_json::from_slice(&body).context(list_in_subscription::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_in_subscription::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list_in_subscription::DeserializeError { body })?;
                list_in_subscription::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_in_subscription {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<PrivateCloud, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: PrivateCloud = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        private_cloud: &PrivateCloud,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(private_cloud);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: PrivateCloud = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: PrivateCloud = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(PrivateCloud),
            Created201(PrivateCloud),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        private_cloud_update: &PrivateCloudUpdate,
    ) -> std::result::Result<update::Response, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(private_cloud_update);
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: PrivateCloud = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: PrivateCloud = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(PrivateCloud),
            Created201(PrivateCloud),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_admin_credentials(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<AdminCredentials, list_admin_credentials::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/listAdminCredentials",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_admin_credentials::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(list_admin_credentials::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_admin_credentials::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_admin_credentials::ResponseBytesError)?;
                let rsp_value: AdminCredentials =
                    serde_json::from_slice(&body).context(list_admin_credentials::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_admin_credentials::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list_admin_credentials::DeserializeError { body })?;
                list_admin_credentials::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_admin_credentials {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod clusters {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<ClusterList, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/clusters",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ClusterList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        cluster_name: &str,
    ) -> std::result::Result<Cluster, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/clusters/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            cluster_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        cluster_name: &str,
        cluster: &Cluster,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/clusters/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            cluster_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(cluster);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Cluster),
            Created201(Cluster),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        cluster_name: &str,
        cluster_update: &ClusterUpdate,
    ) -> std::result::Result<update::Response, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/clusters/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            cluster_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(cluster_update);
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Cluster = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Cluster),
            Created201(Cluster),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        cluster_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/clusters/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            cluster_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod hcx_enterprise_sites {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<HcxEnterpriseSiteList, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/hcxEnterpriseSites",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: HcxEnterpriseSiteList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        hcx_enterprise_site_name: &str,
    ) -> std::result::Result<HcxEnterpriseSite, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/hcxEnterpriseSites/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            hcx_enterprise_site_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: HcxEnterpriseSite = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        hcx_enterprise_site_name: &str,
        hcx_enterprise_site: &HcxEnterpriseSite,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/hcxEnterpriseSites/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            hcx_enterprise_site_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(hcx_enterprise_site);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: HcxEnterpriseSite = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: HcxEnterpriseSite = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(HcxEnterpriseSite),
            Created201(HcxEnterpriseSite),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        hcx_enterprise_site_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/hcxEnterpriseSites/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            hcx_enterprise_site_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod authorizations {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<ExpressRouteAuthorizationList, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/authorizations",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ExpressRouteAuthorizationList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        authorization_name: &str,
    ) -> std::result::Result<ExpressRouteAuthorization, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/authorizations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            authorization_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: ExpressRouteAuthorization = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        authorization_name: &str,
        authorization: &ExpressRouteAuthorization,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/authorizations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            authorization_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(authorization);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: ExpressRouteAuthorization =
                    serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: ExpressRouteAuthorization =
                    serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(ExpressRouteAuthorization),
            Created201(ExpressRouteAuthorization),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        authorization_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/authorizations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            authorization_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod global_reach_connections {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<GlobalReachConnectionList, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/globalReachConnections",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: GlobalReachConnectionList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        global_reach_connection_name: &str,
    ) -> std::result::Result<GlobalReachConnection, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/globalReachConnections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            global_reach_connection_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: GlobalReachConnection = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        global_reach_connection_name: &str,
        global_reach_connection: &GlobalReachConnection,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/globalReachConnections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            global_reach_connection_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(global_reach_connection);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: GlobalReachConnection =
                    serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: GlobalReachConnection =
                    serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(GlobalReachConnection),
            Created201(GlobalReachConnection),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        global_reach_connection_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/globalReachConnections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            global_reach_connection_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod workload_networks {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_segments(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<WorkloadNetworkSegmentsList, list_segments::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/segments",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_segments::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_segments::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_segments::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_segments::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkSegmentsList =
                    serde_json::from_slice(&body).context(list_segments::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_segments::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list_segments::DeserializeError { body })?;
                list_segments::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_segments {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get_segment(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        segment_id: &str,
    ) -> std::result::Result<WorkloadNetworkSegment, get_segment::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/segments/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            segment_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_segment::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_segment::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_segment::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_segment::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkSegment = serde_json::from_slice(&body).context(get_segment::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_segment::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get_segment::DeserializeError { body })?;
                get_segment::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get_segment {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_segments(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        segment_id: &str,
        workload_network_segment: &WorkloadNetworkSegment,
    ) -> std::result::Result<create_segments::Response, create_segments::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/segments/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            segment_id
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_segments::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(workload_network_segment);
        let req = req_builder.build().context(create_segments::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_segments::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_segments::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkSegment =
                    serde_json::from_slice(&body).context(create_segments::DeserializeError { body })?;
                Ok(create_segments::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_segments::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkSegment =
                    serde_json::from_slice(&body).context(create_segments::DeserializeError { body })?;
                Ok(create_segments::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_segments::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_segments::DeserializeError { body })?;
                create_segments::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_segments {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(WorkloadNetworkSegment),
            Created201(WorkloadNetworkSegment),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn update_segments(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        segment_id: &str,
        workload_network_segment: &WorkloadNetworkSegment,
    ) -> std::result::Result<update_segments::Response, update_segments::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/segments/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            segment_id
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_segments::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(workload_network_segment);
        let req = req_builder.build().context(update_segments::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update_segments::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_segments::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkSegment =
                    serde_json::from_slice(&body).context(update_segments::DeserializeError { body })?;
                Ok(update_segments::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(update_segments::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_segments::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(update_segments::DeserializeError { body })?;
                update_segments::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod update_segments {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(WorkloadNetworkSegment),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete_segment(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        segment_id: &str,
    ) -> std::result::Result<delete_segment::Response, delete_segment::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/segments/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            segment_id
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_segment::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_segment::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_segment::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete_segment::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete_segment::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_segment::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_segment::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete_segment::DeserializeError { body })?;
                delete_segment::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete_segment {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_dhcp(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<WorkloadNetworkDhcpList, list_dhcp::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/dhcpConfigurations",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_dhcp::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_dhcp::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_dhcp::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_dhcp::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkDhcpList = serde_json::from_slice(&body).context(list_dhcp::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_dhcp::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list_dhcp::DeserializeError { body })?;
                list_dhcp::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_dhcp {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get_dhcp(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        dhcp_id: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<WorkloadNetworkDhcp, get_dhcp::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/dhcpConfigurations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            dhcp_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_dhcp::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_dhcp::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_dhcp::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_dhcp::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkDhcp = serde_json::from_slice(&body).context(get_dhcp::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_dhcp::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get_dhcp::DeserializeError { body })?;
                get_dhcp::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get_dhcp {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_dhcp(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        dhcp_id: &str,
        workload_network_dhcp: &WorkloadNetworkDhcp,
    ) -> std::result::Result<create_dhcp::Response, create_dhcp::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/dhcpConfigurations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            dhcp_id
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_dhcp::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(workload_network_dhcp);
        let req = req_builder.build().context(create_dhcp::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_dhcp::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_dhcp::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkDhcp = serde_json::from_slice(&body).context(create_dhcp::DeserializeError { body })?;
                Ok(create_dhcp::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_dhcp::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkDhcp = serde_json::from_slice(&body).context(create_dhcp::DeserializeError { body })?;
                Ok(create_dhcp::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_dhcp::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_dhcp::DeserializeError { body })?;
                create_dhcp::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_dhcp {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(WorkloadNetworkDhcp),
            Created201(WorkloadNetworkDhcp),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn update_dhcp(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        dhcp_id: &str,
        workload_network_dhcp: &WorkloadNetworkDhcp,
    ) -> std::result::Result<update_dhcp::Response, update_dhcp::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/dhcpConfigurations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            dhcp_id
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_dhcp::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(workload_network_dhcp);
        let req = req_builder.build().context(update_dhcp::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update_dhcp::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_dhcp::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkDhcp = serde_json::from_slice(&body).context(update_dhcp::DeserializeError { body })?;
                Ok(update_dhcp::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(update_dhcp::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_dhcp::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(update_dhcp::DeserializeError { body })?;
                update_dhcp::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod update_dhcp {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(WorkloadNetworkDhcp),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete_dhcp(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        dhcp_id: &str,
    ) -> std::result::Result<delete_dhcp::Response, delete_dhcp::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/dhcpConfigurations/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            dhcp_id
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_dhcp::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_dhcp::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_dhcp::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete_dhcp::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete_dhcp::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_dhcp::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_dhcp::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete_dhcp::DeserializeError { body })?;
                delete_dhcp::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete_dhcp {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_gateways(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<WorkloadNetworkGatewayList, list_gateways::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/gateways",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_gateways::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_gateways::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_gateways::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_gateways::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkGatewayList =
                    serde_json::from_slice(&body).context(list_gateways::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_gateways::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list_gateways::DeserializeError { body })?;
                list_gateways::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_gateways {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get_gateway(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        gateway_id: &str,
    ) -> std::result::Result<WorkloadNetworkGateway, get_gateway::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/gateways/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            gateway_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_gateway::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_gateway::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_gateway::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gateway::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkGateway = serde_json::from_slice(&body).context(get_gateway::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gateway::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get_gateway::DeserializeError { body })?;
                get_gateway::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get_gateway {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_port_mirroring(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<WorkloadNetworkPortMirroringList, list_port_mirroring::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/portMirroringProfiles",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_port_mirroring::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_port_mirroring::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_port_mirroring::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_port_mirroring::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkPortMirroringList =
                    serde_json::from_slice(&body).context(list_port_mirroring::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_port_mirroring::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list_port_mirroring::DeserializeError { body })?;
                list_port_mirroring::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_port_mirroring {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get_port_mirroring(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        port_mirroring_id: &str,
    ) -> std::result::Result<WorkloadNetworkPortMirroring, get_port_mirroring::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/portMirroringProfiles/{}" , operation_config . base_path () , subscription_id , resource_group_name , private_cloud_name , port_mirroring_id) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_port_mirroring::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_port_mirroring::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_port_mirroring::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_port_mirroring::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkPortMirroring =
                    serde_json::from_slice(&body).context(get_port_mirroring::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_port_mirroring::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get_port_mirroring::DeserializeError { body })?;
                get_port_mirroring::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get_port_mirroring {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_port_mirroring(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        port_mirroring_id: &str,
        workload_network_port_mirroring: &WorkloadNetworkPortMirroring,
    ) -> std::result::Result<create_port_mirroring::Response, create_port_mirroring::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/portMirroringProfiles/{}" , operation_config . base_path () , subscription_id , resource_group_name , private_cloud_name , port_mirroring_id) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_port_mirroring::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(workload_network_port_mirroring);
        let req = req_builder.build().context(create_port_mirroring::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_port_mirroring::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_port_mirroring::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkPortMirroring =
                    serde_json::from_slice(&body).context(create_port_mirroring::DeserializeError { body })?;
                Ok(create_port_mirroring::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_port_mirroring::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkPortMirroring =
                    serde_json::from_slice(&body).context(create_port_mirroring::DeserializeError { body })?;
                Ok(create_port_mirroring::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_port_mirroring::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_port_mirroring::DeserializeError { body })?;
                create_port_mirroring::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_port_mirroring {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(WorkloadNetworkPortMirroring),
            Created201(WorkloadNetworkPortMirroring),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn update_port_mirroring(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        port_mirroring_id: &str,
        workload_network_port_mirroring: &WorkloadNetworkPortMirroring,
    ) -> std::result::Result<update_port_mirroring::Response, update_port_mirroring::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/portMirroringProfiles/{}" , operation_config . base_path () , subscription_id , resource_group_name , private_cloud_name , port_mirroring_id) ;
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_port_mirroring::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(workload_network_port_mirroring);
        let req = req_builder.build().context(update_port_mirroring::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update_port_mirroring::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_port_mirroring::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkPortMirroring =
                    serde_json::from_slice(&body).context(update_port_mirroring::DeserializeError { body })?;
                Ok(update_port_mirroring::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(update_port_mirroring::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_port_mirroring::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(update_port_mirroring::DeserializeError { body })?;
                update_port_mirroring::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod update_port_mirroring {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(WorkloadNetworkPortMirroring),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete_port_mirroring(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        port_mirroring_id: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<delete_port_mirroring::Response, delete_port_mirroring::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/portMirroringProfiles/{}" , operation_config . base_path () , subscription_id , resource_group_name , private_cloud_name , port_mirroring_id) ;
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_port_mirroring::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_port_mirroring::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_port_mirroring::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete_port_mirroring::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete_port_mirroring::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_port_mirroring::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_port_mirroring::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete_port_mirroring::DeserializeError { body })?;
                delete_port_mirroring::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete_port_mirroring {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_vm_groups(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<WorkloadNetworkVmGroupsList, list_vm_groups::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/vmGroups",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_vm_groups::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_vm_groups::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_vm_groups::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_vm_groups::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkVmGroupsList =
                    serde_json::from_slice(&body).context(list_vm_groups::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_vm_groups::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list_vm_groups::DeserializeError { body })?;
                list_vm_groups::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_vm_groups {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get_vm_group(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        vm_group_id: &str,
    ) -> std::result::Result<WorkloadNetworkVmGroup, get_vm_group::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/vmGroups/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            vm_group_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_vm_group::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_vm_group::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_vm_group::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_vm_group::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkVmGroup = serde_json::from_slice(&body).context(get_vm_group::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_vm_group::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get_vm_group::DeserializeError { body })?;
                get_vm_group::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get_vm_group {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_vm_group(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        vm_group_id: &str,
        workload_network_vm_group: &WorkloadNetworkVmGroup,
    ) -> std::result::Result<create_vm_group::Response, create_vm_group::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/vmGroups/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            vm_group_id
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_vm_group::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(workload_network_vm_group);
        let req = req_builder.build().context(create_vm_group::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_vm_group::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_vm_group::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkVmGroup =
                    serde_json::from_slice(&body).context(create_vm_group::DeserializeError { body })?;
                Ok(create_vm_group::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_vm_group::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkVmGroup =
                    serde_json::from_slice(&body).context(create_vm_group::DeserializeError { body })?;
                Ok(create_vm_group::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_vm_group::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(create_vm_group::DeserializeError { body })?;
                create_vm_group::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_vm_group {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(WorkloadNetworkVmGroup),
            Created201(WorkloadNetworkVmGroup),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn update_vm_group(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        vm_group_id: &str,
        workload_network_vm_group: &WorkloadNetworkVmGroup,
    ) -> std::result::Result<update_vm_group::Response, update_vm_group::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/vmGroups/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            vm_group_id
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_vm_group::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(workload_network_vm_group);
        let req = req_builder.build().context(update_vm_group::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update_vm_group::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_vm_group::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkVmGroup =
                    serde_json::from_slice(&body).context(update_vm_group::DeserializeError { body })?;
                Ok(update_vm_group::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(update_vm_group::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_vm_group::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(update_vm_group::DeserializeError { body })?;
                update_vm_group::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod update_vm_group {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(WorkloadNetworkVmGroup),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete_vm_group(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        vm_group_id: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<delete_vm_group::Response, delete_vm_group::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/vmGroups/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            vm_group_id
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_vm_group::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_vm_group::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_vm_group::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete_vm_group::Response::Ok200),
            StatusCode::ACCEPTED => Ok(delete_vm_group::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_vm_group::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_vm_group::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(delete_vm_group::DeserializeError { body })?;
                delete_vm_group::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete_vm_group {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_virtual_machines(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
    ) -> std::result::Result<WorkloadNetworkVirtualMachinesList, list_virtual_machines::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/virtualMachines",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_virtual_machines::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_virtual_machines::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_virtual_machines::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_virtual_machines::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkVirtualMachinesList =
                    serde_json::from_slice(&body).context(list_virtual_machines::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_virtual_machines::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(list_virtual_machines::DeserializeError { body })?;
                list_virtual_machines::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_virtual_machines {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get_virtual_machine(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        virtual_machine_id: &str,
    ) -> std::result::Result<WorkloadNetworkVirtualMachine, get_virtual_machine::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/workloadNetworks/default/virtualMachines/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            virtual_machine_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_virtual_machine::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_virtual_machine::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_virtual_machine::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_virtual_machine::ResponseBytesError)?;
                let rsp_value: WorkloadNetworkVirtualMachine =
                    serde_json::from_slice(&body).context(get_virtual_machine::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_virtual_machine::ResponseBytesError)?;
                let rsp_value: CloudError = serde_json::from_slice(&body).context(get_virtual_machine::DeserializeError { body })?;
                get_virtual_machine::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get_virtual_machine {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::CloudError,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
