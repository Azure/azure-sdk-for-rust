#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PresentationTimeRange {
    #[serde(rename = "startTimestamp", skip_serializing_if = "Option::is_none")]
    pub start_timestamp: Option<i64>,
    #[serde(rename = "endTimestamp", skip_serializing_if = "Option::is_none")]
    pub end_timestamp: Option<i64>,
    #[serde(rename = "presentationWindowDuration", skip_serializing_if = "Option::is_none")]
    pub presentation_window_duration: Option<i64>,
    #[serde(rename = "liveBackoffDuration", skip_serializing_if = "Option::is_none")]
    pub live_backoff_duration: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timescale: Option<i64>,
    #[serde(rename = "forceEndTimestamp", skip_serializing_if = "Option::is_none")]
    pub force_end_timestamp: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FilterTrackPropertyCondition {
    pub property: filter_track_property_condition::Property,
    pub value: String,
    pub operation: filter_track_property_condition::Operation,
}
pub mod filter_track_property_condition {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Property {
        Unknown,
        Type,
        Name,
        Language,
        #[serde(rename = "FourCC")]
        FourCc,
        Bitrate,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Operation {
        Equal,
        NotEqual,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirstQuality {
    pub bitrate: i32,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FilterTrackSelection {
    #[serde(rename = "trackSelections")]
    pub track_selections: Vec<FilterTrackPropertyCondition>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MediaFilterProperties {
    #[serde(rename = "presentationTimeRange", skip_serializing_if = "Option::is_none")]
    pub presentation_time_range: Option<PresentationTimeRange>,
    #[serde(rename = "firstQuality", skip_serializing_if = "Option::is_none")]
    pub first_quality: Option<FirstQuality>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub tracks: Vec<FilterTrackSelection>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AccountFilter {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<MediaFilterProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ODataError {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<ODataError>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApiError {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ODataError>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AccountFilterCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AccountFilter>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Resource {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrackedResource {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ProxyResource {
    #[serde(flatten)]
    pub resource: Resource,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Provider {
    #[serde(rename = "providerName")]
    pub provider_name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationDisplay {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricDimension {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing)]
    pub display_name: Option<String>,
    #[serde(rename = "toBeExportedForShoebox", skip_serializing)]
    pub to_be_exported_for_shoebox: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Metric {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing)]
    pub display_name: Option<String>,
    #[serde(rename = "displayDescription", skip_serializing)]
    pub display_description: Option<String>,
    #[serde(skip_serializing)]
    pub unit: Option<metric::Unit>,
    #[serde(rename = "aggregationType", skip_serializing)]
    pub aggregation_type: Option<metric::AggregationType>,
    #[serde(skip_serializing)]
    pub dimensions: Vec<MetricDimension>,
}
pub mod metric {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Unit {
        Bytes,
        Count,
        Milliseconds,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AggregationType {
        Average,
        Count,
        Total,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceSpecification {
    #[serde(rename = "metricSpecifications", skip_serializing)]
    pub metric_specifications: Vec<Metric>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricProperties {
    #[serde(rename = "serviceSpecification", skip_serializing_if = "Option::is_none")]
    pub service_specification: Option<ServiceSpecification>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Operation {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display: Option<OperationDisplay>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<MetricProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Location {
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EntityNameAvailabilityCheckOutput {
    #[serde(rename = "nameAvailable")]
    pub name_available: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StorageAccount {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub type_: storage_account::Type,
}
pub mod storage_account {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Primary,
        Secondary,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SyncStorageKeysInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MediaServiceProperties {
    #[serde(rename = "mediaServiceId", skip_serializing)]
    pub media_service_id: Option<String>,
    #[serde(rename = "storageAccounts", skip_serializing_if = "Vec::is_empty")]
    pub storage_accounts: Vec<StorageAccount>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MediaService {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<MediaServiceProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListEdgePoliciesInput {
    #[serde(rename = "deviceId", skip_serializing_if = "Option::is_none")]
    pub device_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EdgeUsageDataEventHub {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EdgeUsageDataCollectionPolicy {
    #[serde(rename = "dataCollectionFrequency", skip_serializing_if = "Option::is_none")]
    pub data_collection_frequency: Option<String>,
    #[serde(rename = "dataReportingFrequency", skip_serializing_if = "Option::is_none")]
    pub data_reporting_frequency: Option<String>,
    #[serde(rename = "maxAllowedUnreportedUsageDuration", skip_serializing_if = "Option::is_none")]
    pub max_allowed_unreported_usage_duration: Option<String>,
    #[serde(rename = "eventHubDetails", skip_serializing_if = "Option::is_none")]
    pub event_hub_details: Option<EdgeUsageDataEventHub>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EdgePolicies {
    #[serde(rename = "usageDataCollectionPolicy", skip_serializing_if = "Option::is_none")]
    pub usage_data_collection_policy: Option<EdgeUsageDataCollectionPolicy>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubscriptionMediaService {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<MediaServiceProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Operation>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MediaServiceCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<MediaService>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CheckNameAvailabilityInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubscriptionMediaServiceCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<SubscriptionMediaService>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AssetProperties {
    #[serde(rename = "assetId", skip_serializing)]
    pub asset_id: Option<String>,
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(rename = "lastModified", skip_serializing)]
    pub last_modified: Option<String>,
    #[serde(rename = "alternateId", skip_serializing_if = "Option::is_none")]
    pub alternate_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    #[serde(rename = "storageAccountName", skip_serializing_if = "Option::is_none")]
    pub storage_account_name: Option<String>,
    #[serde(rename = "storageEncryptionFormat", skip_serializing)]
    pub storage_encryption_format: Option<asset_properties::StorageEncryptionFormat>,
}
pub mod asset_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StorageEncryptionFormat {
        None,
        MediaStorageClientEncryption,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AssetContainerSas {
    #[serde(rename = "assetContainerSasUrls", skip_serializing_if = "Vec::is_empty")]
    pub asset_container_sas_urls: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AssetFileEncryptionMetadata {
    #[serde(rename = "initializationVector", skip_serializing_if = "Option::is_none")]
    pub initialization_vector: Option<String>,
    #[serde(rename = "assetFileName", skip_serializing_if = "Option::is_none")]
    pub asset_file_name: Option<String>,
    #[serde(rename = "assetFileId")]
    pub asset_file_id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StorageEncryptedAssetDecryptionData {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(rename = "assetFileEncryptionMetadata", skip_serializing_if = "Vec::is_empty")]
    pub asset_file_encryption_metadata: Vec<AssetFileEncryptionMetadata>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListStreamingLocatorsResponse {
    #[serde(rename = "streamingLocators", skip_serializing)]
    pub streaming_locators: Vec<AssetStreamingLocator>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AssetStreamingLocator {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "assetName", skip_serializing)]
    pub asset_name: Option<String>,
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing)]
    pub end_time: Option<String>,
    #[serde(rename = "streamingLocatorId", skip_serializing)]
    pub streaming_locator_id: Option<String>,
    #[serde(rename = "streamingPolicyName", skip_serializing)]
    pub streaming_policy_name: Option<String>,
    #[serde(rename = "defaultContentKeyPolicyName", skip_serializing)]
    pub default_content_key_policy_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Asset {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AssetProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AssetFilter {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<MediaFilterProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AssetCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Asset>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListContainerSasInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub permissions: Option<list_container_sas_input::Permissions>,
    #[serde(rename = "expiryTime", skip_serializing_if = "Option::is_none")]
    pub expiry_time: Option<String>,
}
pub mod list_container_sas_input {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Permissions {
        Read,
        ReadWrite,
        ReadWriteDelete,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AssetFilterCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AssetFilter>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
    #[serde(rename = "bestEffort")]
    pub best_effort: bool,
    #[serde(rename = "configurationData")]
    pub configuration_data: i32,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyContentKeyLocation {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader {
    #[serde(flatten)]
    pub content_key_policy_play_ready_content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier {
    #[serde(flatten)]
    pub content_key_policy_play_ready_content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation,
    #[serde(rename = "keyId")]
    pub key_id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyPlayRight {
    #[serde(rename = "firstPlayExpiration", skip_serializing_if = "Option::is_none")]
    pub first_play_expiration: Option<String>,
    #[serde(rename = "scmsRestriction", skip_serializing_if = "Option::is_none")]
    pub scms_restriction: Option<i32>,
    #[serde(rename = "agcAndColorStripeRestriction", skip_serializing_if = "Option::is_none")]
    pub agc_and_color_stripe_restriction: Option<i32>,
    #[serde(rename = "explicitAnalogTelevisionOutputRestriction", skip_serializing_if = "Option::is_none")]
    pub explicit_analog_television_output_restriction: Option<ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction>,
    #[serde(rename = "digitalVideoOnlyContentRestriction")]
    pub digital_video_only_content_restriction: bool,
    #[serde(rename = "imageConstraintForAnalogComponentVideoRestriction")]
    pub image_constraint_for_analog_component_video_restriction: bool,
    #[serde(rename = "imageConstraintForAnalogComputerMonitorRestriction")]
    pub image_constraint_for_analog_computer_monitor_restriction: bool,
    #[serde(rename = "allowPassingVideoContentToUnknownOutput")]
    pub allow_passing_video_content_to_unknown_output: content_key_policy_play_ready_play_right::AllowPassingVideoContentToUnknownOutput,
    #[serde(rename = "uncompressedDigitalVideoOpl", skip_serializing_if = "Option::is_none")]
    pub uncompressed_digital_video_opl: Option<i32>,
    #[serde(rename = "compressedDigitalVideoOpl", skip_serializing_if = "Option::is_none")]
    pub compressed_digital_video_opl: Option<i32>,
    #[serde(rename = "analogVideoOpl", skip_serializing_if = "Option::is_none")]
    pub analog_video_opl: Option<i32>,
    #[serde(rename = "compressedDigitalAudioOpl", skip_serializing_if = "Option::is_none")]
    pub compressed_digital_audio_opl: Option<i32>,
    #[serde(rename = "uncompressedDigitalAudioOpl", skip_serializing_if = "Option::is_none")]
    pub uncompressed_digital_audio_opl: Option<i32>,
}
pub mod content_key_policy_play_ready_play_right {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AllowPassingVideoContentToUnknownOutput {
        Unknown,
        NotAllowed,
        Allowed,
        AllowedWithVideoConstriction,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyTokenClaim {
    #[serde(rename = "claimType", skip_serializing_if = "Option::is_none")]
    pub claim_type: Option<String>,
    #[serde(rename = "claimValue", skip_serializing_if = "Option::is_none")]
    pub claim_value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyLicense {
    #[serde(rename = "allowTestDevices")]
    pub allow_test_devices: bool,
    #[serde(rename = "beginDate", skip_serializing_if = "Option::is_none")]
    pub begin_date: Option<String>,
    #[serde(rename = "expirationDate", skip_serializing_if = "Option::is_none")]
    pub expiration_date: Option<String>,
    #[serde(rename = "relativeBeginDate", skip_serializing_if = "Option::is_none")]
    pub relative_begin_date: Option<String>,
    #[serde(rename = "relativeExpirationDate", skip_serializing_if = "Option::is_none")]
    pub relative_expiration_date: Option<String>,
    #[serde(rename = "gracePeriod", skip_serializing_if = "Option::is_none")]
    pub grace_period: Option<String>,
    #[serde(rename = "playRight", skip_serializing_if = "Option::is_none")]
    pub play_right: Option<ContentKeyPolicyPlayReadyPlayRight>,
    #[serde(rename = "licenseType")]
    pub license_type: content_key_policy_play_ready_license::LicenseType,
    #[serde(rename = "contentKeyLocation")]
    pub content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation,
    #[serde(rename = "contentType")]
    pub content_type: content_key_policy_play_ready_license::ContentType,
}
pub mod content_key_policy_play_ready_license {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LicenseType {
        Unknown,
        NonPersistent,
        Persistent,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ContentType {
        Unknown,
        Unspecified,
        UltraVioletDownload,
        UltraVioletStreaming,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyRestriction {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyOpenRestriction {
    #[serde(flatten)]
    pub content_key_policy_restriction: ContentKeyPolicyRestriction,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyUnknownRestriction {
    #[serde(flatten)]
    pub content_key_policy_restriction: ContentKeyPolicyRestriction,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyConfiguration {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyRestrictionTokenKey {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicySymmetricTokenKey {
    #[serde(flatten)]
    pub content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey,
    #[serde(rename = "keyValue")]
    pub key_value: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyRsaTokenKey {
    #[serde(flatten)]
    pub content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey,
    pub exponent: String,
    pub modulus: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyX509CertificateTokenKey {
    #[serde(flatten)]
    pub content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey,
    #[serde(rename = "rawBody")]
    pub raw_body: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyTokenRestriction {
    #[serde(flatten)]
    pub content_key_policy_restriction: ContentKeyPolicyRestriction,
    pub issuer: String,
    pub audience: String,
    #[serde(rename = "primaryVerificationKey")]
    pub primary_verification_key: ContentKeyPolicyRestrictionTokenKey,
    #[serde(rename = "alternateVerificationKeys", skip_serializing_if = "Vec::is_empty")]
    pub alternate_verification_keys: Vec<ContentKeyPolicyRestrictionTokenKey>,
    #[serde(rename = "requiredClaims", skip_serializing_if = "Vec::is_empty")]
    pub required_claims: Vec<ContentKeyPolicyTokenClaim>,
    #[serde(rename = "restrictionTokenType")]
    pub restriction_token_type: content_key_policy_token_restriction::RestrictionTokenType,
    #[serde(rename = "openIdConnectDiscoveryDocument", skip_serializing_if = "Option::is_none")]
    pub open_id_connect_discovery_document: Option<String>,
}
pub mod content_key_policy_token_restriction {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RestrictionTokenType {
        Unknown,
        Swt,
        Jwt,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyClearKeyConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyUnknownConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyWidevineConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
    #[serde(rename = "widevineTemplate")]
    pub widevine_template: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
    pub licenses: Vec<ContentKeyPolicyPlayReadyLicense>,
    #[serde(rename = "responseCustomData", skip_serializing_if = "Option::is_none")]
    pub response_custom_data: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyFairPlayOfflineRentalConfiguration {
    #[serde(rename = "playbackDurationSeconds")]
    pub playback_duration_seconds: i64,
    #[serde(rename = "storageDurationSeconds")]
    pub storage_duration_seconds: i64,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyFairPlayConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
    pub ask: String,
    #[serde(rename = "fairPlayPfxPassword")]
    pub fair_play_pfx_password: String,
    #[serde(rename = "fairPlayPfx")]
    pub fair_play_pfx: String,
    #[serde(rename = "rentalAndLeaseKeyType")]
    pub rental_and_lease_key_type: content_key_policy_fair_play_configuration::RentalAndLeaseKeyType,
    #[serde(rename = "rentalDuration")]
    pub rental_duration: i64,
    #[serde(rename = "offlineRentalConfiguration", skip_serializing_if = "Option::is_none")]
    pub offline_rental_configuration: Option<ContentKeyPolicyFairPlayOfflineRentalConfiguration>,
}
pub mod content_key_policy_fair_play_configuration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RentalAndLeaseKeyType {
        Unknown,
        Undefined,
        DualExpiry,
        PersistentUnlimited,
        PersistentLimited,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyOption {
    #[serde(rename = "policyOptionId", skip_serializing)]
    pub policy_option_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub configuration: ContentKeyPolicyConfiguration,
    pub restriction: ContentKeyPolicyRestriction,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyProperties {
    #[serde(rename = "policyId", skip_serializing)]
    pub policy_id: Option<String>,
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(rename = "lastModified", skip_serializing)]
    pub last_modified: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub options: Vec<ContentKeyPolicyOption>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ContentKeyPolicyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ContentKeyPolicy>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Preset {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Codec {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Audio {
    #[serde(flatten)]
    pub codec: Codec,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channels: Option<i32>,
    #[serde(rename = "samplingRate", skip_serializing_if = "Option::is_none")]
    pub sampling_rate: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bitrate: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AacAudio {
    #[serde(flatten)]
    pub audio: Audio,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub profile: Option<aac_audio::Profile>,
}
pub mod aac_audio {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Profile {
        AacLc,
        HeAacV1,
        HeAacV2,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FaceDetectorPreset {
    #[serde(flatten)]
    pub preset: Preset,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolution: Option<face_detector_preset::Resolution>,
    #[serde(rename = "experimentalOptions", skip_serializing_if = "Option::is_none")]
    pub experimental_options: Option<serde_json::Value>,
}
pub mod face_detector_preset {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Resolution {
        SourceResolution,
        StandardDefinition,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AudioAnalyzerPreset {
    #[serde(flatten)]
    pub preset: Preset,
    #[serde(rename = "audioLanguage", skip_serializing_if = "Option::is_none")]
    pub audio_language: Option<String>,
    #[serde(rename = "experimentalOptions", skip_serializing_if = "Option::is_none")]
    pub experimental_options: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Overlay {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(rename = "inputLabel")]
    pub input_label: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,
    #[serde(rename = "fadeInDuration", skip_serializing_if = "Option::is_none")]
    pub fade_in_duration: Option<String>,
    #[serde(rename = "fadeOutDuration", skip_serializing_if = "Option::is_none")]
    pub fade_out_duration: Option<String>,
    #[serde(rename = "audioGainLevel", skip_serializing_if = "Option::is_none")]
    pub audio_gain_level: Option<f64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AudioOverlay {
    #[serde(flatten)]
    pub overlay: Overlay,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopyVideo {
    #[serde(flatten)]
    pub codec: Codec,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Video {
    #[serde(flatten)]
    pub codec: Codec,
    #[serde(rename = "keyFrameInterval", skip_serializing_if = "Option::is_none")]
    pub key_frame_interval: Option<String>,
    #[serde(rename = "stretchMode", skip_serializing_if = "Option::is_none")]
    pub stretch_mode: Option<video::StretchMode>,
}
pub mod video {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StretchMode {
        None,
        AutoSize,
        AutoFit,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Image {
    #[serde(flatten)]
    pub video: Video,
    pub start: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub step: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Format {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(rename = "filenamePattern")]
    pub filename_pattern: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageFormat {
    #[serde(flatten)]
    pub format: Format,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JpgFormat {
    #[serde(flatten)]
    pub image_format: ImageFormat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PngFormat {
    #[serde(flatten)]
    pub image_format: ImageFormat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopyAudio {
    #[serde(flatten)]
    pub codec: Codec,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Deinterlace {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parity: Option<deinterlace::Parity>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<deinterlace::Mode>,
}
pub mod deinterlace {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Parity {
        Auto,
        TopFieldFirst,
        BottomFieldFirst,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Mode {
        Off,
        AutoPixelAdaptive,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Rectangle {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub left: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Filters {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deinterlace: Option<Deinterlace>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rotation: Option<filters::Rotation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub crop: Option<Rectangle>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub overlays: Vec<Overlay>,
}
pub mod filters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Rotation {
        Auto,
        None,
        Rotate0,
        Rotate90,
        Rotate180,
        Rotate270,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Layer {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoLayer {
    #[serde(flatten)]
    pub layer: Layer,
    pub bitrate: i32,
    #[serde(rename = "maxBitrate", skip_serializing_if = "Option::is_none")]
    pub max_bitrate: Option<i32>,
    #[serde(rename = "bFrames", skip_serializing_if = "Option::is_none")]
    pub b_frames: Option<i32>,
    #[serde(rename = "frameRate", skip_serializing_if = "Option::is_none")]
    pub frame_rate: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub slices: Option<i32>,
    #[serde(rename = "adaptiveBFrame", skip_serializing_if = "Option::is_none")]
    pub adaptive_b_frame: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct H264Layer {
    #[serde(flatten)]
    pub video_layer: VideoLayer,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub profile: Option<h264_layer::Profile>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(rename = "bufferWindow", skip_serializing_if = "Option::is_none")]
    pub buffer_window: Option<String>,
    #[serde(rename = "referenceFrames", skip_serializing_if = "Option::is_none")]
    pub reference_frames: Option<i32>,
    #[serde(rename = "entropyMode", skip_serializing_if = "Option::is_none")]
    pub entropy_mode: Option<h264_layer::EntropyMode>,
}
pub mod h264_layer {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Profile {
        Auto,
        Baseline,
        Main,
        High,
        High422,
        High444,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EntropyMode {
        Cabac,
        Cavlc,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct H264Video {
    #[serde(flatten)]
    pub video: Video,
    #[serde(rename = "sceneChangeDetection", skip_serializing_if = "Option::is_none")]
    pub scene_change_detection: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub complexity: Option<h264_video::Complexity>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub layers: Vec<H264Layer>,
}
pub mod h264_video {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Complexity {
        Speed,
        Balanced,
        Quality,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JpgImage {
    #[serde(flatten)]
    pub image: Image,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub layers: Vec<JpgLayer>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JpgLayer {
    #[serde(flatten)]
    pub layer: Layer,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quality: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MultiBitrateFormat {
    #[serde(flatten)]
    pub format: Format,
    #[serde(rename = "outputFiles", skip_serializing_if = "Vec::is_empty")]
    pub output_files: Vec<OutputFile>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OutputFile {
    pub labels: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Mp4Format {
    #[serde(flatten)]
    pub multi_bitrate_format: MultiBitrateFormat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PngImage {
    #[serde(flatten)]
    pub image: Image,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub layers: Vec<PngLayer>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PngLayer {
    #[serde(flatten)]
    pub layer: Layer,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BuiltInStandardEncoderPreset {
    #[serde(flatten)]
    pub preset: Preset,
    #[serde(rename = "presetName")]
    pub preset_name: built_in_standard_encoder_preset::PresetName,
}
pub mod built_in_standard_encoder_preset {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PresetName {
        #[serde(rename = "H264SingleBitrateSD")]
        H264SingleBitrateSd,
        H264SingleBitrate720p,
        H264SingleBitrate1080p,
        AdaptiveStreaming,
        #[serde(rename = "AACGoodQualityAudio")]
        AacGoodQualityAudio,
        ContentAwareEncodingExperimental,
        ContentAwareEncoding,
        H264MultipleBitrate1080p,
        H264MultipleBitrate720p,
        #[serde(rename = "H264MultipleBitrateSD")]
        H264MultipleBitrateSd,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StandardEncoderPreset {
    #[serde(flatten)]
    pub preset: Preset,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filters: Option<Filters>,
    pub codecs: Vec<Codec>,
    pub formats: Vec<Format>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoAnalyzerPreset {
    #[serde(flatten)]
    pub audio_analyzer_preset: AudioAnalyzerPreset,
    #[serde(rename = "insightsToExtract", skip_serializing_if = "Option::is_none")]
    pub insights_to_extract: Option<video_analyzer_preset::InsightsToExtract>,
}
pub mod video_analyzer_preset {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum InsightsToExtract {
        AudioInsightsOnly,
        VideoInsightsOnly,
        AllInsights,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransportStreamFormat {
    #[serde(flatten)]
    pub multi_bitrate_format: MultiBitrateFormat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoOverlay {
    #[serde(flatten)]
    pub overlay: Overlay,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<Rectangle>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub opacity: Option<f64>,
    #[serde(rename = "cropRectangle", skip_serializing_if = "Option::is_none")]
    pub crop_rectangle: Option<Rectangle>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransformOutput {
    #[serde(rename = "onError", skip_serializing_if = "Option::is_none")]
    pub on_error: Option<transform_output::OnError>,
    #[serde(rename = "relativePriority", skip_serializing_if = "Option::is_none")]
    pub relative_priority: Option<transform_output::RelativePriority>,
    pub preset: Preset,
}
pub mod transform_output {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OnError {
        StopProcessingJob,
        ContinueJob,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RelativePriority {
        Low,
        Normal,
        High,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransformProperties {
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "lastModified", skip_serializing)]
    pub last_modified: Option<String>,
    pub outputs: Vec<TransformOutput>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Transform {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<TransformProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInput {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInputClip {
    #[serde(flatten)]
    pub job_input: JobInput,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub files: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<ClipTime>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<ClipTime>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ClipTime {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AbsoluteClipTime {
    #[serde(flatten)]
    pub clip_time: ClipTime,
    pub time: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInputs {
    #[serde(flatten)]
    pub job_input: JobInput,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub inputs: Vec<JobInput>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInputAsset {
    #[serde(flatten)]
    pub job_input_clip: JobInputClip,
    #[serde(rename = "assetName")]
    pub asset_name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInputHttp {
    #[serde(flatten)]
    pub job_input_clip: JobInputClip,
    #[serde(rename = "baseUri", skip_serializing_if = "Option::is_none")]
    pub base_uri: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobOutput {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<JobError>,
    #[serde(skip_serializing)]
    pub state: Option<job_output::State>,
    #[serde(skip_serializing)]
    pub progress: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing)]
    pub end_time: Option<String>,
}
pub mod job_output {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Canceled,
        Canceling,
        Error,
        Finished,
        Processing,
        Queued,
        Scheduled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobError {
    #[serde(skip_serializing)]
    pub code: Option<job_error::Code>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
    #[serde(skip_serializing)]
    pub category: Option<job_error::Category>,
    #[serde(skip_serializing)]
    pub retry: Option<job_error::Retry>,
    #[serde(skip_serializing)]
    pub details: Vec<JobErrorDetail>,
}
pub mod job_error {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Code {
        ServiceError,
        ServiceTransientError,
        DownloadNotAccessible,
        DownloadTransientError,
        UploadNotAccessible,
        UploadTransientError,
        ConfigurationUnsupported,
        ContentMalformed,
        ContentUnsupported,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Category {
        Service,
        Download,
        Upload,
        Configuration,
        Content,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Retry {
        DoNotRetry,
        MayRetry,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobOutputAsset {
    #[serde(flatten)]
    pub job_output: JobOutput,
    #[serde(rename = "assetName")]
    pub asset_name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobErrorDetail {
    #[serde(skip_serializing)]
    pub code: Option<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobProperties {
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(skip_serializing)]
    pub state: Option<job_properties::State>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub input: JobInput,
    #[serde(rename = "lastModified", skip_serializing)]
    pub last_modified: Option<String>,
    pub outputs: Vec<JobOutput>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<job_properties::Priority>,
    #[serde(rename = "correlationData", skip_serializing_if = "Option::is_none")]
    pub correlation_data: Option<serde_json::Value>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing)]
    pub end_time: Option<String>,
}
pub mod job_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Canceled,
        Canceling,
        Error,
        Finished,
        Processing,
        Queued,
        Scheduled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Priority {
        Low,
        Normal,
        High,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Job {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<JobProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransformCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Transform>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Job>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrackPropertyCondition {
    pub property: track_property_condition::Property,
    pub operation: track_property_condition::Operation,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
pub mod track_property_condition {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Property {
        Unknown,
        #[serde(rename = "FourCC")]
        FourCc,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Operation {
        Unknown,
        Equal,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrackSelection {
    #[serde(rename = "trackSelections", skip_serializing_if = "Vec::is_empty")]
    pub track_selections: Vec<TrackPropertyCondition>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DefaultKey {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "policyName", skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicyContentKey {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "policyName", skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub tracks: Vec<TrackSelection>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicyContentKeys {
    #[serde(rename = "defaultKey", skip_serializing_if = "Option::is_none")]
    pub default_key: Option<DefaultKey>,
    #[serde(rename = "keyToTrackMappings", skip_serializing_if = "Vec::is_empty")]
    pub key_to_track_mappings: Vec<StreamingPolicyContentKey>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicyPlayReadyConfiguration {
    #[serde(rename = "customLicenseAcquisitionUrlTemplate", skip_serializing_if = "Option::is_none")]
    pub custom_license_acquisition_url_template: Option<String>,
    #[serde(rename = "playReadyCustomAttributes", skip_serializing_if = "Option::is_none")]
    pub play_ready_custom_attributes: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicyWidevineConfiguration {
    #[serde(rename = "customLicenseAcquisitionUrlTemplate", skip_serializing_if = "Option::is_none")]
    pub custom_license_acquisition_url_template: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicyFairPlayConfiguration {
    #[serde(rename = "customLicenseAcquisitionUrlTemplate", skip_serializing_if = "Option::is_none")]
    pub custom_license_acquisition_url_template: Option<String>,
    #[serde(rename = "allowPersistentLicense")]
    pub allow_persistent_license: bool,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CbcsDrmConfiguration {
    #[serde(rename = "fairPlay", skip_serializing_if = "Option::is_none")]
    pub fair_play: Option<StreamingPolicyFairPlayConfiguration>,
    #[serde(rename = "playReady", skip_serializing_if = "Option::is_none")]
    pub play_ready: Option<StreamingPolicyPlayReadyConfiguration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub widevine: Option<StreamingPolicyWidevineConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CencDrmConfiguration {
    #[serde(rename = "playReady", skip_serializing_if = "Option::is_none")]
    pub play_ready: Option<StreamingPolicyPlayReadyConfiguration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub widevine: Option<StreamingPolicyWidevineConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EnabledProtocols {
    pub download: bool,
    pub dash: bool,
    pub hls: bool,
    #[serde(rename = "smoothStreaming")]
    pub smooth_streaming: bool,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NoEncryption {
    #[serde(rename = "enabledProtocols", skip_serializing_if = "Option::is_none")]
    pub enabled_protocols: Option<EnabledProtocols>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EnvelopeEncryption {
    #[serde(rename = "enabledProtocols", skip_serializing_if = "Option::is_none")]
    pub enabled_protocols: Option<EnabledProtocols>,
    #[serde(rename = "clearTracks", skip_serializing_if = "Vec::is_empty")]
    pub clear_tracks: Vec<TrackSelection>,
    #[serde(rename = "contentKeys", skip_serializing_if = "Option::is_none")]
    pub content_keys: Option<StreamingPolicyContentKeys>,
    #[serde(rename = "customKeyAcquisitionUrlTemplate", skip_serializing_if = "Option::is_none")]
    pub custom_key_acquisition_url_template: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommonEncryptionCenc {
    #[serde(rename = "enabledProtocols", skip_serializing_if = "Option::is_none")]
    pub enabled_protocols: Option<EnabledProtocols>,
    #[serde(rename = "clearTracks", skip_serializing_if = "Vec::is_empty")]
    pub clear_tracks: Vec<TrackSelection>,
    #[serde(rename = "contentKeys", skip_serializing_if = "Option::is_none")]
    pub content_keys: Option<StreamingPolicyContentKeys>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub drm: Option<CencDrmConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommonEncryptionCbcs {
    #[serde(rename = "enabledProtocols", skip_serializing_if = "Option::is_none")]
    pub enabled_protocols: Option<EnabledProtocols>,
    #[serde(rename = "clearTracks", skip_serializing_if = "Vec::is_empty")]
    pub clear_tracks: Vec<TrackSelection>,
    #[serde(rename = "contentKeys", skip_serializing_if = "Option::is_none")]
    pub content_keys: Option<StreamingPolicyContentKeys>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub drm: Option<CbcsDrmConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicyProperties {
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(rename = "defaultContentKeyPolicyName", skip_serializing_if = "Option::is_none")]
    pub default_content_key_policy_name: Option<String>,
    #[serde(rename = "envelopeEncryption", skip_serializing_if = "Option::is_none")]
    pub envelope_encryption: Option<EnvelopeEncryption>,
    #[serde(rename = "commonEncryptionCenc", skip_serializing_if = "Option::is_none")]
    pub common_encryption_cenc: Option<CommonEncryptionCenc>,
    #[serde(rename = "commonEncryptionCbcs", skip_serializing_if = "Option::is_none")]
    pub common_encryption_cbcs: Option<CommonEncryptionCbcs>,
    #[serde(rename = "noEncryption", skip_serializing_if = "Option::is_none")]
    pub no_encryption: Option<NoEncryption>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<StreamingPolicyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingLocatorContentKey {
    pub id: String,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<streaming_locator_content_key::Type>,
    #[serde(rename = "labelReferenceInStreamingPolicy", skip_serializing_if = "Option::is_none")]
    pub label_reference_in_streaming_policy: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(rename = "policyName", skip_serializing)]
    pub policy_name: Option<String>,
    #[serde(skip_serializing)]
    pub tracks: Vec<TrackSelection>,
}
pub mod streaming_locator_content_key {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        CommonEncryptionCenc,
        CommonEncryptionCbcs,
        EnvelopeEncryption,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPath {
    #[serde(rename = "streamingProtocol")]
    pub streaming_protocol: streaming_path::StreamingProtocol,
    #[serde(rename = "encryptionScheme")]
    pub encryption_scheme: streaming_path::EncryptionScheme,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub paths: Vec<String>,
}
pub mod streaming_path {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StreamingProtocol {
        Hls,
        Dash,
        SmoothStreaming,
        Download,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EncryptionScheme {
        NoEncryption,
        EnvelopeEncryption,
        CommonEncryptionCenc,
        CommonEncryptionCbcs,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingLocatorProperties {
    #[serde(rename = "assetName")]
    pub asset_name: String,
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "streamingLocatorId", skip_serializing_if = "Option::is_none")]
    pub streaming_locator_id: Option<String>,
    #[serde(rename = "streamingPolicyName")]
    pub streaming_policy_name: String,
    #[serde(rename = "defaultContentKeyPolicyName", skip_serializing_if = "Option::is_none")]
    pub default_content_key_policy_name: Option<String>,
    #[serde(rename = "contentKeys", skip_serializing_if = "Vec::is_empty")]
    pub content_keys: Vec<StreamingLocatorContentKey>,
    #[serde(rename = "alternativeMediaId", skip_serializing_if = "Option::is_none")]
    pub alternative_media_id: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub filters: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListContentKeysResponse {
    #[serde(rename = "contentKeys", skip_serializing_if = "Vec::is_empty")]
    pub content_keys: Vec<StreamingLocatorContentKey>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListPathsResponse {
    #[serde(rename = "streamingPaths", skip_serializing_if = "Vec::is_empty")]
    pub streaming_paths: Vec<StreamingPath>,
    #[serde(rename = "downloadPaths", skip_serializing_if = "Vec::is_empty")]
    pub download_paths: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingLocator {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<StreamingLocatorProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicyCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<StreamingPolicy>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingLocatorCollection {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<StreamingLocator>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Hls {
    #[serde(rename = "fragmentsPerTsSegment", skip_serializing_if = "Option::is_none")]
    pub fragments_per_ts_segment: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveOutputProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "assetName")]
    pub asset_name: String,
    #[serde(rename = "archiveWindowLength")]
    pub archive_window_length: String,
    #[serde(rename = "manifestName", skip_serializing_if = "Option::is_none")]
    pub manifest_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hls: Option<Hls>,
    #[serde(rename = "outputSnapTime", skip_serializing_if = "Option::is_none")]
    pub output_snap_time: Option<i64>,
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(rename = "lastModified", skip_serializing)]
    pub last_modified: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
    #[serde(rename = "resourceState", skip_serializing)]
    pub resource_state: Option<live_output_properties::ResourceState>,
}
pub mod live_output_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ResourceState {
        Creating,
        Running,
        Deleting,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveOutput {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<LiveOutputProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveOutputListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LiveOutput>,
    #[serde(rename = "@odata.count", skip_serializing_if = "Option::is_none")]
    pub odata_count: Option<i32>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventEndpoint {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventInputAccessControl {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip: Option<IpAccessControl>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventInput {
    #[serde(rename = "streamingProtocol")]
    pub streaming_protocol: live_event_input::StreamingProtocol,
    #[serde(rename = "accessControl", skip_serializing_if = "Option::is_none")]
    pub access_control: Option<LiveEventInputAccessControl>,
    #[serde(rename = "keyFrameIntervalDuration", skip_serializing_if = "Option::is_none")]
    pub key_frame_interval_duration: Option<String>,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    pub access_token: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub endpoints: Vec<LiveEventEndpoint>,
}
pub mod live_event_input {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StreamingProtocol {
        #[serde(rename = "FragmentedMP4")]
        FragmentedMp4,
        #[serde(rename = "RTMP")]
        Rtmp,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpRange {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(rename = "subnetPrefixLength", skip_serializing_if = "Option::is_none")]
    pub subnet_prefix_length: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpAccessControl {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub allow: Vec<IpRange>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventPreviewAccessControl {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip: Option<IpAccessControl>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventPreview {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub endpoints: Vec<LiveEventEndpoint>,
    #[serde(rename = "accessControl", skip_serializing_if = "Option::is_none")]
    pub access_control: Option<LiveEventPreviewAccessControl>,
    #[serde(rename = "previewLocator", skip_serializing_if = "Option::is_none")]
    pub preview_locator: Option<String>,
    #[serde(rename = "streamingPolicyName", skip_serializing_if = "Option::is_none")]
    pub streaming_policy_name: Option<String>,
    #[serde(rename = "alternativeMediaId", skip_serializing_if = "Option::is_none")]
    pub alternative_media_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventEncoding {
    #[serde(rename = "encodingType", skip_serializing_if = "Option::is_none")]
    pub encoding_type: Option<live_event_encoding::EncodingType>,
    #[serde(rename = "presetName", skip_serializing_if = "Option::is_none")]
    pub preset_name: Option<String>,
}
pub mod live_event_encoding {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EncodingType {
        None,
        Basic,
        Standard,
        Premium1080p,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CrossSiteAccessPolicies {
    #[serde(rename = "clientAccessPolicy", skip_serializing_if = "Option::is_none")]
    pub client_access_policy: Option<String>,
    #[serde(rename = "crossDomainPolicy", skip_serializing_if = "Option::is_none")]
    pub cross_domain_policy: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventActionInput {
    #[serde(rename = "removeOutputsOnStop", skip_serializing_if = "Option::is_none")]
    pub remove_outputs_on_stop: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub input: LiveEventInput,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preview: Option<LiveEventPreview>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encoding: Option<LiveEventEncoding>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
    #[serde(rename = "resourceState", skip_serializing)]
    pub resource_state: Option<live_event_properties::ResourceState>,
    #[serde(rename = "crossSiteAccessPolicies", skip_serializing_if = "Option::is_none")]
    pub cross_site_access_policies: Option<CrossSiteAccessPolicies>,
    #[serde(rename = "vanityUrl", skip_serializing_if = "Option::is_none")]
    pub vanity_url: Option<bool>,
    #[serde(rename = "streamOptions", skip_serializing_if = "Vec::is_empty")]
    pub stream_options: Vec<String>,
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(rename = "lastModified", skip_serializing)]
    pub last_modified: Option<String>,
}
pub mod live_event_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ResourceState {
        Stopped,
        Starting,
        Running,
        Stopping,
        Deleting,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEvent {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<LiveEventProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LiveEvent>,
    #[serde(rename = "@odata.count", skip_serializing_if = "Option::is_none")]
    pub odata_count: Option<i32>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AkamaiSignatureHeaderAuthenticationKey {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
    #[serde(rename = "base64Key", skip_serializing_if = "Option::is_none")]
    pub base64_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiration: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AkamaiAccessControl {
    #[serde(rename = "akamaiSignatureHeaderAuthenticationKeyList", skip_serializing_if = "Vec::is_empty")]
    pub akamai_signature_header_authentication_key_list: Vec<AkamaiSignatureHeaderAuthenticationKey>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingEndpointAccessControl {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub akamai: Option<AkamaiAccessControl>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip: Option<IpAccessControl>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingEntityScaleUnit {
    #[serde(rename = "scaleUnit", skip_serializing_if = "Option::is_none")]
    pub scale_unit: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingEndpointProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "scaleUnits")]
    pub scale_units: i32,
    #[serde(rename = "availabilitySetName", skip_serializing_if = "Option::is_none")]
    pub availability_set_name: Option<String>,
    #[serde(rename = "accessControl", skip_serializing_if = "Option::is_none")]
    pub access_control: Option<StreamingEndpointAccessControl>,
    #[serde(rename = "maxCacheAge", skip_serializing_if = "Option::is_none")]
    pub max_cache_age: Option<i64>,
    #[serde(rename = "customHostNames", skip_serializing_if = "Vec::is_empty")]
    pub custom_host_names: Vec<String>,
    #[serde(rename = "hostName", skip_serializing)]
    pub host_name: Option<String>,
    #[serde(rename = "cdnEnabled", skip_serializing_if = "Option::is_none")]
    pub cdn_enabled: Option<bool>,
    #[serde(rename = "cdnProvider", skip_serializing_if = "Option::is_none")]
    pub cdn_provider: Option<String>,
    #[serde(rename = "cdnProfile", skip_serializing_if = "Option::is_none")]
    pub cdn_profile: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
    #[serde(rename = "resourceState", skip_serializing)]
    pub resource_state: Option<streaming_endpoint_properties::ResourceState>,
    #[serde(rename = "crossSiteAccessPolicies", skip_serializing_if = "Option::is_none")]
    pub cross_site_access_policies: Option<CrossSiteAccessPolicies>,
    #[serde(rename = "freeTrialEndTime", skip_serializing)]
    pub free_trial_end_time: Option<String>,
    #[serde(skip_serializing)]
    pub created: Option<String>,
    #[serde(rename = "lastModified", skip_serializing)]
    pub last_modified: Option<String>,
}
pub mod streaming_endpoint_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ResourceState {
        Stopped,
        Starting,
        Running,
        Stopping,
        Deleting,
        Scaling,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingEndpoint {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<StreamingEndpointProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingEndpointListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<StreamingEndpoint>,
    #[serde(rename = "@odata.count", skip_serializing_if = "Option::is_none")]
    pub odata_count: Option<i32>,
    #[serde(rename = "@odata.nextLink", skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
