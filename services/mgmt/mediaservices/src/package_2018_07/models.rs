#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AacAudio {
    #[serde(flatten)]
    pub audio: Audio,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profile: Option<aac_audio::Profile>,
}
impl AacAudio {
    pub fn new(audio: Audio) -> Self {
        Self { audio, profile: None }
    }
}
pub mod aac_audio {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Profile {
        AacLc,
        HeAacV1,
        HeAacV2,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AbsoluteClipTime {
    #[serde(flatten)]
    pub clip_time: ClipTime,
    pub time: String,
}
impl AbsoluteClipTime {
    pub fn new(clip_time: ClipTime, time: String) -> Self {
        Self { clip_time, time }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AccountFilter {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<MediaFilterProperties>,
}
impl AccountFilter {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AccountFilterCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AccountFilter>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl AccountFilterCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AkamaiAccessControl {
    #[serde(
        rename = "akamaiSignatureHeaderAuthenticationKeyList",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub akamai_signature_header_authentication_key_list: Vec<AkamaiSignatureHeaderAuthenticationKey>,
}
impl AkamaiAccessControl {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AkamaiSignatureHeaderAuthenticationKey {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identifier: Option<String>,
    #[serde(rename = "base64Key", default, skip_serializing_if = "Option::is_none")]
    pub base64_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expiration: Option<String>,
}
impl AkamaiSignatureHeaderAuthenticationKey {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ApiError {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<ODataError>,
}
impl ApiError {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Asset {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<AssetProperties>,
}
impl Asset {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AssetCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Asset>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl AssetCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AssetContainerSas {
    #[serde(rename = "assetContainerSasUrls", default, skip_serializing_if = "Vec::is_empty")]
    pub asset_container_sas_urls: Vec<String>,
}
impl AssetContainerSas {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AssetFileEncryptionMetadata {
    #[serde(rename = "initializationVector", default, skip_serializing_if = "Option::is_none")]
    pub initialization_vector: Option<String>,
    #[serde(rename = "assetFileName", default, skip_serializing_if = "Option::is_none")]
    pub asset_file_name: Option<String>,
    #[serde(rename = "assetFileId")]
    pub asset_file_id: String,
}
impl AssetFileEncryptionMetadata {
    pub fn new(asset_file_id: String) -> Self {
        Self {
            initialization_vector: None,
            asset_file_name: None,
            asset_file_id,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AssetFilter {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<MediaFilterProperties>,
}
impl AssetFilter {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AssetFilterCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AssetFilter>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl AssetFilterCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AssetProperties {
    #[serde(rename = "assetId", default, skip_serializing_if = "Option::is_none")]
    pub asset_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(rename = "lastModified", default, skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<String>,
    #[serde(rename = "alternateId", default, skip_serializing_if = "Option::is_none")]
    pub alternate_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    #[serde(rename = "storageAccountName", default, skip_serializing_if = "Option::is_none")]
    pub storage_account_name: Option<String>,
    #[serde(rename = "storageEncryptionFormat", default, skip_serializing_if = "Option::is_none")]
    pub storage_encryption_format: Option<asset_properties::StorageEncryptionFormat>,
}
impl AssetProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod asset_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StorageEncryptionFormat {
        None,
        MediaStorageClientEncryption,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AssetStreamingLocator {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "assetName", default, skip_serializing_if = "Option::is_none")]
    pub asset_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", default, skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "streamingLocatorId", default, skip_serializing_if = "Option::is_none")]
    pub streaming_locator_id: Option<String>,
    #[serde(rename = "streamingPolicyName", default, skip_serializing_if = "Option::is_none")]
    pub streaming_policy_name: Option<String>,
    #[serde(rename = "defaultContentKeyPolicyName", default, skip_serializing_if = "Option::is_none")]
    pub default_content_key_policy_name: Option<String>,
}
impl AssetStreamingLocator {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Audio {
    #[serde(flatten)]
    pub codec: Codec,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channels: Option<i32>,
    #[serde(rename = "samplingRate", default, skip_serializing_if = "Option::is_none")]
    pub sampling_rate: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bitrate: Option<i32>,
}
impl Audio {
    pub fn new(codec: Codec) -> Self {
        Self {
            codec,
            channels: None,
            sampling_rate: None,
            bitrate: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AudioAnalyzerPreset {
    #[serde(flatten)]
    pub preset: Preset,
    #[serde(rename = "audioLanguage", default, skip_serializing_if = "Option::is_none")]
    pub audio_language: Option<String>,
    #[serde(rename = "experimentalOptions", default, skip_serializing_if = "Option::is_none")]
    pub experimental_options: Option<serde_json::Value>,
}
impl AudioAnalyzerPreset {
    pub fn new(preset: Preset) -> Self {
        Self {
            preset,
            audio_language: None,
            experimental_options: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AudioOverlay {
    #[serde(flatten)]
    pub overlay: Overlay,
}
impl AudioOverlay {
    pub fn new(overlay: Overlay) -> Self {
        Self { overlay }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BuiltInStandardEncoderPreset {
    #[serde(flatten)]
    pub preset: Preset,
    #[serde(rename = "presetName")]
    pub preset_name: built_in_standard_encoder_preset::PresetName,
}
impl BuiltInStandardEncoderPreset {
    pub fn new(preset: Preset, preset_name: built_in_standard_encoder_preset::PresetName) -> Self {
        Self { preset, preset_name }
    }
}
pub mod built_in_standard_encoder_preset {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PresetName {
        #[serde(rename = "H264SingleBitrateSD")]
        H264SingleBitrateSd,
        H264SingleBitrate720p,
        H264SingleBitrate1080p,
        AdaptiveStreaming,
        #[serde(rename = "AACGoodQualityAudio")]
        AacGoodQualityAudio,
        ContentAwareEncodingExperimental,
        ContentAwareEncoding,
        H264MultipleBitrate1080p,
        H264MultipleBitrate720p,
        #[serde(rename = "H264MultipleBitrateSD")]
        H264MultipleBitrateSd,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CbcsDrmConfiguration {
    #[serde(rename = "fairPlay", default, skip_serializing_if = "Option::is_none")]
    pub fair_play: Option<StreamingPolicyFairPlayConfiguration>,
    #[serde(rename = "playReady", default, skip_serializing_if = "Option::is_none")]
    pub play_ready: Option<StreamingPolicyPlayReadyConfiguration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub widevine: Option<StreamingPolicyWidevineConfiguration>,
}
impl CbcsDrmConfiguration {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CencDrmConfiguration {
    #[serde(rename = "playReady", default, skip_serializing_if = "Option::is_none")]
    pub play_ready: Option<StreamingPolicyPlayReadyConfiguration>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub widevine: Option<StreamingPolicyWidevineConfiguration>,
}
impl CencDrmConfiguration {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CheckNameAvailabilityInput {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
impl CheckNameAvailabilityInput {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ClipTime {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
impl ClipTime {
    pub fn new(odata_type: String) -> Self {
        Self { odata_type }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Codec {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}
impl Codec {
    pub fn new(odata_type: String) -> Self {
        Self { odata_type, label: None }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CommonEncryptionCbcs {
    #[serde(rename = "enabledProtocols", default, skip_serializing_if = "Option::is_none")]
    pub enabled_protocols: Option<EnabledProtocols>,
    #[serde(rename = "clearTracks", default, skip_serializing_if = "Vec::is_empty")]
    pub clear_tracks: Vec<TrackSelection>,
    #[serde(rename = "contentKeys", default, skip_serializing_if = "Option::is_none")]
    pub content_keys: Option<StreamingPolicyContentKeys>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drm: Option<CbcsDrmConfiguration>,
}
impl CommonEncryptionCbcs {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CommonEncryptionCenc {
    #[serde(rename = "enabledProtocols", default, skip_serializing_if = "Option::is_none")]
    pub enabled_protocols: Option<EnabledProtocols>,
    #[serde(rename = "clearTracks", default, skip_serializing_if = "Vec::is_empty")]
    pub clear_tracks: Vec<TrackSelection>,
    #[serde(rename = "contentKeys", default, skip_serializing_if = "Option::is_none")]
    pub content_keys: Option<StreamingPolicyContentKeys>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drm: Option<CencDrmConfiguration>,
}
impl CommonEncryptionCenc {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ContentKeyPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<ContentKeyPolicyProperties>,
}
impl ContentKeyPolicy {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyClearKeyConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
}
impl ContentKeyPolicyClearKeyConfiguration {
    pub fn new(content_key_policy_configuration: ContentKeyPolicyConfiguration) -> Self {
        Self {
            content_key_policy_configuration,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ContentKeyPolicyCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ContentKeyPolicy>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl ContentKeyPolicyCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyConfiguration {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
impl ContentKeyPolicyConfiguration {
    pub fn new(odata_type: String) -> Self {
        Self { odata_type }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyFairPlayConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
    pub ask: String,
    #[serde(rename = "fairPlayPfxPassword")]
    pub fair_play_pfx_password: String,
    #[serde(rename = "fairPlayPfx")]
    pub fair_play_pfx: String,
    #[serde(rename = "rentalAndLeaseKeyType")]
    pub rental_and_lease_key_type: content_key_policy_fair_play_configuration::RentalAndLeaseKeyType,
    #[serde(rename = "rentalDuration")]
    pub rental_duration: i64,
    #[serde(rename = "offlineRentalConfiguration", default, skip_serializing_if = "Option::is_none")]
    pub offline_rental_configuration: Option<ContentKeyPolicyFairPlayOfflineRentalConfiguration>,
}
impl ContentKeyPolicyFairPlayConfiguration {
    pub fn new(
        content_key_policy_configuration: ContentKeyPolicyConfiguration,
        ask: String,
        fair_play_pfx_password: String,
        fair_play_pfx: String,
        rental_and_lease_key_type: content_key_policy_fair_play_configuration::RentalAndLeaseKeyType,
        rental_duration: i64,
    ) -> Self {
        Self {
            content_key_policy_configuration,
            ask,
            fair_play_pfx_password,
            fair_play_pfx,
            rental_and_lease_key_type,
            rental_duration,
            offline_rental_configuration: None,
        }
    }
}
pub mod content_key_policy_fair_play_configuration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RentalAndLeaseKeyType {
        Unknown,
        Undefined,
        DualExpiry,
        PersistentUnlimited,
        PersistentLimited,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyFairPlayOfflineRentalConfiguration {
    #[serde(rename = "playbackDurationSeconds")]
    pub playback_duration_seconds: i64,
    #[serde(rename = "storageDurationSeconds")]
    pub storage_duration_seconds: i64,
}
impl ContentKeyPolicyFairPlayOfflineRentalConfiguration {
    pub fn new(playback_duration_seconds: i64, storage_duration_seconds: i64) -> Self {
        Self {
            playback_duration_seconds,
            storage_duration_seconds,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyOpenRestriction {
    #[serde(flatten)]
    pub content_key_policy_restriction: ContentKeyPolicyRestriction,
}
impl ContentKeyPolicyOpenRestriction {
    pub fn new(content_key_policy_restriction: ContentKeyPolicyRestriction) -> Self {
        Self {
            content_key_policy_restriction,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyOption {
    #[serde(rename = "policyOptionId", default, skip_serializing_if = "Option::is_none")]
    pub policy_option_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub configuration: ContentKeyPolicyConfiguration,
    pub restriction: ContentKeyPolicyRestriction,
}
impl ContentKeyPolicyOption {
    pub fn new(configuration: ContentKeyPolicyConfiguration, restriction: ContentKeyPolicyRestriction) -> Self {
        Self {
            policy_option_id: None,
            name: None,
            configuration,
            restriction,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
    pub licenses: Vec<ContentKeyPolicyPlayReadyLicense>,
    #[serde(rename = "responseCustomData", default, skip_serializing_if = "Option::is_none")]
    pub response_custom_data: Option<String>,
}
impl ContentKeyPolicyPlayReadyConfiguration {
    pub fn new(content_key_policy_configuration: ContentKeyPolicyConfiguration, licenses: Vec<ContentKeyPolicyPlayReadyLicense>) -> Self {
        Self {
            content_key_policy_configuration,
            licenses,
            response_custom_data: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader {
    #[serde(flatten)]
    pub content_key_policy_play_ready_content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation,
}
impl ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader {
    pub fn new(content_key_policy_play_ready_content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation) -> Self {
        Self {
            content_key_policy_play_ready_content_key_location,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier {
    #[serde(flatten)]
    pub content_key_policy_play_ready_content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation,
    #[serde(rename = "keyId")]
    pub key_id: String,
}
impl ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier {
    pub fn new(content_key_policy_play_ready_content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation, key_id: String) -> Self {
        Self {
            content_key_policy_play_ready_content_key_location,
            key_id,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyContentKeyLocation {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
impl ContentKeyPolicyPlayReadyContentKeyLocation {
    pub fn new(odata_type: String) -> Self {
        Self { odata_type }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
    #[serde(rename = "bestEffort")]
    pub best_effort: bool,
    #[serde(rename = "configurationData")]
    pub configuration_data: i32,
}
impl ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
    pub fn new(best_effort: bool, configuration_data: i32) -> Self {
        Self {
            best_effort,
            configuration_data,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyLicense {
    #[serde(rename = "allowTestDevices")]
    pub allow_test_devices: bool,
    #[serde(rename = "beginDate", default, skip_serializing_if = "Option::is_none")]
    pub begin_date: Option<String>,
    #[serde(rename = "expirationDate", default, skip_serializing_if = "Option::is_none")]
    pub expiration_date: Option<String>,
    #[serde(rename = "relativeBeginDate", default, skip_serializing_if = "Option::is_none")]
    pub relative_begin_date: Option<String>,
    #[serde(rename = "relativeExpirationDate", default, skip_serializing_if = "Option::is_none")]
    pub relative_expiration_date: Option<String>,
    #[serde(rename = "gracePeriod", default, skip_serializing_if = "Option::is_none")]
    pub grace_period: Option<String>,
    #[serde(rename = "playRight", default, skip_serializing_if = "Option::is_none")]
    pub play_right: Option<ContentKeyPolicyPlayReadyPlayRight>,
    #[serde(rename = "licenseType")]
    pub license_type: content_key_policy_play_ready_license::LicenseType,
    #[serde(rename = "contentKeyLocation")]
    pub content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation,
    #[serde(rename = "contentType")]
    pub content_type: content_key_policy_play_ready_license::ContentType,
}
impl ContentKeyPolicyPlayReadyLicense {
    pub fn new(
        allow_test_devices: bool,
        license_type: content_key_policy_play_ready_license::LicenseType,
        content_key_location: ContentKeyPolicyPlayReadyContentKeyLocation,
        content_type: content_key_policy_play_ready_license::ContentType,
    ) -> Self {
        Self {
            allow_test_devices,
            begin_date: None,
            expiration_date: None,
            relative_begin_date: None,
            relative_expiration_date: None,
            grace_period: None,
            play_right: None,
            license_type,
            content_key_location,
            content_type,
        }
    }
}
pub mod content_key_policy_play_ready_license {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LicenseType {
        Unknown,
        NonPersistent,
        Persistent,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ContentType {
        Unknown,
        Unspecified,
        UltraVioletDownload,
        UltraVioletStreaming,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyPlayReadyPlayRight {
    #[serde(rename = "firstPlayExpiration", default, skip_serializing_if = "Option::is_none")]
    pub first_play_expiration: Option<String>,
    #[serde(rename = "scmsRestriction", default, skip_serializing_if = "Option::is_none")]
    pub scms_restriction: Option<i32>,
    #[serde(rename = "agcAndColorStripeRestriction", default, skip_serializing_if = "Option::is_none")]
    pub agc_and_color_stripe_restriction: Option<i32>,
    #[serde(
        rename = "explicitAnalogTelevisionOutputRestriction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub explicit_analog_television_output_restriction: Option<ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction>,
    #[serde(rename = "digitalVideoOnlyContentRestriction")]
    pub digital_video_only_content_restriction: bool,
    #[serde(rename = "imageConstraintForAnalogComponentVideoRestriction")]
    pub image_constraint_for_analog_component_video_restriction: bool,
    #[serde(rename = "imageConstraintForAnalogComputerMonitorRestriction")]
    pub image_constraint_for_analog_computer_monitor_restriction: bool,
    #[serde(rename = "allowPassingVideoContentToUnknownOutput")]
    pub allow_passing_video_content_to_unknown_output: content_key_policy_play_ready_play_right::AllowPassingVideoContentToUnknownOutput,
    #[serde(rename = "uncompressedDigitalVideoOpl", default, skip_serializing_if = "Option::is_none")]
    pub uncompressed_digital_video_opl: Option<i32>,
    #[serde(rename = "compressedDigitalVideoOpl", default, skip_serializing_if = "Option::is_none")]
    pub compressed_digital_video_opl: Option<i32>,
    #[serde(rename = "analogVideoOpl", default, skip_serializing_if = "Option::is_none")]
    pub analog_video_opl: Option<i32>,
    #[serde(rename = "compressedDigitalAudioOpl", default, skip_serializing_if = "Option::is_none")]
    pub compressed_digital_audio_opl: Option<i32>,
    #[serde(rename = "uncompressedDigitalAudioOpl", default, skip_serializing_if = "Option::is_none")]
    pub uncompressed_digital_audio_opl: Option<i32>,
}
impl ContentKeyPolicyPlayReadyPlayRight {
    pub fn new(
        digital_video_only_content_restriction: bool,
        image_constraint_for_analog_component_video_restriction: bool,
        image_constraint_for_analog_computer_monitor_restriction: bool,
        allow_passing_video_content_to_unknown_output: content_key_policy_play_ready_play_right::AllowPassingVideoContentToUnknownOutput,
    ) -> Self {
        Self {
            first_play_expiration: None,
            scms_restriction: None,
            agc_and_color_stripe_restriction: None,
            explicit_analog_television_output_restriction: None,
            digital_video_only_content_restriction,
            image_constraint_for_analog_component_video_restriction,
            image_constraint_for_analog_computer_monitor_restriction,
            allow_passing_video_content_to_unknown_output,
            uncompressed_digital_video_opl: None,
            compressed_digital_video_opl: None,
            analog_video_opl: None,
            compressed_digital_audio_opl: None,
            uncompressed_digital_audio_opl: None,
        }
    }
}
pub mod content_key_policy_play_ready_play_right {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AllowPassingVideoContentToUnknownOutput {
        Unknown,
        NotAllowed,
        Allowed,
        AllowedWithVideoConstriction,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyProperties {
    #[serde(rename = "policyId", default, skip_serializing_if = "Option::is_none")]
    pub policy_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(rename = "lastModified", default, skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub options: Vec<ContentKeyPolicyOption>,
}
impl ContentKeyPolicyProperties {
    pub fn new(options: Vec<ContentKeyPolicyOption>) -> Self {
        Self {
            policy_id: None,
            created: None,
            last_modified: None,
            description: None,
            options,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyRestriction {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
impl ContentKeyPolicyRestriction {
    pub fn new(odata_type: String) -> Self {
        Self { odata_type }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyRestrictionTokenKey {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
impl ContentKeyPolicyRestrictionTokenKey {
    pub fn new(odata_type: String) -> Self {
        Self { odata_type }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyRsaTokenKey {
    #[serde(flatten)]
    pub content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey,
    pub exponent: String,
    pub modulus: String,
}
impl ContentKeyPolicyRsaTokenKey {
    pub fn new(content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey, exponent: String, modulus: String) -> Self {
        Self {
            content_key_policy_restriction_token_key,
            exponent,
            modulus,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicySymmetricTokenKey {
    #[serde(flatten)]
    pub content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey,
    #[serde(rename = "keyValue")]
    pub key_value: String,
}
impl ContentKeyPolicySymmetricTokenKey {
    pub fn new(content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey, key_value: String) -> Self {
        Self {
            content_key_policy_restriction_token_key,
            key_value,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ContentKeyPolicyTokenClaim {
    #[serde(rename = "claimType", default, skip_serializing_if = "Option::is_none")]
    pub claim_type: Option<String>,
    #[serde(rename = "claimValue", default, skip_serializing_if = "Option::is_none")]
    pub claim_value: Option<String>,
}
impl ContentKeyPolicyTokenClaim {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyTokenRestriction {
    #[serde(flatten)]
    pub content_key_policy_restriction: ContentKeyPolicyRestriction,
    pub issuer: String,
    pub audience: String,
    #[serde(rename = "primaryVerificationKey")]
    pub primary_verification_key: ContentKeyPolicyRestrictionTokenKey,
    #[serde(rename = "alternateVerificationKeys", default, skip_serializing_if = "Vec::is_empty")]
    pub alternate_verification_keys: Vec<ContentKeyPolicyRestrictionTokenKey>,
    #[serde(rename = "requiredClaims", default, skip_serializing_if = "Vec::is_empty")]
    pub required_claims: Vec<ContentKeyPolicyTokenClaim>,
    #[serde(rename = "restrictionTokenType")]
    pub restriction_token_type: content_key_policy_token_restriction::RestrictionTokenType,
    #[serde(rename = "openIdConnectDiscoveryDocument", default, skip_serializing_if = "Option::is_none")]
    pub open_id_connect_discovery_document: Option<String>,
}
impl ContentKeyPolicyTokenRestriction {
    pub fn new(
        content_key_policy_restriction: ContentKeyPolicyRestriction,
        issuer: String,
        audience: String,
        primary_verification_key: ContentKeyPolicyRestrictionTokenKey,
        restriction_token_type: content_key_policy_token_restriction::RestrictionTokenType,
    ) -> Self {
        Self {
            content_key_policy_restriction,
            issuer,
            audience,
            primary_verification_key,
            alternate_verification_keys: Vec::new(),
            required_claims: Vec::new(),
            restriction_token_type,
            open_id_connect_discovery_document: None,
        }
    }
}
pub mod content_key_policy_token_restriction {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RestrictionTokenType {
        Unknown,
        Swt,
        Jwt,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyUnknownConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
}
impl ContentKeyPolicyUnknownConfiguration {
    pub fn new(content_key_policy_configuration: ContentKeyPolicyConfiguration) -> Self {
        Self {
            content_key_policy_configuration,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyUnknownRestriction {
    #[serde(flatten)]
    pub content_key_policy_restriction: ContentKeyPolicyRestriction,
}
impl ContentKeyPolicyUnknownRestriction {
    pub fn new(content_key_policy_restriction: ContentKeyPolicyRestriction) -> Self {
        Self {
            content_key_policy_restriction,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyWidevineConfiguration {
    #[serde(flatten)]
    pub content_key_policy_configuration: ContentKeyPolicyConfiguration,
    #[serde(rename = "widevineTemplate")]
    pub widevine_template: String,
}
impl ContentKeyPolicyWidevineConfiguration {
    pub fn new(content_key_policy_configuration: ContentKeyPolicyConfiguration, widevine_template: String) -> Self {
        Self {
            content_key_policy_configuration,
            widevine_template,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContentKeyPolicyX509CertificateTokenKey {
    #[serde(flatten)]
    pub content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey,
    #[serde(rename = "rawBody")]
    pub raw_body: String,
}
impl ContentKeyPolicyX509CertificateTokenKey {
    pub fn new(content_key_policy_restriction_token_key: ContentKeyPolicyRestrictionTokenKey, raw_body: String) -> Self {
        Self {
            content_key_policy_restriction_token_key,
            raw_body,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopyAudio {
    #[serde(flatten)]
    pub codec: Codec,
}
impl CopyAudio {
    pub fn new(codec: Codec) -> Self {
        Self { codec }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CopyVideo {
    #[serde(flatten)]
    pub codec: Codec,
}
impl CopyVideo {
    pub fn new(codec: Codec) -> Self {
        Self { codec }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CrossSiteAccessPolicies {
    #[serde(rename = "clientAccessPolicy", default, skip_serializing_if = "Option::is_none")]
    pub client_access_policy: Option<String>,
    #[serde(rename = "crossDomainPolicy", default, skip_serializing_if = "Option::is_none")]
    pub cross_domain_policy: Option<String>,
}
impl CrossSiteAccessPolicies {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct DefaultKey {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "policyName", default, skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
}
impl DefaultKey {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Deinterlace {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parity: Option<deinterlace::Parity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<deinterlace::Mode>,
}
impl Deinterlace {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod deinterlace {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Parity {
        Auto,
        TopFieldFirst,
        BottomFieldFirst,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Mode {
        Off,
        AutoPixelAdaptive,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct EdgePolicies {
    #[serde(rename = "usageDataCollectionPolicy", default, skip_serializing_if = "Option::is_none")]
    pub usage_data_collection_policy: Option<EdgeUsageDataCollectionPolicy>,
}
impl EdgePolicies {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct EdgeUsageDataCollectionPolicy {
    #[serde(rename = "dataCollectionFrequency", default, skip_serializing_if = "Option::is_none")]
    pub data_collection_frequency: Option<String>,
    #[serde(rename = "dataReportingFrequency", default, skip_serializing_if = "Option::is_none")]
    pub data_reporting_frequency: Option<String>,
    #[serde(rename = "maxAllowedUnreportedUsageDuration", default, skip_serializing_if = "Option::is_none")]
    pub max_allowed_unreported_usage_duration: Option<String>,
    #[serde(rename = "eventHubDetails", default, skip_serializing_if = "Option::is_none")]
    pub event_hub_details: Option<EdgeUsageDataEventHub>,
}
impl EdgeUsageDataCollectionPolicy {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct EdgeUsageDataEventHub {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
}
impl EdgeUsageDataEventHub {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EnabledProtocols {
    pub download: bool,
    pub dash: bool,
    pub hls: bool,
    #[serde(rename = "smoothStreaming")]
    pub smooth_streaming: bool,
}
impl EnabledProtocols {
    pub fn new(download: bool, dash: bool, hls: bool, smooth_streaming: bool) -> Self {
        Self {
            download,
            dash,
            hls,
            smooth_streaming,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EntityNameAvailabilityCheckOutput {
    #[serde(rename = "nameAvailable")]
    pub name_available: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl EntityNameAvailabilityCheckOutput {
    pub fn new(name_available: bool) -> Self {
        Self {
            name_available,
            reason: None,
            message: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct EnvelopeEncryption {
    #[serde(rename = "enabledProtocols", default, skip_serializing_if = "Option::is_none")]
    pub enabled_protocols: Option<EnabledProtocols>,
    #[serde(rename = "clearTracks", default, skip_serializing_if = "Vec::is_empty")]
    pub clear_tracks: Vec<TrackSelection>,
    #[serde(rename = "contentKeys", default, skip_serializing_if = "Option::is_none")]
    pub content_keys: Option<StreamingPolicyContentKeys>,
    #[serde(rename = "customKeyAcquisitionUrlTemplate", default, skip_serializing_if = "Option::is_none")]
    pub custom_key_acquisition_url_template: Option<String>,
}
impl EnvelopeEncryption {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FaceDetectorPreset {
    #[serde(flatten)]
    pub preset: Preset,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolution: Option<face_detector_preset::Resolution>,
    #[serde(rename = "experimentalOptions", default, skip_serializing_if = "Option::is_none")]
    pub experimental_options: Option<serde_json::Value>,
}
impl FaceDetectorPreset {
    pub fn new(preset: Preset) -> Self {
        Self {
            preset,
            resolution: None,
            experimental_options: None,
        }
    }
}
pub mod face_detector_preset {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Resolution {
        SourceResolution,
        StandardDefinition,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FilterTrackPropertyCondition {
    pub property: filter_track_property_condition::Property,
    pub value: String,
    pub operation: filter_track_property_condition::Operation,
}
impl FilterTrackPropertyCondition {
    pub fn new(
        property: filter_track_property_condition::Property,
        value: String,
        operation: filter_track_property_condition::Operation,
    ) -> Self {
        Self {
            property,
            value,
            operation,
        }
    }
}
pub mod filter_track_property_condition {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Property {
        Unknown,
        Type,
        Name,
        Language,
        #[serde(rename = "FourCC")]
        FourCc,
        Bitrate,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Operation {
        Equal,
        NotEqual,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FilterTrackSelection {
    #[serde(rename = "trackSelections")]
    pub track_selections: Vec<FilterTrackPropertyCondition>,
}
impl FilterTrackSelection {
    pub fn new(track_selections: Vec<FilterTrackPropertyCondition>) -> Self {
        Self { track_selections }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Filters {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deinterlace: Option<Deinterlace>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotation: Option<filters::Rotation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub crop: Option<Rectangle>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub overlays: Vec<Overlay>,
}
impl Filters {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod filters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Rotation {
        Auto,
        None,
        Rotate0,
        Rotate90,
        Rotate180,
        Rotate270,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirstQuality {
    pub bitrate: i32,
}
impl FirstQuality {
    pub fn new(bitrate: i32) -> Self {
        Self { bitrate }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Format {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(rename = "filenamePattern")]
    pub filename_pattern: String,
}
impl Format {
    pub fn new(odata_type: String, filename_pattern: String) -> Self {
        Self {
            odata_type,
            filename_pattern,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct H264Layer {
    #[serde(flatten)]
    pub video_layer: VideoLayer,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profile: Option<h264_layer::Profile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(rename = "bufferWindow", default, skip_serializing_if = "Option::is_none")]
    pub buffer_window: Option<String>,
    #[serde(rename = "referenceFrames", default, skip_serializing_if = "Option::is_none")]
    pub reference_frames: Option<i32>,
    #[serde(rename = "entropyMode", default, skip_serializing_if = "Option::is_none")]
    pub entropy_mode: Option<h264_layer::EntropyMode>,
}
impl H264Layer {
    pub fn new(video_layer: VideoLayer) -> Self {
        Self {
            video_layer,
            profile: None,
            level: None,
            buffer_window: None,
            reference_frames: None,
            entropy_mode: None,
        }
    }
}
pub mod h264_layer {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Profile {
        Auto,
        Baseline,
        Main,
        High,
        High422,
        High444,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EntropyMode {
        Cabac,
        Cavlc,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct H264Video {
    #[serde(flatten)]
    pub video: Video,
    #[serde(rename = "sceneChangeDetection", default, skip_serializing_if = "Option::is_none")]
    pub scene_change_detection: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub complexity: Option<h264_video::Complexity>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub layers: Vec<H264Layer>,
}
impl H264Video {
    pub fn new(video: Video) -> Self {
        Self {
            video,
            scene_change_detection: None,
            complexity: None,
            layers: Vec::new(),
        }
    }
}
pub mod h264_video {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Complexity {
        Speed,
        Balanced,
        Quality,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Hls {
    #[serde(rename = "fragmentsPerTsSegment", default, skip_serializing_if = "Option::is_none")]
    pub fragments_per_ts_segment: Option<i32>,
}
impl Hls {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct IpAccessControl {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub allow: Vec<IpRange>,
}
impl IpAccessControl {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct IpRange {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(rename = "subnetPrefixLength", default, skip_serializing_if = "Option::is_none")]
    pub subnet_prefix_length: Option<i32>,
}
impl IpRange {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Image {
    #[serde(flatten)]
    pub video: Video,
    pub start: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub range: Option<String>,
}
impl Image {
    pub fn new(video: Video, start: String) -> Self {
        Self {
            video,
            start,
            step: None,
            range: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageFormat {
    #[serde(flatten)]
    pub format: Format,
}
impl ImageFormat {
    pub fn new(format: Format) -> Self {
        Self { format }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Job {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<JobProperties>,
}
impl Job {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct JobCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Job>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl JobCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct JobError {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<job_error::Code>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<job_error::Category>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry: Option<job_error::Retry>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<JobErrorDetail>,
}
impl JobError {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod job_error {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Code {
        ServiceError,
        ServiceTransientError,
        DownloadNotAccessible,
        DownloadTransientError,
        UploadNotAccessible,
        UploadTransientError,
        ConfigurationUnsupported,
        ContentMalformed,
        ContentUnsupported,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Category {
        Service,
        Download,
        Upload,
        Configuration,
        Content,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Retry {
        DoNotRetry,
        MayRetry,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct JobErrorDetail {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl JobErrorDetail {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInput {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
impl JobInput {
    pub fn new(odata_type: String) -> Self {
        Self { odata_type }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInputAsset {
    #[serde(flatten)]
    pub job_input_clip: JobInputClip,
    #[serde(rename = "assetName")]
    pub asset_name: String,
}
impl JobInputAsset {
    pub fn new(job_input_clip: JobInputClip, asset_name: String) -> Self {
        Self {
            job_input_clip,
            asset_name,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInputClip {
    #[serde(flatten)]
    pub job_input: JobInput,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub files: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<ClipTime>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<ClipTime>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}
impl JobInputClip {
    pub fn new(job_input: JobInput) -> Self {
        Self {
            job_input,
            files: Vec::new(),
            start: None,
            end: None,
            label: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInputHttp {
    #[serde(flatten)]
    pub job_input_clip: JobInputClip,
    #[serde(rename = "baseUri", default, skip_serializing_if = "Option::is_none")]
    pub base_uri: Option<String>,
}
impl JobInputHttp {
    pub fn new(job_input_clip: JobInputClip) -> Self {
        Self {
            job_input_clip,
            base_uri: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobInputs {
    #[serde(flatten)]
    pub job_input: JobInput,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub inputs: Vec<JobInput>,
}
impl JobInputs {
    pub fn new(job_input: JobInput) -> Self {
        Self {
            job_input,
            inputs: Vec::new(),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobOutput {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<JobError>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<job_output::State>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub progress: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", default, skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
}
impl JobOutput {
    pub fn new(odata_type: String) -> Self {
        Self {
            odata_type,
            error: None,
            state: None,
            progress: None,
            label: None,
            start_time: None,
            end_time: None,
        }
    }
}
pub mod job_output {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Canceled,
        Canceling,
        Error,
        Finished,
        Processing,
        Queued,
        Scheduled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobOutputAsset {
    #[serde(flatten)]
    pub job_output: JobOutput,
    #[serde(rename = "assetName")]
    pub asset_name: String,
}
impl JobOutputAsset {
    pub fn new(job_output: JobOutput, asset_name: String) -> Self {
        Self { job_output, asset_name }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<job_properties::State>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub input: JobInput,
    #[serde(rename = "lastModified", default, skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<String>,
    pub outputs: Vec<JobOutput>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<job_properties::Priority>,
    #[serde(rename = "correlationData", default, skip_serializing_if = "Option::is_none")]
    pub correlation_data: Option<serde_json::Value>,
    #[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", default, skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
}
impl JobProperties {
    pub fn new(input: JobInput, outputs: Vec<JobOutput>) -> Self {
        Self {
            created: None,
            state: None,
            description: None,
            input,
            last_modified: None,
            outputs,
            priority: None,
            correlation_data: None,
            start_time: None,
            end_time: None,
        }
    }
}
pub mod job_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Canceled,
        Canceling,
        Error,
        Finished,
        Processing,
        Queued,
        Scheduled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Priority {
        Low,
        Normal,
        High,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JpgFormat {
    #[serde(flatten)]
    pub image_format: ImageFormat,
}
impl JpgFormat {
    pub fn new(image_format: ImageFormat) -> Self {
        Self { image_format }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JpgImage {
    #[serde(flatten)]
    pub image: Image,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub layers: Vec<JpgLayer>,
}
impl JpgImage {
    pub fn new(image: Image) -> Self {
        Self { image, layers: Vec::new() }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JpgLayer {
    #[serde(flatten)]
    pub layer: Layer,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quality: Option<i32>,
}
impl JpgLayer {
    pub fn new(layer: Layer) -> Self {
        Self { layer, quality: None }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Layer {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}
impl Layer {
    pub fn new(odata_type: String) -> Self {
        Self {
            odata_type,
            width: None,
            height: None,
            label: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ListContainerSasInput {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<list_container_sas_input::Permissions>,
    #[serde(rename = "expiryTime", default, skip_serializing_if = "Option::is_none")]
    pub expiry_time: Option<String>,
}
impl ListContainerSasInput {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod list_container_sas_input {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Permissions {
        Read,
        ReadWrite,
        ReadWriteDelete,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ListContentKeysResponse {
    #[serde(rename = "contentKeys", default, skip_serializing_if = "Vec::is_empty")]
    pub content_keys: Vec<StreamingLocatorContentKey>,
}
impl ListContentKeysResponse {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ListEdgePoliciesInput {
    #[serde(rename = "deviceId", default, skip_serializing_if = "Option::is_none")]
    pub device_id: Option<String>,
}
impl ListEdgePoliciesInput {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ListPathsResponse {
    #[serde(rename = "streamingPaths", default, skip_serializing_if = "Vec::is_empty")]
    pub streaming_paths: Vec<StreamingPath>,
    #[serde(rename = "downloadPaths", default, skip_serializing_if = "Vec::is_empty")]
    pub download_paths: Vec<String>,
}
impl ListPathsResponse {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ListStreamingLocatorsResponse {
    #[serde(rename = "streamingLocators", default, skip_serializing_if = "Vec::is_empty")]
    pub streaming_locators: Vec<AssetStreamingLocator>,
}
impl ListStreamingLocatorsResponse {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveEvent {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<LiveEventProperties>,
}
impl LiveEvent {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveEventActionInput {
    #[serde(rename = "removeOutputsOnStop", default, skip_serializing_if = "Option::is_none")]
    pub remove_outputs_on_stop: Option<bool>,
}
impl LiveEventActionInput {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveEventEncoding {
    #[serde(rename = "encodingType", default, skip_serializing_if = "Option::is_none")]
    pub encoding_type: Option<live_event_encoding::EncodingType>,
    #[serde(rename = "presetName", default, skip_serializing_if = "Option::is_none")]
    pub preset_name: Option<String>,
}
impl LiveEventEncoding {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod live_event_encoding {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EncodingType {
        None,
        Basic,
        Standard,
        Premium1080p,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveEventEndpoint {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}
impl LiveEventEndpoint {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventInput {
    #[serde(rename = "streamingProtocol")]
    pub streaming_protocol: live_event_input::StreamingProtocol,
    #[serde(rename = "accessControl", default, skip_serializing_if = "Option::is_none")]
    pub access_control: Option<LiveEventInputAccessControl>,
    #[serde(rename = "keyFrameIntervalDuration", default, skip_serializing_if = "Option::is_none")]
    pub key_frame_interval_duration: Option<String>,
    #[serde(rename = "accessToken", default, skip_serializing_if = "Option::is_none")]
    pub access_token: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub endpoints: Vec<LiveEventEndpoint>,
}
impl LiveEventInput {
    pub fn new(streaming_protocol: live_event_input::StreamingProtocol) -> Self {
        Self {
            streaming_protocol,
            access_control: None,
            key_frame_interval_duration: None,
            access_token: None,
            endpoints: Vec::new(),
        }
    }
}
pub mod live_event_input {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StreamingProtocol {
        #[serde(rename = "FragmentedMP4")]
        FragmentedMp4,
        #[serde(rename = "RTMP")]
        Rtmp,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveEventInputAccessControl {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<IpAccessControl>,
}
impl LiveEventInputAccessControl {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveEventListResult {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LiveEvent>,
    #[serde(rename = "@odata.count", default, skip_serializing_if = "Option::is_none")]
    pub odata_count: Option<i32>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl LiveEventListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveEventPreview {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub endpoints: Vec<LiveEventEndpoint>,
    #[serde(rename = "accessControl", default, skip_serializing_if = "Option::is_none")]
    pub access_control: Option<LiveEventPreviewAccessControl>,
    #[serde(rename = "previewLocator", default, skip_serializing_if = "Option::is_none")]
    pub preview_locator: Option<String>,
    #[serde(rename = "streamingPolicyName", default, skip_serializing_if = "Option::is_none")]
    pub streaming_policy_name: Option<String>,
    #[serde(rename = "alternativeMediaId", default, skip_serializing_if = "Option::is_none")]
    pub alternative_media_id: Option<String>,
}
impl LiveEventPreview {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveEventPreviewAccessControl {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<IpAccessControl>,
}
impl LiveEventPreviewAccessControl {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveEventProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub input: LiveEventInput,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preview: Option<LiveEventPreview>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encoding: Option<LiveEventEncoding>,
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[serde(rename = "resourceState", default, skip_serializing_if = "Option::is_none")]
    pub resource_state: Option<live_event_properties::ResourceState>,
    #[serde(rename = "crossSiteAccessPolicies", default, skip_serializing_if = "Option::is_none")]
    pub cross_site_access_policies: Option<CrossSiteAccessPolicies>,
    #[serde(rename = "vanityUrl", default, skip_serializing_if = "Option::is_none")]
    pub vanity_url: Option<bool>,
    #[serde(rename = "streamOptions", default, skip_serializing_if = "Vec::is_empty")]
    pub stream_options: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(rename = "lastModified", default, skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<String>,
}
impl LiveEventProperties {
    pub fn new(input: LiveEventInput) -> Self {
        Self {
            description: None,
            input,
            preview: None,
            encoding: None,
            provisioning_state: None,
            resource_state: None,
            cross_site_access_policies: None,
            vanity_url: None,
            stream_options: Vec::new(),
            created: None,
            last_modified: None,
        }
    }
}
pub mod live_event_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ResourceState {
        Stopped,
        Starting,
        Running,
        Stopping,
        Deleting,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveOutput {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<LiveOutputProperties>,
}
impl LiveOutput {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LiveOutputListResult {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LiveOutput>,
    #[serde(rename = "@odata.count", default, skip_serializing_if = "Option::is_none")]
    pub odata_count: Option<i32>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl LiveOutputListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LiveOutputProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "assetName")]
    pub asset_name: String,
    #[serde(rename = "archiveWindowLength")]
    pub archive_window_length: String,
    #[serde(rename = "manifestName", default, skip_serializing_if = "Option::is_none")]
    pub manifest_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hls: Option<Hls>,
    #[serde(rename = "outputSnapTime", default, skip_serializing_if = "Option::is_none")]
    pub output_snap_time: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(rename = "lastModified", default, skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<String>,
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[serde(rename = "resourceState", default, skip_serializing_if = "Option::is_none")]
    pub resource_state: Option<live_output_properties::ResourceState>,
}
impl LiveOutputProperties {
    pub fn new(asset_name: String, archive_window_length: String) -> Self {
        Self {
            description: None,
            asset_name,
            archive_window_length,
            manifest_name: None,
            hls: None,
            output_snap_time: None,
            created: None,
            last_modified: None,
            provisioning_state: None,
            resource_state: None,
        }
    }
}
pub mod live_output_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ResourceState {
        Creating,
        Running,
        Deleting,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Location {
    pub name: String,
}
impl Location {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct MediaFilterProperties {
    #[serde(rename = "presentationTimeRange", default, skip_serializing_if = "Option::is_none")]
    pub presentation_time_range: Option<PresentationTimeRange>,
    #[serde(rename = "firstQuality", default, skip_serializing_if = "Option::is_none")]
    pub first_quality: Option<FirstQuality>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tracks: Vec<FilterTrackSelection>,
}
impl MediaFilterProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct MediaService {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<MediaServiceProperties>,
}
impl MediaService {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct MediaServiceCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<MediaService>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl MediaServiceCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct MediaServiceProperties {
    #[serde(rename = "mediaServiceId", default, skip_serializing_if = "Option::is_none")]
    pub media_service_id: Option<String>,
    #[serde(rename = "storageAccounts", default, skip_serializing_if = "Vec::is_empty")]
    pub storage_accounts: Vec<StorageAccount>,
}
impl MediaServiceProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Metric {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "displayDescription", default, skip_serializing_if = "Option::is_none")]
    pub display_description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<metric::Unit>,
    #[serde(rename = "aggregationType", default, skip_serializing_if = "Option::is_none")]
    pub aggregation_type: Option<metric::AggregationType>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dimensions: Vec<MetricDimension>,
}
impl Metric {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod metric {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Unit {
        Bytes,
        Count,
        Milliseconds,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AggregationType {
        Average,
        Count,
        Total,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct MetricDimension {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "toBeExportedForShoebox", default, skip_serializing_if = "Option::is_none")]
    pub to_be_exported_for_shoebox: Option<bool>,
}
impl MetricDimension {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct MetricProperties {
    #[serde(rename = "serviceSpecification", default, skip_serializing_if = "Option::is_none")]
    pub service_specification: Option<ServiceSpecification>,
}
impl MetricProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Mp4Format {
    #[serde(flatten)]
    pub multi_bitrate_format: MultiBitrateFormat,
}
impl Mp4Format {
    pub fn new(multi_bitrate_format: MultiBitrateFormat) -> Self {
        Self { multi_bitrate_format }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MultiBitrateFormat {
    #[serde(flatten)]
    pub format: Format,
    #[serde(rename = "outputFiles", default, skip_serializing_if = "Vec::is_empty")]
    pub output_files: Vec<OutputFile>,
}
impl MultiBitrateFormat {
    pub fn new(format: Format) -> Self {
        Self {
            format,
            output_files: Vec::new(),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct NoEncryption {
    #[serde(rename = "enabledProtocols", default, skip_serializing_if = "Option::is_none")]
    pub enabled_protocols: Option<EnabledProtocols>,
}
impl NoEncryption {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ODataError {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<ODataError>,
}
impl ODataError {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Operation {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display: Option<OperationDisplay>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<MetricProperties>,
}
impl Operation {
    pub fn new(name: String) -> Self {
        Self {
            name,
            display: None,
            origin: None,
            properties: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Operation>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl OperationCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationDisplay {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
impl OperationDisplay {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OutputFile {
    pub labels: Vec<String>,
}
impl OutputFile {
    pub fn new(labels: Vec<String>) -> Self {
        Self { labels }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Overlay {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
    #[serde(rename = "inputLabel")]
    pub input_label: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,
    #[serde(rename = "fadeInDuration", default, skip_serializing_if = "Option::is_none")]
    pub fade_in_duration: Option<String>,
    #[serde(rename = "fadeOutDuration", default, skip_serializing_if = "Option::is_none")]
    pub fade_out_duration: Option<String>,
    #[serde(rename = "audioGainLevel", default, skip_serializing_if = "Option::is_none")]
    pub audio_gain_level: Option<f64>,
}
impl Overlay {
    pub fn new(odata_type: String, input_label: String) -> Self {
        Self {
            odata_type,
            input_label,
            start: None,
            end: None,
            fade_in_duration: None,
            fade_out_duration: None,
            audio_gain_level: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PngFormat {
    #[serde(flatten)]
    pub image_format: ImageFormat,
}
impl PngFormat {
    pub fn new(image_format: ImageFormat) -> Self {
        Self { image_format }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PngImage {
    #[serde(flatten)]
    pub image: Image,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub layers: Vec<PngLayer>,
}
impl PngImage {
    pub fn new(image: Image) -> Self {
        Self { image, layers: Vec::new() }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PngLayer {
    #[serde(flatten)]
    pub layer: Layer,
}
impl PngLayer {
    pub fn new(layer: Layer) -> Self {
        Self { layer }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PresentationTimeRange {
    #[serde(rename = "startTimestamp", default, skip_serializing_if = "Option::is_none")]
    pub start_timestamp: Option<i64>,
    #[serde(rename = "endTimestamp", default, skip_serializing_if = "Option::is_none")]
    pub end_timestamp: Option<i64>,
    #[serde(rename = "presentationWindowDuration", default, skip_serializing_if = "Option::is_none")]
    pub presentation_window_duration: Option<i64>,
    #[serde(rename = "liveBackoffDuration", default, skip_serializing_if = "Option::is_none")]
    pub live_backoff_duration: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timescale: Option<i64>,
    #[serde(rename = "forceEndTimestamp", default, skip_serializing_if = "Option::is_none")]
    pub force_end_timestamp: Option<bool>,
}
impl PresentationTimeRange {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Preset {
    #[serde(rename = "@odata.type")]
    pub odata_type: String,
}
impl Preset {
    pub fn new(odata_type: String) -> Self {
        Self { odata_type }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Provider {
    #[serde(rename = "providerName")]
    pub provider_name: String,
}
impl Provider {
    pub fn new(provider_name: String) -> Self {
        Self { provider_name }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ProxyResource {
    #[serde(flatten)]
    pub resource: Resource,
}
impl ProxyResource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Rectangle {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub left: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub top: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<String>,
}
impl Rectangle {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Resource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
impl Resource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ServiceSpecification {
    #[serde(rename = "metricSpecifications", default, skip_serializing_if = "Vec::is_empty")]
    pub metric_specifications: Vec<Metric>,
}
impl ServiceSpecification {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StandardEncoderPreset {
    #[serde(flatten)]
    pub preset: Preset,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filters: Option<Filters>,
    pub codecs: Vec<Codec>,
    pub formats: Vec<Format>,
}
impl StandardEncoderPreset {
    pub fn new(preset: Preset, codecs: Vec<Codec>, formats: Vec<Format>) -> Self {
        Self {
            preset,
            filters: None,
            codecs,
            formats,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StorageAccount {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub type_: storage_account::Type,
}
impl StorageAccount {
    pub fn new(type_: storage_account::Type) -> Self {
        Self { id: None, type_ }
    }
}
pub mod storage_account {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Primary,
        Secondary,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StorageEncryptedAssetDecryptionData {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(rename = "assetFileEncryptionMetadata", default, skip_serializing_if = "Vec::is_empty")]
    pub asset_file_encryption_metadata: Vec<AssetFileEncryptionMetadata>,
}
impl StorageEncryptedAssetDecryptionData {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingEndpoint {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<StreamingEndpointProperties>,
}
impl StreamingEndpoint {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingEndpointAccessControl {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub akamai: Option<AkamaiAccessControl>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<IpAccessControl>,
}
impl StreamingEndpointAccessControl {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingEndpointListResult {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<StreamingEndpoint>,
    #[serde(rename = "@odata.count", default, skip_serializing_if = "Option::is_none")]
    pub odata_count: Option<i32>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl StreamingEndpointListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingEndpointProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "scaleUnits")]
    pub scale_units: i32,
    #[serde(rename = "availabilitySetName", default, skip_serializing_if = "Option::is_none")]
    pub availability_set_name: Option<String>,
    #[serde(rename = "accessControl", default, skip_serializing_if = "Option::is_none")]
    pub access_control: Option<StreamingEndpointAccessControl>,
    #[serde(rename = "maxCacheAge", default, skip_serializing_if = "Option::is_none")]
    pub max_cache_age: Option<i64>,
    #[serde(rename = "customHostNames", default, skip_serializing_if = "Vec::is_empty")]
    pub custom_host_names: Vec<String>,
    #[serde(rename = "hostName", default, skip_serializing_if = "Option::is_none")]
    pub host_name: Option<String>,
    #[serde(rename = "cdnEnabled", default, skip_serializing_if = "Option::is_none")]
    pub cdn_enabled: Option<bool>,
    #[serde(rename = "cdnProvider", default, skip_serializing_if = "Option::is_none")]
    pub cdn_provider: Option<String>,
    #[serde(rename = "cdnProfile", default, skip_serializing_if = "Option::is_none")]
    pub cdn_profile: Option<String>,
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[serde(rename = "resourceState", default, skip_serializing_if = "Option::is_none")]
    pub resource_state: Option<streaming_endpoint_properties::ResourceState>,
    #[serde(rename = "crossSiteAccessPolicies", default, skip_serializing_if = "Option::is_none")]
    pub cross_site_access_policies: Option<CrossSiteAccessPolicies>,
    #[serde(rename = "freeTrialEndTime", default, skip_serializing_if = "Option::is_none")]
    pub free_trial_end_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(rename = "lastModified", default, skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<String>,
}
impl StreamingEndpointProperties {
    pub fn new(scale_units: i32) -> Self {
        Self {
            description: None,
            scale_units,
            availability_set_name: None,
            access_control: None,
            max_cache_age: None,
            custom_host_names: Vec::new(),
            host_name: None,
            cdn_enabled: None,
            cdn_provider: None,
            cdn_profile: None,
            provisioning_state: None,
            resource_state: None,
            cross_site_access_policies: None,
            free_trial_end_time: None,
            created: None,
            last_modified: None,
        }
    }
}
pub mod streaming_endpoint_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ResourceState {
        Stopped,
        Starting,
        Running,
        Stopping,
        Deleting,
        Scaling,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingEntityScaleUnit {
    #[serde(rename = "scaleUnit", default, skip_serializing_if = "Option::is_none")]
    pub scale_unit: Option<i32>,
}
impl StreamingEntityScaleUnit {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingLocator {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<StreamingLocatorProperties>,
}
impl StreamingLocator {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingLocatorCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<StreamingLocator>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl StreamingLocatorCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingLocatorContentKey {
    pub id: String,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<streaming_locator_content_key::Type>,
    #[serde(rename = "labelReferenceInStreamingPolicy", default, skip_serializing_if = "Option::is_none")]
    pub label_reference_in_streaming_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(rename = "policyName", default, skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tracks: Vec<TrackSelection>,
}
impl StreamingLocatorContentKey {
    pub fn new(id: String) -> Self {
        Self {
            id,
            type_: None,
            label_reference_in_streaming_policy: None,
            value: None,
            policy_name: None,
            tracks: Vec::new(),
        }
    }
}
pub mod streaming_locator_content_key {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        CommonEncryptionCenc,
        CommonEncryptionCbcs,
        EnvelopeEncryption,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingLocatorProperties {
    #[serde(rename = "assetName")]
    pub asset_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", default, skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "streamingLocatorId", default, skip_serializing_if = "Option::is_none")]
    pub streaming_locator_id: Option<String>,
    #[serde(rename = "streamingPolicyName")]
    pub streaming_policy_name: String,
    #[serde(rename = "defaultContentKeyPolicyName", default, skip_serializing_if = "Option::is_none")]
    pub default_content_key_policy_name: Option<String>,
    #[serde(rename = "contentKeys", default, skip_serializing_if = "Vec::is_empty")]
    pub content_keys: Vec<StreamingLocatorContentKey>,
    #[serde(rename = "alternativeMediaId", default, skip_serializing_if = "Option::is_none")]
    pub alternative_media_id: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub filters: Vec<String>,
}
impl StreamingLocatorProperties {
    pub fn new(asset_name: String, streaming_policy_name: String) -> Self {
        Self {
            asset_name,
            created: None,
            start_time: None,
            end_time: None,
            streaming_locator_id: None,
            streaming_policy_name,
            default_content_key_policy_name: None,
            content_keys: Vec::new(),
            alternative_media_id: None,
            filters: Vec::new(),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPath {
    #[serde(rename = "streamingProtocol")]
    pub streaming_protocol: streaming_path::StreamingProtocol,
    #[serde(rename = "encryptionScheme")]
    pub encryption_scheme: streaming_path::EncryptionScheme,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub paths: Vec<String>,
}
impl StreamingPath {
    pub fn new(streaming_protocol: streaming_path::StreamingProtocol, encryption_scheme: streaming_path::EncryptionScheme) -> Self {
        Self {
            streaming_protocol,
            encryption_scheme,
            paths: Vec::new(),
        }
    }
}
pub mod streaming_path {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StreamingProtocol {
        Hls,
        Dash,
        SmoothStreaming,
        Download,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EncryptionScheme {
        NoEncryption,
        EnvelopeEncryption,
        CommonEncryptionCenc,
        CommonEncryptionCbcs,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<StreamingPolicyProperties>,
}
impl StreamingPolicy {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingPolicyCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<StreamingPolicy>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl StreamingPolicyCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingPolicyContentKey {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "policyName", default, skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tracks: Vec<TrackSelection>,
}
impl StreamingPolicyContentKey {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingPolicyContentKeys {
    #[serde(rename = "defaultKey", default, skip_serializing_if = "Option::is_none")]
    pub default_key: Option<DefaultKey>,
    #[serde(rename = "keyToTrackMappings", default, skip_serializing_if = "Vec::is_empty")]
    pub key_to_track_mappings: Vec<StreamingPolicyContentKey>,
}
impl StreamingPolicyContentKeys {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StreamingPolicyFairPlayConfiguration {
    #[serde(rename = "customLicenseAcquisitionUrlTemplate", default, skip_serializing_if = "Option::is_none")]
    pub custom_license_acquisition_url_template: Option<String>,
    #[serde(rename = "allowPersistentLicense")]
    pub allow_persistent_license: bool,
}
impl StreamingPolicyFairPlayConfiguration {
    pub fn new(allow_persistent_license: bool) -> Self {
        Self {
            custom_license_acquisition_url_template: None,
            allow_persistent_license,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingPolicyPlayReadyConfiguration {
    #[serde(rename = "customLicenseAcquisitionUrlTemplate", default, skip_serializing_if = "Option::is_none")]
    pub custom_license_acquisition_url_template: Option<String>,
    #[serde(rename = "playReadyCustomAttributes", default, skip_serializing_if = "Option::is_none")]
    pub play_ready_custom_attributes: Option<String>,
}
impl StreamingPolicyPlayReadyConfiguration {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingPolicyProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(rename = "defaultContentKeyPolicyName", default, skip_serializing_if = "Option::is_none")]
    pub default_content_key_policy_name: Option<String>,
    #[serde(rename = "envelopeEncryption", default, skip_serializing_if = "Option::is_none")]
    pub envelope_encryption: Option<EnvelopeEncryption>,
    #[serde(rename = "commonEncryptionCenc", default, skip_serializing_if = "Option::is_none")]
    pub common_encryption_cenc: Option<CommonEncryptionCenc>,
    #[serde(rename = "commonEncryptionCbcs", default, skip_serializing_if = "Option::is_none")]
    pub common_encryption_cbcs: Option<CommonEncryptionCbcs>,
    #[serde(rename = "noEncryption", default, skip_serializing_if = "Option::is_none")]
    pub no_encryption: Option<NoEncryption>,
}
impl StreamingPolicyProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct StreamingPolicyWidevineConfiguration {
    #[serde(rename = "customLicenseAcquisitionUrlTemplate", default, skip_serializing_if = "Option::is_none")]
    pub custom_license_acquisition_url_template: Option<String>,
}
impl StreamingPolicyWidevineConfiguration {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct SubscriptionMediaService {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<MediaServiceProperties>,
}
impl SubscriptionMediaService {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct SubscriptionMediaServiceCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<SubscriptionMediaService>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl SubscriptionMediaServiceCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct SyncStorageKeysInput {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
impl SyncStorageKeysInput {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrackPropertyCondition {
    pub property: track_property_condition::Property,
    pub operation: track_property_condition::Operation,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
impl TrackPropertyCondition {
    pub fn new(property: track_property_condition::Property, operation: track_property_condition::Operation) -> Self {
        Self {
            property,
            operation,
            value: None,
        }
    }
}
pub mod track_property_condition {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Property {
        Unknown,
        #[serde(rename = "FourCC")]
        FourCc,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Operation {
        Unknown,
        Equal,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct TrackSelection {
    #[serde(rename = "trackSelections", default, skip_serializing_if = "Vec::is_empty")]
    pub track_selections: Vec<TrackPropertyCondition>,
}
impl TrackSelection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct TrackedResource {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
}
impl TrackedResource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Transform {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<TransformProperties>,
}
impl Transform {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct TransformCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Transform>,
    #[serde(rename = "@odata.nextLink", default, skip_serializing_if = "Option::is_none")]
    pub odata_next_link: Option<String>,
}
impl TransformCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransformOutput {
    #[serde(rename = "onError", default, skip_serializing_if = "Option::is_none")]
    pub on_error: Option<transform_output::OnError>,
    #[serde(rename = "relativePriority", default, skip_serializing_if = "Option::is_none")]
    pub relative_priority: Option<transform_output::RelativePriority>,
    pub preset: Preset,
}
impl TransformOutput {
    pub fn new(preset: Preset) -> Self {
        Self {
            on_error: None,
            relative_priority: None,
            preset,
        }
    }
}
pub mod transform_output {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OnError {
        StopProcessingJob,
        ContinueJob,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RelativePriority {
        Low,
        Normal,
        High,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransformProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub created: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "lastModified", default, skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<String>,
    pub outputs: Vec<TransformOutput>,
}
impl TransformProperties {
    pub fn new(outputs: Vec<TransformOutput>) -> Self {
        Self {
            created: None,
            description: None,
            last_modified: None,
            outputs,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransportStreamFormat {
    #[serde(flatten)]
    pub multi_bitrate_format: MultiBitrateFormat,
}
impl TransportStreamFormat {
    pub fn new(multi_bitrate_format: MultiBitrateFormat) -> Self {
        Self { multi_bitrate_format }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Video {
    #[serde(flatten)]
    pub codec: Codec,
    #[serde(rename = "keyFrameInterval", default, skip_serializing_if = "Option::is_none")]
    pub key_frame_interval: Option<String>,
    #[serde(rename = "stretchMode", default, skip_serializing_if = "Option::is_none")]
    pub stretch_mode: Option<video::StretchMode>,
}
impl Video {
    pub fn new(codec: Codec) -> Self {
        Self {
            codec,
            key_frame_interval: None,
            stretch_mode: None,
        }
    }
}
pub mod video {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StretchMode {
        None,
        AutoSize,
        AutoFit,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoAnalyzerPreset {
    #[serde(flatten)]
    pub audio_analyzer_preset: AudioAnalyzerPreset,
    #[serde(rename = "insightsToExtract", default, skip_serializing_if = "Option::is_none")]
    pub insights_to_extract: Option<video_analyzer_preset::InsightsToExtract>,
}
impl VideoAnalyzerPreset {
    pub fn new(audio_analyzer_preset: AudioAnalyzerPreset) -> Self {
        Self {
            audio_analyzer_preset,
            insights_to_extract: None,
        }
    }
}
pub mod video_analyzer_preset {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum InsightsToExtract {
        AudioInsightsOnly,
        VideoInsightsOnly,
        AllInsights,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoLayer {
    #[serde(flatten)]
    pub layer: Layer,
    pub bitrate: i32,
    #[serde(rename = "maxBitrate", default, skip_serializing_if = "Option::is_none")]
    pub max_bitrate: Option<i32>,
    #[serde(rename = "bFrames", default, skip_serializing_if = "Option::is_none")]
    pub b_frames: Option<i32>,
    #[serde(rename = "frameRate", default, skip_serializing_if = "Option::is_none")]
    pub frame_rate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slices: Option<i32>,
    #[serde(rename = "adaptiveBFrame", default, skip_serializing_if = "Option::is_none")]
    pub adaptive_b_frame: Option<bool>,
}
impl VideoLayer {
    pub fn new(layer: Layer, bitrate: i32) -> Self {
        Self {
            layer,
            bitrate,
            max_bitrate: None,
            b_frames: None,
            frame_rate: None,
            slices: None,
            adaptive_b_frame: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoOverlay {
    #[serde(flatten)]
    pub overlay: Overlay,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<Rectangle>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<f64>,
    #[serde(rename = "cropRectangle", default, skip_serializing_if = "Option::is_none")]
    pub crop_rectangle: Option<Rectangle>,
}
impl VideoOverlay {
    pub fn new(overlay: Overlay) -> Self {
        Self {
            overlay,
            position: None,
            opacity: None,
            crop_rectangle: None,
        }
    }
}
