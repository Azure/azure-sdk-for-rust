#![doc = "generated by AutoRust"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AccessPolicyEntity {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<AccessPolicyProperties>,
}
impl AccessPolicyEntity {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AccessPolicyEntityCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AccessPolicyEntity>,
    #[serde(rename = "@nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl AccessPolicyEntityCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AccessPolicyProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<access_policy_properties::Role>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<AuthenticationBase>,
}
impl AccessPolicyProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod access_policy_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Role {
        Reader,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AccountEncryption {
    #[serde(rename = "type")]
    pub type_: account_encryption::Type,
    #[serde(rename = "keyVaultProperties", default, skip_serializing_if = "Option::is_none")]
    pub key_vault_properties: Option<KeyVaultProperties>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<ResourceIdentity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}
impl AccountEncryption {
    pub fn new(type_: account_encryption::Type) -> Self {
        Self {
            type_,
            key_vault_properties: None,
            identity: None,
            status: None,
        }
    }
}
pub mod account_encryption {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        SystemKey,
        CustomerKey,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AudioEncoderAac {
    #[serde(flatten)]
    pub audio_encoder_base: AudioEncoderBase,
}
impl AudioEncoderAac {
    pub fn new(audio_encoder_base: AudioEncoderBase) -> Self {
        Self { audio_encoder_base }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AudioEncoderBase {
    #[serde(rename = "@type")]
    pub type_: String,
    #[serde(rename = "bitrateKbps", default, skip_serializing_if = "Option::is_none")]
    pub bitrate_kbps: Option<String>,
}
impl AudioEncoderBase {
    pub fn new(type_: String) -> Self {
        Self { type_, bitrate_kbps: None }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AuthenticationBase {
    #[serde(rename = "@type")]
    pub type_: String,
}
impl AuthenticationBase {
    pub fn new(type_: String) -> Self {
        Self { type_ }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CertificateSource {
    #[serde(rename = "@type")]
    pub type_: String,
}
impl CertificateSource {
    pub fn new(type_: String) -> Self {
        Self { type_ }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CheckNameAvailabilityRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
impl CheckNameAvailabilityRequest {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CheckNameAvailabilityResponse {
    #[serde(rename = "nameAvailable", default, skip_serializing_if = "Option::is_none")]
    pub name_available: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<check_name_availability_response::Reason>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl CheckNameAvailabilityResponse {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod check_name_availability_response {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Reason {
        Invalid,
        AlreadyExists,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CredentialsBase {
    #[serde(rename = "@type")]
    pub type_: String,
}
impl CredentialsBase {
    pub fn new(type_: String) -> Self {
        Self { type_ }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EccTokenKey {
    #[serde(flatten)]
    pub token_key: TokenKey,
    pub alg: ecc_token_key::Alg,
    pub x: String,
    pub y: String,
}
impl EccTokenKey {
    pub fn new(token_key: TokenKey, alg: ecc_token_key::Alg, x: String, y: String) -> Self {
        Self { token_key, alg, x, y }
    }
}
pub mod ecc_token_key {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Alg {
        #[serde(rename = "ES256")]
        Es256,
        #[serde(rename = "ES384")]
        Es384,
        #[serde(rename = "ES512")]
        Es512,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct EdgeModuleEntity {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<EdgeModuleProperties>,
}
impl EdgeModuleEntity {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct EdgeModuleEntityCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<EdgeModuleEntity>,
    #[serde(rename = "@nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl EdgeModuleEntityCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct EdgeModuleProperties {
    #[serde(rename = "edgeModuleId", default, skip_serializing_if = "Option::is_none")]
    pub edge_module_id: Option<String>,
}
impl EdgeModuleProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct EdgeModuleProvisioningToken {
    #[serde(rename = "expirationDate", default, skip_serializing_if = "Option::is_none")]
    pub expiration_date: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
}
impl EdgeModuleProvisioningToken {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EncoderCustomPreset {
    #[serde(flatten)]
    pub encoder_preset_base: EncoderPresetBase,
    #[serde(rename = "audioEncoder", default, skip_serializing_if = "Option::is_none")]
    pub audio_encoder: Option<AudioEncoderBase>,
    #[serde(rename = "videoEncoder", default, skip_serializing_if = "Option::is_none")]
    pub video_encoder: Option<VideoEncoderBase>,
}
impl EncoderCustomPreset {
    pub fn new(encoder_preset_base: EncoderPresetBase) -> Self {
        Self {
            encoder_preset_base,
            audio_encoder: None,
            video_encoder: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EncoderPresetBase {
    #[serde(rename = "@type")]
    pub type_: String,
}
impl EncoderPresetBase {
    pub fn new(type_: String) -> Self {
        Self { type_ }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EncoderProcessor {
    #[serde(flatten)]
    pub processor_node_base: ProcessorNodeBase,
    pub preset: EncoderPresetBase,
}
impl EncoderProcessor {
    pub fn new(processor_node_base: ProcessorNodeBase, preset: EncoderPresetBase) -> Self {
        Self {
            processor_node_base,
            preset,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EncoderSystemPreset {
    #[serde(flatten)]
    pub encoder_preset_base: EncoderPresetBase,
    pub name: encoder_system_preset::Name,
}
impl EncoderSystemPreset {
    pub fn new(encoder_preset_base: EncoderPresetBase, name: encoder_system_preset::Name) -> Self {
        Self { encoder_preset_base, name }
    }
}
pub mod encoder_system_preset {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        #[serde(rename = "SingleLayer_540p_H264_AAC")]
        SingleLayer540pH264Aac,
        #[serde(rename = "SingleLayer_720p_H264_AAC")]
        SingleLayer720pH264Aac,
        #[serde(rename = "SingleLayer_1080p_H264_AAC")]
        SingleLayer1080pH264Aac,
        #[serde(rename = "SingleLayer_2160p_H264_AAC")]
        SingleLayer2160pH264Aac,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Endpoint {
    #[serde(rename = "endpointUrl", default, skip_serializing_if = "Option::is_none")]
    pub endpoint_url: Option<String>,
    #[serde(rename = "type")]
    pub type_: endpoint::Type,
}
impl Endpoint {
    pub fn new(type_: endpoint::Type) -> Self {
        Self { endpoint_url: None, type_ }
    }
}
pub mod endpoint {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        ClientApi,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EndpointBase {
    #[serde(rename = "@type")]
    pub type_: String,
    pub credentials: CredentialsBase,
    pub url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tunnel: Option<TunnelBase>,
}
impl EndpointBase {
    pub fn new(type_: String, credentials: CredentialsBase, url: String) -> Self {
        Self {
            type_,
            credentials,
            url,
            tunnel: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ErrorAdditionalInfo {
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub info: Option<serde_json::Value>,
}
impl ErrorAdditionalInfo {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ErrorDetail {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<ErrorDetail>,
    #[serde(rename = "additionalInfo", default, skip_serializing_if = "Vec::is_empty")]
    pub additional_info: Vec<ErrorAdditionalInfo>,
}
impl ErrorDetail {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ErrorResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,
}
impl ErrorResponse {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct GroupLevelAccessControl {
    #[serde(rename = "publicNetworkAccess", default, skip_serializing_if = "Option::is_none")]
    pub public_network_access: Option<group_level_access_control::PublicNetworkAccess>,
}
impl GroupLevelAccessControl {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod group_level_access_control {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PublicNetworkAccess {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IotHub {
    pub id: String,
    pub identity: ResourceIdentity,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}
impl IotHub {
    pub fn new(id: String, identity: ResourceIdentity) -> Self {
        Self {
            id,
            identity,
            status: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JwtAuthentication {
    #[serde(flatten)]
    pub authentication_base: AuthenticationBase,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub issuers: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub audiences: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub claims: Vec<TokenClaim>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub keys: Vec<TokenKey>,
}
impl JwtAuthentication {
    pub fn new(authentication_base: AuthenticationBase) -> Self {
        Self {
            authentication_base,
            issuers: Vec::new(),
            audiences: Vec::new(),
            claims: Vec::new(),
            keys: Vec::new(),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct KeyVaultProperties {
    #[serde(rename = "keyIdentifier")]
    pub key_identifier: String,
    #[serde(rename = "currentKeyIdentifier", default, skip_serializing_if = "Option::is_none")]
    pub current_key_identifier: Option<String>,
}
impl KeyVaultProperties {
    pub fn new(key_identifier: String) -> Self {
        Self {
            key_identifier,
            current_key_identifier: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListProvisioningTokenInput {
    #[serde(rename = "expirationDate")]
    pub expiration_date: String,
}
impl ListProvisioningTokenInput {
    pub fn new(expiration_date: String) -> Self {
        Self { expiration_date }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LivePipeline {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<LivePipelineProperties>,
}
impl LivePipeline {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LivePipelineCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LivePipeline>,
    #[serde(rename = "@nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl LivePipelineCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LivePipelineOperationStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,
}
impl LivePipelineOperationStatus {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineProperties {
    #[serde(rename = "topologyName")]
    pub topology_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "bitrateKbps")]
    pub bitrate_kbps: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<live_pipeline_properties::State>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<ParameterDefinition>,
}
impl LivePipelineProperties {
    pub fn new(topology_name: String, bitrate_kbps: i32) -> Self {
        Self {
            topology_name,
            description: None,
            bitrate_kbps,
            state: None,
            parameters: Vec::new(),
        }
    }
}
pub mod live_pipeline_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Inactive,
        Activating,
        Active,
        Deactivating,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LivePipelinePropertiesUpdate {
    #[serde(rename = "topologyName", default, skip_serializing_if = "Option::is_none")]
    pub topology_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "bitrateKbps", default, skip_serializing_if = "Option::is_none")]
    pub bitrate_kbps: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<live_pipeline_properties_update::State>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<ParameterDefinition>,
}
impl LivePipelinePropertiesUpdate {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod live_pipeline_properties_update {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Inactive,
        Activating,
        Active,
        Deactivating,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LivePipelineUpdate {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<LivePipelinePropertiesUpdate>,
}
impl LivePipelineUpdate {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LogSpecification {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "blobDuration", default, skip_serializing_if = "Option::is_none")]
    pub blob_duration: Option<String>,
}
impl LogSpecification {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct MetricDimension {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "toBeExportedForShoebox", default, skip_serializing_if = "Option::is_none")]
    pub to_be_exported_for_shoebox: Option<bool>,
}
impl MetricDimension {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct MetricSpecification {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "displayDescription", default, skip_serializing_if = "Option::is_none")]
    pub display_description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<metric_specification::Unit>,
    #[serde(rename = "aggregationType", default, skip_serializing_if = "Option::is_none")]
    pub aggregation_type: Option<metric_specification::AggregationType>,
    #[serde(rename = "lockAggregationType", default, skip_serializing_if = "Option::is_none")]
    pub lock_aggregation_type: Option<metric_specification::LockAggregationType>,
    #[serde(rename = "supportedAggregationTypes", default, skip_serializing_if = "Vec::is_empty")]
    pub supported_aggregation_types: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dimensions: Vec<MetricDimension>,
    #[serde(rename = "enableRegionalMdmAccount", default, skip_serializing_if = "Option::is_none")]
    pub enable_regional_mdm_account: Option<bool>,
    #[serde(rename = "sourceMdmAccount", default, skip_serializing_if = "Option::is_none")]
    pub source_mdm_account: Option<String>,
    #[serde(rename = "sourceMdmNamespace", default, skip_serializing_if = "Option::is_none")]
    pub source_mdm_namespace: Option<String>,
    #[serde(rename = "supportedTimeGrainTypes", default, skip_serializing_if = "Vec::is_empty")]
    pub supported_time_grain_types: Vec<String>,
}
impl MetricSpecification {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod metric_specification {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Unit {
        Bytes,
        Count,
        Milliseconds,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AggregationType {
        Average,
        Count,
        Total,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LockAggregationType {
        Average,
        Count,
        Total,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct NetworkAccessControl {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub integration: Option<GroupLevelAccessControl>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingestion: Option<GroupLevelAccessControl>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consumption: Option<GroupLevelAccessControl>,
}
impl NetworkAccessControl {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NodeBase {
    #[serde(rename = "@type")]
    pub type_: String,
    pub name: String,
}
impl NodeBase {
    pub fn new(type_: String, name: String) -> Self {
        Self { type_, name }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NodeInput {
    #[serde(rename = "nodeName")]
    pub node_name: String,
}
impl NodeInput {
    pub fn new(node_name: String) -> Self {
        Self { node_name }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Operation {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display: Option<OperationDisplay>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<Properties>,
    #[serde(rename = "isDataAction", default, skip_serializing_if = "Option::is_none")]
    pub is_data_action: Option<bool>,
    #[serde(rename = "actionType", default, skip_serializing_if = "Option::is_none")]
    pub action_type: Option<operation::ActionType>,
}
impl Operation {
    pub fn new(name: String) -> Self {
        Self {
            name,
            display: None,
            origin: None,
            properties: None,
            is_data_action: None,
            action_type: None,
        }
    }
}
pub mod operation {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ActionType {
        Internal,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Operation>,
}
impl OperationCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationDisplay {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
impl OperationDisplay {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParameterDeclaration {
    pub name: String,
    #[serde(rename = "type")]
    pub type_: parameter_declaration::Type,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<String>,
}
impl ParameterDeclaration {
    pub fn new(name: String, type_: parameter_declaration::Type) -> Self {
        Self {
            name,
            type_,
            description: None,
            default: None,
        }
    }
}
pub mod parameter_declaration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        String,
        SecretString,
        Int,
        Double,
        Bool,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParameterDefinition {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
impl ParameterDefinition {
    pub fn new(name: String) -> Self {
        Self { name, value: None }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PemCertificateList {
    #[serde(flatten)]
    pub certificate_source: CertificateSource,
    pub certificates: Vec<String>,
}
impl PemCertificateList {
    pub fn new(certificate_source: CertificateSource, certificates: Vec<String>) -> Self {
        Self {
            certificate_source,
            certificates,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineJob {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<PipelineJobProperties>,
}
impl PipelineJob {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineJobCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PipelineJob>,
    #[serde(rename = "@nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl PipelineJobCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineJobError {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl PipelineJobError {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineJobOperationStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,
}
impl PipelineJobOperationStatus {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineJobProperties {
    #[serde(rename = "topologyName")]
    pub topology_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<pipeline_job_properties::State>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expiration: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<PipelineJobError>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<ParameterDefinition>,
}
impl PipelineJobProperties {
    pub fn new(topology_name: String) -> Self {
        Self {
            topology_name,
            description: None,
            state: None,
            expiration: None,
            error: None,
            parameters: Vec::new(),
        }
    }
}
pub mod pipeline_job_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Processing,
        Canceled,
        Completed,
        Failed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineJobPropertiesUpdate {
    #[serde(rename = "topologyName", default, skip_serializing_if = "Option::is_none")]
    pub topology_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<pipeline_job_properties_update::State>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expiration: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<PipelineJobError>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<ParameterDefinition>,
}
impl PipelineJobPropertiesUpdate {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod pipeline_job_properties_update {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Processing,
        Canceled,
        Completed,
        Failed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineJobUpdate {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<PipelineJobPropertiesUpdate>,
}
impl PipelineJobUpdate {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopology {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<PipelineTopologyProperties>,
    pub kind: pipeline_topology::Kind,
    pub sku: Sku,
}
impl PipelineTopology {
    pub fn new(kind: pipeline_topology::Kind, sku: Sku) -> Self {
        Self {
            proxy_resource: ProxyResource::default(),
            properties: None,
            kind,
            sku,
        }
    }
}
pub mod pipeline_topology {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Kind {
        Live,
        Batch,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineTopologyCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PipelineTopology>,
    #[serde(rename = "@nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl PipelineTopologyCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopologyProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<ParameterDeclaration>,
    pub sources: Vec<SourceNodeBase>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub processors: Vec<ProcessorNodeBase>,
    pub sinks: Vec<SinkNodeBase>,
}
impl PipelineTopologyProperties {
    pub fn new(sources: Vec<SourceNodeBase>, sinks: Vec<SinkNodeBase>) -> Self {
        Self {
            description: None,
            parameters: Vec::new(),
            sources,
            processors: Vec::new(),
            sinks,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineTopologyPropertiesUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<ParameterDeclaration>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub sources: Vec<SourceNodeBase>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub processors: Vec<ProcessorNodeBase>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub sinks: Vec<SinkNodeBase>,
}
impl PipelineTopologyPropertiesUpdate {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PipelineTopologyUpdate {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<PipelineTopologyPropertiesUpdate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<pipeline_topology_update::Kind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sku: Option<Sku>,
}
impl PipelineTopologyUpdate {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod pipeline_topology_update {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Kind {
        Live,
        Batch,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateEndpoint {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
impl PrivateEndpoint {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateEndpointConnection {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateEndpointConnectionProperties>,
}
impl PrivateEndpointConnection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateEndpointConnectionListResult {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateEndpointConnection>,
}
impl PrivateEndpointConnectionListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnectionProperties {
    #[serde(rename = "privateEndpoint", default, skip_serializing_if = "Option::is_none")]
    pub private_endpoint: Option<PrivateEndpoint>,
    #[serde(rename = "privateLinkServiceConnectionState")]
    pub private_link_service_connection_state: PrivateLinkServiceConnectionState,
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<PrivateEndpointConnectionProvisioningState>,
}
impl PrivateEndpointConnectionProperties {
    pub fn new(private_link_service_connection_state: PrivateLinkServiceConnectionState) -> Self {
        Self {
            private_endpoint: None,
            private_link_service_connection_state,
            provisioning_state: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum PrivateEndpointConnectionProvisioningState {
    Succeeded,
    Creating,
    Deleting,
    Failed,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum PrivateEndpointServiceConnectionStatus {
    Pending,
    Approved,
    Rejected,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateLinkResource {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateLinkResourceProperties>,
}
impl PrivateLinkResource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateLinkResourceListResult {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateLinkResource>,
}
impl PrivateLinkResourceListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateLinkResourceProperties {
    #[serde(rename = "groupId", default, skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,
    #[serde(rename = "requiredMembers", default, skip_serializing_if = "Vec::is_empty")]
    pub required_members: Vec<String>,
    #[serde(rename = "requiredZoneNames", default, skip_serializing_if = "Vec::is_empty")]
    pub required_zone_names: Vec<String>,
}
impl PrivateLinkResourceProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateLinkServiceConnectionState {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<PrivateEndpointServiceConnectionStatus>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "actionsRequired", default, skip_serializing_if = "Option::is_none")]
    pub actions_required: Option<String>,
}
impl PrivateLinkServiceConnectionState {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ProcessorNodeBase {
    #[serde(flatten)]
    pub node_base: NodeBase,
    #[serde(rename = "@type")]
    pub type_: String,
    pub inputs: Vec<NodeInput>,
}
impl ProcessorNodeBase {
    pub fn new(node_base: NodeBase, type_: String, inputs: Vec<NodeInput>) -> Self {
        Self { node_base, type_, inputs }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Properties {
    #[serde(rename = "serviceSpecification", default, skip_serializing_if = "Option::is_none")]
    pub service_specification: Option<ServiceSpecification>,
}
impl Properties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ProxyResource {
    #[serde(flatten)]
    pub resource: Resource,
}
impl ProxyResource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct Resource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[serde(rename = "systemData", default, skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,
}
impl Resource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResourceIdentity {
    #[serde(rename = "userAssignedIdentity")]
    pub user_assigned_identity: String,
}
impl ResourceIdentity {
    pub fn new(user_assigned_identity: String) -> Self {
        Self { user_assigned_identity }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RsaTokenKey {
    #[serde(flatten)]
    pub token_key: TokenKey,
    pub alg: rsa_token_key::Alg,
    pub n: String,
    pub e: String,
}
impl RsaTokenKey {
    pub fn new(token_key: TokenKey, alg: rsa_token_key::Alg, n: String, e: String) -> Self {
        Self { token_key, alg, n, e }
    }
}
pub mod rsa_token_key {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Alg {
        #[serde(rename = "RS256")]
        Rs256,
        #[serde(rename = "RS384")]
        Rs384,
        #[serde(rename = "RS512")]
        Rs512,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RtspSource {
    #[serde(flatten)]
    pub source_node_base: SourceNodeBase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transport: Option<rtsp_source::Transport>,
    pub endpoint: EndpointBase,
}
impl RtspSource {
    pub fn new(source_node_base: SourceNodeBase, endpoint: EndpointBase) -> Self {
        Self {
            source_node_base,
            transport: None,
            endpoint,
        }
    }
}
pub mod rtsp_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Transport {
        Http,
        Tcp,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecureIotDeviceRemoteTunnel {
    #[serde(flatten)]
    pub tunnel_base: TunnelBase,
    #[serde(rename = "iotHubName")]
    pub iot_hub_name: String,
    #[serde(rename = "deviceId")]
    pub device_id: String,
}
impl SecureIotDeviceRemoteTunnel {
    pub fn new(tunnel_base: TunnelBase, iot_hub_name: String, device_id: String) -> Self {
        Self {
            tunnel_base,
            iot_hub_name,
            device_id,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ServiceSpecification {
    #[serde(rename = "logSpecifications", default, skip_serializing_if = "Vec::is_empty")]
    pub log_specifications: Vec<LogSpecification>,
    #[serde(rename = "metricSpecifications", default, skip_serializing_if = "Vec::is_empty")]
    pub metric_specifications: Vec<MetricSpecification>,
}
impl ServiceSpecification {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SinkNodeBase {
    #[serde(flatten)]
    pub node_base: NodeBase,
    #[serde(rename = "@type")]
    pub type_: String,
    pub inputs: Vec<NodeInput>,
}
impl SinkNodeBase {
    pub fn new(node_base: NodeBase, type_: String, inputs: Vec<NodeInput>) -> Self {
        Self { node_base, type_, inputs }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Sku {
    pub name: sku::Name,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tier: Option<sku::Tier>,
}
impl Sku {
    pub fn new(name: sku::Name) -> Self {
        Self { name, tier: None }
    }
}
pub mod sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        #[serde(rename = "Live_S1")]
        LiveS1,
        #[serde(rename = "Batch_S1")]
        BatchS1,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Standard,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SourceNodeBase {
    #[serde(flatten)]
    pub node_base: NodeBase,
    #[serde(rename = "@type")]
    pub type_: String,
}
impl SourceNodeBase {
    pub fn new(node_base: NodeBase, type_: String) -> Self {
        Self { node_base, type_ }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StorageAccount {
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<ResourceIdentity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}
impl StorageAccount {
    pub fn new(id: String) -> Self {
        Self {
            id,
            identity: None,
            status: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TimeSequenceBase {
    #[serde(rename = "@type")]
    pub type_: String,
}
impl TimeSequenceBase {
    pub fn new(type_: String) -> Self {
        Self { type_ }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TlsEndpoint {
    #[serde(flatten)]
    pub endpoint_base: EndpointBase,
    #[serde(rename = "trustedCertificates", default, skip_serializing_if = "Option::is_none")]
    pub trusted_certificates: Option<CertificateSource>,
    #[serde(rename = "validationOptions", default, skip_serializing_if = "Option::is_none")]
    pub validation_options: Option<TlsValidationOptions>,
}
impl TlsEndpoint {
    pub fn new(endpoint_base: EndpointBase) -> Self {
        Self {
            endpoint_base,
            trusted_certificates: None,
            validation_options: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct TlsValidationOptions {
    #[serde(rename = "ignoreHostname", default, skip_serializing_if = "Option::is_none")]
    pub ignore_hostname: Option<String>,
    #[serde(rename = "ignoreSignature", default, skip_serializing_if = "Option::is_none")]
    pub ignore_signature: Option<String>,
}
impl TlsValidationOptions {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TokenClaim {
    pub name: String,
    pub value: String,
}
impl TokenClaim {
    pub fn new(name: String, value: String) -> Self {
        Self { name, value }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TokenKey {
    #[serde(rename = "@type")]
    pub type_: String,
    pub kid: String,
}
impl TokenKey {
    pub fn new(type_: String, kid: String) -> Self {
        Self { type_, kid }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrackedResource {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    pub location: String,
}
impl TrackedResource {
    pub fn new(location: String) -> Self {
        Self {
            resource: Resource::default(),
            tags: None,
            location,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TunnelBase {
    #[serde(rename = "@type")]
    pub type_: String,
}
impl TunnelBase {
    pub fn new(type_: String) -> Self {
        Self { type_ }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UnsecuredEndpoint {
    #[serde(flatten)]
    pub endpoint_base: EndpointBase,
}
impl UnsecuredEndpoint {
    pub fn new(endpoint_base: EndpointBase) -> Self {
        Self { endpoint_base }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct UserAssignedManagedIdentities {}
impl UserAssignedManagedIdentities {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct UserAssignedManagedIdentity {
    #[serde(rename = "clientId", default, skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    #[serde(rename = "principalId", default, skip_serializing_if = "Option::is_none")]
    pub principal_id: Option<String>,
}
impl UserAssignedManagedIdentity {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UsernamePasswordCredentials {
    #[serde(flatten)]
    pub credentials_base: CredentialsBase,
    pub username: String,
    pub password: String,
}
impl UsernamePasswordCredentials {
    pub fn new(credentials_base: CredentialsBase, username: String, password: String) -> Self {
        Self {
            credentials_base,
            username,
            password,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoAnalyzer {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<VideoAnalyzerProperties>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<VideoAnalyzerIdentity>,
}
impl VideoAnalyzer {
    pub fn new(tracked_resource: TrackedResource) -> Self {
        Self {
            tracked_resource,
            properties: None,
            identity: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoAnalyzerCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VideoAnalyzer>,
}
impl VideoAnalyzerCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoAnalyzerIdentity {
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "userAssignedIdentities", default, skip_serializing_if = "Option::is_none")]
    pub user_assigned_identities: Option<UserAssignedManagedIdentities>,
}
impl VideoAnalyzerIdentity {
    pub fn new(type_: String) -> Self {
        Self {
            type_,
            user_assigned_identities: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoAnalyzerOperationStatus {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", default, skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,
}
impl VideoAnalyzerOperationStatus {
    pub fn new(name: String) -> Self {
        Self {
            name,
            id: None,
            start_time: None,
            end_time: None,
            status: None,
            error: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoAnalyzerPrivateEndpointConnectionOperationStatus {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", default, skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,
}
impl VideoAnalyzerPrivateEndpointConnectionOperationStatus {
    pub fn new(name: String) -> Self {
        Self {
            name,
            id: None,
            start_time: None,
            end_time: None,
            status: None,
            error: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoAnalyzerProperties {
    #[serde(rename = "storageAccounts")]
    pub storage_accounts: Vec<StorageAccount>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub endpoints: Vec<Endpoint>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption: Option<AccountEncryption>,
    #[serde(rename = "iotHubs", default, skip_serializing_if = "Vec::is_empty")]
    pub iot_hubs: Vec<IotHub>,
    #[serde(rename = "publicNetworkAccess", default, skip_serializing_if = "Option::is_none")]
    pub public_network_access: Option<video_analyzer_properties::PublicNetworkAccess>,
    #[serde(rename = "networkAccessControl", default, skip_serializing_if = "Option::is_none")]
    pub network_access_control: Option<NetworkAccessControl>,
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<video_analyzer_properties::ProvisioningState>,
    #[serde(rename = "privateEndpointConnections", default, skip_serializing_if = "Vec::is_empty")]
    pub private_endpoint_connections: Vec<PrivateEndpointConnection>,
}
impl VideoAnalyzerProperties {
    pub fn new(storage_accounts: Vec<StorageAccount>) -> Self {
        Self {
            storage_accounts,
            endpoints: Vec::new(),
            encryption: None,
            iot_hubs: Vec::new(),
            public_network_access: None,
            network_access_control: None,
            provisioning_state: None,
            private_endpoint_connections: Vec::new(),
        }
    }
}
pub mod video_analyzer_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PublicNetworkAccess {
        Enabled,
        Disabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProvisioningState {
        Failed,
        InProgress,
        Succeeded,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoAnalyzerPropertiesUpdate {
    #[serde(rename = "storageAccounts", default, skip_serializing_if = "Vec::is_empty")]
    pub storage_accounts: Vec<StorageAccount>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub endpoints: Vec<Endpoint>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption: Option<AccountEncryption>,
    #[serde(rename = "iotHubs", default, skip_serializing_if = "Vec::is_empty")]
    pub iot_hubs: Vec<IotHub>,
    #[serde(rename = "publicNetworkAccess", default, skip_serializing_if = "Option::is_none")]
    pub public_network_access: Option<video_analyzer_properties_update::PublicNetworkAccess>,
    #[serde(rename = "networkAccessControl", default, skip_serializing_if = "Option::is_none")]
    pub network_access_control: Option<NetworkAccessControl>,
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<video_analyzer_properties_update::ProvisioningState>,
    #[serde(rename = "privateEndpointConnections", default, skip_serializing_if = "Vec::is_empty")]
    pub private_endpoint_connections: Vec<PrivateEndpointConnection>,
}
impl VideoAnalyzerPropertiesUpdate {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod video_analyzer_properties_update {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PublicNetworkAccess {
        Enabled,
        Disabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProvisioningState {
        Failed,
        InProgress,
        Succeeded,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoAnalyzerUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<VideoAnalyzerPropertiesUpdate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<VideoAnalyzerIdentity>,
}
impl VideoAnalyzerUpdate {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoArchival {
    #[serde(rename = "retentionPeriod", default, skip_serializing_if = "Option::is_none")]
    pub retention_period: Option<String>,
}
impl VideoArchival {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoContentToken {
    #[serde(rename = "expirationDate", default, skip_serializing_if = "Option::is_none")]
    pub expiration_date: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
}
impl VideoContentToken {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoContentUrls {
    #[serde(rename = "downloadUrl", default, skip_serializing_if = "Option::is_none")]
    pub download_url: Option<String>,
    #[serde(rename = "archiveBaseUrl", default, skip_serializing_if = "Option::is_none")]
    pub archive_base_url: Option<String>,
    #[serde(rename = "rtspTunnelUrl", default, skip_serializing_if = "Option::is_none")]
    pub rtsp_tunnel_url: Option<String>,
    #[serde(rename = "previewImageUrls", default, skip_serializing_if = "Option::is_none")]
    pub preview_image_urls: Option<VideoPreviewImageUrls>,
}
impl VideoContentUrls {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoCreationProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "segmentLength", default, skip_serializing_if = "Option::is_none")]
    pub segment_length: Option<String>,
    #[serde(rename = "retentionPeriod", default, skip_serializing_if = "Option::is_none")]
    pub retention_period: Option<String>,
}
impl VideoCreationProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoEncoderBase {
    #[serde(rename = "@type")]
    pub type_: String,
    #[serde(rename = "bitrateKbps", default, skip_serializing_if = "Option::is_none")]
    pub bitrate_kbps: Option<String>,
    #[serde(rename = "frameRate", default, skip_serializing_if = "Option::is_none")]
    pub frame_rate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<VideoScale>,
}
impl VideoEncoderBase {
    pub fn new(type_: String) -> Self {
        Self {
            type_,
            bitrate_kbps: None,
            frame_rate: None,
            scale: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoEncoderH264 {
    #[serde(flatten)]
    pub video_encoder_base: VideoEncoderBase,
}
impl VideoEncoderH264 {
    pub fn new(video_encoder_base: VideoEncoderBase) -> Self {
        Self { video_encoder_base }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoEntity {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<VideoProperties>,
}
impl VideoEntity {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoEntityCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VideoEntity>,
    #[serde(rename = "@nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl VideoEntityCollection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoFlags {
    #[serde(rename = "canStream")]
    pub can_stream: bool,
    #[serde(rename = "hasData")]
    pub has_data: bool,
    #[serde(rename = "isInUse")]
    pub is_in_use: bool,
}
impl VideoFlags {
    pub fn new(can_stream: bool, has_data: bool, is_in_use: bool) -> Self {
        Self {
            can_stream,
            has_data,
            is_in_use,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoMediaInfo {
    #[serde(rename = "segmentLength", default, skip_serializing_if = "Option::is_none")]
    pub segment_length: Option<String>,
}
impl VideoMediaInfo {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoPreviewImageUrls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub small: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub large: Option<String>,
}
impl VideoPreviewImageUrls {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<video_properties::Type>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flags: Option<VideoFlags>,
    #[serde(rename = "contentUrls", default, skip_serializing_if = "Option::is_none")]
    pub content_urls: Option<VideoContentUrls>,
    #[serde(rename = "mediaInfo", default, skip_serializing_if = "Option::is_none")]
    pub media_info: Option<VideoMediaInfo>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archival: Option<VideoArchival>,
}
impl VideoProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod video_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Archive,
        File,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoPublishingOptions {
    #[serde(rename = "disableArchive", default, skip_serializing_if = "Option::is_none")]
    pub disable_archive: Option<String>,
    #[serde(rename = "disableRtspPublishing", default, skip_serializing_if = "Option::is_none")]
    pub disable_rtsp_publishing: Option<String>,
}
impl VideoPublishingOptions {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct VideoScale {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<video_scale::Mode>,
}
impl VideoScale {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod video_scale {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Mode {
        Pad,
        PreserveAspectRatio,
        Stretch,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoSequenceAbsoluteTimeMarkers {
    #[serde(flatten)]
    pub time_sequence_base: TimeSequenceBase,
    pub ranges: String,
}
impl VideoSequenceAbsoluteTimeMarkers {
    pub fn new(time_sequence_base: TimeSequenceBase, ranges: String) -> Self {
        Self {
            time_sequence_base,
            ranges,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoSink {
    #[serde(flatten)]
    pub sink_node_base: SinkNodeBase,
    #[serde(rename = "videoName")]
    pub video_name: String,
    #[serde(rename = "videoCreationProperties", default, skip_serializing_if = "Option::is_none")]
    pub video_creation_properties: Option<VideoCreationProperties>,
    #[serde(rename = "videoPublishingOptions", default, skip_serializing_if = "Option::is_none")]
    pub video_publishing_options: Option<VideoPublishingOptions>,
}
impl VideoSink {
    pub fn new(sink_node_base: SinkNodeBase, video_name: String) -> Self {
        Self {
            sink_node_base,
            video_name,
            video_creation_properties: None,
            video_publishing_options: None,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoSource {
    #[serde(flatten)]
    pub source_node_base: SourceNodeBase,
    #[serde(rename = "videoName")]
    pub video_name: String,
    #[serde(rename = "timeSequences")]
    pub time_sequences: TimeSequenceBase,
}
impl VideoSource {
    pub fn new(source_node_base: SourceNodeBase, video_name: String, time_sequences: TimeSequenceBase) -> Self {
        Self {
            source_node_base,
            video_name,
            time_sequences,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct SystemData {
    #[serde(rename = "createdBy", default, skip_serializing_if = "Option::is_none")]
    pub created_by: Option<String>,
    #[serde(rename = "createdByType", default, skip_serializing_if = "Option::is_none")]
    pub created_by_type: Option<system_data::CreatedByType>,
    #[serde(rename = "createdAt", default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(rename = "lastModifiedBy", default, skip_serializing_if = "Option::is_none")]
    pub last_modified_by: Option<String>,
    #[serde(rename = "lastModifiedByType", default, skip_serializing_if = "Option::is_none")]
    pub last_modified_by_type: Option<system_data::LastModifiedByType>,
    #[serde(rename = "lastModifiedAt", default, skip_serializing_if = "Option::is_none")]
    pub last_modified_at: Option<String>,
}
impl SystemData {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod system_data {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum CreatedByType {
        User,
        Application,
        ManagedIdentity,
        Key,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LastModifiedByType {
        User,
        Application,
        ManagedIdentity,
        Key,
    }
}
