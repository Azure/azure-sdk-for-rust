# ! [doc = "generated by AutoRust 0.1.0"] # ! [allow (unused_mut)] # ! [allow (unused_variables)] # ! [allow (unused_imports)] use crate :: models :: * ; use reqwest :: StatusCode ; use snafu :: { ResultExt , Snafu } ; pub mod sql_v3_operations { use crate :: models :: * ; use reqwest :: StatusCode ; use snafu :: { ResultExt , Snafu } ; pub async fn list (operation_config : & crate :: OperationConfig) -> std :: result :: Result < Vec < AvailableRpOperation > , list :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/providers/Microsoft.Synapse/operations" , & operation_config . base_path ,) ; let mut req_builder = client . get (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (list :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } let req = req_builder . build () . context (list :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (list :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (list :: ResponseBytesError) ? ; let rsp_value : Vec < AvailableRpOperation > = serde_json :: from_slice (& body) . context (list :: DeserializeError { body }) ? ; Ok (rsp_value) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (list :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (list :: DeserializeError { body }) ? ; list :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod list { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn get_location_header_result (operation_config : & crate :: OperationConfig , subscription_id : & str , resource_group_name : & str , workspace_name : & str , operation_id : & str) -> std :: result :: Result < get_location_header_result :: Response , get_location_header_result :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/operationResults/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , operation_id) ; let mut req_builder = client . get (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (get_location_header_result :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; let req = req_builder . build () . context (get_location_header_result :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (get_location_header_result :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { Ok (get_location_header_result :: Response :: Ok200) } StatusCode :: NO_CONTENT => { Ok (get_location_header_result :: Response :: NoContent204) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (get_location_header_result :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (get_location_header_result :: DeserializeError { body }) ? ; get_location_header_result :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod get_location_header_result { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug)] pub enum Response { Ok200 , NoContent204 , } # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn get_azure_async_header_result (operation_config : & crate :: OperationConfig , subscription_id : & str , resource_group_name : & str , workspace_name : & str , operation_id : & str) -> std :: result :: Result < OperationResource , get_azure_async_header_result :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/operationStatuses/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , operation_id) ; let mut req_builder = client . get (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (get_azure_async_header_result :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; let req = req_builder . build () . context (get_azure_async_header_result :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (get_azure_async_header_result :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (get_azure_async_header_result :: ResponseBytesError) ? ; let rsp_value : OperationResource = serde_json :: from_slice (& body) . context (get_azure_async_header_result :: DeserializeError { body }) ? ; Ok (rsp_value) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (get_azure_async_header_result :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (get_azure_async_header_result :: DeserializeError { body }) ? ; get_azure_async_header_result :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod get_azure_async_header_result { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } } pub mod sql_pools_v3 { use crate :: models :: * ; use reqwest :: StatusCode ; use snafu :: { ResultExt , Snafu } ; pub async fn get (operation_config : & crate :: OperationConfig , resource_group_name : & str , workspace_name : & str , sql_pool_name : & str , subscription_id : & str) -> std :: result :: Result < SqlPoolV3 , get :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlPools/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , sql_pool_name) ; let mut req_builder = client . get (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (get :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; let req = req_builder . build () . context (get :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (get :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (get :: ResponseBytesError) ? ; let rsp_value : SqlPoolV3 = serde_json :: from_slice (& body) . context (get :: DeserializeError { body }) ? ; Ok (rsp_value) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (get :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (get :: DeserializeError { body }) ? ; get :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod get { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn create_or_update (operation_config : & crate :: OperationConfig , resource_group_name : & str , workspace_name : & str , sql_pool_name : & str , parameters : & SqlPoolV3 , subscription_id : & str) -> std :: result :: Result < create_or_update :: Response , create_or_update :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlPools/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , sql_pool_name) ; let mut req_builder = client . put (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (create_or_update :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; req_builder = req_builder . json (parameters) ; let req = req_builder . build () . context (create_or_update :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (create_or_update :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (create_or_update :: ResponseBytesError) ? ; let rsp_value : SqlPoolV3 = serde_json :: from_slice (& body) . context (create_or_update :: DeserializeError { body }) ? ; Ok (create_or_update :: Response :: Ok200 (rsp_value)) } StatusCode :: ACCEPTED => { Ok (create_or_update :: Response :: Accepted202) } StatusCode :: CREATED => { let body : bytes :: Bytes = rsp . bytes () . await . context (create_or_update :: ResponseBytesError) ? ; let rsp_value : SqlPoolV3 = serde_json :: from_slice (& body) . context (create_or_update :: DeserializeError { body }) ? ; Ok (create_or_update :: Response :: Created201 (rsp_value)) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (create_or_update :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (create_or_update :: DeserializeError { body }) ? ; create_or_update :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod create_or_update { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug)] pub enum Response { Ok200 (SqlPoolV3) , Accepted202 , Created201 (SqlPoolV3) , } # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn update (operation_config : & crate :: OperationConfig , subscription_id : & str , resource_group_name : & str , workspace_name : & str , sql_pool_name : & str , parameters : & SqlPoolUpdate) -> std :: result :: Result < update :: Response , update :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlPools/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , sql_pool_name) ; let mut req_builder = client . patch (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (update :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; req_builder = req_builder . json (parameters) ; let req = req_builder . build () . context (update :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (update :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (update :: ResponseBytesError) ? ; let rsp_value : SqlPoolV3 = serde_json :: from_slice (& body) . context (update :: DeserializeError { body }) ? ; Ok (update :: Response :: Ok200 (rsp_value)) } StatusCode :: ACCEPTED => { Ok (update :: Response :: Accepted202) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (update :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (update :: DeserializeError { body }) ? ; update :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod update { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug)] pub enum Response { Ok200 (SqlPoolV3) , Accepted202 , } # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn delete (operation_config : & crate :: OperationConfig , resource_group_name : & str , workspace_name : & str , sql_pool_name : & str , subscription_id : & str) -> std :: result :: Result < delete :: Response , delete :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlPools/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , sql_pool_name) ; let mut req_builder = client . delete (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (delete :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; let req = req_builder . build () . context (delete :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (delete :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { Ok (delete :: Response :: Ok200) } StatusCode :: ACCEPTED => { Ok (delete :: Response :: Accepted202) } StatusCode :: NO_CONTENT => { Ok (delete :: Response :: NoContent204) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (delete :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (delete :: DeserializeError { body }) ? ; delete :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod delete { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug)] pub enum Response { Ok200 , Accepted202 , NoContent204 , } # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn list_by_workspace (operation_config : & crate :: OperationConfig , subscription_id : & str , resource_group_name : & str , workspace_name : & str) -> std :: result :: Result < SqlPoolListResult , list_by_workspace :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlPools" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name) ; let mut req_builder = client . get (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (list_by_workspace :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; let req = req_builder . build () . context (list_by_workspace :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (list_by_workspace :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (list_by_workspace :: ResponseBytesError) ? ; let rsp_value : SqlPoolListResult = serde_json :: from_slice (& body) . context (list_by_workspace :: DeserializeError { body }) ? ; Ok (rsp_value) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (list_by_workspace :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (list_by_workspace :: DeserializeError { body }) ? ; list_by_workspace :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod list_by_workspace { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } } pub mod sql_databases { use crate :: models :: * ; use reqwest :: StatusCode ; use snafu :: { ResultExt , Snafu } ; pub async fn get (operation_config : & crate :: OperationConfig , resource_group_name : & str , workspace_name : & str , sql_database_name : & str , subscription_id : & str) -> std :: result :: Result < SqlDatabase , get :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlDatabases/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , sql_database_name) ; let mut req_builder = client . get (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (get :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; let req = req_builder . build () . context (get :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (get :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (get :: ResponseBytesError) ? ; let rsp_value : SqlDatabase = serde_json :: from_slice (& body) . context (get :: DeserializeError { body }) ? ; Ok (rsp_value) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (get :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (get :: DeserializeError { body }) ? ; get :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod get { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn create_or_update (operation_config : & crate :: OperationConfig , resource_group_name : & str , workspace_name : & str , sql_database_name : & str , parameters : & SqlDatabase , subscription_id : & str) -> std :: result :: Result < create_or_update :: Response , create_or_update :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlDatabases/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , sql_database_name) ; let mut req_builder = client . put (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (create_or_update :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; req_builder = req_builder . json (parameters) ; let req = req_builder . build () . context (create_or_update :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (create_or_update :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (create_or_update :: ResponseBytesError) ? ; let rsp_value : SqlDatabase = serde_json :: from_slice (& body) . context (create_or_update :: DeserializeError { body }) ? ; Ok (create_or_update :: Response :: Ok200 (rsp_value)) } StatusCode :: ACCEPTED => { Ok (create_or_update :: Response :: Accepted202) } StatusCode :: CREATED => { let body : bytes :: Bytes = rsp . bytes () . await . context (create_or_update :: ResponseBytesError) ? ; let rsp_value : SqlDatabase = serde_json :: from_slice (& body) . context (create_or_update :: DeserializeError { body }) ? ; Ok (create_or_update :: Response :: Created201 (rsp_value)) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (create_or_update :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (create_or_update :: DeserializeError { body }) ? ; create_or_update :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod create_or_update { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug)] pub enum Response { Ok200 (SqlDatabase) , Accepted202 , Created201 (SqlDatabase) , } # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn update (operation_config : & crate :: OperationConfig , resource_group_name : & str , workspace_name : & str , sql_database_name : & str , parameters : & SqlDatabaseUpdate , subscription_id : & str) -> std :: result :: Result < update :: Response , update :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlDatabases/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , sql_database_name) ; let mut req_builder = client . patch (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (update :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; req_builder = req_builder . json (parameters) ; let req = req_builder . build () . context (update :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (update :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (update :: ResponseBytesError) ? ; let rsp_value : SqlDatabase = serde_json :: from_slice (& body) . context (update :: DeserializeError { body }) ? ; Ok (update :: Response :: Ok200 (rsp_value)) } StatusCode :: ACCEPTED => { Ok (update :: Response :: Accepted202) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (update :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (update :: DeserializeError { body }) ? ; update :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod update { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug)] pub enum Response { Ok200 (SqlDatabase) , Accepted202 , } # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn delete (operation_config : & crate :: OperationConfig , resource_group_name : & str , workspace_name : & str , sql_database_name : & str , subscription_id : & str) -> std :: result :: Result < delete :: Response , delete :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlDatabases/{}" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name , sql_database_name) ; let mut req_builder = client . delete (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (delete :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; let req = req_builder . build () . context (delete :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (delete :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { Ok (delete :: Response :: Ok200) } StatusCode :: ACCEPTED => { Ok (delete :: Response :: Accepted202) } StatusCode :: NO_CONTENT => { Ok (delete :: Response :: NoContent204) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (delete :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (delete :: DeserializeError { body }) ? ; delete :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod delete { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug)] pub enum Response { Ok200 , Accepted202 , NoContent204 , } # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } pub async fn list_by_workspace (operation_config : & crate :: OperationConfig , resource_group_name : & str , workspace_name : & str , subscription_id : & str) -> std :: result :: Result < SqlDatabaseListResult , list_by_workspace :: Error > { let client = & operation_config . client ; let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Synapse/workspaces/{}/sqlDatabases" , & operation_config . base_path , subscription_id , resource_group_name , workspace_name) ; let mut req_builder = client . get (uri_str) ; if let Some (token_credential) = & operation_config . token_credential { let token_response = token_credential . get_token (& operation_config . token_credential_resource) . await . context (list_by_workspace :: GetTokenError) ? ; req_builder = req_builder . bearer_auth (token_response . token . secret ()) ; } req_builder = req_builder . query (& [("api-version" , & operation_config . api_version)]) ; let req = req_builder . build () . context (list_by_workspace :: BuildRequestError) ? ; let rsp = client . execute (req) . await . context (list_by_workspace :: ExecuteRequestError) ? ; match rsp . status () { StatusCode :: OK => { let body : bytes :: Bytes = rsp . bytes () . await . context (list_by_workspace :: ResponseBytesError) ? ; let rsp_value : SqlDatabaseListResult = serde_json :: from_slice (& body) . context (list_by_workspace :: DeserializeError { body }) ? ; Ok (rsp_value) } status_code => { let body : bytes :: Bytes = rsp . bytes () . await . context (list_by_workspace :: ResponseBytesError) ? ; let rsp_value : ErrorContract = serde_json :: from_slice (& body) . context (list_by_workspace :: DeserializeError { body }) ? ; list_by_workspace :: DefaultResponse { status_code , value : rsp_value } . fail () } } } pub mod list_by_workspace { use crate :: { models , models :: * } ; use reqwest :: StatusCode ; use snafu :: Snafu ; # [derive (Debug , Snafu)] # [snafu (visibility (pub (crate)))] pub enum Error { DefaultResponse { status_code : StatusCode , value : models :: ErrorContract , } , BuildRequestError { source : reqwest :: Error } , ExecuteRequestError { source : reqwest :: Error } , ResponseBytesError { source : reqwest :: Error } , DeserializeError { source : serde_json :: Error , body : bytes :: Bytes } , GetTokenError { source : azure_core :: errors :: AzureError } , } } }