#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BigDataPoolResourceInfoListResult {
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BigDataPoolResourceInfo>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BigDataPoolPatchInfo {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BigDataPoolResourceInfo {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<BigDataPoolResourceProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BigDataPoolResourceProperties {
    #[serde(rename = "provisioningState", skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[serde(rename = "autoScale", skip_serializing_if = "Option::is_none")]
    pub auto_scale: Option<AutoScaleProperties>,
    #[serde(rename = "creationDate", skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<String>,
    #[serde(rename = "autoPause", skip_serializing_if = "Option::is_none")]
    pub auto_pause: Option<AutoPauseProperties>,
    #[serde(rename = "isComputeIsolationEnabled", skip_serializing_if = "Option::is_none")]
    pub is_compute_isolation_enabled: Option<bool>,
    #[serde(rename = "sessionLevelPackagesEnabled", skip_serializing_if = "Option::is_none")]
    pub session_level_packages_enabled: Option<bool>,
    #[serde(rename = "sparkEventsFolder", skip_serializing_if = "Option::is_none")]
    pub spark_events_folder: Option<String>,
    #[serde(rename = "nodeCount", skip_serializing_if = "Option::is_none")]
    pub node_count: Option<i32>,
    #[serde(rename = "libraryRequirements", skip_serializing_if = "Option::is_none")]
    pub library_requirements: Option<LibraryRequirements>,
    #[serde(rename = "customLibraries", skip_serializing_if = "Vec::is_empty")]
    pub custom_libraries: Vec<LibraryInfo>,
    #[serde(rename = "sparkConfigProperties", skip_serializing_if = "Option::is_none")]
    pub spark_config_properties: Option<LibraryRequirements>,
    #[serde(rename = "sparkVersion", skip_serializing_if = "Option::is_none")]
    pub spark_version: Option<String>,
    #[serde(rename = "defaultSparkLogFolder", skip_serializing_if = "Option::is_none")]
    pub default_spark_log_folder: Option<String>,
    #[serde(rename = "nodeSize", skip_serializing_if = "Option::is_none")]
    pub node_size: Option<big_data_pool_resource_properties::NodeSize>,
    #[serde(rename = "nodeSizeFamily", skip_serializing_if = "Option::is_none")]
    pub node_size_family: Option<big_data_pool_resource_properties::NodeSizeFamily>,
}
pub mod big_data_pool_resource_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum NodeSize {
        None,
        Small,
        Medium,
        Large,
        XLarge,
        #[serde(rename = "XXLarge")]
        XxLarge,
        #[serde(rename = "XXXLarge")]
        XxxLarge,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum NodeSizeFamily {
        None,
        MemoryOptimized,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AutoScaleProperties {
    #[serde(rename = "minNodeCount", skip_serializing_if = "Option::is_none")]
    pub min_node_count: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(rename = "maxNodeCount", skip_serializing_if = "Option::is_none")]
    pub max_node_count: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AutoPauseProperties {
    #[serde(rename = "delayInMinutes", skip_serializing_if = "Option::is_none")]
    pub delay_in_minutes: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LibraryInfo {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(rename = "containerName", skip_serializing_if = "Option::is_none")]
    pub container_name: Option<String>,
    #[serde(rename = "uploadedTimestamp", skip_serializing_if = "Option::is_none")]
    pub uploaded_timestamp: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LibraryRequirements {
    #[serde(skip_serializing)]
    pub time: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filename: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorDetail {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorContract {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorResponse>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AadAdminProperties {
    #[serde(rename = "tenantId", skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub login: Option<String>,
    #[serde(rename = "administratorType", skip_serializing_if = "Option::is_none")]
    pub administrator_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sid: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WorkspaceInfoListResult {
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Workspace>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataLakeStorageAccountDetails {
    #[serde(rename = "accountUrl", skip_serializing_if = "Option::is_none")]
    pub account_url: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filesystem: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EncryptionDetails {
    #[serde(rename = "doubleEncryptionEnabled", skip_serializing)]
    pub double_encryption_enabled: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cmk: Option<CustomerManagedKeyDetails>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomerManagedKeyDetails {
    #[serde(skip_serializing)]
    pub status: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<WorkspaceKeyDetails>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WorkspaceKeyDetails {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "keyVaultUrl", skip_serializing_if = "Option::is_none")]
    pub key_vault_url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIdentity {
    #[serde(rename = "principalId", skip_serializing)]
    pub principal_id: Option<String>,
    #[serde(rename = "tenantId", skip_serializing)]
    pub tenant_id: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<managed_identity::Type>,
}
pub mod managed_identity {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        None,
        SystemAssigned,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkProfile {
    #[serde(rename = "computeSubnetId", skip_serializing_if = "Option::is_none")]
    pub compute_subnet_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedVirtualNetworkSettings {
    #[serde(rename = "preventDataExfiltration", skip_serializing_if = "Option::is_none")]
    pub prevent_data_exfiltration: Option<bool>,
    #[serde(rename = "linkedAccessCheckOnTargetResource", skip_serializing_if = "Option::is_none")]
    pub linked_access_check_on_target_resource: Option<bool>,
    #[serde(rename = "allowedAadTenantIdsForLinking", skip_serializing_if = "Vec::is_empty")]
    pub allowed_aad_tenant_ids_for_linking: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BabylonConfiguration {
    #[serde(rename = "babylonResourceId", skip_serializing_if = "Option::is_none")]
    pub babylon_resource_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WorkspaceAadAdminInfo {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AadAdminProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Workspace {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<WorkspaceProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedIdentity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WorkspaceProperties {
    #[serde(rename = "defaultDataLakeStorage", skip_serializing_if = "Option::is_none")]
    pub default_data_lake_storage: Option<DataLakeStorageAccountDetails>,
    #[serde(rename = "sqlAdministratorLoginPassword", skip_serializing_if = "Option::is_none")]
    pub sql_administrator_login_password: Option<String>,
    #[serde(rename = "managedResourceGroupName", skip_serializing_if = "Option::is_none")]
    pub managed_resource_group_name: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
    #[serde(rename = "sqlAdministratorLogin", skip_serializing_if = "Option::is_none")]
    pub sql_administrator_login: Option<String>,
    #[serde(rename = "virtualNetworkProfile", skip_serializing_if = "Option::is_none")]
    pub virtual_network_profile: Option<VirtualNetworkProfile>,
    #[serde(rename = "connectivityEndpoints", skip_serializing_if = "Option::is_none")]
    pub connectivity_endpoints: Option<serde_json::Value>,
    #[serde(rename = "managedVirtualNetwork", skip_serializing_if = "Option::is_none")]
    pub managed_virtual_network: Option<String>,
    #[serde(rename = "privateEndpointConnections", skip_serializing_if = "Vec::is_empty")]
    pub private_endpoint_connections: Vec<PrivateEndpointConnection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encryption: Option<EncryptionDetails>,
    #[serde(rename = "workspaceUID", skip_serializing)]
    pub workspace_uid: Option<String>,
    #[serde(rename = "extraProperties", skip_serializing)]
    pub extra_properties: Option<serde_json::Value>,
    #[serde(rename = "managedVirtualNetworkSettings", skip_serializing_if = "Option::is_none")]
    pub managed_virtual_network_settings: Option<ManagedVirtualNetworkSettings>,
    #[serde(rename = "babylonConfiguration", skip_serializing_if = "Option::is_none")]
    pub babylon_configuration: Option<BabylonConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WorkspacePatchInfo {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedIdentity>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<WorkspacePatchProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WorkspacePatchProperties {
    #[serde(rename = "sqlAdministratorLoginPassword", skip_serializing_if = "Option::is_none")]
    pub sql_administrator_login_password: Option<String>,
    #[serde(rename = "managedVirtualNetworkSettings", skip_serializing_if = "Option::is_none")]
    pub managed_virtual_network_settings: Option<ManagedVirtualNetworkSettings>,
    #[serde(rename = "babylonConfiguration", skip_serializing_if = "Option::is_none")]
    pub babylon_configuration: Option<BabylonConfiguration>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIdentitySqlControlSettingsModel {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<managed_identity_sql_control_settings_model::Properties>,
}
pub mod managed_identity_sql_control_settings_model {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct Properties {
        #[serde(rename = "grantSqlControlToManagedIdentity", skip_serializing_if = "Option::is_none")]
        pub grant_sql_control_to_managed_identity: Option<properties::GrantSqlControlToManagedIdentity>,
    }
    pub mod properties {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
        pub struct GrantSqlControlToManagedIdentity {
            #[serde(rename = "desiredState", skip_serializing_if = "Option::is_none")]
            pub desired_state: Option<grant_sql_control_to_managed_identity::DesiredState>,
            #[serde(rename = "actualState", skip_serializing)]
            pub actual_state: Option<grant_sql_control_to_managed_identity::ActualState>,
        }
        pub mod grant_sql_control_to_managed_identity {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
            pub enum DesiredState {
                Enabled,
                Disabled,
            }
            #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
            pub enum ActualState {
                Enabling,
                Enabled,
                Disabling,
                Disabled,
                Unknown,
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestorableDroppedSqlPoolProperties {
    #[serde(rename = "databaseName", skip_serializing)]
    pub database_name: Option<String>,
    #[serde(skip_serializing)]
    pub edition: Option<String>,
    #[serde(rename = "maxSizeBytes", skip_serializing)]
    pub max_size_bytes: Option<String>,
    #[serde(rename = "serviceLevelObjective", skip_serializing)]
    pub service_level_objective: Option<String>,
    #[serde(rename = "elasticPoolName", skip_serializing)]
    pub elastic_pool_name: Option<String>,
    #[serde(rename = "creationDate", skip_serializing)]
    pub creation_date: Option<String>,
    #[serde(rename = "deletionDate", skip_serializing)]
    pub deletion_date: Option<String>,
    #[serde(rename = "earliestRestoreDate", skip_serializing)]
    pub earliest_restore_date: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestorableDroppedSqlPool {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing)]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<RestorableDroppedSqlPoolProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestorableDroppedSqlPoolListResult {
    pub value: Vec<RestorableDroppedSqlPool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnectionList {
    #[serde(skip_serializing)]
    pub value: Vec<PrivateEndpointConnection>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnection {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateEndpointConnectionProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableRpOperation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display: Option<AvailableRpOperationDisplayInfo>,
    #[serde(rename = "isDataAction", skip_serializing_if = "Option::is_none")]
    pub is_data_action: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<OperationMetaPropertyInfo>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationResource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<operation_resource::Status>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "percentComplete", skip_serializing_if = "Option::is_none")]
    pub percent_complete: Option<f64>,
}
pub mod operation_resource {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        InProgress,
        Succeeded,
        Failed,
        Canceled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableRpOperationDisplayInfo {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationMetaPropertyInfo {
    #[serde(rename = "serviceSpecification", skip_serializing_if = "Option::is_none")]
    pub service_specification: Option<OperationMetaServiceSpecification>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationMetaServiceSpecification {
    #[serde(rename = "metricSpecifications", skip_serializing_if = "Vec::is_empty")]
    pub metric_specifications: Vec<OperationMetaMetricSpecification>,
    #[serde(rename = "logSpecifications", skip_serializing_if = "Vec::is_empty")]
    pub log_specifications: Vec<OperationMetaLogSpecification>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationMetaMetricSpecification {
    #[serde(rename = "sourceMdmNamespace", skip_serializing_if = "Option::is_none")]
    pub source_mdm_namespace: Option<String>,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "aggregationType", skip_serializing_if = "Option::is_none")]
    pub aggregation_type: Option<String>,
    #[serde(rename = "displayDescription", skip_serializing_if = "Option::is_none")]
    pub display_description: Option<String>,
    #[serde(rename = "sourceMdmAccount", skip_serializing_if = "Option::is_none")]
    pub source_mdm_account: Option<String>,
    #[serde(rename = "enableRegionalMdmAccount", skip_serializing_if = "Option::is_none")]
    pub enable_regional_mdm_account: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub dimensions: Vec<OperationMetaMetricDimensionSpecification>,
    #[serde(rename = "supportsInstanceLevelAggregation", skip_serializing_if = "Option::is_none")]
    pub supports_instance_level_aggregation: Option<bool>,
    #[serde(rename = "metricFilterPattern", skip_serializing_if = "Option::is_none")]
    pub metric_filter_pattern: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationMetaLogSpecification {
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "blobDuration", skip_serializing_if = "Option::is_none")]
    pub blob_duration: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationMetaMetricDimensionSpecification {
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "toBeExportedForShoebox", skip_serializing_if = "Option::is_none")]
    pub to_be_exported_for_shoebox: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkHubInfoListResult {
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateLinkHub>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkHub {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateLinkHubProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkHubPatchInfo {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkHubProperties {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<private_link_hub_properties::ProvisioningState>,
    #[serde(rename = "privateEndpointConnections", skip_serializing)]
    pub private_endpoint_connections: Vec<PrivateEndpointConnectionForPrivateLinkHubBasic>,
}
pub mod private_link_hub_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProvisioningState {
        Succeeded,
        Failed,
        Deleting,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnectionForPrivateLinkHubBasic {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateEndpointConnectionProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnectionProperties {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
    #[serde(rename = "privateEndpoint", skip_serializing_if = "Option::is_none")]
    pub private_endpoint: Option<PrivateEndpoint>,
    #[serde(rename = "privateLinkServiceConnectionState", skip_serializing_if = "Option::is_none")]
    pub private_link_service_connection_state: Option<PrivateLinkServiceConnectionState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceConnectionState {
    #[serde(skip_serializing)]
    pub status: Option<String>,
    #[serde(skip_serializing)]
    pub description: Option<String>,
    #[serde(rename = "actionsRequired", skip_serializing)]
    pub actions_required: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpoint {
    #[serde(skip_serializing)]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CheckNameAvailabilityRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CheckNameAvailabilityResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub available: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpFirewallRuleInfo {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<IpFirewallRuleProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ReplaceAllIpFirewallRulesRequest {
    #[serde(rename = "ipFirewallRules", skip_serializing_if = "Option::is_none")]
    pub ip_firewall_rules: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpFirewallRuleProperties {
    #[serde(rename = "endIpAddress", skip_serializing_if = "Option::is_none")]
    pub end_ip_address: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ip_firewall_rule_properties::ProvisioningState>,
    #[serde(rename = "startIpAddress", skip_serializing_if = "Option::is_none")]
    pub start_ip_address: Option<String>,
}
pub mod ip_firewall_rule_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProvisioningState {
        Provisioning,
        Succeeded,
        Deleting,
        Failed,
        DeleteError,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpFirewallRuleInfoListResult {
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<IpFirewallRuleInfo>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ReplaceAllFirewallRulesOperationResponse {
    #[serde(rename = "operationId", skip_serializing_if = "Option::is_none")]
    pub operation_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolInfoListResult {
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<SqlPool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPool {
    #[serde(flatten)]
    pub tracked_resource: TrackedResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<Sku>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolResourceProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolPatchInfo {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<Sku>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolResourceProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Sku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capacity: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolResourceProperties {
    #[serde(rename = "maxSizeBytes", skip_serializing_if = "Option::is_none")]
    pub max_size_bytes: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collation: Option<String>,
    #[serde(rename = "sourceDatabaseId", skip_serializing_if = "Option::is_none")]
    pub source_database_id: Option<String>,
    #[serde(rename = "recoverableDatabaseId", skip_serializing_if = "Option::is_none")]
    pub recoverable_database_id: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(rename = "restorePointInTime", skip_serializing_if = "Option::is_none")]
    pub restore_point_in_time: Option<String>,
    #[serde(rename = "createMode", skip_serializing_if = "Option::is_none")]
    pub create_mode: Option<String>,
    #[serde(rename = "creationDate", skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetadataSyncConfig {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<metadata_sync_config::Properties>,
}
pub mod metadata_sync_config {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct Properties {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
        #[serde(rename = "syncIntervalInMinutes", skip_serializing)]
        pub sync_interval_in_minutes: Option<i32>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GeoBackupPolicyProperties {
    pub state: geo_backup_policy_properties::State,
    #[serde(rename = "storageType", skip_serializing)]
    pub storage_type: Option<String>,
}
pub mod geo_backup_policy_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Disabled,
        Enabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GeoBackupPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    pub properties: GeoBackupPolicyProperties,
    #[serde(skip_serializing)]
    pub kind: Option<String>,
    #[serde(skip_serializing)]
    pub location: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TopQueries {
    #[serde(rename = "aggregationFunction", skip_serializing)]
    pub aggregation_function: Option<top_queries::AggregationFunction>,
    #[serde(rename = "executionType", skip_serializing)]
    pub execution_type: Option<top_queries::ExecutionType>,
    #[serde(rename = "intervalType", skip_serializing)]
    pub interval_type: Option<String>,
    #[serde(rename = "numberOfTopQueries", skip_serializing)]
    pub number_of_top_queries: Option<f64>,
    #[serde(rename = "observationStartTime", skip_serializing)]
    pub observation_start_time: Option<String>,
    #[serde(rename = "observationEndTime", skip_serializing)]
    pub observation_end_time: Option<String>,
    #[serde(rename = "observedMetric", skip_serializing)]
    pub observed_metric: Option<top_queries::ObservedMetric>,
    #[serde(skip_serializing)]
    pub queries: Vec<QueryStatistic>,
}
pub mod top_queries {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AggregationFunction {
        #[serde(rename = "min")]
        Min,
        #[serde(rename = "max")]
        Max,
        #[serde(rename = "avg")]
        Avg,
        #[serde(rename = "sum")]
        Sum,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ExecutionType {
        #[serde(rename = "any")]
        Any,
        #[serde(rename = "regular")]
        Regular,
        #[serde(rename = "irregular")]
        Irregular,
        #[serde(rename = "aborted")]
        Aborted,
        #[serde(rename = "exception")]
        Exception,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ObservedMetric {
        #[serde(rename = "cpu")]
        Cpu,
        #[serde(rename = "io")]
        Io,
        #[serde(rename = "logio")]
        Logio,
        #[serde(rename = "duration")]
        Duration,
        #[serde(rename = "executionCount")]
        ExecutionCount,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QueryStatistic {
    #[serde(rename = "queryId", skip_serializing)]
    pub query_id: Option<String>,
    #[serde(skip_serializing)]
    pub intervals: Vec<QueryInterval>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QueryInterval {
    #[serde(rename = "intervalStartTime", skip_serializing)]
    pub interval_start_time: Option<String>,
    #[serde(rename = "executionCount", skip_serializing)]
    pub execution_count: Option<f64>,
    #[serde(skip_serializing)]
    pub metrics: Vec<QueryMetric>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QueryMetric {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing)]
    pub display_name: Option<String>,
    #[serde(skip_serializing)]
    pub unit: Option<query_metric::Unit>,
    #[serde(skip_serializing)]
    pub value: Option<f64>,
}
pub mod query_metric {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Unit {
        #[serde(rename = "percentage")]
        Percentage,
        #[serde(rename = "KB")]
        Kb,
        #[serde(rename = "microseconds")]
        Microseconds,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TopQueriesListResult {
    pub value: Vec<TopQueries>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataWarehouseUserActivitiesProperties {
    #[serde(rename = "activeQueriesCount", skip_serializing)]
    pub active_queries_count: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataWarehouseUserActivities {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<DataWarehouseUserActivitiesProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestorePointListResult {
    #[serde(skip_serializing)]
    pub value: Vec<RestorePoint>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestorePointProperties {
    #[serde(rename = "restorePointType", skip_serializing)]
    pub restore_point_type: Option<restore_point_properties::RestorePointType>,
    #[serde(rename = "earliestRestoreDate", skip_serializing)]
    pub earliest_restore_date: Option<String>,
    #[serde(rename = "restorePointCreationDate", skip_serializing)]
    pub restore_point_creation_date: Option<String>,
    #[serde(rename = "restorePointLabel", skip_serializing)]
    pub restore_point_label: Option<String>,
}
pub mod restore_point_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RestorePointType {
        #[serde(rename = "CONTINUOUS")]
        Continuous,
        #[serde(rename = "DISCRETE")]
        Discrete,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RestorePoint {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing)]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<RestorePointProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ReplicationLinkProperties {
    #[serde(rename = "isTerminationAllowed", skip_serializing)]
    pub is_termination_allowed: Option<bool>,
    #[serde(rename = "replicationMode", skip_serializing)]
    pub replication_mode: Option<String>,
    #[serde(rename = "partnerServer", skip_serializing)]
    pub partner_server: Option<String>,
    #[serde(rename = "partnerDatabase", skip_serializing)]
    pub partner_database: Option<String>,
    #[serde(rename = "partnerLocation", skip_serializing)]
    pub partner_location: Option<String>,
    #[serde(skip_serializing)]
    pub role: Option<replication_link_properties::Role>,
    #[serde(rename = "partnerRole", skip_serializing)]
    pub partner_role: Option<replication_link_properties::PartnerRole>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(rename = "percentComplete", skip_serializing)]
    pub percent_complete: Option<i32>,
    #[serde(rename = "replicationState", skip_serializing)]
    pub replication_state: Option<replication_link_properties::ReplicationState>,
}
pub mod replication_link_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Role {
        Primary,
        Secondary,
        NonReadableSecondary,
        Source,
        Copy,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PartnerRole {
        Primary,
        Secondary,
        NonReadableSecondary,
        Source,
        Copy,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ReplicationState {
        #[serde(rename = "PENDING")]
        Pending,
        #[serde(rename = "SEEDING")]
        Seeding,
        #[serde(rename = "CATCH_UP")]
        CatchUp,
        #[serde(rename = "SUSPENDED")]
        Suspended,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ReplicationLink {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing)]
    pub location: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ReplicationLinkProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ReplicationLinkListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ReplicationLink>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransparentDataEncryptionProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<transparent_data_encryption_properties::Status>,
}
pub mod transparent_data_encryption_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransparentDataEncryption {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing)]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<TransparentDataEncryptionProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolBlobAuditingPolicyProperties {
    pub state: sql_pool_blob_auditing_policy_properties::State,
    #[serde(rename = "storageEndpoint", skip_serializing_if = "Option::is_none")]
    pub storage_endpoint: Option<String>,
    #[serde(rename = "storageAccountAccessKey", skip_serializing_if = "Option::is_none")]
    pub storage_account_access_key: Option<String>,
    #[serde(rename = "retentionDays", skip_serializing_if = "Option::is_none")]
    pub retention_days: Option<i32>,
    #[serde(rename = "auditActionsAndGroups", skip_serializing_if = "Vec::is_empty")]
    pub audit_actions_and_groups: Vec<String>,
    #[serde(rename = "storageAccountSubscriptionId", skip_serializing_if = "Option::is_none")]
    pub storage_account_subscription_id: Option<String>,
    #[serde(rename = "isStorageSecondaryKeyInUse", skip_serializing_if = "Option::is_none")]
    pub is_storage_secondary_key_in_use: Option<bool>,
    #[serde(rename = "isAzureMonitorTargetEnabled", skip_serializing_if = "Option::is_none")]
    pub is_azure_monitor_target_enabled: Option<bool>,
}
pub mod sql_pool_blob_auditing_policy_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolBlobAuditingPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing)]
    pub kind: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolBlobAuditingPolicyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolBlobAuditingPolicySqlPoolOperationListResult {
    #[serde(skip_serializing)]
    pub value: Vec<SqlPoolOperation>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolOperationProperties {
    #[serde(rename = "databaseName", skip_serializing)]
    pub database_name: Option<String>,
    #[serde(skip_serializing)]
    pub operation: Option<String>,
    #[serde(rename = "operationFriendlyName", skip_serializing)]
    pub operation_friendly_name: Option<String>,
    #[serde(rename = "percentComplete", skip_serializing)]
    pub percent_complete: Option<i32>,
    #[serde(rename = "serverName", skip_serializing)]
    pub server_name: Option<String>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(skip_serializing)]
    pub state: Option<sql_pool_operation_properties::State>,
    #[serde(rename = "errorCode", skip_serializing)]
    pub error_code: Option<i32>,
    #[serde(rename = "errorDescription", skip_serializing)]
    pub error_description: Option<String>,
    #[serde(rename = "errorSeverity", skip_serializing)]
    pub error_severity: Option<i32>,
    #[serde(rename = "isUserError", skip_serializing)]
    pub is_user_error: Option<bool>,
    #[serde(rename = "estimatedCompletionTime", skip_serializing)]
    pub estimated_completion_time: Option<String>,
    #[serde(skip_serializing)]
    pub description: Option<String>,
    #[serde(rename = "isCancellable", skip_serializing)]
    pub is_cancellable: Option<bool>,
}
pub mod sql_pool_operation_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Pending,
        InProgress,
        Succeeded,
        Failed,
        CancelInProgress,
        Cancelled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolOperation {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolOperationProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolUsage {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "resourceName", skip_serializing)]
    pub resource_name: Option<String>,
    #[serde(rename = "displayName", skip_serializing)]
    pub display_name: Option<String>,
    #[serde(rename = "currentValue", skip_serializing)]
    pub current_value: Option<f64>,
    #[serde(skip_serializing)]
    pub limit: Option<f64>,
    #[serde(skip_serializing)]
    pub unit: Option<String>,
    #[serde(rename = "nextResetTime", skip_serializing)]
    pub next_reset_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolUsageListResult {
    pub value: Vec<SqlPoolUsage>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SensitivityLabelProperties {
    #[serde(rename = "labelName", skip_serializing_if = "Option::is_none")]
    pub label_name: Option<String>,
    #[serde(rename = "labelId", skip_serializing_if = "Option::is_none")]
    pub label_id: Option<String>,
    #[serde(rename = "informationType", skip_serializing_if = "Option::is_none")]
    pub information_type: Option<String>,
    #[serde(rename = "informationTypeId", skip_serializing_if = "Option::is_none")]
    pub information_type_id: Option<String>,
    #[serde(rename = "isDisabled", skip_serializing)]
    pub is_disabled: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SensitivityLabel {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SensitivityLabelProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SensitivityLabelListResult {
    #[serde(skip_serializing)]
    pub value: Vec<SensitivityLabel>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolSchema {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolSchemaListResult {
    #[serde(skip_serializing)]
    pub value: Vec<SqlPoolSchema>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolTable {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolTableListResult {
    #[serde(skip_serializing)]
    pub value: Vec<SqlPoolTable>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolColumnProperties {
    #[serde(rename = "columnType", skip_serializing_if = "Option::is_none")]
    pub column_type: Option<sql_pool_column_properties::ColumnType>,
}
pub mod sql_pool_column_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ColumnType {
        #[serde(rename = "image")]
        Image,
        #[serde(rename = "text")]
        Text,
        #[serde(rename = "uniqueidentifier")]
        Uniqueidentifier,
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "time")]
        Time,
        #[serde(rename = "datetime2")]
        Datetime2,
        #[serde(rename = "datetimeoffset")]
        Datetimeoffset,
        #[serde(rename = "tinyint")]
        Tinyint,
        #[serde(rename = "smallint")]
        Smallint,
        #[serde(rename = "int")]
        Int,
        #[serde(rename = "smalldatetime")]
        Smalldatetime,
        #[serde(rename = "real")]
        Real,
        #[serde(rename = "money")]
        Money,
        #[serde(rename = "datetime")]
        Datetime,
        #[serde(rename = "float")]
        Float,
        #[serde(rename = "sql_variant")]
        SqlVariant,
        #[serde(rename = "ntext")]
        Ntext,
        #[serde(rename = "bit")]
        Bit,
        #[serde(rename = "decimal")]
        Decimal,
        #[serde(rename = "numeric")]
        Numeric,
        #[serde(rename = "smallmoney")]
        Smallmoney,
        #[serde(rename = "bigint")]
        Bigint,
        #[serde(rename = "hierarchyid")]
        Hierarchyid,
        #[serde(rename = "geometry")]
        Geometry,
        #[serde(rename = "geography")]
        Geography,
        #[serde(rename = "varbinary")]
        Varbinary,
        #[serde(rename = "varchar")]
        Varchar,
        #[serde(rename = "binary")]
        Binary,
        #[serde(rename = "char")]
        Char,
        #[serde(rename = "timestamp")]
        Timestamp,
        #[serde(rename = "nvarchar")]
        Nvarchar,
        #[serde(rename = "nchar")]
        Nchar,
        #[serde(rename = "xml")]
        Xml,
        #[serde(rename = "sysname")]
        Sysname,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolColumn {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolColumnProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolColumnListResult {
    #[serde(skip_serializing)]
    pub value: Vec<SqlPoolColumn>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolConnectionPolicyProperties {
    #[serde(rename = "securityEnabledAccess", skip_serializing_if = "Option::is_none")]
    pub security_enabled_access: Option<String>,
    #[serde(rename = "proxyDnsName", skip_serializing_if = "Option::is_none")]
    pub proxy_dns_name: Option<String>,
    #[serde(rename = "proxyPort", skip_serializing_if = "Option::is_none")]
    pub proxy_port: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub visibility: Option<String>,
    #[serde(rename = "useServerDefault", skip_serializing_if = "Option::is_none")]
    pub use_server_default: Option<String>,
    #[serde(rename = "redirectionState", skip_serializing_if = "Option::is_none")]
    pub redirection_state: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolConnectionPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing)]
    pub kind: Option<String>,
    #[serde(skip_serializing)]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolConnectionPolicyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolVulnerabilityAssessmentProperties {
    #[serde(rename = "storageContainerPath", skip_serializing_if = "Option::is_none")]
    pub storage_container_path: Option<String>,
    #[serde(rename = "storageContainerSasKey", skip_serializing_if = "Option::is_none")]
    pub storage_container_sas_key: Option<String>,
    #[serde(rename = "storageAccountAccessKey", skip_serializing_if = "Option::is_none")]
    pub storage_account_access_key: Option<String>,
    #[serde(rename = "recurringScans", skip_serializing_if = "Option::is_none")]
    pub recurring_scans: Option<VulnerabilityAssessmentRecurringScansProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VulnerabilityAssessmentRecurringScansProperties {
    #[serde(rename = "isEnabled", skip_serializing_if = "Option::is_none")]
    pub is_enabled: Option<bool>,
    #[serde(rename = "emailSubscriptionAdmins", skip_serializing_if = "Option::is_none")]
    pub email_subscription_admins: Option<bool>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub emails: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolVulnerabilityAssessment {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolVulnerabilityAssessmentProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolVulnerabilityAssessmentListResult {
    #[serde(skip_serializing)]
    pub value: Vec<SqlPoolVulnerabilityAssessment>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VulnerabilityAssessmentScanRecordListResult {
    #[serde(skip_serializing)]
    pub value: Vec<VulnerabilityAssessmentScanRecord>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VulnerabilityAssessmentScanRecord {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VulnerabilityAssessmentScanRecordProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VulnerabilityAssessmentScanRecordProperties {
    #[serde(rename = "scanId", skip_serializing)]
    pub scan_id: Option<String>,
    #[serde(rename = "triggerType", skip_serializing)]
    pub trigger_type: Option<vulnerability_assessment_scan_record_properties::TriggerType>,
    #[serde(skip_serializing)]
    pub state: Option<vulnerability_assessment_scan_record_properties::State>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing)]
    pub end_time: Option<String>,
    #[serde(skip_serializing)]
    pub errors: Vec<VulnerabilityAssessmentScanError>,
    #[serde(rename = "storageContainerPath", skip_serializing)]
    pub storage_container_path: Option<String>,
    #[serde(rename = "numberOfFailedSecurityChecks", skip_serializing)]
    pub number_of_failed_security_checks: Option<i32>,
}
pub mod vulnerability_assessment_scan_record_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum TriggerType {
        OnDemand,
        Recurring,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Passed,
        Failed,
        FailedToRun,
        InProgress,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VulnerabilityAssessmentScanError {
    #[serde(skip_serializing)]
    pub code: Option<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityAlertPolicyProperties {
    pub state: security_alert_policy_properties::State,
    #[serde(rename = "disabledAlerts", skip_serializing_if = "Vec::is_empty")]
    pub disabled_alerts: Vec<String>,
    #[serde(rename = "emailAddresses", skip_serializing_if = "Vec::is_empty")]
    pub email_addresses: Vec<String>,
    #[serde(rename = "emailAccountAdmins", skip_serializing_if = "Option::is_none")]
    pub email_account_admins: Option<bool>,
    #[serde(rename = "storageEndpoint", skip_serializing_if = "Option::is_none")]
    pub storage_endpoint: Option<String>,
    #[serde(rename = "storageAccountAccessKey", skip_serializing_if = "Option::is_none")]
    pub storage_account_access_key: Option<String>,
    #[serde(rename = "retentionDays", skip_serializing_if = "Option::is_none")]
    pub retention_days: Option<i32>,
    #[serde(rename = "creationTime", skip_serializing)]
    pub creation_time: Option<String>,
}
pub mod security_alert_policy_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        New,
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolSecurityAlertPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SecurityAlertPolicyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolVulnerabilityAssessmentRuleBaselineProperties {
    #[serde(rename = "baselineResults")]
    pub baseline_results: Vec<SqlPoolVulnerabilityAssessmentRuleBaselineItem>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolVulnerabilityAssessmentRuleBaselineItem {
    pub result: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolVulnerabilityAssessmentRuleBaseline {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolVulnerabilityAssessmentRuleBaselineProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolVulnerabilityAssessmentScanExportProperties {
    #[serde(rename = "exportedReportLocation", skip_serializing)]
    pub exported_report_location: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolVulnerabilityAssessmentScansExport {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SqlPoolVulnerabilityAssessmentScanExportProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResourceMoveDefinition {
    pub id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CreateSqlPoolRestorePointDefinition {
    #[serde(rename = "restorePointLabel")]
    pub restore_point_label: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExtendedSqlPoolBlobAuditingPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExtendedSqlPoolBlobAuditingPolicyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExtendedSqlPoolBlobAuditingPolicyProperties {
    #[serde(rename = "predicateExpression", skip_serializing_if = "Option::is_none")]
    pub predicate_expression: Option<String>,
    pub state: extended_sql_pool_blob_auditing_policy_properties::State,
    #[serde(rename = "storageEndpoint", skip_serializing_if = "Option::is_none")]
    pub storage_endpoint: Option<String>,
    #[serde(rename = "storageAccountAccessKey", skip_serializing_if = "Option::is_none")]
    pub storage_account_access_key: Option<String>,
    #[serde(rename = "retentionDays", skip_serializing_if = "Option::is_none")]
    pub retention_days: Option<i32>,
    #[serde(rename = "auditActionsAndGroups", skip_serializing_if = "Vec::is_empty")]
    pub audit_actions_and_groups: Vec<String>,
    #[serde(rename = "storageAccountSubscriptionId", skip_serializing_if = "Option::is_none")]
    pub storage_account_subscription_id: Option<String>,
    #[serde(rename = "isStorageSecondaryKeyInUse", skip_serializing_if = "Option::is_none")]
    pub is_storage_secondary_key_in_use: Option<bool>,
    #[serde(rename = "isAzureMonitorTargetEnabled", skip_serializing_if = "Option::is_none")]
    pub is_azure_monitor_target_enabled: Option<bool>,
    #[serde(rename = "queueDelayMs", skip_serializing_if = "Option::is_none")]
    pub queue_delay_ms: Option<i32>,
}
pub mod extended_sql_pool_blob_auditing_policy_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExtendedSqlPoolBlobAuditingPolicyListResult {
    #[serde(skip_serializing)]
    pub value: Vec<ExtendedSqlPoolBlobAuditingPolicy>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataMaskingPolicy {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<DataMaskingPolicyProperties>,
    #[serde(skip_serializing)]
    pub location: Option<String>,
    #[serde(skip_serializing)]
    pub kind: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataMaskingPolicyProperties {
    #[serde(rename = "dataMaskingState")]
    pub data_masking_state: data_masking_policy_properties::DataMaskingState,
    #[serde(rename = "exemptPrincipals", skip_serializing_if = "Option::is_none")]
    pub exempt_principals: Option<String>,
    #[serde(rename = "applicationPrincipals", skip_serializing)]
    pub application_principals: Option<String>,
    #[serde(rename = "maskingLevel", skip_serializing)]
    pub masking_level: Option<String>,
}
pub mod data_masking_policy_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum DataMaskingState {
        Disabled,
        Enabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataMaskingRule {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<DataMaskingRuleProperties>,
    #[serde(skip_serializing)]
    pub location: Option<String>,
    #[serde(skip_serializing)]
    pub kind: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataMaskingRuleProperties {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(rename = "aliasName", skip_serializing_if = "Option::is_none")]
    pub alias_name: Option<String>,
    #[serde(rename = "ruleState", skip_serializing_if = "Option::is_none")]
    pub rule_state: Option<data_masking_rule_properties::RuleState>,
    #[serde(rename = "schemaName")]
    pub schema_name: String,
    #[serde(rename = "tableName")]
    pub table_name: String,
    #[serde(rename = "columnName")]
    pub column_name: String,
    #[serde(rename = "maskingFunction")]
    pub masking_function: data_masking_rule_properties::MaskingFunction,
    #[serde(rename = "numberFrom", skip_serializing_if = "Option::is_none")]
    pub number_from: Option<String>,
    #[serde(rename = "numberTo", skip_serializing_if = "Option::is_none")]
    pub number_to: Option<String>,
    #[serde(rename = "prefixSize", skip_serializing_if = "Option::is_none")]
    pub prefix_size: Option<String>,
    #[serde(rename = "suffixSize", skip_serializing_if = "Option::is_none")]
    pub suffix_size: Option<String>,
    #[serde(rename = "replacementString", skip_serializing_if = "Option::is_none")]
    pub replacement_string: Option<String>,
}
pub mod data_masking_rule_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RuleState {
        Disabled,
        Enabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum MaskingFunction {
        Default,
        #[serde(rename = "CCN")]
        Ccn,
        Email,
        Number,
        #[serde(rename = "SSN")]
        Ssn,
        Text,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataMaskingRuleListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<DataMaskingRule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlPoolBlobAuditingPolicyListResult {
    #[serde(skip_serializing)]
    pub value: Vec<SqlPoolBlobAuditingPolicy>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudError {
    pub error: CloudErrorBody,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudErrorBody {
    pub code: String,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<CloudError>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubResource {
    #[serde(flatten)]
    pub azure_entity_resource: AzureEntityResource,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntime {
    #[serde(rename = "type")]
    pub type_: IntegrationRuntimeType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IntegrationRuntimeType {
    Managed,
    SelfHosted,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntime {
    #[serde(flatten)]
    pub integration_runtime: IntegrationRuntime,
    #[serde(skip_serializing)]
    pub state: Option<IntegrationRuntimeState>,
    #[serde(rename = "typeProperties")]
    pub type_properties: ManagedIntegrationRuntimeTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeTypeProperties {
    #[serde(rename = "computeProperties", skip_serializing_if = "Option::is_none")]
    pub compute_properties: Option<IntegrationRuntimeComputeProperties>,
    #[serde(rename = "ssisProperties", skip_serializing_if = "Option::is_none")]
    pub ssis_properties: Option<IntegrationRuntimeSsisProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeComputeProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(rename = "nodeSize", skip_serializing_if = "Option::is_none")]
    pub node_size: Option<String>,
    #[serde(rename = "numberOfNodes", skip_serializing_if = "Option::is_none")]
    pub number_of_nodes: Option<i64>,
    #[serde(rename = "maxParallelExecutionsPerNode", skip_serializing_if = "Option::is_none")]
    pub max_parallel_executions_per_node: Option<i64>,
    #[serde(rename = "dataFlowProperties", skip_serializing_if = "Option::is_none")]
    pub data_flow_properties: Option<IntegrationRuntimeDataFlowProperties>,
    #[serde(rename = "vNetProperties", skip_serializing_if = "Option::is_none")]
    pub v_net_properties: Option<IntegrationRuntimeVNetProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeDataFlowProperties {
    #[serde(rename = "computeType", skip_serializing_if = "Option::is_none")]
    pub compute_type: Option<integration_runtime_data_flow_properties::ComputeType>,
    #[serde(rename = "coreCount", skip_serializing_if = "Option::is_none")]
    pub core_count: Option<i64>,
    #[serde(rename = "timeToLive", skip_serializing_if = "Option::is_none")]
    pub time_to_live: Option<i64>,
}
pub mod integration_runtime_data_flow_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ComputeType {
        General,
        MemoryOptimized,
        ComputeOptimized,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeVNetProperties {
    #[serde(rename = "vNetId", skip_serializing_if = "Option::is_none")]
    pub v_net_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<String>,
    #[serde(rename = "publicIPs", skip_serializing_if = "Vec::is_empty")]
    pub public_i_ps: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeSsisProperties {
    #[serde(rename = "catalogInfo", skip_serializing_if = "Option::is_none")]
    pub catalog_info: Option<IntegrationRuntimeSsisCatalogInfo>,
    #[serde(rename = "licenseType", skip_serializing_if = "Option::is_none")]
    pub license_type: Option<integration_runtime_ssis_properties::LicenseType>,
    #[serde(rename = "customSetupScriptProperties", skip_serializing_if = "Option::is_none")]
    pub custom_setup_script_properties: Option<IntegrationRuntimeCustomSetupScriptProperties>,
    #[serde(rename = "dataProxyProperties", skip_serializing_if = "Option::is_none")]
    pub data_proxy_properties: Option<IntegrationRuntimeDataProxyProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edition: Option<integration_runtime_ssis_properties::Edition>,
    #[serde(rename = "expressCustomSetupProperties", skip_serializing_if = "Vec::is_empty")]
    pub express_custom_setup_properties: Vec<CustomSetupBase>,
}
pub mod integration_runtime_ssis_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LicenseType {
        BasePrice,
        LicenseIncluded,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Edition {
        Standard,
        Enterprise,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecretBase {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecureString {
    #[serde(flatten)]
    pub secret_base: SecretBase,
    pub value: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeSsisCatalogInfo {
    #[serde(rename = "catalogServerEndpoint", skip_serializing_if = "Option::is_none")]
    pub catalog_server_endpoint: Option<String>,
    #[serde(rename = "catalogAdminUserName", skip_serializing_if = "Option::is_none")]
    pub catalog_admin_user_name: Option<String>,
    #[serde(rename = "catalogAdminPassword", skip_serializing_if = "Option::is_none")]
    pub catalog_admin_password: Option<SecureString>,
    #[serde(rename = "catalogPricingTier", skip_serializing_if = "Option::is_none")]
    pub catalog_pricing_tier: Option<integration_runtime_ssis_catalog_info::CatalogPricingTier>,
}
pub mod integration_runtime_ssis_catalog_info {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum CatalogPricingTier {
        Basic,
        Standard,
        Premium,
        #[serde(rename = "PremiumRS")]
        PremiumRs,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeCustomSetupScriptProperties {
    #[serde(rename = "blobContainerUri", skip_serializing_if = "Option::is_none")]
    pub blob_container_uri: Option<String>,
    #[serde(rename = "sasToken", skip_serializing_if = "Option::is_none")]
    pub sas_token: Option<SecureString>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeDataProxyProperties {
    #[serde(rename = "connectVia", skip_serializing_if = "Option::is_none")]
    pub connect_via: Option<EntityReference>,
    #[serde(rename = "stagingLinkedService", skip_serializing_if = "Option::is_none")]
    pub staging_linked_service: Option<EntityReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomSetupBase {
    #[serde(rename = "type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CmdkeySetup {
    #[serde(flatten)]
    pub custom_setup_base: CustomSetupBase,
    #[serde(rename = "typeProperties")]
    pub type_properties: CmdkeySetupTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CmdkeySetupTypeProperties {
    #[serde(rename = "targetName")]
    pub target_name: serde_json::Value,
    #[serde(rename = "userName")]
    pub user_name: serde_json::Value,
    pub password: SecretBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EnvironmentVariableSetup {
    #[serde(flatten)]
    pub custom_setup_base: CustomSetupBase,
    #[serde(rename = "typeProperties")]
    pub type_properties: EnvironmentVariableSetupTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EnvironmentVariableSetupTypeProperties {
    #[serde(rename = "variableName")]
    pub variable_name: String,
    #[serde(rename = "variableValue")]
    pub variable_value: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ComponentSetup {
    #[serde(flatten)]
    pub custom_setup_base: CustomSetupBase,
    #[serde(rename = "typeProperties")]
    pub type_properties: LicensedComponentSetupTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LicensedComponentSetupTypeProperties {
    #[serde(rename = "componentName")]
    pub component_name: String,
    #[serde(rename = "licenseKey", skip_serializing_if = "Option::is_none")]
    pub license_key: Option<SecretBase>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EntityReference {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<entity_reference::Type>,
    #[serde(rename = "referenceName", skip_serializing_if = "Option::is_none")]
    pub reference_name: Option<String>,
}
pub mod entity_reference {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        IntegrationRuntimeReference,
        LinkedServiceReference,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntime {
    #[serde(flatten)]
    pub integration_runtime: IntegrationRuntime,
    #[serde(rename = "typeProperties", skip_serializing_if = "Option::is_none")]
    pub type_properties: Option<SelfHostedIntegrationRuntimeTypeProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntimeTypeProperties {
    #[serde(rename = "linkedInfo", skip_serializing_if = "Option::is_none")]
    pub linked_info: Option<LinkedIntegrationRuntimeType>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntimeType {
    #[serde(rename = "authorizationType")]
    pub authorization_type: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntimeKeyAuthorization {
    #[serde(flatten)]
    pub linked_integration_runtime_type: LinkedIntegrationRuntimeType,
    pub key: SecureString,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntimeRbacAuthorization {
    #[serde(flatten)]
    pub linked_integration_runtime_type: LinkedIntegrationRuntimeType,
    #[serde(rename = "resourceId")]
    pub resource_id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeStatus {
    #[serde(rename = "type")]
    pub type_: IntegrationRuntimeType,
    #[serde(rename = "dataFactoryName", skip_serializing)]
    pub data_factory_name: Option<String>,
    #[serde(skip_serializing)]
    pub state: Option<IntegrationRuntimeState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IntegrationRuntimeState {
    Initial,
    Stopped,
    Started,
    Starting,
    Stopping,
    NeedRegistration,
    Online,
    Limited,
    Offline,
    AccessDenied,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeStatus {
    #[serde(flatten)]
    pub integration_runtime_status: IntegrationRuntimeStatus,
    #[serde(rename = "typeProperties")]
    pub type_properties: ManagedIntegrationRuntimeStatusTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeStatusTypeProperties {
    #[serde(rename = "createTime", skip_serializing)]
    pub create_time: Option<String>,
    #[serde(skip_serializing)]
    pub nodes: Vec<ManagedIntegrationRuntimeNode>,
    #[serde(rename = "otherErrors", skip_serializing)]
    pub other_errors: Vec<ManagedIntegrationRuntimeError>,
    #[serde(rename = "lastOperation", skip_serializing_if = "Option::is_none")]
    pub last_operation: Option<ManagedIntegrationRuntimeOperationResult>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeOperationResult {
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(skip_serializing)]
    pub result: Option<String>,
    #[serde(rename = "errorCode", skip_serializing)]
    pub error_code: Option<String>,
    #[serde(skip_serializing)]
    pub parameters: Vec<String>,
    #[serde(rename = "activityId", skip_serializing)]
    pub activity_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeNode {
    #[serde(rename = "nodeId", skip_serializing)]
    pub node_id: Option<String>,
    #[serde(skip_serializing)]
    pub status: Option<managed_integration_runtime_node::Status>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub errors: Vec<ManagedIntegrationRuntimeError>,
}
pub mod managed_integration_runtime_node {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Starting,
        Available,
        Recycling,
        Unavailable,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedIntegrationRuntimeError {
    #[serde(skip_serializing)]
    pub time: Option<String>,
    #[serde(skip_serializing)]
    pub code: Option<String>,
    #[serde(skip_serializing)]
    pub parameters: Vec<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntimeStatus {
    #[serde(flatten)]
    pub integration_runtime_status: IntegrationRuntimeStatus,
    #[serde(rename = "typeProperties")]
    pub type_properties: SelfHostedIntegrationRuntimeStatusTypeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntimeStatusTypeProperties {
    #[serde(rename = "createTime", skip_serializing)]
    pub create_time: Option<String>,
    #[serde(rename = "taskQueueId", skip_serializing)]
    pub task_queue_id: Option<String>,
    #[serde(rename = "nodeCommunicationChannelEncryptionMode", skip_serializing)]
    pub node_communication_channel_encryption_mode: Option<String>,
    #[serde(rename = "internalChannelEncryption", skip_serializing)]
    pub internal_channel_encryption: Option<self_hosted_integration_runtime_status_type_properties::InternalChannelEncryption>,
    #[serde(skip_serializing)]
    pub version: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub nodes: Vec<SelfHostedIntegrationRuntimeNode>,
    #[serde(rename = "scheduledUpdateDate", skip_serializing)]
    pub scheduled_update_date: Option<String>,
    #[serde(rename = "updateDelayOffset", skip_serializing)]
    pub update_delay_offset: Option<String>,
    #[serde(rename = "localTimeZoneOffset", skip_serializing)]
    pub local_time_zone_offset: Option<String>,
    #[serde(skip_serializing)]
    pub capabilities: Option<serde_json::Value>,
    #[serde(rename = "serviceUrls", skip_serializing)]
    pub service_urls: Vec<String>,
    #[serde(rename = "autoUpdate", skip_serializing_if = "Option::is_none")]
    pub auto_update: Option<IntegrationRuntimeAutoUpdate>,
    #[serde(rename = "versionStatus", skip_serializing)]
    pub version_status: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub links: Vec<LinkedIntegrationRuntime>,
    #[serde(rename = "pushedVersion", skip_serializing)]
    pub pushed_version: Option<String>,
    #[serde(rename = "latestVersion", skip_serializing)]
    pub latest_version: Option<String>,
    #[serde(rename = "autoUpdateETA", skip_serializing)]
    pub auto_update_eta: Option<String>,
}
pub mod self_hosted_integration_runtime_status_type_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum InternalChannelEncryption {
        NotSet,
        SslEncrypted,
        NotEncrypted,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IntegrationRuntimeAutoUpdate {
    On,
    Off,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LinkedIntegrationRuntime {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "subscriptionId", skip_serializing)]
    pub subscription_id: Option<String>,
    #[serde(rename = "dataFactoryName", skip_serializing)]
    pub data_factory_name: Option<String>,
    #[serde(rename = "dataFactoryLocation", skip_serializing)]
    pub data_factory_location: Option<String>,
    #[serde(rename = "createTime", skip_serializing)]
    pub create_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SelfHostedIntegrationRuntimeNode {
    #[serde(rename = "nodeName", skip_serializing)]
    pub node_name: Option<String>,
    #[serde(rename = "machineName", skip_serializing)]
    pub machine_name: Option<String>,
    #[serde(rename = "hostServiceUri", skip_serializing)]
    pub host_service_uri: Option<String>,
    #[serde(skip_serializing)]
    pub status: Option<self_hosted_integration_runtime_node::Status>,
    #[serde(skip_serializing)]
    pub capabilities: Option<serde_json::Value>,
    #[serde(rename = "versionStatus", skip_serializing)]
    pub version_status: Option<String>,
    #[serde(skip_serializing)]
    pub version: Option<String>,
    #[serde(rename = "registerTime", skip_serializing)]
    pub register_time: Option<String>,
    #[serde(rename = "lastConnectTime", skip_serializing)]
    pub last_connect_time: Option<String>,
    #[serde(rename = "expiryTime", skip_serializing)]
    pub expiry_time: Option<String>,
    #[serde(rename = "lastStartTime", skip_serializing)]
    pub last_start_time: Option<String>,
    #[serde(rename = "lastStopTime", skip_serializing)]
    pub last_stop_time: Option<String>,
    #[serde(rename = "lastUpdateResult", skip_serializing)]
    pub last_update_result: Option<self_hosted_integration_runtime_node::LastUpdateResult>,
    #[serde(rename = "lastStartUpdateTime", skip_serializing)]
    pub last_start_update_time: Option<String>,
    #[serde(rename = "lastEndUpdateTime", skip_serializing)]
    pub last_end_update_time: Option<String>,
    #[serde(rename = "isActiveDispatcher", skip_serializing)]
    pub is_active_dispatcher: Option<bool>,
    #[serde(rename = "concurrentJobsLimit", skip_serializing)]
    pub concurrent_jobs_limit: Option<i64>,
    #[serde(rename = "maxConcurrentJobs", skip_serializing)]
    pub max_concurrent_jobs: Option<i64>,
}
pub mod self_hosted_integration_runtime_node {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        NeedRegistration,
        Online,
        Limited,
        Offline,
        Upgrading,
        Initializing,
        InitializeFailed,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LastUpdateResult {
        None,
        Succeed,
        Fail,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeConnectionInfo {
    #[serde(rename = "serviceToken", skip_serializing)]
    pub service_token: Option<String>,
    #[serde(rename = "identityCertThumbprint", skip_serializing)]
    pub identity_cert_thumbprint: Option<String>,
    #[serde(rename = "hostServiceUri", skip_serializing)]
    pub host_service_uri: Option<String>,
    #[serde(skip_serializing)]
    pub version: Option<String>,
    #[serde(rename = "publicKey", skip_serializing)]
    pub public_key: Option<String>,
    #[serde(rename = "isIdentityCertExprired", skip_serializing)]
    pub is_identity_cert_exprired: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeRegenerateKeyParameters {
    #[serde(rename = "keyName", skip_serializing_if = "Option::is_none")]
    pub key_name: Option<integration_runtime_regenerate_key_parameters::KeyName>,
}
pub mod integration_runtime_regenerate_key_parameters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum KeyName {
        #[serde(rename = "authKey1")]
        AuthKey1,
        #[serde(rename = "authKey2")]
        AuthKey2,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeAuthKeys {
    #[serde(rename = "authKey1", skip_serializing_if = "Option::is_none")]
    pub auth_key1: Option<String>,
    #[serde(rename = "authKey2", skip_serializing_if = "Option::is_none")]
    pub auth_key2: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeMonitoringData {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub nodes: Vec<IntegrationRuntimeNodeMonitoringData>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeNodeMonitoringData {
    #[serde(rename = "nodeName", skip_serializing)]
    pub node_name: Option<String>,
    #[serde(rename = "availableMemoryInMB", skip_serializing)]
    pub available_memory_in_mb: Option<i64>,
    #[serde(rename = "cpuUtilization", skip_serializing)]
    pub cpu_utilization: Option<i64>,
    #[serde(rename = "concurrentJobsLimit", skip_serializing)]
    pub concurrent_jobs_limit: Option<i64>,
    #[serde(rename = "concurrentJobsRunning", skip_serializing)]
    pub concurrent_jobs_running: Option<i64>,
    #[serde(rename = "maxConcurrentJobs", skip_serializing)]
    pub max_concurrent_jobs: Option<i64>,
    #[serde(rename = "sentBytes", skip_serializing)]
    pub sent_bytes: Option<f64>,
    #[serde(rename = "receivedBytes", skip_serializing)]
    pub received_bytes: Option<f64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeNodeIpAddress {
    #[serde(rename = "ipAddress", skip_serializing)]
    pub ip_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisObjectMetadataListResponse {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<SsisObjectMetadata>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisObjectMetadata {
    #[serde(rename = "type")]
    pub type_: SsisObjectMetadataType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SsisObjectMetadataType {
    Folder,
    Project,
    Package,
    Environment,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisFolder {
    #[serde(flatten)]
    pub ssis_object_metadata: SsisObjectMetadata,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisProject {
    #[serde(flatten)]
    pub ssis_object_metadata: SsisObjectMetadata,
    #[serde(rename = "folderId", skip_serializing_if = "Option::is_none")]
    pub folder_id: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
    #[serde(rename = "environmentRefs", skip_serializing_if = "Vec::is_empty")]
    pub environment_refs: Vec<SsisEnvironmentReference>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<SsisParameter>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisPackage {
    #[serde(flatten)]
    pub ssis_object_metadata: SsisObjectMetadata,
    #[serde(rename = "folderId", skip_serializing_if = "Option::is_none")]
    pub folder_id: Option<i64>,
    #[serde(rename = "projectVersion", skip_serializing_if = "Option::is_none")]
    pub project_version: Option<i64>,
    #[serde(rename = "projectId", skip_serializing_if = "Option::is_none")]
    pub project_id: Option<i64>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<SsisParameter>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisEnvironment {
    #[serde(flatten)]
    pub ssis_object_metadata: SsisObjectMetadata,
    #[serde(rename = "folderId", skip_serializing_if = "Option::is_none")]
    pub folder_id: Option<i64>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub variables: Vec<SsisVariable>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisParameter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "dataType", skip_serializing_if = "Option::is_none")]
    pub data_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sensitive: Option<bool>,
    #[serde(rename = "designDefaultValue", skip_serializing_if = "Option::is_none")]
    pub design_default_value: Option<String>,
    #[serde(rename = "defaultValue", skip_serializing_if = "Option::is_none")]
    pub default_value: Option<String>,
    #[serde(rename = "sensitiveDefaultValue", skip_serializing_if = "Option::is_none")]
    pub sensitive_default_value: Option<String>,
    #[serde(rename = "valueType", skip_serializing_if = "Option::is_none")]
    pub value_type: Option<String>,
    #[serde(rename = "valueSet", skip_serializing_if = "Option::is_none")]
    pub value_set: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variable: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisVariable {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "dataType", skip_serializing_if = "Option::is_none")]
    pub data_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sensitive: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(rename = "sensitiveValue", skip_serializing_if = "Option::is_none")]
    pub sensitive_value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisEnvironmentReference {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i64>,
    #[serde(rename = "environmentFolderName", skip_serializing_if = "Option::is_none")]
    pub environment_folder_name: Option<String>,
    #[serde(rename = "environmentName", skip_serializing_if = "Option::is_none")]
    pub environment_name: Option<String>,
    #[serde(rename = "referenceType", skip_serializing_if = "Option::is_none")]
    pub reference_type: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UpdateIntegrationRuntimeRequest {
    #[serde(rename = "autoUpdate", skip_serializing_if = "Option::is_none")]
    pub auto_update: Option<IntegrationRuntimeAutoUpdate>,
    #[serde(rename = "updateDelayOffset", skip_serializing_if = "Option::is_none")]
    pub update_delay_offset: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: IntegrationRuntime,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GetSsisObjectMetadataRequest {
    #[serde(rename = "metadataPath", skip_serializing_if = "Option::is_none")]
    pub metadata_path: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UpdateIntegrationRuntimeNodeRequest {
    #[serde(rename = "concurrentJobsLimit", skip_serializing_if = "Option::is_none")]
    pub concurrent_jobs_limit: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeListResponse {
    pub value: Vec<IntegrationRuntimeResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IntegrationRuntimeStatusResponse {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    pub properties: IntegrationRuntimeStatus,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SsisObjectMetadataStatusResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkResourceListResult {
    #[serde(skip_serializing)]
    pub value: Vec<PrivateLinkResource>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkResource {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateLinkResourceProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkResourceProperties {
    #[serde(rename = "groupId", skip_serializing)]
    pub group_id: Option<String>,
    #[serde(rename = "requiredMembers", skip_serializing)]
    pub required_members: Vec<String>,
    #[serde(rename = "requiredZoneNames", skip_serializing)]
    pub required_zone_names: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct KeyInfoListResult {
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Key>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Key {
    #[serde(flatten)]
    pub proxy_resource: ProxyResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<KeyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct KeyProperties {
    #[serde(rename = "isActiveCMK", skip_serializing_if = "Option::is_none")]
    pub is_active_cmk: Option<bool>,
    #[serde(rename = "keyVaultUrl", skip_serializing_if = "Option::is_none")]
    pub key_vault_url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrackedResource {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    pub location: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Resource {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorResponse {
    #[serde(skip_serializing)]
    pub code: Option<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
    #[serde(skip_serializing)]
    pub target: Option<String>,
    #[serde(skip_serializing)]
    pub details: Vec<ErrorResponse>,
    #[serde(rename = "additionalInfo", skip_serializing)]
    pub additional_info: Vec<ErrorAdditionalInfo>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorAdditionalInfo {
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub info: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ProxyResource {
    #[serde(flatten)]
    pub resource: Resource,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureEntityResource {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
