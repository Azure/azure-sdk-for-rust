#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use crate::models::*;
use reqwest::StatusCode;
use snafu::{ResultExt, Snafu};
pub async fn get_catalog(
    operation_config: &crate::OperationConfig,
    subscription_id: &str,
    reserved_resource_type: &str,
    location: Option<&str>,
) -> std::result::Result<Vec<Catalog>, get_catalog::Error> {
    let client = &operation_config.client;
    let uri_str = &format!(
        "{}/subscriptions/{}/providers/Microsoft.Capacity/catalogs",
        &operation_config.base_path, subscription_id
    );
    let mut req_builder = client.get(uri_str);
    if let Some(token) = &operation_config.bearer_access_token {
        req_builder = req_builder.bearer_auth(token);
    }
    req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
    req_builder = req_builder.query(&[("reservedResourceType", reserved_resource_type)]);
    if let Some(location) = location {
        req_builder = req_builder.query(&[("location", location)]);
    }
    let req = req_builder.build().context(get_catalog::BuildRequestError)?;
    let rsp = client.execute(req).await.context(get_catalog::ExecuteRequestError)?;
    match rsp.status() {
        StatusCode::OK => {
            let body: bytes::Bytes = rsp.bytes().await.context(get_catalog::ResponseBytesError)?;
            let rsp_value: Vec<Catalog> = serde_json::from_slice(&body).context(get_catalog::DeserializeError { body })?;
            Ok(rsp_value)
        }
        status_code => {
            let body: bytes::Bytes = rsp.bytes().await.context(get_catalog::ResponseBytesError)?;
            let rsp_value: Error = serde_json::from_slice(&body).context(get_catalog::DeserializeError { body })?;
            get_catalog::DefaultResponse {
                status_code,
                value: rsp_value,
            }
            .fail()
        }
    }
}
pub mod get_catalog {
    use crate::{models, models::*};
    use reqwest::StatusCode;
    use snafu::Snafu;
    #[derive(Debug, Snafu)]
    #[snafu(visibility(pub(crate)))]
    pub enum Error {
        DefaultResponse { status_code: StatusCode, value: models::Error },
        BuildRequestError { source: reqwest::Error },
        ExecuteRequestError { source: reqwest::Error },
        ResponseBytesError { source: reqwest::Error },
        DeserializeError { source: serde_json::Error, body: bytes::Bytes },
    }
}
pub async fn get_applied_reservation_list(
    operation_config: &crate::OperationConfig,
    subscription_id: &str,
) -> std::result::Result<AppliedReservations, get_applied_reservation_list::Error> {
    let client = &operation_config.client;
    let uri_str = &format!(
        "{}/subscriptions/{}/providers/Microsoft.Capacity/appliedReservations",
        &operation_config.base_path, subscription_id
    );
    let mut req_builder = client.get(uri_str);
    if let Some(token) = &operation_config.bearer_access_token {
        req_builder = req_builder.bearer_auth(token);
    }
    req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
    let req = req_builder.build().context(get_applied_reservation_list::BuildRequestError)?;
    let rsp = client
        .execute(req)
        .await
        .context(get_applied_reservation_list::ExecuteRequestError)?;
    match rsp.status() {
        StatusCode::OK => {
            let body: bytes::Bytes = rsp.bytes().await.context(get_applied_reservation_list::ResponseBytesError)?;
            let rsp_value: AppliedReservations =
                serde_json::from_slice(&body).context(get_applied_reservation_list::DeserializeError { body })?;
            Ok(rsp_value)
        }
        status_code => {
            let body: bytes::Bytes = rsp.bytes().await.context(get_applied_reservation_list::ResponseBytesError)?;
            let rsp_value: Error = serde_json::from_slice(&body).context(get_applied_reservation_list::DeserializeError { body })?;
            get_applied_reservation_list::DefaultResponse {
                status_code,
                value: rsp_value,
            }
            .fail()
        }
    }
}
pub mod get_applied_reservation_list {
    use crate::{models, models::*};
    use reqwest::StatusCode;
    use snafu::Snafu;
    #[derive(Debug, Snafu)]
    #[snafu(visibility(pub(crate)))]
    pub enum Error {
        DefaultResponse { status_code: StatusCode, value: models::Error },
        BuildRequestError { source: reqwest::Error },
        ExecuteRequestError { source: reqwest::Error },
        ResponseBytesError { source: reqwest::Error },
        DeserializeError { source: serde_json::Error, body: bytes::Bytes },
    }
}
pub mod reservation_order {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(operation_config: &crate::OperationConfig) -> std::result::Result<ReservationOrderList, list::Error> {
        let client = &operation_config.client;
        let uri_str = &format!("{}/providers/Microsoft.Capacity/reservationOrders", &operation_config.base_path,);
        let mut req_builder = client.get(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ReservationOrderList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        reservation_order_id: &str,
    ) -> std::result::Result<ReservationOrderResponse, get::Error> {
        let client = &operation_config.client;
        let uri_str = &format!(
            "{}/providers/Microsoft.Capacity/reservationOrders/{}",
            &operation_config.base_path, reservation_order_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: ReservationOrderResponse = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
}
pub mod reservation {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn split(
        operation_config: &crate::OperationConfig,
        reservation_order_id: &str,
        body: &SplitRequest,
    ) -> std::result::Result<split::Response, split::Error> {
        let client = &operation_config.client;
        let uri_str = &format!(
            "{}/providers/Microsoft.Capacity/reservationOrders/{}/split",
            &operation_config.base_path, reservation_order_id
        );
        let mut req_builder = client.post(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        req_builder = req_builder.json(body);
        let req = req_builder.build().context(split::BuildRequestError)?;
        let rsp = client.execute(req).await.context(split::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(split::ResponseBytesError)?;
                let rsp_value: Vec<ReservationResponse> = serde_json::from_slice(&body).context(split::DeserializeError { body })?;
                Ok(split::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(split::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(split::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(split::DeserializeError { body })?;
                split::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod split {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Vec<ReservationResponse>),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
    pub async fn merge(
        operation_config: &crate::OperationConfig,
        reservation_order_id: &str,
        body: &MergeRequest,
    ) -> std::result::Result<merge::Response, merge::Error> {
        let client = &operation_config.client;
        let uri_str = &format!(
            "{}/providers/Microsoft.Capacity/reservationOrders/{}/merge",
            &operation_config.base_path, reservation_order_id
        );
        let mut req_builder = client.post(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        req_builder = req_builder.json(body);
        let req = req_builder.build().context(merge::BuildRequestError)?;
        let rsp = client.execute(req).await.context(merge::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(merge::ResponseBytesError)?;
                let rsp_value: Vec<ReservationResponse> = serde_json::from_slice(&body).context(merge::DeserializeError { body })?;
                Ok(merge::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(merge::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(merge::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(merge::DeserializeError { body })?;
                merge::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod merge {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(Vec<ReservationResponse>),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        reservation_order_id: &str,
    ) -> std::result::Result<ReservationList, list::Error> {
        let client = &operation_config.client;
        let uri_str = &format!(
            "{}/providers/Microsoft.Capacity/reservationOrders/{}/reservations",
            &operation_config.base_path, reservation_order_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ReservationList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        reservation_id: &str,
        reservation_order_id: &str,
    ) -> std::result::Result<ReservationResponse, get::Error> {
        let client = &operation_config.client;
        let uri_str = &format!(
            "{}/providers/Microsoft.Capacity/reservationOrders/{}/reservations/{}",
            &operation_config.base_path, reservation_order_id, reservation_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: ReservationResponse = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        reservation_order_id: &str,
        reservation_id: &str,
        parameters: &Patch,
    ) -> std::result::Result<update::Response, update::Error> {
        let client = &operation_config.client;
        let uri_str = &format!(
            "{}/providers/Microsoft.Capacity/reservationOrders/{}/reservations/{}",
            &operation_config.base_path, reservation_order_id, reservation_id
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        req_builder = req_builder.json(parameters);
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: ReservationResponse = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(update::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(update::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(ReservationResponse),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
    pub async fn list_revisions(
        operation_config: &crate::OperationConfig,
        reservation_id: &str,
        reservation_order_id: &str,
    ) -> std::result::Result<ReservationList, list_revisions::Error> {
        let client = &operation_config.client;
        let uri_str = &format!(
            "{}/providers/Microsoft.Capacity/reservationOrders/{}/reservations/{}/revisions",
            &operation_config.base_path, reservation_order_id, reservation_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        let req = req_builder.build().context(list_revisions::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_revisions::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_revisions::ResponseBytesError)?;
                let rsp_value: ReservationList = serde_json::from_slice(&body).context(list_revisions::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_revisions::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(list_revisions::DeserializeError { body })?;
                list_revisions::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_revisions {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
}
pub mod operation {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(operation_config: &crate::OperationConfig) -> std::result::Result<OperationList, list::Error> {
        let client = &operation_config.client;
        let uri_str = &format!("{}/providers/Microsoft.Capacity/operations", &operation_config.base_path,);
        let mut req_builder = client.get(uri_str);
        if let Some(token) = &operation_config.bearer_access_token {
            req_builder = req_builder.bearer_auth(token);
        }
        req_builder = req_builder.query(&[("api-version", &operation_config.api_version)]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: OperationList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: Error = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse { status_code: StatusCode, value: models::Error },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
        }
    }
}
