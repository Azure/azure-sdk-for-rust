#![doc = "generated by AutoRust"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::de::{value, Deserializer, IntoDeserializer};
use serde::{Deserialize, Serialize, Serializer};
use std::str::FromStr;
#[doc = "Profile for enabling a user to access a managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AccessProfile {
    #[doc = "Base64-encoded Kubernetes configuration file."]
    #[serde(rename = "kubeConfig", default, skip_serializing_if = "Option::is_none")]
    pub kube_config: Option<String>,
}
impl AccessProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Agent Pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AgentPool {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[doc = "Properties for the container service agent pool profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagedClusterAgentPoolProfileProperties>,
}
impl AgentPool {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The list of available versions for an agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AgentPoolAvailableVersions {
    #[doc = "Id of the agent pool available versions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Name of the agent pool available versions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Type of the agent pool  available versions."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The list of available agent pool versions."]
    pub properties: AgentPoolAvailableVersionsProperties,
}
impl AgentPoolAvailableVersions {
    pub fn new(properties: AgentPoolAvailableVersionsProperties) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            properties,
        }
    }
}
#[doc = "The list of available agent pool versions."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AgentPoolAvailableVersionsProperties {
    #[doc = "List of versions available for agent pool."]
    #[serde(rename = "agentPoolVersions", default, skip_serializing_if = "Vec::is_empty")]
    pub agent_pool_versions: Vec<serde_json::Value>,
}
impl AgentPoolAvailableVersionsProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The response from the List Agent Pools operation."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AgentPoolListResult {
    #[doc = "The list of agent pools."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AgentPool>,
    #[doc = "The URL to get the next set of agent pool results."]
    #[serde(rename = "nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl azure_core::Continuable for AgentPoolListResult {
    fn continuation(&self) -> Option<azure_core::prelude::Continuation> {
        self.next_link.clone().map(azure_core::prelude::Continuation::from)
    }
}
impl AgentPoolListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "AgentPoolMode represents mode of an agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(remote = "AgentPoolMode")]
pub enum AgentPoolMode {
    System,
    User,
    #[serde(skip_deserializing)]
    UnknownValue(String),
}
impl FromStr for AgentPoolMode {
    type Err = value::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(s.into_deserializer())
    }
}
impl<'de> Deserialize<'de> for AgentPoolMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
        Ok(deserialized)
    }
}
impl Serialize for AgentPoolMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::System => serializer.serialize_unit_variant("AgentPoolMode", 0u32, "System"),
            Self::User => serializer.serialize_unit_variant("AgentPoolMode", 1u32, "User"),
            Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
        }
    }
}
#[doc = "AgentPoolType represents types of an agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(remote = "AgentPoolType")]
pub enum AgentPoolType {
    VirtualMachineScaleSets,
    AvailabilitySet,
    #[serde(skip_deserializing)]
    UnknownValue(String),
}
impl FromStr for AgentPoolType {
    type Err = value::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(s.into_deserializer())
    }
}
impl<'de> Deserialize<'de> for AgentPoolType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
        Ok(deserialized)
    }
}
impl Serialize for AgentPoolType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::VirtualMachineScaleSets => serializer.serialize_unit_variant("AgentPoolType", 0u32, "VirtualMachineScaleSets"),
            Self::AvailabilitySet => serializer.serialize_unit_variant("AgentPoolType", 1u32, "AvailabilitySet"),
            Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
        }
    }
}
#[doc = "The list of available upgrades for an agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AgentPoolUpgradeProfile {
    #[doc = "Id of the agent pool upgrade profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Name of the agent pool upgrade profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Type of the agent pool upgrade profile."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The list of available upgrade versions."]
    pub properties: AgentPoolUpgradeProfileProperties,
}
impl AgentPoolUpgradeProfile {
    pub fn new(properties: AgentPoolUpgradeProfileProperties) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            properties,
        }
    }
}
#[doc = "The list of available upgrade versions."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AgentPoolUpgradeProfileProperties {
    #[doc = "Kubernetes version (major, minor, patch)."]
    #[serde(rename = "kubernetesVersion")]
    pub kubernetes_version: String,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType")]
    pub os_type: OsType,
    #[doc = "List of orchestrator types and versions available for upgrade."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub upgrades: Vec<serde_json::Value>,
    #[doc = "LatestNodeImageVersion is the latest AKS supported node image version."]
    #[serde(rename = "latestNodeImageVersion", default, skip_serializing_if = "Option::is_none")]
    pub latest_node_image_version: Option<String>,
}
impl AgentPoolUpgradeProfileProperties {
    pub fn new(kubernetes_version: String, os_type: OsType) -> Self {
        Self {
            kubernetes_version,
            os_type,
            upgrades: Vec::new(),
            latest_node_image_version: None,
        }
    }
}
#[doc = "Settings for upgrading an agentpool"]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AgentPoolUpgradeSettings {
    #[doc = "Count or percentage of additional nodes to be added during upgrade. If empty uses AKS default"]
    #[serde(rename = "maxSurge", default, skip_serializing_if = "Option::is_none")]
    pub max_surge: Option<String>,
}
impl AgentPoolUpgradeSettings {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "An error response from the Container service."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CloudError {
    #[doc = "An error response from the Container service."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<CloudErrorBody>,
}
impl azure_core::Continuable for CloudError {
    fn continuation(&self) -> Option<azure_core::prelude::Continuation> {
        None
    }
}
impl CloudError {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "An error response from the Container service."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CloudErrorBody {
    #[doc = "An identifier for the error. Codes are invariant and are intended to be consumed programmatically."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[doc = "A message describing the error, intended to be suitable for display in a user interface."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[doc = "The target of the particular error. For example, the name of the property in error."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[doc = "A list of additional details about the error."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<CloudErrorBody>,
}
impl CloudErrorBody {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Container service."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerService {
    #[serde(flatten)]
    pub resource: Resource,
    #[doc = "Properties of the container service."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<ContainerServiceProperties>,
}
impl ContainerService {
    pub fn new(resource: Resource) -> Self {
        Self {
            resource,
            properties: None,
        }
    }
}
#[doc = "Profile for the container service agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceAgentPoolProfile {
    #[doc = "Unique name of the agent pool profile in the context of the subscription and resource group."]
    pub name: String,
    #[doc = "Number of agents (VMs) to host docker containers. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1. "]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    #[doc = "Size of agent VMs."]
    #[serde(rename = "vmSize")]
    pub vm_size: ContainerServiceVmSize,
    #[doc = "OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified."]
    #[serde(rename = "osDiskSizeGB", default, skip_serializing_if = "Option::is_none")]
    pub os_disk_size_gb: Option<ContainerServiceOsDisk>,
    #[doc = "DNS prefix to be used to create the FQDN for the agent pool."]
    #[serde(rename = "dnsPrefix", default, skip_serializing_if = "Option::is_none")]
    pub dns_prefix: Option<String>,
    #[doc = "FQDN for the agent pool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[doc = "Ports number array used to expose on this agent pool. The default opened ports are different based on your choice of orchestrator."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub ports: Vec<i64>,
    #[doc = "Storage profile specifies what kind of storage used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will choose for you based on the orchestrator choice."]
    #[serde(rename = "storageProfile", default, skip_serializing_if = "Option::is_none")]
    pub storage_profile: Option<ContainerServiceStorageProfile>,
    #[doc = "VNet SubnetID specifies the VNet's subnet identifier."]
    #[serde(rename = "vnetSubnetID", default, skip_serializing_if = "Option::is_none")]
    pub vnet_subnet_id: Option<ContainerServiceVnetSubnetId>,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType", default, skip_serializing_if = "Option::is_none")]
    pub os_type: Option<OsType>,
}
impl ContainerServiceAgentPoolProfile {
    pub fn new(name: String, vm_size: ContainerServiceVmSize) -> Self {
        Self {
            name,
            count: None,
            vm_size,
            os_disk_size_gb: None,
            dns_prefix: None,
            fqdn: None,
            ports: Vec::new(),
            storage_profile: None,
            vnet_subnet_id: None,
            os_type: None,
        }
    }
}
#[doc = "Properties to configure a custom container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceCustomProfile {
    #[doc = "The name of the custom orchestrator to use."]
    pub orchestrator: String,
}
impl ContainerServiceCustomProfile {
    pub fn new(orchestrator: String) -> Self {
        Self { orchestrator }
    }
}
#[doc = "Profile for diagnostics on the container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceDiagnosticsProfile {
    #[doc = "Profile for diagnostics on the container service VMs."]
    #[serde(rename = "vmDiagnostics")]
    pub vm_diagnostics: ContainerServiceVmDiagnostics,
}
impl ContainerServiceDiagnosticsProfile {
    pub fn new(vm_diagnostics: ContainerServiceVmDiagnostics) -> Self {
        Self { vm_diagnostics }
    }
}
#[doc = "Profile for Linux VMs in the container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceLinuxProfile {
    #[doc = "The administrator username to use for Linux VMs."]
    #[serde(rename = "adminUsername")]
    pub admin_username: String,
    #[doc = "SSH configuration for Linux-based VMs running on Azure."]
    pub ssh: ContainerServiceSshConfiguration,
}
impl ContainerServiceLinuxProfile {
    pub fn new(admin_username: String, ssh: ContainerServiceSshConfiguration) -> Self {
        Self { admin_username, ssh }
    }
}
#[doc = "The response from the List Container Services operation."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ContainerServiceListResult {
    #[doc = "The list of container services."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ContainerService>,
    #[doc = "The URL to get the next set of container service results."]
    #[serde(rename = "nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl azure_core::Continuable for ContainerServiceListResult {
    fn continuation(&self) -> Option<azure_core::prelude::Continuation> {
        self.next_link.clone().map(azure_core::prelude::Continuation::from)
    }
}
impl ContainerServiceListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Profile for the container service master."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceMasterProfile {
    #[doc = "Number of masters (VMs) in the container service cluster. Allowed values are 1, 3, and 5. The default value is 1."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<container_service_master_profile::Count>,
    #[doc = "DNS prefix to be used to create the FQDN for the master pool."]
    #[serde(rename = "dnsPrefix")]
    pub dns_prefix: String,
    #[doc = "Size of agent VMs."]
    #[serde(rename = "vmSize")]
    pub vm_size: ContainerServiceVmSize,
    #[doc = "OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified."]
    #[serde(rename = "osDiskSizeGB", default, skip_serializing_if = "Option::is_none")]
    pub os_disk_size_gb: Option<ContainerServiceOsDisk>,
    #[doc = "specifies a subnet's resource id with subscription, resource group, vnet and subnet name"]
    #[serde(rename = "vnetSubnetID", default, skip_serializing_if = "Option::is_none")]
    pub vnet_subnet_id: Option<ContainerServiceVnetSubnetId>,
    #[doc = "FirstConsecutiveStaticIP used to specify the first static ip of masters."]
    #[serde(rename = "firstConsecutiveStaticIP", default, skip_serializing_if = "Option::is_none")]
    pub first_consecutive_static_ip: Option<String>,
    #[doc = "Storage profile specifies what kind of storage used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will choose for you based on the orchestrator choice."]
    #[serde(rename = "storageProfile", default, skip_serializing_if = "Option::is_none")]
    pub storage_profile: Option<ContainerServiceStorageProfile>,
    #[doc = "FQDN for the master pool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
}
impl ContainerServiceMasterProfile {
    pub fn new(dns_prefix: String, vm_size: ContainerServiceVmSize) -> Self {
        Self {
            count: None,
            dns_prefix,
            vm_size,
            os_disk_size_gb: None,
            vnet_subnet_id: None,
            first_consecutive_static_ip: None,
            storage_profile: None,
            fqdn: None,
        }
    }
}
pub mod container_service_master_profile {
    use super::*;
    #[doc = "Number of masters (VMs) in the container service cluster. Allowed values are 1, 3, and 5. The default value is 1."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Count {}
}
#[doc = "Profile of network configuration."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ContainerServiceNetworkProfile {
    #[doc = "Network plugin used for building Kubernetes network."]
    #[serde(rename = "networkPlugin", default, skip_serializing_if = "Option::is_none")]
    pub network_plugin: Option<container_service_network_profile::NetworkPlugin>,
    #[doc = "Network policy used for building Kubernetes network."]
    #[serde(rename = "networkPolicy", default, skip_serializing_if = "Option::is_none")]
    pub network_policy: Option<container_service_network_profile::NetworkPolicy>,
    #[doc = "Network mode used for building Kubernetes network."]
    #[serde(rename = "networkMode", default, skip_serializing_if = "Option::is_none")]
    pub network_mode: Option<container_service_network_profile::NetworkMode>,
    #[doc = "A CIDR notation IP range from which to assign pod IPs when kubenet is used."]
    #[serde(rename = "podCidr", default, skip_serializing_if = "Option::is_none")]
    pub pod_cidr: Option<String>,
    #[doc = "A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges."]
    #[serde(rename = "serviceCidr", default, skip_serializing_if = "Option::is_none")]
    pub service_cidr: Option<String>,
    #[doc = "An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr."]
    #[serde(rename = "dnsServiceIP", default, skip_serializing_if = "Option::is_none")]
    pub dns_service_ip: Option<String>,
    #[doc = "A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range."]
    #[serde(rename = "dockerBridgeCidr", default, skip_serializing_if = "Option::is_none")]
    pub docker_bridge_cidr: Option<String>,
    #[doc = "The outbound (egress) routing method."]
    #[serde(rename = "outboundType", default, skip_serializing_if = "Option::is_none")]
    pub outbound_type: Option<container_service_network_profile::OutboundType>,
    #[doc = "The load balancer sku for the managed cluster."]
    #[serde(rename = "loadBalancerSku", default, skip_serializing_if = "Option::is_none")]
    pub load_balancer_sku: Option<container_service_network_profile::LoadBalancerSku>,
    #[doc = "Profile of the managed cluster load balancer."]
    #[serde(rename = "loadBalancerProfile", default, skip_serializing_if = "Option::is_none")]
    pub load_balancer_profile: Option<ManagedClusterLoadBalancerProfile>,
}
impl ContainerServiceNetworkProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod container_service_network_profile {
    use super::*;
    #[doc = "Network plugin used for building Kubernetes network."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "NetworkPlugin")]
    pub enum NetworkPlugin {
        #[serde(rename = "azure")]
        Azure,
        #[serde(rename = "kubenet")]
        Kubenet,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for NetworkPlugin {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for NetworkPlugin {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for NetworkPlugin {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Azure => serializer.serialize_unit_variant("NetworkPlugin", 0u32, "azure"),
                Self::Kubenet => serializer.serialize_unit_variant("NetworkPlugin", 1u32, "kubenet"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
    impl Default for NetworkPlugin {
        fn default() -> Self {
            Self::Kubenet
        }
    }
    #[doc = "Network policy used for building Kubernetes network."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "NetworkPolicy")]
    pub enum NetworkPolicy {
        #[serde(rename = "calico")]
        Calico,
        #[serde(rename = "azure")]
        Azure,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for NetworkPolicy {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for NetworkPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for NetworkPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Calico => serializer.serialize_unit_variant("NetworkPolicy", 0u32, "calico"),
                Self::Azure => serializer.serialize_unit_variant("NetworkPolicy", 1u32, "azure"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
    #[doc = "Network mode used for building Kubernetes network."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "NetworkMode")]
    pub enum NetworkMode {
        #[serde(rename = "transparent")]
        Transparent,
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for NetworkMode {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for NetworkMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for NetworkMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Transparent => serializer.serialize_unit_variant("NetworkMode", 0u32, "transparent"),
                Self::Bridge => serializer.serialize_unit_variant("NetworkMode", 1u32, "bridge"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
    #[doc = "The outbound (egress) routing method."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "OutboundType")]
    pub enum OutboundType {
        #[serde(rename = "loadBalancer")]
        LoadBalancer,
        #[serde(rename = "userDefinedRouting")]
        UserDefinedRouting,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for OutboundType {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for OutboundType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for OutboundType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::LoadBalancer => serializer.serialize_unit_variant("OutboundType", 0u32, "loadBalancer"),
                Self::UserDefinedRouting => serializer.serialize_unit_variant("OutboundType", 1u32, "userDefinedRouting"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
    impl Default for OutboundType {
        fn default() -> Self {
            Self::LoadBalancer
        }
    }
    #[doc = "The load balancer sku for the managed cluster."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "LoadBalancerSku")]
    pub enum LoadBalancerSku {
        #[serde(rename = "standard")]
        Standard,
        #[serde(rename = "basic")]
        Basic,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for LoadBalancerSku {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for LoadBalancerSku {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for LoadBalancerSku {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Standard => serializer.serialize_unit_variant("LoadBalancerSku", 0u32, "standard"),
                Self::Basic => serializer.serialize_unit_variant("LoadBalancerSku", 1u32, "basic"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
}
pub type ContainerServiceOsDisk = i32;
#[doc = "Profile for the container service orchestrator."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceOrchestratorProfile {
    #[doc = "The orchestrator to use to manage container service cluster resources. Valid values are Kubernetes, Swarm, DCOS, DockerCE and Custom."]
    #[serde(rename = "orchestratorType")]
    pub orchestrator_type: container_service_orchestrator_profile::OrchestratorType,
    #[doc = "The version of the orchestrator to use. You can specify the major.minor.patch part of the actual version.For example, you can specify version as \"1.6.11\"."]
    #[serde(rename = "orchestratorVersion", default, skip_serializing_if = "Option::is_none")]
    pub orchestrator_version: Option<String>,
}
impl ContainerServiceOrchestratorProfile {
    pub fn new(orchestrator_type: container_service_orchestrator_profile::OrchestratorType) -> Self {
        Self {
            orchestrator_type,
            orchestrator_version: None,
        }
    }
}
pub mod container_service_orchestrator_profile {
    use super::*;
    #[doc = "The orchestrator to use to manage container service cluster resources. Valid values are Kubernetes, Swarm, DCOS, DockerCE and Custom."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "OrchestratorType")]
    pub enum OrchestratorType {
        Kubernetes,
        Swarm,
        #[serde(rename = "DCOS")]
        Dcos,
        #[serde(rename = "DockerCE")]
        DockerCe,
        Custom,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for OrchestratorType {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for OrchestratorType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for OrchestratorType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Kubernetes => serializer.serialize_unit_variant("OrchestratorType", 0u32, "Kubernetes"),
                Self::Swarm => serializer.serialize_unit_variant("OrchestratorType", 1u32, "Swarm"),
                Self::Dcos => serializer.serialize_unit_variant("OrchestratorType", 2u32, "DCOS"),
                Self::DockerCe => serializer.serialize_unit_variant("OrchestratorType", 3u32, "DockerCE"),
                Self::Custom => serializer.serialize_unit_variant("OrchestratorType", 4u32, "Custom"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
}
#[doc = "Properties of the container service."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceProperties {
    #[doc = "The current deployment or provisioning state, which only appears in the response."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[doc = "Profile for the container service orchestrator."]
    #[serde(rename = "orchestratorProfile")]
    pub orchestrator_profile: ContainerServiceOrchestratorProfile,
    #[doc = "Properties to configure a custom container service cluster."]
    #[serde(rename = "customProfile", default, skip_serializing_if = "Option::is_none")]
    pub custom_profile: Option<ContainerServiceCustomProfile>,
    #[doc = "Information about a service principal identity for the cluster to use for manipulating Azure APIs. Either secret or keyVaultSecretRef must be specified."]
    #[serde(rename = "servicePrincipalProfile", default, skip_serializing_if = "Option::is_none")]
    pub service_principal_profile: Option<ContainerServiceServicePrincipalProfile>,
    #[doc = "Profile for the container service master."]
    #[serde(rename = "masterProfile")]
    pub master_profile: ContainerServiceMasterProfile,
    #[doc = "Properties of the agent pool."]
    #[serde(rename = "agentPoolProfiles", default, skip_serializing_if = "Vec::is_empty")]
    pub agent_pool_profiles: Vec<ContainerServiceAgentPoolProfile>,
    #[doc = "Profile for Windows VMs in the container service cluster."]
    #[serde(rename = "windowsProfile", default, skip_serializing_if = "Option::is_none")]
    pub windows_profile: Option<ContainerServiceWindowsProfile>,
    #[doc = "Profile for Linux VMs in the container service cluster."]
    #[serde(rename = "linuxProfile")]
    pub linux_profile: ContainerServiceLinuxProfile,
    #[doc = "Profile for diagnostics on the container service cluster."]
    #[serde(rename = "diagnosticsProfile", default, skip_serializing_if = "Option::is_none")]
    pub diagnostics_profile: Option<ContainerServiceDiagnosticsProfile>,
}
impl ContainerServiceProperties {
    pub fn new(
        orchestrator_profile: ContainerServiceOrchestratorProfile,
        master_profile: ContainerServiceMasterProfile,
        linux_profile: ContainerServiceLinuxProfile,
    ) -> Self {
        Self {
            provisioning_state: None,
            orchestrator_profile,
            custom_profile: None,
            service_principal_profile: None,
            master_profile,
            agent_pool_profiles: Vec::new(),
            windows_profile: None,
            linux_profile,
            diagnostics_profile: None,
        }
    }
}
#[doc = "Information about a service principal identity for the cluster to use for manipulating Azure APIs. Either secret or keyVaultSecretRef must be specified."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceServicePrincipalProfile {
    #[doc = "The ID for the service principal."]
    #[serde(rename = "clientId")]
    pub client_id: String,
    #[doc = "The secret password associated with the service principal in plain text."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    #[doc = "Reference to a secret stored in Azure Key Vault."]
    #[serde(rename = "keyVaultSecretRef", default, skip_serializing_if = "Option::is_none")]
    pub key_vault_secret_ref: Option<KeyVaultSecretRef>,
}
impl ContainerServiceServicePrincipalProfile {
    pub fn new(client_id: String) -> Self {
        Self {
            client_id,
            secret: None,
            key_vault_secret_ref: None,
        }
    }
}
#[doc = "SSH configuration for Linux-based VMs running on Azure."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceSshConfiguration {
    #[doc = "The list of SSH public keys used to authenticate with Linux-based VMs. Only expect one key specified."]
    #[serde(rename = "publicKeys")]
    pub public_keys: Vec<ContainerServiceSshPublicKey>,
}
impl ContainerServiceSshConfiguration {
    pub fn new(public_keys: Vec<ContainerServiceSshPublicKey>) -> Self {
        Self { public_keys }
    }
}
#[doc = "Contains information about SSH certificate public key data."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceSshPublicKey {
    #[doc = "Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers."]
    #[serde(rename = "keyData")]
    pub key_data: String,
}
impl ContainerServiceSshPublicKey {
    pub fn new(key_data: String) -> Self {
        Self { key_data }
    }
}
#[doc = "Storage profile specifies what kind of storage used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will choose for you based on the orchestrator choice."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(remote = "ContainerServiceStorageProfile")]
pub enum ContainerServiceStorageProfile {
    StorageAccount,
    ManagedDisks,
    #[serde(skip_deserializing)]
    UnknownValue(String),
}
impl FromStr for ContainerServiceStorageProfile {
    type Err = value::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(s.into_deserializer())
    }
}
impl<'de> Deserialize<'de> for ContainerServiceStorageProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
        Ok(deserialized)
    }
}
impl Serialize for ContainerServiceStorageProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::StorageAccount => serializer.serialize_unit_variant("ContainerServiceStorageProfile", 0u32, "StorageAccount"),
            Self::ManagedDisks => serializer.serialize_unit_variant("ContainerServiceStorageProfile", 1u32, "ManagedDisks"),
            Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
        }
    }
}
#[doc = "Profile for diagnostics on the container service VMs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceVmDiagnostics {
    #[doc = "Whether the VM diagnostic agent is provisioned on the VM."]
    pub enabled: bool,
    #[doc = "The URI of the storage account where diagnostics are stored."]
    #[serde(rename = "storageUri", default, skip_serializing_if = "Option::is_none")]
    pub storage_uri: Option<String>,
}
impl ContainerServiceVmDiagnostics {
    pub fn new(enabled: bool) -> Self {
        Self {
            enabled,
            storage_uri: None,
        }
    }
}
#[doc = "Size of agent VMs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(remote = "ContainerServiceVmSize")]
pub enum ContainerServiceVmSize {
    #[serde(rename = "Standard_A1")]
    StandardA1,
    #[serde(rename = "Standard_A10")]
    StandardA10,
    #[serde(rename = "Standard_A11")]
    StandardA11,
    #[serde(rename = "Standard_A1_v2")]
    StandardA1V2,
    #[serde(rename = "Standard_A2")]
    StandardA2,
    #[serde(rename = "Standard_A2_v2")]
    StandardA2V2,
    #[serde(rename = "Standard_A2m_v2")]
    StandardA2mV2,
    #[serde(rename = "Standard_A3")]
    StandardA3,
    #[serde(rename = "Standard_A4")]
    StandardA4,
    #[serde(rename = "Standard_A4_v2")]
    StandardA4V2,
    #[serde(rename = "Standard_A4m_v2")]
    StandardA4mV2,
    #[serde(rename = "Standard_A5")]
    StandardA5,
    #[serde(rename = "Standard_A6")]
    StandardA6,
    #[serde(rename = "Standard_A7")]
    StandardA7,
    #[serde(rename = "Standard_A8")]
    StandardA8,
    #[serde(rename = "Standard_A8_v2")]
    StandardA8V2,
    #[serde(rename = "Standard_A8m_v2")]
    StandardA8mV2,
    #[serde(rename = "Standard_A9")]
    StandardA9,
    #[serde(rename = "Standard_B2ms")]
    StandardB2ms,
    #[serde(rename = "Standard_B2s")]
    StandardB2s,
    #[serde(rename = "Standard_B4ms")]
    StandardB4ms,
    #[serde(rename = "Standard_B8ms")]
    StandardB8ms,
    #[serde(rename = "Standard_D1")]
    StandardD1,
    #[serde(rename = "Standard_D11")]
    StandardD11,
    #[serde(rename = "Standard_D11_v2")]
    StandardD11V2,
    #[serde(rename = "Standard_D11_v2_Promo")]
    StandardD11V2Promo,
    #[serde(rename = "Standard_D12")]
    StandardD12,
    #[serde(rename = "Standard_D12_v2")]
    StandardD12V2,
    #[serde(rename = "Standard_D12_v2_Promo")]
    StandardD12V2Promo,
    #[serde(rename = "Standard_D13")]
    StandardD13,
    #[serde(rename = "Standard_D13_v2")]
    StandardD13V2,
    #[serde(rename = "Standard_D13_v2_Promo")]
    StandardD13V2Promo,
    #[serde(rename = "Standard_D14")]
    StandardD14,
    #[serde(rename = "Standard_D14_v2")]
    StandardD14V2,
    #[serde(rename = "Standard_D14_v2_Promo")]
    StandardD14V2Promo,
    #[serde(rename = "Standard_D15_v2")]
    StandardD15V2,
    #[serde(rename = "Standard_D16_v3")]
    StandardD16V3,
    #[serde(rename = "Standard_D16s_v3")]
    StandardD16sV3,
    #[serde(rename = "Standard_D1_v2")]
    StandardD1V2,
    #[serde(rename = "Standard_D2")]
    StandardD2,
    #[serde(rename = "Standard_D2_v2")]
    StandardD2V2,
    #[serde(rename = "Standard_D2_v2_Promo")]
    StandardD2V2Promo,
    #[serde(rename = "Standard_D2_v3")]
    StandardD2V3,
    #[serde(rename = "Standard_D2s_v3")]
    StandardD2sV3,
    #[serde(rename = "Standard_D3")]
    StandardD3,
    #[serde(rename = "Standard_D32_v3")]
    StandardD32V3,
    #[serde(rename = "Standard_D32s_v3")]
    StandardD32sV3,
    #[serde(rename = "Standard_D3_v2")]
    StandardD3V2,
    #[serde(rename = "Standard_D3_v2_Promo")]
    StandardD3V2Promo,
    #[serde(rename = "Standard_D4")]
    StandardD4,
    #[serde(rename = "Standard_D4_v2")]
    StandardD4V2,
    #[serde(rename = "Standard_D4_v2_Promo")]
    StandardD4V2Promo,
    #[serde(rename = "Standard_D4_v3")]
    StandardD4V3,
    #[serde(rename = "Standard_D4s_v3")]
    StandardD4sV3,
    #[serde(rename = "Standard_D5_v2")]
    StandardD5V2,
    #[serde(rename = "Standard_D5_v2_Promo")]
    StandardD5V2Promo,
    #[serde(rename = "Standard_D64_v3")]
    StandardD64V3,
    #[serde(rename = "Standard_D64s_v3")]
    StandardD64sV3,
    #[serde(rename = "Standard_D8_v3")]
    StandardD8V3,
    #[serde(rename = "Standard_D8s_v3")]
    StandardD8sV3,
    #[serde(rename = "Standard_DS1")]
    StandardDs1,
    #[serde(rename = "Standard_DS11")]
    StandardDs11,
    #[serde(rename = "Standard_DS11_v2")]
    StandardDs11V2,
    #[serde(rename = "Standard_DS11_v2_Promo")]
    StandardDs11V2Promo,
    #[serde(rename = "Standard_DS12")]
    StandardDs12,
    #[serde(rename = "Standard_DS12_v2")]
    StandardDs12V2,
    #[serde(rename = "Standard_DS12_v2_Promo")]
    StandardDs12V2Promo,
    #[serde(rename = "Standard_DS13")]
    StandardDs13,
    #[serde(rename = "Standard_DS13-2_v2")]
    StandardDs132V2,
    #[serde(rename = "Standard_DS13-4_v2")]
    StandardDs134V2,
    #[serde(rename = "Standard_DS13_v2")]
    StandardDs13V2,
    #[serde(rename = "Standard_DS13_v2_Promo")]
    StandardDs13V2Promo,
    #[serde(rename = "Standard_DS14")]
    StandardDs14,
    #[serde(rename = "Standard_DS14-4_v2")]
    StandardDs144V2,
    #[serde(rename = "Standard_DS14-8_v2")]
    StandardDs148V2,
    #[serde(rename = "Standard_DS14_v2")]
    StandardDs14V2,
    #[serde(rename = "Standard_DS14_v2_Promo")]
    StandardDs14V2Promo,
    #[serde(rename = "Standard_DS15_v2")]
    StandardDs15V2,
    #[serde(rename = "Standard_DS1_v2")]
    StandardDs1V2,
    #[serde(rename = "Standard_DS2")]
    StandardDs2,
    #[serde(rename = "Standard_DS2_v2")]
    StandardDs2V2,
    #[serde(rename = "Standard_DS2_v2_Promo")]
    StandardDs2V2Promo,
    #[serde(rename = "Standard_DS3")]
    StandardDs3,
    #[serde(rename = "Standard_DS3_v2")]
    StandardDs3V2,
    #[serde(rename = "Standard_DS3_v2_Promo")]
    StandardDs3V2Promo,
    #[serde(rename = "Standard_DS4")]
    StandardDs4,
    #[serde(rename = "Standard_DS4_v2")]
    StandardDs4V2,
    #[serde(rename = "Standard_DS4_v2_Promo")]
    StandardDs4V2Promo,
    #[serde(rename = "Standard_DS5_v2")]
    StandardDs5V2,
    #[serde(rename = "Standard_DS5_v2_Promo")]
    StandardDs5V2Promo,
    #[serde(rename = "Standard_E16_v3")]
    StandardE16V3,
    #[serde(rename = "Standard_E16s_v3")]
    StandardE16sV3,
    #[serde(rename = "Standard_E2_v3")]
    StandardE2V3,
    #[serde(rename = "Standard_E2s_v3")]
    StandardE2sV3,
    #[serde(rename = "Standard_E32-16s_v3")]
    StandardE3216sV3,
    #[serde(rename = "Standard_E32-8s_v3")]
    StandardE328sV3,
    #[serde(rename = "Standard_E32_v3")]
    StandardE32V3,
    #[serde(rename = "Standard_E32s_v3")]
    StandardE32sV3,
    #[serde(rename = "Standard_E4_v3")]
    StandardE4V3,
    #[serde(rename = "Standard_E4s_v3")]
    StandardE4sV3,
    #[serde(rename = "Standard_E64-16s_v3")]
    StandardE6416sV3,
    #[serde(rename = "Standard_E64-32s_v3")]
    StandardE6432sV3,
    #[serde(rename = "Standard_E64_v3")]
    StandardE64V3,
    #[serde(rename = "Standard_E64s_v3")]
    StandardE64sV3,
    #[serde(rename = "Standard_E8_v3")]
    StandardE8V3,
    #[serde(rename = "Standard_E8s_v3")]
    StandardE8sV3,
    #[serde(rename = "Standard_F1")]
    StandardF1,
    #[serde(rename = "Standard_F16")]
    StandardF16,
    #[serde(rename = "Standard_F16s")]
    StandardF16s,
    #[serde(rename = "Standard_F16s_v2")]
    StandardF16sV2,
    #[serde(rename = "Standard_F1s")]
    StandardF1s,
    #[serde(rename = "Standard_F2")]
    StandardF2,
    #[serde(rename = "Standard_F2s")]
    StandardF2s,
    #[serde(rename = "Standard_F2s_v2")]
    StandardF2sV2,
    #[serde(rename = "Standard_F32s_v2")]
    StandardF32sV2,
    #[serde(rename = "Standard_F4")]
    StandardF4,
    #[serde(rename = "Standard_F4s")]
    StandardF4s,
    #[serde(rename = "Standard_F4s_v2")]
    StandardF4sV2,
    #[serde(rename = "Standard_F64s_v2")]
    StandardF64sV2,
    #[serde(rename = "Standard_F72s_v2")]
    StandardF72sV2,
    #[serde(rename = "Standard_F8")]
    StandardF8,
    #[serde(rename = "Standard_F8s")]
    StandardF8s,
    #[serde(rename = "Standard_F8s_v2")]
    StandardF8sV2,
    #[serde(rename = "Standard_G1")]
    StandardG1,
    #[serde(rename = "Standard_G2")]
    StandardG2,
    #[serde(rename = "Standard_G3")]
    StandardG3,
    #[serde(rename = "Standard_G4")]
    StandardG4,
    #[serde(rename = "Standard_G5")]
    StandardG5,
    #[serde(rename = "Standard_GS1")]
    StandardGs1,
    #[serde(rename = "Standard_GS2")]
    StandardGs2,
    #[serde(rename = "Standard_GS3")]
    StandardGs3,
    #[serde(rename = "Standard_GS4")]
    StandardGs4,
    #[serde(rename = "Standard_GS4-4")]
    StandardGs44,
    #[serde(rename = "Standard_GS4-8")]
    StandardGs48,
    #[serde(rename = "Standard_GS5")]
    StandardGs5,
    #[serde(rename = "Standard_GS5-16")]
    StandardGs516,
    #[serde(rename = "Standard_GS5-8")]
    StandardGs58,
    #[serde(rename = "Standard_H16")]
    StandardH16,
    #[serde(rename = "Standard_H16m")]
    StandardH16m,
    #[serde(rename = "Standard_H16mr")]
    StandardH16mr,
    #[serde(rename = "Standard_H16r")]
    StandardH16r,
    #[serde(rename = "Standard_H8")]
    StandardH8,
    #[serde(rename = "Standard_H8m")]
    StandardH8m,
    #[serde(rename = "Standard_L16s")]
    StandardL16s,
    #[serde(rename = "Standard_L32s")]
    StandardL32s,
    #[serde(rename = "Standard_L4s")]
    StandardL4s,
    #[serde(rename = "Standard_L8s")]
    StandardL8s,
    #[serde(rename = "Standard_M128-32ms")]
    StandardM12832ms,
    #[serde(rename = "Standard_M128-64ms")]
    StandardM12864ms,
    #[serde(rename = "Standard_M128ms")]
    StandardM128ms,
    #[serde(rename = "Standard_M128s")]
    StandardM128s,
    #[serde(rename = "Standard_M64-16ms")]
    StandardM6416ms,
    #[serde(rename = "Standard_M64-32ms")]
    StandardM6432ms,
    #[serde(rename = "Standard_M64ms")]
    StandardM64ms,
    #[serde(rename = "Standard_M64s")]
    StandardM64s,
    #[serde(rename = "Standard_NC12")]
    StandardNc12,
    #[serde(rename = "Standard_NC12s_v2")]
    StandardNc12sV2,
    #[serde(rename = "Standard_NC12s_v3")]
    StandardNc12sV3,
    #[serde(rename = "Standard_NC24")]
    StandardNc24,
    #[serde(rename = "Standard_NC24r")]
    StandardNc24r,
    #[serde(rename = "Standard_NC24rs_v2")]
    StandardNc24rsV2,
    #[serde(rename = "Standard_NC24rs_v3")]
    StandardNc24rsV3,
    #[serde(rename = "Standard_NC24s_v2")]
    StandardNc24sV2,
    #[serde(rename = "Standard_NC24s_v3")]
    StandardNc24sV3,
    #[serde(rename = "Standard_NC6")]
    StandardNc6,
    #[serde(rename = "Standard_NC6s_v2")]
    StandardNc6sV2,
    #[serde(rename = "Standard_NC6s_v3")]
    StandardNc6sV3,
    #[serde(rename = "Standard_ND12s")]
    StandardNd12s,
    #[serde(rename = "Standard_ND24rs")]
    StandardNd24rs,
    #[serde(rename = "Standard_ND24s")]
    StandardNd24s,
    #[serde(rename = "Standard_ND6s")]
    StandardNd6s,
    #[serde(rename = "Standard_NV12")]
    StandardNv12,
    #[serde(rename = "Standard_NV24")]
    StandardNv24,
    #[serde(rename = "Standard_NV6")]
    StandardNv6,
    #[serde(skip_deserializing)]
    UnknownValue(String),
}
impl FromStr for ContainerServiceVmSize {
    type Err = value::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(s.into_deserializer())
    }
}
impl<'de> Deserialize<'de> for ContainerServiceVmSize {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
        Ok(deserialized)
    }
}
impl Serialize for ContainerServiceVmSize {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::StandardA1 => serializer.serialize_unit_variant("ContainerServiceVmSize", 0u32, "Standard_A1"),
            Self::StandardA10 => serializer.serialize_unit_variant("ContainerServiceVmSize", 1u32, "Standard_A10"),
            Self::StandardA11 => serializer.serialize_unit_variant("ContainerServiceVmSize", 2u32, "Standard_A11"),
            Self::StandardA1V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 3u32, "Standard_A1_v2"),
            Self::StandardA2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 4u32, "Standard_A2"),
            Self::StandardA2V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 5u32, "Standard_A2_v2"),
            Self::StandardA2mV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 6u32, "Standard_A2m_v2"),
            Self::StandardA3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 7u32, "Standard_A3"),
            Self::StandardA4 => serializer.serialize_unit_variant("ContainerServiceVmSize", 8u32, "Standard_A4"),
            Self::StandardA4V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 9u32, "Standard_A4_v2"),
            Self::StandardA4mV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 10u32, "Standard_A4m_v2"),
            Self::StandardA5 => serializer.serialize_unit_variant("ContainerServiceVmSize", 11u32, "Standard_A5"),
            Self::StandardA6 => serializer.serialize_unit_variant("ContainerServiceVmSize", 12u32, "Standard_A6"),
            Self::StandardA7 => serializer.serialize_unit_variant("ContainerServiceVmSize", 13u32, "Standard_A7"),
            Self::StandardA8 => serializer.serialize_unit_variant("ContainerServiceVmSize", 14u32, "Standard_A8"),
            Self::StandardA8V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 15u32, "Standard_A8_v2"),
            Self::StandardA8mV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 16u32, "Standard_A8m_v2"),
            Self::StandardA9 => serializer.serialize_unit_variant("ContainerServiceVmSize", 17u32, "Standard_A9"),
            Self::StandardB2ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 18u32, "Standard_B2ms"),
            Self::StandardB2s => serializer.serialize_unit_variant("ContainerServiceVmSize", 19u32, "Standard_B2s"),
            Self::StandardB4ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 20u32, "Standard_B4ms"),
            Self::StandardB8ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 21u32, "Standard_B8ms"),
            Self::StandardD1 => serializer.serialize_unit_variant("ContainerServiceVmSize", 22u32, "Standard_D1"),
            Self::StandardD11 => serializer.serialize_unit_variant("ContainerServiceVmSize", 23u32, "Standard_D11"),
            Self::StandardD11V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 24u32, "Standard_D11_v2"),
            Self::StandardD11V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 25u32, "Standard_D11_v2_Promo"),
            Self::StandardD12 => serializer.serialize_unit_variant("ContainerServiceVmSize", 26u32, "Standard_D12"),
            Self::StandardD12V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 27u32, "Standard_D12_v2"),
            Self::StandardD12V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 28u32, "Standard_D12_v2_Promo"),
            Self::StandardD13 => serializer.serialize_unit_variant("ContainerServiceVmSize", 29u32, "Standard_D13"),
            Self::StandardD13V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 30u32, "Standard_D13_v2"),
            Self::StandardD13V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 31u32, "Standard_D13_v2_Promo"),
            Self::StandardD14 => serializer.serialize_unit_variant("ContainerServiceVmSize", 32u32, "Standard_D14"),
            Self::StandardD14V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 33u32, "Standard_D14_v2"),
            Self::StandardD14V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 34u32, "Standard_D14_v2_Promo"),
            Self::StandardD15V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 35u32, "Standard_D15_v2"),
            Self::StandardD16V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 36u32, "Standard_D16_v3"),
            Self::StandardD16sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 37u32, "Standard_D16s_v3"),
            Self::StandardD1V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 38u32, "Standard_D1_v2"),
            Self::StandardD2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 39u32, "Standard_D2"),
            Self::StandardD2V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 40u32, "Standard_D2_v2"),
            Self::StandardD2V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 41u32, "Standard_D2_v2_Promo"),
            Self::StandardD2V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 42u32, "Standard_D2_v3"),
            Self::StandardD2sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 43u32, "Standard_D2s_v3"),
            Self::StandardD3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 44u32, "Standard_D3"),
            Self::StandardD32V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 45u32, "Standard_D32_v3"),
            Self::StandardD32sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 46u32, "Standard_D32s_v3"),
            Self::StandardD3V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 47u32, "Standard_D3_v2"),
            Self::StandardD3V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 48u32, "Standard_D3_v2_Promo"),
            Self::StandardD4 => serializer.serialize_unit_variant("ContainerServiceVmSize", 49u32, "Standard_D4"),
            Self::StandardD4V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 50u32, "Standard_D4_v2"),
            Self::StandardD4V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 51u32, "Standard_D4_v2_Promo"),
            Self::StandardD4V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 52u32, "Standard_D4_v3"),
            Self::StandardD4sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 53u32, "Standard_D4s_v3"),
            Self::StandardD5V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 54u32, "Standard_D5_v2"),
            Self::StandardD5V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 55u32, "Standard_D5_v2_Promo"),
            Self::StandardD64V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 56u32, "Standard_D64_v3"),
            Self::StandardD64sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 57u32, "Standard_D64s_v3"),
            Self::StandardD8V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 58u32, "Standard_D8_v3"),
            Self::StandardD8sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 59u32, "Standard_D8s_v3"),
            Self::StandardDs1 => serializer.serialize_unit_variant("ContainerServiceVmSize", 60u32, "Standard_DS1"),
            Self::StandardDs11 => serializer.serialize_unit_variant("ContainerServiceVmSize", 61u32, "Standard_DS11"),
            Self::StandardDs11V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 62u32, "Standard_DS11_v2"),
            Self::StandardDs11V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 63u32, "Standard_DS11_v2_Promo"),
            Self::StandardDs12 => serializer.serialize_unit_variant("ContainerServiceVmSize", 64u32, "Standard_DS12"),
            Self::StandardDs12V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 65u32, "Standard_DS12_v2"),
            Self::StandardDs12V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 66u32, "Standard_DS12_v2_Promo"),
            Self::StandardDs13 => serializer.serialize_unit_variant("ContainerServiceVmSize", 67u32, "Standard_DS13"),
            Self::StandardDs132V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 68u32, "Standard_DS13-2_v2"),
            Self::StandardDs134V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 69u32, "Standard_DS13-4_v2"),
            Self::StandardDs13V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 70u32, "Standard_DS13_v2"),
            Self::StandardDs13V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 71u32, "Standard_DS13_v2_Promo"),
            Self::StandardDs14 => serializer.serialize_unit_variant("ContainerServiceVmSize", 72u32, "Standard_DS14"),
            Self::StandardDs144V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 73u32, "Standard_DS14-4_v2"),
            Self::StandardDs148V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 74u32, "Standard_DS14-8_v2"),
            Self::StandardDs14V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 75u32, "Standard_DS14_v2"),
            Self::StandardDs14V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 76u32, "Standard_DS14_v2_Promo"),
            Self::StandardDs15V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 77u32, "Standard_DS15_v2"),
            Self::StandardDs1V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 78u32, "Standard_DS1_v2"),
            Self::StandardDs2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 79u32, "Standard_DS2"),
            Self::StandardDs2V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 80u32, "Standard_DS2_v2"),
            Self::StandardDs2V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 81u32, "Standard_DS2_v2_Promo"),
            Self::StandardDs3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 82u32, "Standard_DS3"),
            Self::StandardDs3V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 83u32, "Standard_DS3_v2"),
            Self::StandardDs3V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 84u32, "Standard_DS3_v2_Promo"),
            Self::StandardDs4 => serializer.serialize_unit_variant("ContainerServiceVmSize", 85u32, "Standard_DS4"),
            Self::StandardDs4V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 86u32, "Standard_DS4_v2"),
            Self::StandardDs4V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 87u32, "Standard_DS4_v2_Promo"),
            Self::StandardDs5V2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 88u32, "Standard_DS5_v2"),
            Self::StandardDs5V2Promo => serializer.serialize_unit_variant("ContainerServiceVmSize", 89u32, "Standard_DS5_v2_Promo"),
            Self::StandardE16V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 90u32, "Standard_E16_v3"),
            Self::StandardE16sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 91u32, "Standard_E16s_v3"),
            Self::StandardE2V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 92u32, "Standard_E2_v3"),
            Self::StandardE2sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 93u32, "Standard_E2s_v3"),
            Self::StandardE3216sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 94u32, "Standard_E32-16s_v3"),
            Self::StandardE328sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 95u32, "Standard_E32-8s_v3"),
            Self::StandardE32V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 96u32, "Standard_E32_v3"),
            Self::StandardE32sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 97u32, "Standard_E32s_v3"),
            Self::StandardE4V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 98u32, "Standard_E4_v3"),
            Self::StandardE4sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 99u32, "Standard_E4s_v3"),
            Self::StandardE6416sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 100u32, "Standard_E64-16s_v3"),
            Self::StandardE6432sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 101u32, "Standard_E64-32s_v3"),
            Self::StandardE64V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 102u32, "Standard_E64_v3"),
            Self::StandardE64sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 103u32, "Standard_E64s_v3"),
            Self::StandardE8V3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 104u32, "Standard_E8_v3"),
            Self::StandardE8sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 105u32, "Standard_E8s_v3"),
            Self::StandardF1 => serializer.serialize_unit_variant("ContainerServiceVmSize", 106u32, "Standard_F1"),
            Self::StandardF16 => serializer.serialize_unit_variant("ContainerServiceVmSize", 107u32, "Standard_F16"),
            Self::StandardF16s => serializer.serialize_unit_variant("ContainerServiceVmSize", 108u32, "Standard_F16s"),
            Self::StandardF16sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 109u32, "Standard_F16s_v2"),
            Self::StandardF1s => serializer.serialize_unit_variant("ContainerServiceVmSize", 110u32, "Standard_F1s"),
            Self::StandardF2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 111u32, "Standard_F2"),
            Self::StandardF2s => serializer.serialize_unit_variant("ContainerServiceVmSize", 112u32, "Standard_F2s"),
            Self::StandardF2sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 113u32, "Standard_F2s_v2"),
            Self::StandardF32sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 114u32, "Standard_F32s_v2"),
            Self::StandardF4 => serializer.serialize_unit_variant("ContainerServiceVmSize", 115u32, "Standard_F4"),
            Self::StandardF4s => serializer.serialize_unit_variant("ContainerServiceVmSize", 116u32, "Standard_F4s"),
            Self::StandardF4sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 117u32, "Standard_F4s_v2"),
            Self::StandardF64sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 118u32, "Standard_F64s_v2"),
            Self::StandardF72sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 119u32, "Standard_F72s_v2"),
            Self::StandardF8 => serializer.serialize_unit_variant("ContainerServiceVmSize", 120u32, "Standard_F8"),
            Self::StandardF8s => serializer.serialize_unit_variant("ContainerServiceVmSize", 121u32, "Standard_F8s"),
            Self::StandardF8sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 122u32, "Standard_F8s_v2"),
            Self::StandardG1 => serializer.serialize_unit_variant("ContainerServiceVmSize", 123u32, "Standard_G1"),
            Self::StandardG2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 124u32, "Standard_G2"),
            Self::StandardG3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 125u32, "Standard_G3"),
            Self::StandardG4 => serializer.serialize_unit_variant("ContainerServiceVmSize", 126u32, "Standard_G4"),
            Self::StandardG5 => serializer.serialize_unit_variant("ContainerServiceVmSize", 127u32, "Standard_G5"),
            Self::StandardGs1 => serializer.serialize_unit_variant("ContainerServiceVmSize", 128u32, "Standard_GS1"),
            Self::StandardGs2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 129u32, "Standard_GS2"),
            Self::StandardGs3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 130u32, "Standard_GS3"),
            Self::StandardGs4 => serializer.serialize_unit_variant("ContainerServiceVmSize", 131u32, "Standard_GS4"),
            Self::StandardGs44 => serializer.serialize_unit_variant("ContainerServiceVmSize", 132u32, "Standard_GS4-4"),
            Self::StandardGs48 => serializer.serialize_unit_variant("ContainerServiceVmSize", 133u32, "Standard_GS4-8"),
            Self::StandardGs5 => serializer.serialize_unit_variant("ContainerServiceVmSize", 134u32, "Standard_GS5"),
            Self::StandardGs516 => serializer.serialize_unit_variant("ContainerServiceVmSize", 135u32, "Standard_GS5-16"),
            Self::StandardGs58 => serializer.serialize_unit_variant("ContainerServiceVmSize", 136u32, "Standard_GS5-8"),
            Self::StandardH16 => serializer.serialize_unit_variant("ContainerServiceVmSize", 137u32, "Standard_H16"),
            Self::StandardH16m => serializer.serialize_unit_variant("ContainerServiceVmSize", 138u32, "Standard_H16m"),
            Self::StandardH16mr => serializer.serialize_unit_variant("ContainerServiceVmSize", 139u32, "Standard_H16mr"),
            Self::StandardH16r => serializer.serialize_unit_variant("ContainerServiceVmSize", 140u32, "Standard_H16r"),
            Self::StandardH8 => serializer.serialize_unit_variant("ContainerServiceVmSize", 141u32, "Standard_H8"),
            Self::StandardH8m => serializer.serialize_unit_variant("ContainerServiceVmSize", 142u32, "Standard_H8m"),
            Self::StandardL16s => serializer.serialize_unit_variant("ContainerServiceVmSize", 143u32, "Standard_L16s"),
            Self::StandardL32s => serializer.serialize_unit_variant("ContainerServiceVmSize", 144u32, "Standard_L32s"),
            Self::StandardL4s => serializer.serialize_unit_variant("ContainerServiceVmSize", 145u32, "Standard_L4s"),
            Self::StandardL8s => serializer.serialize_unit_variant("ContainerServiceVmSize", 146u32, "Standard_L8s"),
            Self::StandardM12832ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 147u32, "Standard_M128-32ms"),
            Self::StandardM12864ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 148u32, "Standard_M128-64ms"),
            Self::StandardM128ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 149u32, "Standard_M128ms"),
            Self::StandardM128s => serializer.serialize_unit_variant("ContainerServiceVmSize", 150u32, "Standard_M128s"),
            Self::StandardM6416ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 151u32, "Standard_M64-16ms"),
            Self::StandardM6432ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 152u32, "Standard_M64-32ms"),
            Self::StandardM64ms => serializer.serialize_unit_variant("ContainerServiceVmSize", 153u32, "Standard_M64ms"),
            Self::StandardM64s => serializer.serialize_unit_variant("ContainerServiceVmSize", 154u32, "Standard_M64s"),
            Self::StandardNc12 => serializer.serialize_unit_variant("ContainerServiceVmSize", 155u32, "Standard_NC12"),
            Self::StandardNc12sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 156u32, "Standard_NC12s_v2"),
            Self::StandardNc12sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 157u32, "Standard_NC12s_v3"),
            Self::StandardNc24 => serializer.serialize_unit_variant("ContainerServiceVmSize", 158u32, "Standard_NC24"),
            Self::StandardNc24r => serializer.serialize_unit_variant("ContainerServiceVmSize", 159u32, "Standard_NC24r"),
            Self::StandardNc24rsV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 160u32, "Standard_NC24rs_v2"),
            Self::StandardNc24rsV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 161u32, "Standard_NC24rs_v3"),
            Self::StandardNc24sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 162u32, "Standard_NC24s_v2"),
            Self::StandardNc24sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 163u32, "Standard_NC24s_v3"),
            Self::StandardNc6 => serializer.serialize_unit_variant("ContainerServiceVmSize", 164u32, "Standard_NC6"),
            Self::StandardNc6sV2 => serializer.serialize_unit_variant("ContainerServiceVmSize", 165u32, "Standard_NC6s_v2"),
            Self::StandardNc6sV3 => serializer.serialize_unit_variant("ContainerServiceVmSize", 166u32, "Standard_NC6s_v3"),
            Self::StandardNd12s => serializer.serialize_unit_variant("ContainerServiceVmSize", 167u32, "Standard_ND12s"),
            Self::StandardNd24rs => serializer.serialize_unit_variant("ContainerServiceVmSize", 168u32, "Standard_ND24rs"),
            Self::StandardNd24s => serializer.serialize_unit_variant("ContainerServiceVmSize", 169u32, "Standard_ND24s"),
            Self::StandardNd6s => serializer.serialize_unit_variant("ContainerServiceVmSize", 170u32, "Standard_ND6s"),
            Self::StandardNv12 => serializer.serialize_unit_variant("ContainerServiceVmSize", 171u32, "Standard_NV12"),
            Self::StandardNv24 => serializer.serialize_unit_variant("ContainerServiceVmSize", 172u32, "Standard_NV24"),
            Self::StandardNv6 => serializer.serialize_unit_variant("ContainerServiceVmSize", 173u32, "Standard_NV6"),
            Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
        }
    }
}
pub type ContainerServiceVnetSubnetId = String;
#[doc = "Profile for Windows VMs in the container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceWindowsProfile {
    #[doc = "The administrator username to use for Windows VMs."]
    #[serde(rename = "adminUsername")]
    pub admin_username: String,
    #[doc = "The administrator password to use for Windows VMs."]
    #[serde(rename = "adminPassword")]
    pub admin_password: String,
}
impl ContainerServiceWindowsProfile {
    pub fn new(admin_username: String, admin_password: String) -> Self {
        Self {
            admin_username,
            admin_password,
        }
    }
}
#[doc = "The credential result response."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CredentialResult {
    #[doc = "The name of the credential."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Base64-encoded Kubernetes configuration file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
impl CredentialResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The list of credential result response."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CredentialResults {
    #[doc = "Base64-encoded Kubernetes configuration file."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub kubeconfigs: Vec<CredentialResult>,
}
impl CredentialResults {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Reference to a secret stored in Azure Key Vault."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct KeyVaultSecretRef {
    #[doc = "Key vault identifier."]
    #[serde(rename = "vaultID")]
    pub vault_id: String,
    #[doc = "The secret name."]
    #[serde(rename = "secretName")]
    pub secret_name: String,
    #[doc = "The secret version."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}
impl KeyVaultSecretRef {
    pub fn new(vault_id: String, secret_name: String) -> Self {
        Self {
            vault_id,
            secret_name,
            version: None,
        }
    }
}
#[doc = "Kubelet configurations of agent nodes."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct KubeletConfig {
    #[doc = "CPU Manager policy to use."]
    #[serde(rename = "cpuManagerPolicy", default, skip_serializing_if = "Option::is_none")]
    pub cpu_manager_policy: Option<String>,
    #[doc = "Enable CPU CFS quota enforcement for containers that specify CPU limits."]
    #[serde(rename = "cpuCfsQuota", default, skip_serializing_if = "Option::is_none")]
    pub cpu_cfs_quota: Option<bool>,
    #[doc = "Sets CPU CFS quota period value."]
    #[serde(rename = "cpuCfsQuotaPeriod", default, skip_serializing_if = "Option::is_none")]
    pub cpu_cfs_quota_period: Option<String>,
    #[doc = "The percent of disk usage after which image garbage collection is always run."]
    #[serde(rename = "imageGcHighThreshold", default, skip_serializing_if = "Option::is_none")]
    pub image_gc_high_threshold: Option<i32>,
    #[doc = "The percent of disk usage before which image garbage collection is never run."]
    #[serde(rename = "imageGcLowThreshold", default, skip_serializing_if = "Option::is_none")]
    pub image_gc_low_threshold: Option<i32>,
    #[doc = "Topology Manager policy to use."]
    #[serde(rename = "topologyManagerPolicy", default, skip_serializing_if = "Option::is_none")]
    pub topology_manager_policy: Option<String>,
    #[doc = "Allowlist of unsafe sysctls or unsafe sysctl patterns (ending in `*`)."]
    #[serde(rename = "allowedUnsafeSysctls", default, skip_serializing_if = "Vec::is_empty")]
    pub allowed_unsafe_sysctls: Vec<String>,
    #[doc = "If set to true it will make the Kubelet fail to start if swap is enabled on the node."]
    #[serde(rename = "failSwapOn", default, skip_serializing_if = "Option::is_none")]
    pub fail_swap_on: Option<bool>,
}
impl KubeletConfig {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "OS configurations of Linux agent nodes."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct LinuxOsConfig {
    #[doc = "Sysctl settings for Linux agent nodes."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sysctls: Option<SysctlConfig>,
    #[doc = "Transparent Huge Page enabled configuration."]
    #[serde(rename = "transparentHugePageEnabled", default, skip_serializing_if = "Option::is_none")]
    pub transparent_huge_page_enabled: Option<String>,
    #[doc = "Transparent Huge Page defrag configuration."]
    #[serde(rename = "transparentHugePageDefrag", default, skip_serializing_if = "Option::is_none")]
    pub transparent_huge_page_defrag: Option<String>,
    #[doc = "SwapFileSizeMB specifies size in MB of a swap file will be created on each node."]
    #[serde(rename = "swapFileSizeMB", default, skip_serializing_if = "Option::is_none")]
    pub swap_file_size_mb: Option<i32>,
}
impl LinuxOsConfig {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedCluster {
    #[serde(flatten)]
    pub resource: Resource,
    #[doc = "Properties of the managed cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagedClusterProperties>,
    #[doc = "Identity for the managed cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedClusterIdentity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sku: Option<ManagedClusterSku>,
}
impl ManagedCluster {
    pub fn new(resource: Resource) -> Self {
        Self {
            resource,
            properties: None,
            identity: None,
            sku: None,
        }
    }
}
#[doc = "AADProfile specifies attributes for Azure Active Directory integration."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterAadProfile {
    #[doc = "Whether to enable managed AAD."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub managed: Option<bool>,
    #[doc = "Whether to enable Azure RBAC for Kubernetes authorization."]
    #[serde(rename = "enableAzureRBAC", default, skip_serializing_if = "Option::is_none")]
    pub enable_azure_rbac: Option<bool>,
    #[doc = "AAD group object IDs that will have admin role of the cluster."]
    #[serde(rename = "adminGroupObjectIDs", default, skip_serializing_if = "Vec::is_empty")]
    pub admin_group_object_i_ds: Vec<String>,
    #[doc = "The client AAD application ID."]
    #[serde(rename = "clientAppID", default, skip_serializing_if = "Option::is_none")]
    pub client_app_id: Option<String>,
    #[doc = "The server AAD application ID."]
    #[serde(rename = "serverAppID", default, skip_serializing_if = "Option::is_none")]
    pub server_app_id: Option<String>,
    #[doc = "The server AAD application secret."]
    #[serde(rename = "serverAppSecret", default, skip_serializing_if = "Option::is_none")]
    pub server_app_secret: Option<String>,
    #[doc = "The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription."]
    #[serde(rename = "tenantID", default, skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
}
impl ManagedClusterAadProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Access profile for managed cluster API server."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterApiServerAccessProfile {
    #[doc = "Authorized IP Ranges to kubernetes API server."]
    #[serde(rename = "authorizedIPRanges", default, skip_serializing_if = "Vec::is_empty")]
    pub authorized_ip_ranges: Vec<String>,
    #[doc = "Whether to create the cluster as a private cluster or not."]
    #[serde(rename = "enablePrivateCluster", default, skip_serializing_if = "Option::is_none")]
    pub enable_private_cluster: Option<bool>,
    #[doc = "Private dns zone mode for private cluster. "]
    #[serde(rename = "privateDNSZone", default, skip_serializing_if = "Option::is_none")]
    pub private_dns_zone: Option<String>,
}
impl ManagedClusterApiServerAccessProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Managed cluster Access Profile."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterAccessProfile {
    #[serde(flatten)]
    pub resource: Resource,
    #[doc = "Profile for enabling a user to access a managed cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<AccessProfile>,
}
impl ManagedClusterAccessProfile {
    pub fn new(resource: Resource) -> Self {
        Self {
            resource,
            properties: None,
        }
    }
}
#[doc = "A Kubernetes add-on profile for a managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterAddonProfile {
    #[doc = "Whether the add-on is enabled or not."]
    pub enabled: bool,
    #[doc = "Key-value pairs for configuring an add-on."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<serde_json::Value>,
    #[doc = "Information of user assigned identity used by this add-on."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<serde_json::Value>,
}
impl ManagedClusterAddonProfile {
    pub fn new(enabled: bool) -> Self {
        Self {
            enabled,
            config: None,
            identity: None,
        }
    }
}
#[doc = "Profile for the container service agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterAgentPoolProfile {
    #[serde(flatten)]
    pub managed_cluster_agent_pool_profile_properties: ManagedClusterAgentPoolProfileProperties,
    #[doc = "Unique name of the agent pool profile in the context of the subscription and resource group."]
    pub name: String,
}
impl ManagedClusterAgentPoolProfile {
    pub fn new(name: String) -> Self {
        Self {
            managed_cluster_agent_pool_profile_properties: ManagedClusterAgentPoolProfileProperties::default(),
            name,
        }
    }
}
#[doc = "Properties for the container service agent pool profile."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterAgentPoolProfileProperties {
    #[doc = "Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 100 (inclusive) for user pools and in the range of 1 to 100 (inclusive) for system pools. The default value is 1."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    #[doc = "Size of agent VMs."]
    #[serde(rename = "vmSize", default, skip_serializing_if = "Option::is_none")]
    pub vm_size: Option<ContainerServiceVmSize>,
    #[doc = "OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified."]
    #[serde(rename = "osDiskSizeGB", default, skip_serializing_if = "Option::is_none")]
    pub os_disk_size_gb: Option<ContainerServiceOsDisk>,
    #[doc = "OSDiskType represents the type of an OS disk on an agent pool."]
    #[serde(rename = "osDiskType", default, skip_serializing_if = "Option::is_none")]
    pub os_disk_type: Option<OsDiskType>,
    #[doc = "specifies a subnet's resource id with subscription, resource group, vnet and subnet name"]
    #[serde(rename = "vnetSubnetID", default, skip_serializing_if = "Option::is_none")]
    pub vnet_subnet_id: Option<ContainerServiceVnetSubnetId>,
    #[doc = "specifies a subnet's resource id with subscription, resource group, vnet and subnet name"]
    #[serde(rename = "podSubnetID", default, skip_serializing_if = "Option::is_none")]
    pub pod_subnet_id: Option<ContainerServiceVnetSubnetId>,
    #[doc = "Maximum number of pods that can run on a node."]
    #[serde(rename = "maxPods", default, skip_serializing_if = "Option::is_none")]
    pub max_pods: Option<i32>,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType", default, skip_serializing_if = "Option::is_none")]
    pub os_type: Option<OsType>,
    #[doc = "Maximum number of nodes for auto-scaling"]
    #[serde(rename = "maxCount", default, skip_serializing_if = "Option::is_none")]
    pub max_count: Option<i32>,
    #[doc = "Minimum number of nodes for auto-scaling"]
    #[serde(rename = "minCount", default, skip_serializing_if = "Option::is_none")]
    pub min_count: Option<i32>,
    #[doc = "Whether to enable auto-scaler"]
    #[serde(rename = "enableAutoScaling", default, skip_serializing_if = "Option::is_none")]
    pub enable_auto_scaling: Option<bool>,
    #[doc = "AgentPoolType represents types of an agent pool."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<AgentPoolType>,
    #[doc = "AgentPoolMode represents mode of an agent pool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<AgentPoolMode>,
    #[doc = "Version of orchestrator specified when creating the managed cluster."]
    #[serde(rename = "orchestratorVersion", default, skip_serializing_if = "Option::is_none")]
    pub orchestrator_version: Option<String>,
    #[doc = "Version of node image"]
    #[serde(rename = "nodeImageVersion", default, skip_serializing_if = "Option::is_none")]
    pub node_image_version: Option<String>,
    #[doc = "Settings for upgrading an agentpool"]
    #[serde(rename = "upgradeSettings", default, skip_serializing_if = "Option::is_none")]
    pub upgrade_settings: Option<AgentPoolUpgradeSettings>,
    #[doc = "The current deployment or provisioning state, which only appears in the response."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[doc = "Describes the Power State of the cluster"]
    #[serde(rename = "powerState", default, skip_serializing_if = "Option::is_none")]
    pub power_state: Option<PowerState>,
    #[doc = "Availability zones for nodes. Must use VirtualMachineScaleSets AgentPoolType."]
    #[serde(rename = "availabilityZones", default, skip_serializing_if = "Vec::is_empty")]
    pub availability_zones: Vec<String>,
    #[doc = "Enable public IP for nodes"]
    #[serde(rename = "enableNodePublicIP", default, skip_serializing_if = "Option::is_none")]
    pub enable_node_public_ip: Option<bool>,
    #[doc = "ScaleSetPriority to be used to specify virtual machine scale set priority. Default to regular."]
    #[serde(rename = "scaleSetPriority", default, skip_serializing_if = "Option::is_none")]
    pub scale_set_priority: Option<ScaleSetPriority>,
    #[doc = "ScaleSetEvictionPolicy to be used to specify eviction policy for Spot virtual machine scale set. Default to Delete."]
    #[serde(rename = "scaleSetEvictionPolicy", default, skip_serializing_if = "Option::is_none")]
    pub scale_set_eviction_policy: Option<ScaleSetEvictionPolicy>,
    #[doc = "SpotMaxPrice to be used to specify the maximum price you are willing to pay in US Dollars. Possible values are any decimal value greater than zero or -1 which indicates default price to be up-to on-demand."]
    #[serde(rename = "spotMaxPrice", default, skip_serializing_if = "Option::is_none")]
    pub spot_max_price: Option<SpotMaxPrice>,
    #[doc = "Agent pool tags to be persisted on the agent pool virtual machine scale set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[doc = "Agent pool node labels to be persisted across all nodes in agent pool."]
    #[serde(rename = "nodeLabels", default, skip_serializing_if = "Option::is_none")]
    pub node_labels: Option<serde_json::Value>,
    #[doc = "Taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule."]
    #[serde(rename = "nodeTaints", default, skip_serializing_if = "Vec::is_empty")]
    pub node_taints: Vec<String>,
    #[doc = "The ID for Proximity Placement Group."]
    #[serde(rename = "proximityPlacementGroupID", default, skip_serializing_if = "Option::is_none")]
    pub proximity_placement_group_id: Option<ProximityPlacementGroupId>,
    #[doc = "Kubelet configurations of agent nodes."]
    #[serde(rename = "kubeletConfig", default, skip_serializing_if = "Option::is_none")]
    pub kubelet_config: Option<KubeletConfig>,
    #[doc = "OS configurations of Linux agent nodes."]
    #[serde(rename = "linuxOSConfig", default, skip_serializing_if = "Option::is_none")]
    pub linux_os_config: Option<LinuxOsConfig>,
}
impl ManagedClusterAgentPoolProfileProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Auto upgrade profile for a managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterAutoUpgradeProfile {
    #[doc = "upgrade channel for auto upgrade."]
    #[serde(rename = "upgradeChannel", default, skip_serializing_if = "Option::is_none")]
    pub upgrade_channel: Option<managed_cluster_auto_upgrade_profile::UpgradeChannel>,
}
impl ManagedClusterAutoUpgradeProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod managed_cluster_auto_upgrade_profile {
    use super::*;
    #[doc = "upgrade channel for auto upgrade."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "UpgradeChannel")]
    pub enum UpgradeChannel {
        #[serde(rename = "rapid")]
        Rapid,
        #[serde(rename = "stable")]
        Stable,
        #[serde(rename = "patch")]
        Patch,
        #[serde(rename = "none")]
        None,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for UpgradeChannel {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for UpgradeChannel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for UpgradeChannel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Rapid => serializer.serialize_unit_variant("UpgradeChannel", 0u32, "rapid"),
                Self::Stable => serializer.serialize_unit_variant("UpgradeChannel", 1u32, "stable"),
                Self::Patch => serializer.serialize_unit_variant("UpgradeChannel", 2u32, "patch"),
                Self::None => serializer.serialize_unit_variant("UpgradeChannel", 3u32, "none"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
}
#[doc = "Identity for the managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterIdentity {
    #[doc = "The principal id of the system assigned identity which is used by master components."]
    #[serde(rename = "principalId", default, skip_serializing_if = "Option::is_none")]
    pub principal_id: Option<String>,
    #[doc = "The tenant id of the system assigned identity which is used by master components."]
    #[serde(rename = "tenantId", default, skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
    #[doc = "The type of identity used for the managed cluster. Type 'SystemAssigned' will use an implicitly created identity in master components and an auto-created user assigned identity in MC_ resource group in agent nodes. Type 'None' will not use MSI for the managed cluster, service principal will be used instead."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<managed_cluster_identity::Type>,
    #[doc = "The user identity associated with the managed cluster. This identity will be used in control plane and only one user assigned identity is allowed. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'."]
    #[serde(rename = "userAssignedIdentities", default, skip_serializing_if = "Option::is_none")]
    pub user_assigned_identities: Option<serde_json::Value>,
}
impl ManagedClusterIdentity {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod managed_cluster_identity {
    use super::*;
    #[doc = "The type of identity used for the managed cluster. Type 'SystemAssigned' will use an implicitly created identity in master components and an auto-created user assigned identity in MC_ resource group in agent nodes. Type 'None' will not use MSI for the managed cluster, service principal will be used instead."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        SystemAssigned,
        UserAssigned,
        None,
    }
}
#[doc = "The response from the List Managed Clusters operation."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterListResult {
    #[doc = "The list of managed clusters."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ManagedCluster>,
    #[doc = "The URL to get the next set of managed cluster results."]
    #[serde(rename = "nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl azure_core::Continuable for ManagedClusterListResult {
    fn continuation(&self) -> Option<azure_core::prelude::Continuation> {
        self.next_link.clone().map(azure_core::prelude::Continuation::from)
    }
}
impl ManagedClusterListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Profile of the managed cluster load balancer."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterLoadBalancerProfile {
    #[doc = "Desired managed outbound IPs for the cluster load balancer."]
    #[serde(rename = "managedOutboundIPs", default, skip_serializing_if = "Option::is_none")]
    pub managed_outbound_i_ps: Option<managed_cluster_load_balancer_profile::ManagedOutboundIPs>,
    #[doc = "Desired outbound IP Prefix resources for the cluster load balancer."]
    #[serde(rename = "outboundIPPrefixes", default, skip_serializing_if = "Option::is_none")]
    pub outbound_ip_prefixes: Option<managed_cluster_load_balancer_profile::OutboundIpPrefixes>,
    #[doc = "Desired outbound IP resources for the cluster load balancer."]
    #[serde(rename = "outboundIPs", default, skip_serializing_if = "Option::is_none")]
    pub outbound_i_ps: Option<managed_cluster_load_balancer_profile::OutboundIPs>,
    #[doc = "The effective outbound IP resources of the cluster load balancer."]
    #[serde(rename = "effectiveOutboundIPs", default, skip_serializing_if = "Vec::is_empty")]
    pub effective_outbound_i_ps: Vec<ResourceReference>,
    #[doc = "Desired number of allocated SNAT ports per VM. Allowed values must be in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports."]
    #[serde(rename = "allocatedOutboundPorts", default, skip_serializing_if = "Option::is_none")]
    pub allocated_outbound_ports: Option<i32>,
    #[doc = "Desired outbound flow idle timeout in minutes. Allowed values must be in the range of 4 to 120 (inclusive). The default value is 30 minutes."]
    #[serde(rename = "idleTimeoutInMinutes", default, skip_serializing_if = "Option::is_none")]
    pub idle_timeout_in_minutes: Option<i32>,
}
impl ManagedClusterLoadBalancerProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod managed_cluster_load_balancer_profile {
    use super::*;
    #[doc = "Desired managed outbound IPs for the cluster load balancer."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
    pub struct ManagedOutboundIPs {
        #[doc = "Desired number of outbound IP created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1. "]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub count: Option<i32>,
    }
    impl ManagedOutboundIPs {
        pub fn new() -> Self {
            Self::default()
        }
    }
    #[doc = "Desired outbound IP Prefix resources for the cluster load balancer."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
    pub struct OutboundIpPrefixes {
        #[doc = "A list of public IP prefix resources."]
        #[serde(rename = "publicIPPrefixes", default, skip_serializing_if = "Vec::is_empty")]
        pub public_ip_prefixes: Vec<ResourceReference>,
    }
    impl OutboundIpPrefixes {
        pub fn new() -> Self {
            Self::default()
        }
    }
    #[doc = "Desired outbound IP resources for the cluster load balancer."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
    pub struct OutboundIPs {
        #[doc = "A list of public IP resources."]
        #[serde(rename = "publicIPs", default, skip_serializing_if = "Vec::is_empty")]
        pub public_i_ps: Vec<ResourceReference>,
    }
    impl OutboundIPs {
        pub fn new() -> Self {
            Self::default()
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterPodIdentity {
    #[doc = "Name of the pod identity."]
    pub name: String,
    #[doc = "Namespace of the pod identity."]
    pub namespace: String,
    pub identity: UserAssignedIdentity,
    #[doc = "The current provisioning state of the pod identity."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<managed_cluster_pod_identity::ProvisioningState>,
    #[serde(rename = "provisioningInfo", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_info: Option<managed_cluster_pod_identity::ProvisioningInfo>,
}
impl ManagedClusterPodIdentity {
    pub fn new(name: String, namespace: String, identity: UserAssignedIdentity) -> Self {
        Self {
            name,
            namespace,
            identity,
            provisioning_state: None,
            provisioning_info: None,
        }
    }
}
pub mod managed_cluster_pod_identity {
    use super::*;
    #[doc = "The current provisioning state of the pod identity."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "ProvisioningState")]
    pub enum ProvisioningState {
        Assigned,
        Updating,
        Deleting,
        Failed,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for ProvisioningState {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for ProvisioningState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for ProvisioningState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Assigned => serializer.serialize_unit_variant("ProvisioningState", 0u32, "Assigned"),
                Self::Updating => serializer.serialize_unit_variant("ProvisioningState", 1u32, "Updating"),
                Self::Deleting => serializer.serialize_unit_variant("ProvisioningState", 2u32, "Deleting"),
                Self::Failed => serializer.serialize_unit_variant("ProvisioningState", 3u32, "Failed"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
    pub struct ProvisioningInfo {
        #[doc = "An error response from the Container service."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<CloudError>,
    }
    impl ProvisioningInfo {
        pub fn new() -> Self {
            Self::default()
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterPodIdentityException {
    #[doc = "Name of the pod identity exception."]
    pub name: String,
    #[doc = "Namespace of the pod identity exception."]
    pub namespace: String,
    #[doc = "Pod labels to match."]
    #[serde(rename = "podLabels")]
    pub pod_labels: serde_json::Value,
}
impl ManagedClusterPodIdentityException {
    pub fn new(name: String, namespace: String, pod_labels: serde_json::Value) -> Self {
        Self {
            name,
            namespace,
            pod_labels,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterPodIdentityProfile {
    #[doc = "Whether the pod identity addon is enabled."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[doc = "User assigned pod identity settings."]
    #[serde(rename = "userAssignedIdentities", default, skip_serializing_if = "Vec::is_empty")]
    pub user_assigned_identities: Vec<ManagedClusterPodIdentity>,
    #[doc = "User assigned pod identity exception settings."]
    #[serde(rename = "userAssignedIdentityExceptions", default, skip_serializing_if = "Vec::is_empty")]
    pub user_assigned_identity_exceptions: Vec<ManagedClusterPodIdentityException>,
}
impl ManagedClusterPodIdentityProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The list of available upgrade versions."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterPoolUpgradeProfile {
    #[doc = "Kubernetes version (major, minor, patch)."]
    #[serde(rename = "kubernetesVersion")]
    pub kubernetes_version: String,
    #[doc = "Pool name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType")]
    pub os_type: OsType,
    #[doc = "List of orchestrator types and versions available for upgrade."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub upgrades: Vec<serde_json::Value>,
}
impl ManagedClusterPoolUpgradeProfile {
    pub fn new(kubernetes_version: String, os_type: OsType) -> Self {
        Self {
            kubernetes_version,
            name: None,
            os_type,
            upgrades: Vec::new(),
        }
    }
}
#[doc = "Properties of the managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterProperties {
    #[doc = "The current deployment or provisioning state, which only appears in the response."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[doc = "Describes the Power State of the cluster"]
    #[serde(rename = "powerState", default, skip_serializing_if = "Option::is_none")]
    pub power_state: Option<PowerState>,
    #[doc = "The max number of agent pools for the managed cluster."]
    #[serde(rename = "maxAgentPools", default, skip_serializing_if = "Option::is_none")]
    pub max_agent_pools: Option<i32>,
    #[doc = "Version of Kubernetes specified when creating the managed cluster."]
    #[serde(rename = "kubernetesVersion", default, skip_serializing_if = "Option::is_none")]
    pub kubernetes_version: Option<String>,
    #[doc = "DNS prefix specified when creating the managed cluster."]
    #[serde(rename = "dnsPrefix", default, skip_serializing_if = "Option::is_none")]
    pub dns_prefix: Option<String>,
    #[doc = "FQDN for the master pool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[doc = "FQDN of private cluster."]
    #[serde(rename = "privateFQDN", default, skip_serializing_if = "Option::is_none")]
    pub private_fqdn: Option<String>,
    #[doc = "Properties of the agent pool."]
    #[serde(rename = "agentPoolProfiles", default, skip_serializing_if = "Vec::is_empty")]
    pub agent_pool_profiles: Vec<ManagedClusterAgentPoolProfile>,
    #[doc = "Profile for Linux VMs in the container service cluster."]
    #[serde(rename = "linuxProfile", default, skip_serializing_if = "Option::is_none")]
    pub linux_profile: Option<ContainerServiceLinuxProfile>,
    #[doc = "Profile for Windows VMs in the container service cluster."]
    #[serde(rename = "windowsProfile", default, skip_serializing_if = "Option::is_none")]
    pub windows_profile: Option<ManagedClusterWindowsProfile>,
    #[doc = "Information about a service principal identity for the cluster to use for manipulating Azure APIs."]
    #[serde(rename = "servicePrincipalProfile", default, skip_serializing_if = "Option::is_none")]
    pub service_principal_profile: Option<ManagedClusterServicePrincipalProfile>,
    #[doc = "Profile of managed cluster add-on."]
    #[serde(rename = "addonProfiles", default, skip_serializing_if = "Option::is_none")]
    pub addon_profiles: Option<serde_json::Value>,
    #[serde(rename = "podIdentityProfile", default, skip_serializing_if = "Option::is_none")]
    pub pod_identity_profile: Option<ManagedClusterPodIdentityProfile>,
    #[doc = "Name of the resource group containing agent pool nodes."]
    #[serde(rename = "nodeResourceGroup", default, skip_serializing_if = "Option::is_none")]
    pub node_resource_group: Option<String>,
    #[doc = "Whether to enable Kubernetes Role-Based Access Control."]
    #[serde(rename = "enableRBAC", default, skip_serializing_if = "Option::is_none")]
    pub enable_rbac: Option<bool>,
    #[doc = "(DEPRECATING) Whether to enable Kubernetes pod security policy (preview). This feature is set for removal on October 15th, 2020. Learn more at aka.ms/aks/azpodpolicy."]
    #[serde(rename = "enablePodSecurityPolicy", default, skip_serializing_if = "Option::is_none")]
    pub enable_pod_security_policy: Option<bool>,
    #[doc = "Profile of network configuration."]
    #[serde(rename = "networkProfile", default, skip_serializing_if = "Option::is_none")]
    pub network_profile: Option<ContainerServiceNetworkProfile>,
    #[doc = "AADProfile specifies attributes for Azure Active Directory integration."]
    #[serde(rename = "aadProfile", default, skip_serializing_if = "Option::is_none")]
    pub aad_profile: Option<ManagedClusterAadProfile>,
    #[doc = "Auto upgrade profile for a managed cluster."]
    #[serde(rename = "autoUpgradeProfile", default, skip_serializing_if = "Option::is_none")]
    pub auto_upgrade_profile: Option<ManagedClusterAutoUpgradeProfile>,
    #[doc = "Parameters to be applied to the cluster-autoscaler when enabled"]
    #[serde(rename = "autoScalerProfile", default, skip_serializing_if = "Option::is_none")]
    pub auto_scaler_profile: Option<managed_cluster_properties::AutoScalerProfile>,
    #[doc = "Access profile for managed cluster API server."]
    #[serde(rename = "apiServerAccessProfile", default, skip_serializing_if = "Option::is_none")]
    pub api_server_access_profile: Option<ManagedClusterApiServerAccessProfile>,
    #[doc = "ResourceId of the disk encryption set to use for enabling encryption at rest."]
    #[serde(rename = "diskEncryptionSetID", default, skip_serializing_if = "Option::is_none")]
    pub disk_encryption_set_id: Option<String>,
    #[doc = "Identities associated with the cluster."]
    #[serde(rename = "identityProfile", default, skip_serializing_if = "Option::is_none")]
    pub identity_profile: Option<serde_json::Value>,
}
impl ManagedClusterProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod managed_cluster_properties {
    use super::*;
    #[doc = "Parameters to be applied to the cluster-autoscaler when enabled"]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
    pub struct AutoScalerProfile {
        #[serde(rename = "balance-similar-node-groups", default, skip_serializing_if = "Option::is_none")]
        pub balance_similar_node_groups: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expander: Option<auto_scaler_profile::Expander>,
        #[serde(rename = "max-empty-bulk-delete", default, skip_serializing_if = "Option::is_none")]
        pub max_empty_bulk_delete: Option<String>,
        #[serde(rename = "max-graceful-termination-sec", default, skip_serializing_if = "Option::is_none")]
        pub max_graceful_termination_sec: Option<String>,
        #[serde(rename = "max-total-unready-percentage", default, skip_serializing_if = "Option::is_none")]
        pub max_total_unready_percentage: Option<String>,
        #[serde(rename = "new-pod-scale-up-delay", default, skip_serializing_if = "Option::is_none")]
        pub new_pod_scale_up_delay: Option<String>,
        #[serde(rename = "ok-total-unready-count", default, skip_serializing_if = "Option::is_none")]
        pub ok_total_unready_count: Option<String>,
        #[serde(rename = "scan-interval", default, skip_serializing_if = "Option::is_none")]
        pub scan_interval: Option<String>,
        #[serde(rename = "scale-down-delay-after-add", default, skip_serializing_if = "Option::is_none")]
        pub scale_down_delay_after_add: Option<String>,
        #[serde(rename = "scale-down-delay-after-delete", default, skip_serializing_if = "Option::is_none")]
        pub scale_down_delay_after_delete: Option<String>,
        #[serde(rename = "scale-down-delay-after-failure", default, skip_serializing_if = "Option::is_none")]
        pub scale_down_delay_after_failure: Option<String>,
        #[serde(rename = "scale-down-unneeded-time", default, skip_serializing_if = "Option::is_none")]
        pub scale_down_unneeded_time: Option<String>,
        #[serde(rename = "scale-down-unready-time", default, skip_serializing_if = "Option::is_none")]
        pub scale_down_unready_time: Option<String>,
        #[serde(rename = "scale-down-utilization-threshold", default, skip_serializing_if = "Option::is_none")]
        pub scale_down_utilization_threshold: Option<String>,
        #[serde(rename = "skip-nodes-with-local-storage", default, skip_serializing_if = "Option::is_none")]
        pub skip_nodes_with_local_storage: Option<String>,
        #[serde(rename = "skip-nodes-with-system-pods", default, skip_serializing_if = "Option::is_none")]
        pub skip_nodes_with_system_pods: Option<String>,
    }
    impl AutoScalerProfile {
        pub fn new() -> Self {
            Self::default()
        }
    }
    pub mod auto_scaler_profile {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
        #[serde(remote = "Expander")]
        pub enum Expander {
            #[serde(rename = "least-waste")]
            LeastWaste,
            #[serde(rename = "most-pods")]
            MostPods,
            #[serde(rename = "random")]
            Random,
            #[serde(skip_deserializing)]
            UnknownValue(String),
        }
        impl FromStr for Expander {
            type Err = value::Error;
            fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                Self::deserialize(s.into_deserializer())
            }
        }
        impl<'de> Deserialize<'de> for Expander {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                let s = String::deserialize(deserializer)?;
                let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
                Ok(deserialized)
            }
        }
        impl Serialize for Expander {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                match self {
                    Self::LeastWaste => serializer.serialize_unit_variant("Expander", 0u32, "least-waste"),
                    Self::MostPods => serializer.serialize_unit_variant("Expander", 1u32, "most-pods"),
                    Self::Random => serializer.serialize_unit_variant("Expander", 2u32, "random"),
                    Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
                }
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterSku {
    #[doc = "Name of a managed cluster SKU."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<managed_cluster_sku::Name>,
    #[doc = "Tier of a managed cluster SKU."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tier: Option<managed_cluster_sku::Tier>,
}
impl ManagedClusterSku {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod managed_cluster_sku {
    use super::*;
    #[doc = "Name of a managed cluster SKU."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "Name")]
    pub enum Name {
        Basic,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for Name {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for Name {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for Name {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Basic => serializer.serialize_unit_variant("Name", 0u32, "Basic"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
    #[doc = "Tier of a managed cluster SKU."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "Tier")]
    pub enum Tier {
        Paid,
        Free,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for Tier {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for Tier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for Tier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Paid => serializer.serialize_unit_variant("Tier", 0u32, "Paid"),
                Self::Free => serializer.serialize_unit_variant("Tier", 1u32, "Free"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
}
#[doc = "Information about a service principal identity for the cluster to use for manipulating Azure APIs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterServicePrincipalProfile {
    #[doc = "The ID for the service principal."]
    #[serde(rename = "clientId")]
    pub client_id: String,
    #[doc = "The secret password associated with the service principal in plain text."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
}
impl ManagedClusterServicePrincipalProfile {
    pub fn new(client_id: String) -> Self {
        Self { client_id, secret: None }
    }
}
#[doc = "The list of available upgrades for compute pools."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterUpgradeProfile {
    #[doc = "Id of upgrade profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Name of upgrade profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Type of upgrade profile."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "Control plane and agent pool upgrade profiles."]
    pub properties: ManagedClusterUpgradeProfileProperties,
}
impl ManagedClusterUpgradeProfile {
    pub fn new(properties: ManagedClusterUpgradeProfileProperties) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            properties,
        }
    }
}
#[doc = "Control plane and agent pool upgrade profiles."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterUpgradeProfileProperties {
    #[doc = "The list of available upgrade versions."]
    #[serde(rename = "controlPlaneProfile")]
    pub control_plane_profile: ManagedClusterPoolUpgradeProfile,
    #[doc = "The list of available upgrade versions for agent pools."]
    #[serde(rename = "agentPoolProfiles")]
    pub agent_pool_profiles: Vec<ManagedClusterPoolUpgradeProfile>,
}
impl ManagedClusterUpgradeProfileProperties {
    pub fn new(
        control_plane_profile: ManagedClusterPoolUpgradeProfile,
        agent_pool_profiles: Vec<ManagedClusterPoolUpgradeProfile>,
    ) -> Self {
        Self {
            control_plane_profile,
            agent_pool_profiles,
        }
    }
}
#[doc = "Profile for Windows VMs in the container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterWindowsProfile {
    #[doc = "Specifies the name of the administrator account. <br><br> **restriction:** Cannot end in \".\" <br><br> **Disallowed values:** \"administrator\", \"admin\", \"user\", \"user1\", \"test\", \"user2\", \"test1\", \"user3\", \"admin1\", \"1\", \"123\", \"a\", \"actuser\", \"adm\", \"admin2\", \"aspnet\", \"backup\", \"console\", \"david\", \"guest\", \"john\", \"owner\", \"root\", \"server\", \"sql\", \"support\", \"support_388945a0\", \"sys\", \"test2\", \"test3\", \"user4\", \"user5\". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters"]
    #[serde(rename = "adminUsername")]
    pub admin_username: String,
    #[doc = "Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\\W_]) <br><br> **Disallowed values:** \"abc@123\", \"P@$$w0rd\", \"P@ssw0rd\", \"P@ssword123\", \"Pa$$word\", \"pass@word1\", \"Password!\", \"Password1\", \"Password22\", \"iloveyou!\""]
    #[serde(rename = "adminPassword", default, skip_serializing_if = "Option::is_none")]
    pub admin_password: Option<String>,
    #[doc = "The licenseType to use for Windows VMs. Windows_Server is used to enable Azure Hybrid User Benefits for Windows VMs."]
    #[serde(rename = "licenseType", default, skip_serializing_if = "Option::is_none")]
    pub license_type: Option<managed_cluster_windows_profile::LicenseType>,
}
impl ManagedClusterWindowsProfile {
    pub fn new(admin_username: String) -> Self {
        Self {
            admin_username,
            admin_password: None,
            license_type: None,
        }
    }
}
pub mod managed_cluster_windows_profile {
    use super::*;
    #[doc = "The licenseType to use for Windows VMs. Windows_Server is used to enable Azure Hybrid User Benefits for Windows VMs."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "LicenseType")]
    pub enum LicenseType {
        None,
        #[serde(rename = "Windows_Server")]
        WindowsServer,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for LicenseType {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for LicenseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for LicenseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::None => serializer.serialize_unit_variant("LicenseType", 0u32, "None"),
                Self::WindowsServer => serializer.serialize_unit_variant("LicenseType", 1u32, "Windows_Server"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
}
#[doc = "OSDiskType represents the type of an OS disk on an agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(remote = "OsDiskType")]
pub enum OsDiskType {
    Managed,
    Ephemeral,
    #[serde(skip_deserializing)]
    UnknownValue(String),
}
impl FromStr for OsDiskType {
    type Err = value::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(s.into_deserializer())
    }
}
impl<'de> Deserialize<'de> for OsDiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
        Ok(deserialized)
    }
}
impl Serialize for OsDiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::Managed => serializer.serialize_unit_variant("OsDiskType", 0u32, "Managed"),
            Self::Ephemeral => serializer.serialize_unit_variant("OsDiskType", 1u32, "Ephemeral"),
            Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
        }
    }
}
#[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(remote = "OsType")]
pub enum OsType {
    Linux,
    Windows,
    #[serde(skip_deserializing)]
    UnknownValue(String),
}
impl FromStr for OsType {
    type Err = value::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(s.into_deserializer())
    }
}
impl<'de> Deserialize<'de> for OsType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
        Ok(deserialized)
    }
}
impl Serialize for OsType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::Linux => serializer.serialize_unit_variant("OsType", 0u32, "Linux"),
            Self::Windows => serializer.serialize_unit_variant("OsType", 1u32, "Windows"),
            Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
        }
    }
}
impl Default for OsType {
    fn default() -> Self {
        Self::Linux
    }
}
#[doc = "The List Compute Operation operation response."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationListResult {
    #[doc = "The list of compute operations"]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<OperationValue>,
}
impl azure_core::Continuable for OperationListResult {
    fn continuation(&self) -> Option<azure_core::prelude::Continuation> {
        None
    }
}
impl OperationListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Describes the properties of a Compute Operation value."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationValue {
    #[doc = "The origin of the compute operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[doc = "The name of the compute operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Describes the properties of a Compute Operation Value Display."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display: Option<OperationValueDisplay>,
}
impl OperationValue {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Describes the properties of a Compute Operation Value Display."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationValueDisplay {
    #[doc = "The display name of the compute operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    #[doc = "The display name of the resource the operation applies to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    #[doc = "The description of the operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The resource provider for the operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
}
impl OperationValueDisplay {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Contains information about orchestrator."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrchestratorProfile {
    #[doc = "Orchestrator type."]
    #[serde(rename = "orchestratorType", default, skip_serializing_if = "Option::is_none")]
    pub orchestrator_type: Option<String>,
    #[doc = "Orchestrator version (major, minor, patch)."]
    #[serde(rename = "orchestratorVersion")]
    pub orchestrator_version: String,
    #[doc = "Whether Kubernetes version is currently in preview."]
    #[serde(rename = "isPreview", default, skip_serializing_if = "Option::is_none")]
    pub is_preview: Option<bool>,
}
impl OrchestratorProfile {
    pub fn new(orchestrator_version: String) -> Self {
        Self {
            orchestrator_type: None,
            orchestrator_version,
            is_preview: None,
        }
    }
}
#[doc = "The profile of an orchestrator and its available versions."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrchestratorVersionProfile {
    #[doc = "Orchestrator type."]
    #[serde(rename = "orchestratorType")]
    pub orchestrator_type: String,
    #[doc = "Orchestrator version (major, minor, patch)."]
    #[serde(rename = "orchestratorVersion")]
    pub orchestrator_version: String,
    #[doc = "Installed by default if version is not specified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<bool>,
    #[doc = "Whether Kubernetes version is currently in preview."]
    #[serde(rename = "isPreview", default, skip_serializing_if = "Option::is_none")]
    pub is_preview: Option<bool>,
    #[doc = "The list of available upgrade versions."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub upgrades: Vec<OrchestratorProfile>,
}
impl OrchestratorVersionProfile {
    pub fn new(orchestrator_type: String, orchestrator_version: String) -> Self {
        Self {
            orchestrator_type,
            orchestrator_version,
            default: None,
            is_preview: None,
            upgrades: Vec::new(),
        }
    }
}
#[doc = "The list of versions for supported orchestrators."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrchestratorVersionProfileListResult {
    #[doc = "Id of the orchestrator version profile list result."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Name of the orchestrator version profile list result."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Type of the orchestrator version profile list result."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The properties of an orchestrator version profile."]
    pub properties: OrchestratorVersionProfileProperties,
}
impl OrchestratorVersionProfileListResult {
    pub fn new(properties: OrchestratorVersionProfileProperties) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            properties,
        }
    }
}
#[doc = "The properties of an orchestrator version profile."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrchestratorVersionProfileProperties {
    #[doc = "List of orchestrator version profiles."]
    pub orchestrators: Vec<OrchestratorVersionProfile>,
}
impl OrchestratorVersionProfileProperties {
    pub fn new(orchestrators: Vec<OrchestratorVersionProfile>) -> Self {
        Self { orchestrators }
    }
}
#[doc = "Describes the Power State of the cluster"]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PowerState {
    #[doc = "Tells whether the cluster is Running or Stopped"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<power_state::Code>,
}
impl PowerState {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod power_state {
    use super::*;
    #[doc = "Tells whether the cluster is Running or Stopped"]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "Code")]
    pub enum Code {
        Running,
        Stopped,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for Code {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Running => serializer.serialize_unit_variant("Code", 0u32, "Running"),
                Self::Stopped => serializer.serialize_unit_variant("Code", 1u32, "Stopped"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
}
#[doc = "Private endpoint which a connection belongs to."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateEndpoint {
    #[doc = "The resource Id for private endpoint"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
impl PrivateEndpoint {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "A private endpoint connection"]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateEndpointConnection {
    #[doc = "The ID of the private endpoint connection."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The name of the private endpoint connection."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The resource type."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "Properties of a private endpoint connection."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateEndpointConnectionProperties>,
}
impl PrivateEndpointConnection {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "A list of private endpoint connections"]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateEndpointConnectionListResult {
    #[doc = "The collection value."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateEndpointConnection>,
}
impl PrivateEndpointConnectionListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Properties of a private endpoint connection."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnectionProperties {
    #[doc = "The current provisioning state."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<private_endpoint_connection_properties::ProvisioningState>,
    #[doc = "Private endpoint which a connection belongs to."]
    #[serde(rename = "privateEndpoint", default, skip_serializing_if = "Option::is_none")]
    pub private_endpoint: Option<PrivateEndpoint>,
    #[doc = "The state of a private link service connection."]
    #[serde(rename = "privateLinkServiceConnectionState")]
    pub private_link_service_connection_state: PrivateLinkServiceConnectionState,
}
impl PrivateEndpointConnectionProperties {
    pub fn new(private_link_service_connection_state: PrivateLinkServiceConnectionState) -> Self {
        Self {
            provisioning_state: None,
            private_endpoint: None,
            private_link_service_connection_state,
        }
    }
}
pub mod private_endpoint_connection_properties {
    use super::*;
    #[doc = "The current provisioning state."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "ProvisioningState")]
    pub enum ProvisioningState {
        Succeeded,
        Creating,
        Deleting,
        Failed,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for ProvisioningState {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for ProvisioningState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for ProvisioningState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Succeeded => serializer.serialize_unit_variant("ProvisioningState", 0u32, "Succeeded"),
                Self::Creating => serializer.serialize_unit_variant("ProvisioningState", 1u32, "Creating"),
                Self::Deleting => serializer.serialize_unit_variant("ProvisioningState", 2u32, "Deleting"),
                Self::Failed => serializer.serialize_unit_variant("ProvisioningState", 3u32, "Failed"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
}
#[doc = "A private link resource"]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateLinkResource {
    #[doc = "The ID of the private link resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The name of the private link resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "The resource type."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The group ID of the resource."]
    #[serde(rename = "groupId", default, skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,
    #[doc = "RequiredMembers of the resource"]
    #[serde(rename = "requiredMembers", default, skip_serializing_if = "Vec::is_empty")]
    pub required_members: Vec<String>,
    #[doc = "The private link service ID of the resource, this field is exposed only to NRP internally."]
    #[serde(rename = "privateLinkServiceID", default, skip_serializing_if = "Option::is_none")]
    pub private_link_service_id: Option<String>,
}
impl PrivateLinkResource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "A list of private link resources"]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateLinkResourcesListResult {
    #[doc = "The collection value."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateLinkResource>,
}
impl PrivateLinkResourcesListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The state of a private link service connection."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PrivateLinkServiceConnectionState {
    #[doc = "The private link service connection status."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<private_link_service_connection_state::Status>,
    #[doc = "The private link service connection description."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
impl PrivateLinkServiceConnectionState {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod private_link_service_connection_state {
    use super::*;
    #[doc = "The private link service connection status."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(remote = "Status")]
    pub enum Status {
        Pending,
        Approved,
        Rejected,
        Disconnected,
        #[serde(skip_deserializing)]
        UnknownValue(String),
    }
    impl FromStr for Status {
        type Err = value::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Self::deserialize(s.into_deserializer())
        }
    }
    impl<'de> Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
            Ok(deserialized)
        }
    }
    impl Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self {
                Self::Pending => serializer.serialize_unit_variant("Status", 0u32, "Pending"),
                Self::Approved => serializer.serialize_unit_variant("Status", 1u32, "Approved"),
                Self::Rejected => serializer.serialize_unit_variant("Status", 2u32, "Rejected"),
                Self::Disconnected => serializer.serialize_unit_variant("Status", 3u32, "Disconnected"),
                Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
            }
        }
    }
}
pub type ProximityPlacementGroupId = String;
#[doc = "The Resource model definition."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Resource {
    #[doc = "Resource Id"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Resource name"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Resource type"]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "Resource location"]
    pub location: String,
    #[doc = "Resource tags"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
impl Resource {
    pub fn new(location: String) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            location,
            tags: None,
        }
    }
}
#[doc = "A reference to an Azure resource."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ResourceReference {
    #[doc = "The fully qualified Azure resource id."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
impl ResourceReference {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "ScaleSetEvictionPolicy to be used to specify eviction policy for Spot virtual machine scale set. Default to Delete."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(remote = "ScaleSetEvictionPolicy")]
pub enum ScaleSetEvictionPolicy {
    Delete,
    Deallocate,
    #[serde(skip_deserializing)]
    UnknownValue(String),
}
impl FromStr for ScaleSetEvictionPolicy {
    type Err = value::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(s.into_deserializer())
    }
}
impl<'de> Deserialize<'de> for ScaleSetEvictionPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
        Ok(deserialized)
    }
}
impl Serialize for ScaleSetEvictionPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::Delete => serializer.serialize_unit_variant("ScaleSetEvictionPolicy", 0u32, "Delete"),
            Self::Deallocate => serializer.serialize_unit_variant("ScaleSetEvictionPolicy", 1u32, "Deallocate"),
            Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
        }
    }
}
impl Default for ScaleSetEvictionPolicy {
    fn default() -> Self {
        Self::Delete
    }
}
#[doc = "ScaleSetPriority to be used to specify virtual machine scale set priority. Default to regular."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(remote = "ScaleSetPriority")]
pub enum ScaleSetPriority {
    Spot,
    Regular,
    #[serde(skip_deserializing)]
    UnknownValue(String),
}
impl FromStr for ScaleSetPriority {
    type Err = value::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(s.into_deserializer())
    }
}
impl<'de> Deserialize<'de> for ScaleSetPriority {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let deserialized = Self::from_str(&s).unwrap_or(Self::UnknownValue(s));
        Ok(deserialized)
    }
}
impl Serialize for ScaleSetPriority {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::Spot => serializer.serialize_unit_variant("ScaleSetPriority", 0u32, "Spot"),
            Self::Regular => serializer.serialize_unit_variant("ScaleSetPriority", 1u32, "Regular"),
            Self::UnknownValue(s) => serializer.serialize_str(s.as_str()),
        }
    }
}
impl Default for ScaleSetPriority {
    fn default() -> Self {
        Self::Regular
    }
}
pub type SpotMaxPrice = f64;
#[doc = "Reference to another subresource."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct SubResource {
    #[doc = "Resource ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The name of the resource that is unique within a resource group. This name can be used to access the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Resource type"]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
impl SubResource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Sysctl settings for Linux agent nodes."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct SysctlConfig {
    #[doc = "Sysctl setting net.core.somaxconn."]
    #[serde(rename = "netCoreSomaxconn", default, skip_serializing_if = "Option::is_none")]
    pub net_core_somaxconn: Option<i32>,
    #[doc = "Sysctl setting net.core.netdev_max_backlog."]
    #[serde(rename = "netCoreNetdevMaxBacklog", default, skip_serializing_if = "Option::is_none")]
    pub net_core_netdev_max_backlog: Option<i32>,
    #[doc = "Sysctl setting net.core.rmem_max."]
    #[serde(rename = "netCoreRmemMax", default, skip_serializing_if = "Option::is_none")]
    pub net_core_rmem_max: Option<i32>,
    #[doc = "Sysctl setting net.core.wmem_max."]
    #[serde(rename = "netCoreWmemMax", default, skip_serializing_if = "Option::is_none")]
    pub net_core_wmem_max: Option<i32>,
    #[doc = "Sysctl setting net.core.optmem_max."]
    #[serde(rename = "netCoreOptmemMax", default, skip_serializing_if = "Option::is_none")]
    pub net_core_optmem_max: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_max_syn_backlog."]
    #[serde(rename = "netIpv4TcpMaxSynBacklog", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcp_max_syn_backlog: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_max_tw_buckets."]
    #[serde(rename = "netIpv4TcpMaxTwBuckets", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcp_max_tw_buckets: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_fin_timeout."]
    #[serde(rename = "netIpv4TcpFinTimeout", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcp_fin_timeout: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_keepalive_time."]
    #[serde(rename = "netIpv4TcpKeepaliveTime", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcp_keepalive_time: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_keepalive_probes."]
    #[serde(rename = "netIpv4TcpKeepaliveProbes", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcp_keepalive_probes: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_keepalive_intvl."]
    #[serde(rename = "netIpv4TcpkeepaliveIntvl", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcpkeepalive_intvl: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_rmem."]
    #[serde(rename = "netIpv4TcpRmem", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcp_rmem: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_wmem."]
    #[serde(rename = "netIpv4TcpWmem", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcp_wmem: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.tcp_tw_reuse."]
    #[serde(rename = "netIpv4TcpTwReuse", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_tcp_tw_reuse: Option<bool>,
    #[doc = "Sysctl setting net.ipv4.ip_local_port_range."]
    #[serde(rename = "netIpv4IpLocalPortRange", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_ip_local_port_range: Option<String>,
    #[doc = "Sysctl setting net.ipv4.neigh.default.gc_thresh1."]
    #[serde(rename = "netIpv4NeighDefaultGcThresh1", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_neigh_default_gc_thresh1: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.neigh.default.gc_thresh2."]
    #[serde(rename = "netIpv4NeighDefaultGcThresh2", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_neigh_default_gc_thresh2: Option<i32>,
    #[doc = "Sysctl setting net.ipv4.neigh.default.gc_thresh3."]
    #[serde(rename = "netIpv4NeighDefaultGcThresh3", default, skip_serializing_if = "Option::is_none")]
    pub net_ipv4_neigh_default_gc_thresh3: Option<i32>,
    #[doc = "Sysctl setting net.netfilter.nf_conntrack_max."]
    #[serde(rename = "netNetfilterNfConntrackMax", default, skip_serializing_if = "Option::is_none")]
    pub net_netfilter_nf_conntrack_max: Option<i32>,
    #[doc = "Sysctl setting net.netfilter.nf_conntrack_buckets."]
    #[serde(rename = "netNetfilterNfConntrackBuckets", default, skip_serializing_if = "Option::is_none")]
    pub net_netfilter_nf_conntrack_buckets: Option<i32>,
    #[doc = "Sysctl setting fs.inotify.max_user_watches."]
    #[serde(rename = "fsInotifyMaxUserWatches", default, skip_serializing_if = "Option::is_none")]
    pub fs_inotify_max_user_watches: Option<i32>,
    #[doc = "Sysctl setting fs.file-max."]
    #[serde(rename = "fsFileMax", default, skip_serializing_if = "Option::is_none")]
    pub fs_file_max: Option<i32>,
    #[doc = "Sysctl setting fs.aio-max-nr."]
    #[serde(rename = "fsAioMaxNr", default, skip_serializing_if = "Option::is_none")]
    pub fs_aio_max_nr: Option<i32>,
    #[doc = "Sysctl setting fs.nr_open."]
    #[serde(rename = "fsNrOpen", default, skip_serializing_if = "Option::is_none")]
    pub fs_nr_open: Option<i32>,
    #[doc = "Sysctl setting kernel.threads-max."]
    #[serde(rename = "kernelThreadsMax", default, skip_serializing_if = "Option::is_none")]
    pub kernel_threads_max: Option<i32>,
    #[doc = "Sysctl setting vm.max_map_count."]
    #[serde(rename = "vmMaxMapCount", default, skip_serializing_if = "Option::is_none")]
    pub vm_max_map_count: Option<i32>,
    #[doc = "Sysctl setting vm.swappiness."]
    #[serde(rename = "vmSwappiness", default, skip_serializing_if = "Option::is_none")]
    pub vm_swappiness: Option<i32>,
    #[doc = "Sysctl setting vm.vfs_cache_pressure."]
    #[serde(rename = "vmVfsCachePressure", default, skip_serializing_if = "Option::is_none")]
    pub vm_vfs_cache_pressure: Option<i32>,
}
impl SysctlConfig {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Tags object for patch operations."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct TagsObject {
    #[doc = "Resource tags."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
impl TagsObject {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct UserAssignedIdentity {
    #[doc = "The resource id of the user assigned identity."]
    #[serde(rename = "resourceId", default, skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[doc = "The client id of the user assigned identity."]
    #[serde(rename = "clientId", default, skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    #[doc = "The object id of the user assigned identity."]
    #[serde(rename = "objectId", default, skip_serializing_if = "Option::is_none")]
    pub object_id: Option<String>,
}
impl UserAssignedIdentity {
    pub fn new() -> Self {
        Self::default()
    }
}
