#![doc = "generated by AutoRust"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[doc = "Profile for enabling a user to access a managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AccessProfile {
    #[doc = "Base64-encoded Kubernetes configuration file."]
    #[serde(rename = "kubeConfig", default, skip_serializing_if = "Option::is_none")]
    pub kube_config: Option<String>,
}
impl AccessProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Agent Pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AgentPool {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[doc = "Properties for the container service agent pool profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagedClusterAgentPoolProfileProperties>,
}
impl AgentPool {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The list of available versions for an agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AgentPoolAvailableVersions {
    #[doc = "Id of the agent pool available versions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Name of the agent pool available versions."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Type of the agent pool  available versions."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The list of available agent pool versions."]
    pub properties: AgentPoolAvailableVersionsProperties,
}
impl AgentPoolAvailableVersions {
    pub fn new(properties: AgentPoolAvailableVersionsProperties) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            properties,
        }
    }
}
#[doc = "The list of available agent pool versions."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AgentPoolAvailableVersionsProperties {
    #[doc = "List of versions available for agent pool."]
    #[serde(rename = "agentPoolVersions", default, skip_serializing_if = "Vec::is_empty")]
    pub agent_pool_versions: Vec<serde_json::Value>,
}
impl AgentPoolAvailableVersionsProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The response from the List Agent Pools operation."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct AgentPoolListResult {
    #[doc = "The list of agent pools."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AgentPool>,
    #[doc = "The URL to get the next set of agent pool results."]
    #[serde(rename = "nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl AgentPoolListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "AgentPoolType represents types of an agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AgentPoolType {
    VirtualMachineScaleSets,
    AvailabilitySet,
}
#[doc = "The list of available upgrades for an agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AgentPoolUpgradeProfile {
    #[doc = "Id of the agent pool upgrade profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Name of the agent pool upgrade profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Type of the agent pool upgrade profile."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The list of available upgrade versions."]
    pub properties: AgentPoolUpgradeProfileProperties,
}
impl AgentPoolUpgradeProfile {
    pub fn new(properties: AgentPoolUpgradeProfileProperties) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            properties,
        }
    }
}
#[doc = "The list of available upgrade versions."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AgentPoolUpgradeProfileProperties {
    #[doc = "Kubernetes version (major, minor, patch)."]
    #[serde(rename = "kubernetesVersion")]
    pub kubernetes_version: String,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType")]
    pub os_type: OsType,
    #[doc = "List of orchestrator types and versions available for upgrade."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub upgrades: Vec<serde_json::Value>,
}
impl AgentPoolUpgradeProfileProperties {
    pub fn new(kubernetes_version: String, os_type: OsType) -> Self {
        Self {
            kubernetes_version,
            os_type,
            upgrades: Vec::new(),
        }
    }
}
#[doc = "An error response from the Container service."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CloudError {
    #[doc = "An error response from the Container service."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<CloudErrorBody>,
}
impl CloudError {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "An error response from the Container service."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CloudErrorBody {
    #[doc = "An identifier for the error. Codes are invariant and are intended to be consumed programmatically."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[doc = "A message describing the error, intended to be suitable for display in a user interface."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[doc = "The target of the particular error. For example, the name of the property in error."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[doc = "A list of additional details about the error."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<CloudErrorBody>,
}
impl CloudErrorBody {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Container service."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerService {
    #[serde(flatten)]
    pub resource: Resource,
    #[doc = "Properties of the container service."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<ContainerServiceProperties>,
}
impl ContainerService {
    pub fn new(resource: Resource) -> Self {
        Self {
            resource,
            properties: None,
        }
    }
}
#[doc = "Profile for the container service agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceAgentPoolProfile {
    #[doc = "Unique name of the agent pool profile in the context of the subscription and resource group."]
    pub name: String,
    #[doc = "Number of agents (VMs) to host docker containers. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1. "]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    #[doc = "Size of agent VMs."]
    #[serde(rename = "vmSize")]
    pub vm_size: ContainerServiceVmSize,
    #[doc = "OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified."]
    #[serde(rename = "osDiskSizeGB", default, skip_serializing_if = "Option::is_none")]
    pub os_disk_size_gb: Option<ContainerServiceOsDisk>,
    #[doc = "DNS prefix to be used to create the FQDN for the agent pool."]
    #[serde(rename = "dnsPrefix", default, skip_serializing_if = "Option::is_none")]
    pub dns_prefix: Option<String>,
    #[doc = "FQDN for the agent pool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[doc = "Ports number array used to expose on this agent pool. The default opened ports are different based on your choice of orchestrator."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub ports: Vec<i64>,
    #[doc = "Storage profile specifies what kind of storage used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will choose for you based on the orchestrator choice."]
    #[serde(rename = "storageProfile", default, skip_serializing_if = "Option::is_none")]
    pub storage_profile: Option<ContainerServiceStorageProfile>,
    #[doc = "VNet SubnetID specifies the VNet's subnet identifier."]
    #[serde(rename = "vnetSubnetID", default, skip_serializing_if = "Option::is_none")]
    pub vnet_subnet_id: Option<ContainerServiceVnetSubnetId>,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType", default, skip_serializing_if = "Option::is_none")]
    pub os_type: Option<OsType>,
}
impl ContainerServiceAgentPoolProfile {
    pub fn new(name: String, vm_size: ContainerServiceVmSize) -> Self {
        Self {
            name,
            count: None,
            vm_size,
            os_disk_size_gb: None,
            dns_prefix: None,
            fqdn: None,
            ports: Vec::new(),
            storage_profile: None,
            vnet_subnet_id: None,
            os_type: None,
        }
    }
}
#[doc = "Properties to configure a custom container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceCustomProfile {
    #[doc = "The name of the custom orchestrator to use."]
    pub orchestrator: String,
}
impl ContainerServiceCustomProfile {
    pub fn new(orchestrator: String) -> Self {
        Self { orchestrator }
    }
}
#[doc = "Profile for diagnostics on the container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceDiagnosticsProfile {
    #[doc = "Profile for diagnostics on the container service VMs."]
    #[serde(rename = "vmDiagnostics")]
    pub vm_diagnostics: ContainerServiceVmDiagnostics,
}
impl ContainerServiceDiagnosticsProfile {
    pub fn new(vm_diagnostics: ContainerServiceVmDiagnostics) -> Self {
        Self { vm_diagnostics }
    }
}
#[doc = "Profile for Linux VMs in the container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceLinuxProfile {
    #[doc = "The administrator username to use for Linux VMs."]
    #[serde(rename = "adminUsername")]
    pub admin_username: String,
    #[doc = "SSH configuration for Linux-based VMs running on Azure."]
    pub ssh: ContainerServiceSshConfiguration,
}
impl ContainerServiceLinuxProfile {
    pub fn new(admin_username: String, ssh: ContainerServiceSshConfiguration) -> Self {
        Self { admin_username, ssh }
    }
}
#[doc = "The response from the List Container Services operation."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ContainerServiceListResult {
    #[doc = "The list of container services."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ContainerService>,
    #[doc = "The URL to get the next set of container service results."]
    #[serde(rename = "nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl ContainerServiceListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Profile for the container service master."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceMasterProfile {
    #[doc = "Number of masters (VMs) in the container service cluster. Allowed values are 1, 3, and 5. The default value is 1."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<container_service_master_profile::Count>,
    #[doc = "DNS prefix to be used to create the FQDN for the master pool."]
    #[serde(rename = "dnsPrefix")]
    pub dns_prefix: String,
    #[doc = "Size of agent VMs."]
    #[serde(rename = "vmSize")]
    pub vm_size: ContainerServiceVmSize,
    #[doc = "OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified."]
    #[serde(rename = "osDiskSizeGB", default, skip_serializing_if = "Option::is_none")]
    pub os_disk_size_gb: Option<ContainerServiceOsDisk>,
    #[doc = "VNet SubnetID specifies the VNet's subnet identifier."]
    #[serde(rename = "vnetSubnetID", default, skip_serializing_if = "Option::is_none")]
    pub vnet_subnet_id: Option<ContainerServiceVnetSubnetId>,
    #[doc = "FirstConsecutiveStaticIP used to specify the first static ip of masters."]
    #[serde(rename = "firstConsecutiveStaticIP", default, skip_serializing_if = "Option::is_none")]
    pub first_consecutive_static_ip: Option<String>,
    #[doc = "Storage profile specifies what kind of storage used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will choose for you based on the orchestrator choice."]
    #[serde(rename = "storageProfile", default, skip_serializing_if = "Option::is_none")]
    pub storage_profile: Option<ContainerServiceStorageProfile>,
    #[doc = "FQDN for the master pool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
}
impl ContainerServiceMasterProfile {
    pub fn new(dns_prefix: String, vm_size: ContainerServiceVmSize) -> Self {
        Self {
            count: None,
            dns_prefix,
            vm_size,
            os_disk_size_gb: None,
            vnet_subnet_id: None,
            first_consecutive_static_ip: None,
            storage_profile: None,
            fqdn: None,
        }
    }
}
pub mod container_service_master_profile {
    use super::*;
    #[doc = "Number of masters (VMs) in the container service cluster. Allowed values are 1, 3, and 5. The default value is 1."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Count {}
}
#[doc = "Profile of network configuration."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ContainerServiceNetworkProfile {
    #[doc = "Network plugin used for building Kubernetes network."]
    #[serde(rename = "networkPlugin", default, skip_serializing_if = "Option::is_none")]
    pub network_plugin: Option<container_service_network_profile::NetworkPlugin>,
    #[doc = "Network policy used for building Kubernetes network."]
    #[serde(rename = "networkPolicy", default, skip_serializing_if = "Option::is_none")]
    pub network_policy: Option<container_service_network_profile::NetworkPolicy>,
    #[doc = "A CIDR notation IP range from which to assign pod IPs when kubenet is used."]
    #[serde(rename = "podCidr", default, skip_serializing_if = "Option::is_none")]
    pub pod_cidr: Option<String>,
    #[doc = "A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges."]
    #[serde(rename = "serviceCidr", default, skip_serializing_if = "Option::is_none")]
    pub service_cidr: Option<String>,
    #[doc = "An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr."]
    #[serde(rename = "dnsServiceIP", default, skip_serializing_if = "Option::is_none")]
    pub dns_service_ip: Option<String>,
    #[doc = "A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range."]
    #[serde(rename = "dockerBridgeCidr", default, skip_serializing_if = "Option::is_none")]
    pub docker_bridge_cidr: Option<String>,
    #[doc = "The outbound (egress) routing method."]
    #[serde(rename = "outboundType", default, skip_serializing_if = "Option::is_none")]
    pub outbound_type: Option<container_service_network_profile::OutboundType>,
    #[doc = "The load balancer sku for the managed cluster."]
    #[serde(rename = "loadBalancerSku", default, skip_serializing_if = "Option::is_none")]
    pub load_balancer_sku: Option<container_service_network_profile::LoadBalancerSku>,
    #[doc = "Profile of the managed cluster load balancer."]
    #[serde(rename = "loadBalancerProfile", default, skip_serializing_if = "Option::is_none")]
    pub load_balancer_profile: Option<ManagedClusterLoadBalancerProfile>,
}
impl ContainerServiceNetworkProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod container_service_network_profile {
    use super::*;
    #[doc = "Network plugin used for building Kubernetes network."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum NetworkPlugin {
        #[serde(rename = "azure")]
        Azure,
        #[serde(rename = "kubenet")]
        Kubenet,
    }
    impl Default for NetworkPlugin {
        fn default() -> Self {
            Self::Kubenet
        }
    }
    #[doc = "Network policy used for building Kubernetes network."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum NetworkPolicy {
        #[serde(rename = "calico")]
        Calico,
        #[serde(rename = "azure")]
        Azure,
    }
    #[doc = "The outbound (egress) routing method."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OutboundType {
        #[serde(rename = "loadBalancer")]
        LoadBalancer,
        #[serde(rename = "userDefinedRouting")]
        UserDefinedRouting,
    }
    impl Default for OutboundType {
        fn default() -> Self {
            Self::LoadBalancer
        }
    }
    #[doc = "The load balancer sku for the managed cluster."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LoadBalancerSku {
        #[serde(rename = "standard")]
        Standard,
        #[serde(rename = "basic")]
        Basic,
    }
}
pub type ContainerServiceOsDisk = i32;
#[doc = "Profile for the container service orchestrator."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceOrchestratorProfile {
    #[doc = "The orchestrator to use to manage container service cluster resources. Valid values are Kubernetes, Swarm, DCOS, DockerCE and Custom."]
    #[serde(rename = "orchestratorType")]
    pub orchestrator_type: container_service_orchestrator_profile::OrchestratorType,
    #[doc = "The version of the orchestrator to use. You can specify the major.minor.patch part of the actual version.For example, you can specify version as \"1.6.11\"."]
    #[serde(rename = "orchestratorVersion", default, skip_serializing_if = "Option::is_none")]
    pub orchestrator_version: Option<String>,
}
impl ContainerServiceOrchestratorProfile {
    pub fn new(orchestrator_type: container_service_orchestrator_profile::OrchestratorType) -> Self {
        Self {
            orchestrator_type,
            orchestrator_version: None,
        }
    }
}
pub mod container_service_orchestrator_profile {
    use super::*;
    #[doc = "The orchestrator to use to manage container service cluster resources. Valid values are Kubernetes, Swarm, DCOS, DockerCE and Custom."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OrchestratorType {
        Kubernetes,
        Swarm,
        #[serde(rename = "DCOS")]
        Dcos,
        #[serde(rename = "DockerCE")]
        DockerCe,
        Custom,
    }
}
#[doc = "Properties of the container service."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceProperties {
    #[doc = "The current deployment or provisioning state, which only appears in the response."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[doc = "Profile for the container service orchestrator."]
    #[serde(rename = "orchestratorProfile")]
    pub orchestrator_profile: ContainerServiceOrchestratorProfile,
    #[doc = "Properties to configure a custom container service cluster."]
    #[serde(rename = "customProfile", default, skip_serializing_if = "Option::is_none")]
    pub custom_profile: Option<ContainerServiceCustomProfile>,
    #[doc = "Information about a service principal identity for the cluster to use for manipulating Azure APIs. Either secret or keyVaultSecretRef must be specified."]
    #[serde(rename = "servicePrincipalProfile", default, skip_serializing_if = "Option::is_none")]
    pub service_principal_profile: Option<ContainerServiceServicePrincipalProfile>,
    #[doc = "Profile for the container service master."]
    #[serde(rename = "masterProfile")]
    pub master_profile: ContainerServiceMasterProfile,
    #[doc = "Properties of the agent pool."]
    #[serde(rename = "agentPoolProfiles", default, skip_serializing_if = "Vec::is_empty")]
    pub agent_pool_profiles: Vec<ContainerServiceAgentPoolProfile>,
    #[doc = "Profile for Windows VMs in the container service cluster."]
    #[serde(rename = "windowsProfile", default, skip_serializing_if = "Option::is_none")]
    pub windows_profile: Option<ContainerServiceWindowsProfile>,
    #[doc = "Profile for Linux VMs in the container service cluster."]
    #[serde(rename = "linuxProfile")]
    pub linux_profile: ContainerServiceLinuxProfile,
    #[doc = "Profile for diagnostics on the container service cluster."]
    #[serde(rename = "diagnosticsProfile", default, skip_serializing_if = "Option::is_none")]
    pub diagnostics_profile: Option<ContainerServiceDiagnosticsProfile>,
}
impl ContainerServiceProperties {
    pub fn new(
        orchestrator_profile: ContainerServiceOrchestratorProfile,
        master_profile: ContainerServiceMasterProfile,
        linux_profile: ContainerServiceLinuxProfile,
    ) -> Self {
        Self {
            provisioning_state: None,
            orchestrator_profile,
            custom_profile: None,
            service_principal_profile: None,
            master_profile,
            agent_pool_profiles: Vec::new(),
            windows_profile: None,
            linux_profile,
            diagnostics_profile: None,
        }
    }
}
#[doc = "Information about a service principal identity for the cluster to use for manipulating Azure APIs. Either secret or keyVaultSecretRef must be specified."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceServicePrincipalProfile {
    #[doc = "The ID for the service principal."]
    #[serde(rename = "clientId")]
    pub client_id: String,
    #[doc = "The secret password associated with the service principal in plain text."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    #[doc = "Reference to a secret stored in Azure Key Vault."]
    #[serde(rename = "keyVaultSecretRef", default, skip_serializing_if = "Option::is_none")]
    pub key_vault_secret_ref: Option<KeyVaultSecretRef>,
}
impl ContainerServiceServicePrincipalProfile {
    pub fn new(client_id: String) -> Self {
        Self {
            client_id,
            secret: None,
            key_vault_secret_ref: None,
        }
    }
}
#[doc = "SSH configuration for Linux-based VMs running on Azure."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceSshConfiguration {
    #[doc = "The list of SSH public keys used to authenticate with Linux-based VMs. Only expect one key specified."]
    #[serde(rename = "publicKeys")]
    pub public_keys: Vec<ContainerServiceSshPublicKey>,
}
impl ContainerServiceSshConfiguration {
    pub fn new(public_keys: Vec<ContainerServiceSshPublicKey>) -> Self {
        Self { public_keys }
    }
}
#[doc = "Contains information about SSH certificate public key data."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceSshPublicKey {
    #[doc = "Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers."]
    #[serde(rename = "keyData")]
    pub key_data: String,
}
impl ContainerServiceSshPublicKey {
    pub fn new(key_data: String) -> Self {
        Self { key_data }
    }
}
#[doc = "Storage profile specifies what kind of storage used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will choose for you based on the orchestrator choice."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ContainerServiceStorageProfile {
    StorageAccount,
    ManagedDisks,
}
#[doc = "Profile for diagnostics on the container service VMs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceVmDiagnostics {
    #[doc = "Whether the VM diagnostic agent is provisioned on the VM."]
    pub enabled: bool,
    #[doc = "The URI of the storage account where diagnostics are stored."]
    #[serde(rename = "storageUri", default, skip_serializing_if = "Option::is_none")]
    pub storage_uri: Option<String>,
}
impl ContainerServiceVmDiagnostics {
    pub fn new(enabled: bool) -> Self {
        Self {
            enabled,
            storage_uri: None,
        }
    }
}
#[doc = "Size of agent VMs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ContainerServiceVmSize {
    #[serde(rename = "Standard_A1")]
    StandardA1,
    #[serde(rename = "Standard_A10")]
    StandardA10,
    #[serde(rename = "Standard_A11")]
    StandardA11,
    #[serde(rename = "Standard_A1_v2")]
    StandardA1V2,
    #[serde(rename = "Standard_A2")]
    StandardA2,
    #[serde(rename = "Standard_A2_v2")]
    StandardA2V2,
    #[serde(rename = "Standard_A2m_v2")]
    StandardA2mV2,
    #[serde(rename = "Standard_A3")]
    StandardA3,
    #[serde(rename = "Standard_A4")]
    StandardA4,
    #[serde(rename = "Standard_A4_v2")]
    StandardA4V2,
    #[serde(rename = "Standard_A4m_v2")]
    StandardA4mV2,
    #[serde(rename = "Standard_A5")]
    StandardA5,
    #[serde(rename = "Standard_A6")]
    StandardA6,
    #[serde(rename = "Standard_A7")]
    StandardA7,
    #[serde(rename = "Standard_A8")]
    StandardA8,
    #[serde(rename = "Standard_A8_v2")]
    StandardA8V2,
    #[serde(rename = "Standard_A8m_v2")]
    StandardA8mV2,
    #[serde(rename = "Standard_A9")]
    StandardA9,
    #[serde(rename = "Standard_B2ms")]
    StandardB2ms,
    #[serde(rename = "Standard_B2s")]
    StandardB2s,
    #[serde(rename = "Standard_B4ms")]
    StandardB4ms,
    #[serde(rename = "Standard_B8ms")]
    StandardB8ms,
    #[serde(rename = "Standard_D1")]
    StandardD1,
    #[serde(rename = "Standard_D11")]
    StandardD11,
    #[serde(rename = "Standard_D11_v2")]
    StandardD11V2,
    #[serde(rename = "Standard_D11_v2_Promo")]
    StandardD11V2Promo,
    #[serde(rename = "Standard_D12")]
    StandardD12,
    #[serde(rename = "Standard_D12_v2")]
    StandardD12V2,
    #[serde(rename = "Standard_D12_v2_Promo")]
    StandardD12V2Promo,
    #[serde(rename = "Standard_D13")]
    StandardD13,
    #[serde(rename = "Standard_D13_v2")]
    StandardD13V2,
    #[serde(rename = "Standard_D13_v2_Promo")]
    StandardD13V2Promo,
    #[serde(rename = "Standard_D14")]
    StandardD14,
    #[serde(rename = "Standard_D14_v2")]
    StandardD14V2,
    #[serde(rename = "Standard_D14_v2_Promo")]
    StandardD14V2Promo,
    #[serde(rename = "Standard_D15_v2")]
    StandardD15V2,
    #[serde(rename = "Standard_D16_v3")]
    StandardD16V3,
    #[serde(rename = "Standard_D16s_v3")]
    StandardD16sV3,
    #[serde(rename = "Standard_D1_v2")]
    StandardD1V2,
    #[serde(rename = "Standard_D2")]
    StandardD2,
    #[serde(rename = "Standard_D2_v2")]
    StandardD2V2,
    #[serde(rename = "Standard_D2_v2_Promo")]
    StandardD2V2Promo,
    #[serde(rename = "Standard_D2_v3")]
    StandardD2V3,
    #[serde(rename = "Standard_D2s_v3")]
    StandardD2sV3,
    #[serde(rename = "Standard_D3")]
    StandardD3,
    #[serde(rename = "Standard_D32_v3")]
    StandardD32V3,
    #[serde(rename = "Standard_D32s_v3")]
    StandardD32sV3,
    #[serde(rename = "Standard_D3_v2")]
    StandardD3V2,
    #[serde(rename = "Standard_D3_v2_Promo")]
    StandardD3V2Promo,
    #[serde(rename = "Standard_D4")]
    StandardD4,
    #[serde(rename = "Standard_D4_v2")]
    StandardD4V2,
    #[serde(rename = "Standard_D4_v2_Promo")]
    StandardD4V2Promo,
    #[serde(rename = "Standard_D4_v3")]
    StandardD4V3,
    #[serde(rename = "Standard_D4s_v3")]
    StandardD4sV3,
    #[serde(rename = "Standard_D5_v2")]
    StandardD5V2,
    #[serde(rename = "Standard_D5_v2_Promo")]
    StandardD5V2Promo,
    #[serde(rename = "Standard_D64_v3")]
    StandardD64V3,
    #[serde(rename = "Standard_D64s_v3")]
    StandardD64sV3,
    #[serde(rename = "Standard_D8_v3")]
    StandardD8V3,
    #[serde(rename = "Standard_D8s_v3")]
    StandardD8sV3,
    #[serde(rename = "Standard_DS1")]
    StandardDs1,
    #[serde(rename = "Standard_DS11")]
    StandardDs11,
    #[serde(rename = "Standard_DS11_v2")]
    StandardDs11V2,
    #[serde(rename = "Standard_DS11_v2_Promo")]
    StandardDs11V2Promo,
    #[serde(rename = "Standard_DS12")]
    StandardDs12,
    #[serde(rename = "Standard_DS12_v2")]
    StandardDs12V2,
    #[serde(rename = "Standard_DS12_v2_Promo")]
    StandardDs12V2Promo,
    #[serde(rename = "Standard_DS13")]
    StandardDs13,
    #[serde(rename = "Standard_DS13-2_v2")]
    StandardDs132V2,
    #[serde(rename = "Standard_DS13-4_v2")]
    StandardDs134V2,
    #[serde(rename = "Standard_DS13_v2")]
    StandardDs13V2,
    #[serde(rename = "Standard_DS13_v2_Promo")]
    StandardDs13V2Promo,
    #[serde(rename = "Standard_DS14")]
    StandardDs14,
    #[serde(rename = "Standard_DS14-4_v2")]
    StandardDs144V2,
    #[serde(rename = "Standard_DS14-8_v2")]
    StandardDs148V2,
    #[serde(rename = "Standard_DS14_v2")]
    StandardDs14V2,
    #[serde(rename = "Standard_DS14_v2_Promo")]
    StandardDs14V2Promo,
    #[serde(rename = "Standard_DS15_v2")]
    StandardDs15V2,
    #[serde(rename = "Standard_DS1_v2")]
    StandardDs1V2,
    #[serde(rename = "Standard_DS2")]
    StandardDs2,
    #[serde(rename = "Standard_DS2_v2")]
    StandardDs2V2,
    #[serde(rename = "Standard_DS2_v2_Promo")]
    StandardDs2V2Promo,
    #[serde(rename = "Standard_DS3")]
    StandardDs3,
    #[serde(rename = "Standard_DS3_v2")]
    StandardDs3V2,
    #[serde(rename = "Standard_DS3_v2_Promo")]
    StandardDs3V2Promo,
    #[serde(rename = "Standard_DS4")]
    StandardDs4,
    #[serde(rename = "Standard_DS4_v2")]
    StandardDs4V2,
    #[serde(rename = "Standard_DS4_v2_Promo")]
    StandardDs4V2Promo,
    #[serde(rename = "Standard_DS5_v2")]
    StandardDs5V2,
    #[serde(rename = "Standard_DS5_v2_Promo")]
    StandardDs5V2Promo,
    #[serde(rename = "Standard_E16_v3")]
    StandardE16V3,
    #[serde(rename = "Standard_E16s_v3")]
    StandardE16sV3,
    #[serde(rename = "Standard_E2_v3")]
    StandardE2V3,
    #[serde(rename = "Standard_E2s_v3")]
    StandardE2sV3,
    #[serde(rename = "Standard_E32-16s_v3")]
    StandardE3216sV3,
    #[serde(rename = "Standard_E32-8s_v3")]
    StandardE328sV3,
    #[serde(rename = "Standard_E32_v3")]
    StandardE32V3,
    #[serde(rename = "Standard_E32s_v3")]
    StandardE32sV3,
    #[serde(rename = "Standard_E4_v3")]
    StandardE4V3,
    #[serde(rename = "Standard_E4s_v3")]
    StandardE4sV3,
    #[serde(rename = "Standard_E64-16s_v3")]
    StandardE6416sV3,
    #[serde(rename = "Standard_E64-32s_v3")]
    StandardE6432sV3,
    #[serde(rename = "Standard_E64_v3")]
    StandardE64V3,
    #[serde(rename = "Standard_E64s_v3")]
    StandardE64sV3,
    #[serde(rename = "Standard_E8_v3")]
    StandardE8V3,
    #[serde(rename = "Standard_E8s_v3")]
    StandardE8sV3,
    #[serde(rename = "Standard_F1")]
    StandardF1,
    #[serde(rename = "Standard_F16")]
    StandardF16,
    #[serde(rename = "Standard_F16s")]
    StandardF16s,
    #[serde(rename = "Standard_F16s_v2")]
    StandardF16sV2,
    #[serde(rename = "Standard_F1s")]
    StandardF1s,
    #[serde(rename = "Standard_F2")]
    StandardF2,
    #[serde(rename = "Standard_F2s")]
    StandardF2s,
    #[serde(rename = "Standard_F2s_v2")]
    StandardF2sV2,
    #[serde(rename = "Standard_F32s_v2")]
    StandardF32sV2,
    #[serde(rename = "Standard_F4")]
    StandardF4,
    #[serde(rename = "Standard_F4s")]
    StandardF4s,
    #[serde(rename = "Standard_F4s_v2")]
    StandardF4sV2,
    #[serde(rename = "Standard_F64s_v2")]
    StandardF64sV2,
    #[serde(rename = "Standard_F72s_v2")]
    StandardF72sV2,
    #[serde(rename = "Standard_F8")]
    StandardF8,
    #[serde(rename = "Standard_F8s")]
    StandardF8s,
    #[serde(rename = "Standard_F8s_v2")]
    StandardF8sV2,
    #[serde(rename = "Standard_G1")]
    StandardG1,
    #[serde(rename = "Standard_G2")]
    StandardG2,
    #[serde(rename = "Standard_G3")]
    StandardG3,
    #[serde(rename = "Standard_G4")]
    StandardG4,
    #[serde(rename = "Standard_G5")]
    StandardG5,
    #[serde(rename = "Standard_GS1")]
    StandardGs1,
    #[serde(rename = "Standard_GS2")]
    StandardGs2,
    #[serde(rename = "Standard_GS3")]
    StandardGs3,
    #[serde(rename = "Standard_GS4")]
    StandardGs4,
    #[serde(rename = "Standard_GS4-4")]
    StandardGs44,
    #[serde(rename = "Standard_GS4-8")]
    StandardGs48,
    #[serde(rename = "Standard_GS5")]
    StandardGs5,
    #[serde(rename = "Standard_GS5-16")]
    StandardGs516,
    #[serde(rename = "Standard_GS5-8")]
    StandardGs58,
    #[serde(rename = "Standard_H16")]
    StandardH16,
    #[serde(rename = "Standard_H16m")]
    StandardH16m,
    #[serde(rename = "Standard_H16mr")]
    StandardH16mr,
    #[serde(rename = "Standard_H16r")]
    StandardH16r,
    #[serde(rename = "Standard_H8")]
    StandardH8,
    #[serde(rename = "Standard_H8m")]
    StandardH8m,
    #[serde(rename = "Standard_L16s")]
    StandardL16s,
    #[serde(rename = "Standard_L32s")]
    StandardL32s,
    #[serde(rename = "Standard_L4s")]
    StandardL4s,
    #[serde(rename = "Standard_L8s")]
    StandardL8s,
    #[serde(rename = "Standard_M128-32ms")]
    StandardM12832ms,
    #[serde(rename = "Standard_M128-64ms")]
    StandardM12864ms,
    #[serde(rename = "Standard_M128ms")]
    StandardM128ms,
    #[serde(rename = "Standard_M128s")]
    StandardM128s,
    #[serde(rename = "Standard_M64-16ms")]
    StandardM6416ms,
    #[serde(rename = "Standard_M64-32ms")]
    StandardM6432ms,
    #[serde(rename = "Standard_M64ms")]
    StandardM64ms,
    #[serde(rename = "Standard_M64s")]
    StandardM64s,
    #[serde(rename = "Standard_NC12")]
    StandardNc12,
    #[serde(rename = "Standard_NC12s_v2")]
    StandardNc12sV2,
    #[serde(rename = "Standard_NC12s_v3")]
    StandardNc12sV3,
    #[serde(rename = "Standard_NC24")]
    StandardNc24,
    #[serde(rename = "Standard_NC24r")]
    StandardNc24r,
    #[serde(rename = "Standard_NC24rs_v2")]
    StandardNc24rsV2,
    #[serde(rename = "Standard_NC24rs_v3")]
    StandardNc24rsV3,
    #[serde(rename = "Standard_NC24s_v2")]
    StandardNc24sV2,
    #[serde(rename = "Standard_NC24s_v3")]
    StandardNc24sV3,
    #[serde(rename = "Standard_NC6")]
    StandardNc6,
    #[serde(rename = "Standard_NC6s_v2")]
    StandardNc6sV2,
    #[serde(rename = "Standard_NC6s_v3")]
    StandardNc6sV3,
    #[serde(rename = "Standard_ND12s")]
    StandardNd12s,
    #[serde(rename = "Standard_ND24rs")]
    StandardNd24rs,
    #[serde(rename = "Standard_ND24s")]
    StandardNd24s,
    #[serde(rename = "Standard_ND6s")]
    StandardNd6s,
    #[serde(rename = "Standard_NV12")]
    StandardNv12,
    #[serde(rename = "Standard_NV24")]
    StandardNv24,
    #[serde(rename = "Standard_NV6")]
    StandardNv6,
}
pub type ContainerServiceVnetSubnetId = String;
#[doc = "Profile for Windows VMs in the container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerServiceWindowsProfile {
    #[doc = "The administrator username to use for Windows VMs."]
    #[serde(rename = "adminUsername")]
    pub admin_username: String,
    #[doc = "The administrator password to use for Windows VMs."]
    #[serde(rename = "adminPassword")]
    pub admin_password: String,
}
impl ContainerServiceWindowsProfile {
    pub fn new(admin_username: String, admin_password: String) -> Self {
        Self {
            admin_username,
            admin_password,
        }
    }
}
#[doc = "The credential result response."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CredentialResult {
    #[doc = "The name of the credential."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Base64-encoded Kubernetes configuration file."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
impl CredentialResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The list of credential result response."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct CredentialResults {
    #[doc = "Base64-encoded Kubernetes configuration file."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub kubeconfigs: Vec<CredentialResult>,
}
impl CredentialResults {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Reference to a secret stored in Azure Key Vault."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct KeyVaultSecretRef {
    #[doc = "Key vault identifier."]
    #[serde(rename = "vaultID")]
    pub vault_id: String,
    #[doc = "The secret name."]
    #[serde(rename = "secretName")]
    pub secret_name: String,
    #[doc = "The secret version."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}
impl KeyVaultSecretRef {
    pub fn new(vault_id: String, secret_name: String) -> Self {
        Self {
            vault_id,
            secret_name,
            version: None,
        }
    }
}
#[doc = "Managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedCluster {
    #[serde(flatten)]
    pub resource: Resource,
    #[doc = "Properties of the managed cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagedClusterProperties>,
    #[doc = "Identity for the managed cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedClusterIdentity>,
}
impl ManagedCluster {
    pub fn new(resource: Resource) -> Self {
        Self {
            resource,
            properties: None,
            identity: None,
        }
    }
}
#[doc = "AADProfile specifies attributes for Azure Active Directory integration."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterAadProfile {
    #[doc = "The client AAD application ID."]
    #[serde(rename = "clientAppID")]
    pub client_app_id: String,
    #[doc = "The server AAD application ID."]
    #[serde(rename = "serverAppID")]
    pub server_app_id: String,
    #[doc = "The server AAD application secret."]
    #[serde(rename = "serverAppSecret", default, skip_serializing_if = "Option::is_none")]
    pub server_app_secret: Option<String>,
    #[doc = "The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription."]
    #[serde(rename = "tenantID", default, skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
}
impl ManagedClusterAadProfile {
    pub fn new(client_app_id: String, server_app_id: String) -> Self {
        Self {
            client_app_id,
            server_app_id,
            server_app_secret: None,
            tenant_id: None,
        }
    }
}
#[doc = "Access profile for managed cluster API server."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterApiServerAccessProfile {
    #[doc = "Authorized IP Ranges to kubernetes API server."]
    #[serde(rename = "authorizedIPRanges", default, skip_serializing_if = "Vec::is_empty")]
    pub authorized_ip_ranges: Vec<String>,
    #[doc = "Whether to create the cluster as a private cluster or not."]
    #[serde(rename = "enablePrivateCluster", default, skip_serializing_if = "Option::is_none")]
    pub enable_private_cluster: Option<bool>,
}
impl ManagedClusterApiServerAccessProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Managed cluster Access Profile."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterAccessProfile {
    #[serde(flatten)]
    pub resource: Resource,
    #[doc = "Profile for enabling a user to access a managed cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<AccessProfile>,
}
impl ManagedClusterAccessProfile {
    pub fn new(resource: Resource) -> Self {
        Self {
            resource,
            properties: None,
        }
    }
}
#[doc = "A Kubernetes add-on profile for a managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterAddonProfile {
    #[doc = "Whether the add-on is enabled or not."]
    pub enabled: bool,
    #[doc = "Key-value pairs for configuring an add-on."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<serde_json::Value>,
    #[doc = "Information of user assigned identity used by this add-on."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<serde_json::Value>,
}
impl ManagedClusterAddonProfile {
    pub fn new(enabled: bool) -> Self {
        Self {
            enabled,
            config: None,
            identity: None,
        }
    }
}
#[doc = "Profile for the container service agent pool."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterAgentPoolProfile {
    #[serde(flatten)]
    pub managed_cluster_agent_pool_profile_properties: ManagedClusterAgentPoolProfileProperties,
    #[doc = "Unique name of the agent pool profile in the context of the subscription and resource group."]
    pub name: String,
}
impl ManagedClusterAgentPoolProfile {
    pub fn new(name: String) -> Self {
        Self {
            managed_cluster_agent_pool_profile_properties: ManagedClusterAgentPoolProfileProperties::default(),
            name,
        }
    }
}
#[doc = "Properties for the container service agent pool profile."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterAgentPoolProfileProperties {
    #[doc = "Number of agents (VMs) to host docker containers. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    #[doc = "Size of agent VMs."]
    #[serde(rename = "vmSize", default, skip_serializing_if = "Option::is_none")]
    pub vm_size: Option<ContainerServiceVmSize>,
    #[doc = "OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified."]
    #[serde(rename = "osDiskSizeGB", default, skip_serializing_if = "Option::is_none")]
    pub os_disk_size_gb: Option<ContainerServiceOsDisk>,
    #[doc = "VNet SubnetID specifies the VNet's subnet identifier."]
    #[serde(rename = "vnetSubnetID", default, skip_serializing_if = "Option::is_none")]
    pub vnet_subnet_id: Option<ContainerServiceVnetSubnetId>,
    #[doc = "Maximum number of pods that can run on a node."]
    #[serde(rename = "maxPods", default, skip_serializing_if = "Option::is_none")]
    pub max_pods: Option<i32>,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType", default, skip_serializing_if = "Option::is_none")]
    pub os_type: Option<OsType>,
    #[doc = "Maximum number of nodes for auto-scaling"]
    #[serde(rename = "maxCount", default, skip_serializing_if = "Option::is_none")]
    pub max_count: Option<i32>,
    #[doc = "Minimum number of nodes for auto-scaling"]
    #[serde(rename = "minCount", default, skip_serializing_if = "Option::is_none")]
    pub min_count: Option<i32>,
    #[doc = "Whether to enable auto-scaler"]
    #[serde(rename = "enableAutoScaling", default, skip_serializing_if = "Option::is_none")]
    pub enable_auto_scaling: Option<bool>,
    #[doc = "AgentPoolType represents types of an agent pool."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<AgentPoolType>,
    #[doc = "Version of orchestrator specified when creating the managed cluster."]
    #[serde(rename = "orchestratorVersion", default, skip_serializing_if = "Option::is_none")]
    pub orchestrator_version: Option<String>,
    #[doc = "The current deployment or provisioning state, which only appears in the response."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[doc = "Availability zones for nodes. Must use VirtualMachineScaleSets AgentPoolType."]
    #[serde(rename = "availabilityZones", default, skip_serializing_if = "Vec::is_empty")]
    pub availability_zones: Vec<String>,
    #[doc = "Enable public IP for nodes"]
    #[serde(rename = "enableNodePublicIP", default, skip_serializing_if = "Option::is_none")]
    pub enable_node_public_ip: Option<bool>,
    #[doc = "ScaleSetPriority to be used to specify virtual machine scale set priority. Default to regular."]
    #[serde(rename = "scaleSetPriority", default, skip_serializing_if = "Option::is_none")]
    pub scale_set_priority: Option<ScaleSetPriority>,
    #[doc = "ScaleSetEvictionPolicy to be used to specify eviction policy for low priority virtual machine scale set. Default to Delete."]
    #[serde(rename = "scaleSetEvictionPolicy", default, skip_serializing_if = "Option::is_none")]
    pub scale_set_eviction_policy: Option<ScaleSetEvictionPolicy>,
    #[doc = "Agent pool tags to be persisted on the agent pool virtual machine scale set."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[doc = "Agent pool node labels to be persisted across all nodes in agent pool."]
    #[serde(rename = "nodeLabels", default, skip_serializing_if = "Option::is_none")]
    pub node_labels: Option<serde_json::Value>,
    #[doc = "Taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule."]
    #[serde(rename = "nodeTaints", default, skip_serializing_if = "Vec::is_empty")]
    pub node_taints: Vec<String>,
}
impl ManagedClusterAgentPoolProfileProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Identity for the managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterIdentity {
    #[doc = "The principal id of the system assigned identity which is used by master components."]
    #[serde(rename = "principalId", default, skip_serializing_if = "Option::is_none")]
    pub principal_id: Option<String>,
    #[doc = "The tenant id of the system assigned identity which is used by master components."]
    #[serde(rename = "tenantId", default, skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
    #[doc = "The type of identity used for the managed cluster. Type 'SystemAssigned' will use an implicitly created identity in master components and an auto-created user assigned identity in MC_ resource group in agent nodes. Type 'None' will not use MSI for the managed cluster, service principal will be used instead."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<managed_cluster_identity::Type>,
}
impl ManagedClusterIdentity {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod managed_cluster_identity {
    use super::*;
    #[doc = "The type of identity used for the managed cluster. Type 'SystemAssigned' will use an implicitly created identity in master components and an auto-created user assigned identity in MC_ resource group in agent nodes. Type 'None' will not use MSI for the managed cluster, service principal will be used instead."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        SystemAssigned,
        None,
    }
}
#[doc = "The response from the List Managed Clusters operation."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterListResult {
    #[doc = "The list of managed clusters."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ManagedCluster>,
    #[doc = "The URL to get the next set of managed cluster results."]
    #[serde(rename = "nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl ManagedClusterListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Profile of the managed cluster load balancer."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterLoadBalancerProfile {
    #[doc = "Desired managed outbound IPs for the cluster load balancer."]
    #[serde(rename = "managedOutboundIPs", default, skip_serializing_if = "Option::is_none")]
    pub managed_outbound_i_ps: Option<managed_cluster_load_balancer_profile::ManagedOutboundIPs>,
    #[doc = "Desired outbound IP Prefix resources for the cluster load balancer."]
    #[serde(rename = "outboundIPPrefixes", default, skip_serializing_if = "Option::is_none")]
    pub outbound_ip_prefixes: Option<managed_cluster_load_balancer_profile::OutboundIpPrefixes>,
    #[doc = "Desired outbound IP resources for the cluster load balancer."]
    #[serde(rename = "outboundIPs", default, skip_serializing_if = "Option::is_none")]
    pub outbound_i_ps: Option<managed_cluster_load_balancer_profile::OutboundIPs>,
    #[doc = "The effective outbound IP resources of the cluster load balancer."]
    #[serde(rename = "effectiveOutboundIPs", default, skip_serializing_if = "Vec::is_empty")]
    pub effective_outbound_i_ps: Vec<ResourceReference>,
    #[doc = "Desired number of allocated SNAT ports per VM. Allowed values must be in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports."]
    #[serde(rename = "allocatedOutboundPorts", default, skip_serializing_if = "Option::is_none")]
    pub allocated_outbound_ports: Option<i32>,
    #[doc = "Desired outbound flow idle timeout in minutes. Allowed values must be in the range of 4 to 120 (inclusive). The default value is 30 minutes."]
    #[serde(rename = "idleTimeoutInMinutes", default, skip_serializing_if = "Option::is_none")]
    pub idle_timeout_in_minutes: Option<i32>,
}
impl ManagedClusterLoadBalancerProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
pub mod managed_cluster_load_balancer_profile {
    use super::*;
    #[doc = "Desired managed outbound IPs for the cluster load balancer."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
    pub struct ManagedOutboundIPs {
        #[doc = "Desired number of outbound IP created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1. "]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub count: Option<i32>,
    }
    impl ManagedOutboundIPs {
        pub fn new() -> Self {
            Self::default()
        }
    }
    #[doc = "Desired outbound IP Prefix resources for the cluster load balancer."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
    pub struct OutboundIpPrefixes {
        #[doc = "A list of public IP prefix resources."]
        #[serde(rename = "publicIPPrefixes", default, skip_serializing_if = "Vec::is_empty")]
        pub public_ip_prefixes: Vec<ResourceReference>,
    }
    impl OutboundIpPrefixes {
        pub fn new() -> Self {
            Self::default()
        }
    }
    #[doc = "Desired outbound IP resources for the cluster load balancer."]
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
    pub struct OutboundIPs {
        #[doc = "A list of public IP resources."]
        #[serde(rename = "publicIPs", default, skip_serializing_if = "Vec::is_empty")]
        pub public_i_ps: Vec<ResourceReference>,
    }
    impl OutboundIPs {
        pub fn new() -> Self {
            Self::default()
        }
    }
}
#[doc = "The list of available upgrade versions."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterPoolUpgradeProfile {
    #[doc = "Kubernetes version (major, minor, patch)."]
    #[serde(rename = "kubernetesVersion")]
    pub kubernetes_version: String,
    #[doc = "Pool name."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType")]
    pub os_type: OsType,
    #[doc = "List of orchestrator types and versions available for upgrade."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub upgrades: Vec<serde_json::Value>,
}
impl ManagedClusterPoolUpgradeProfile {
    pub fn new(kubernetes_version: String, os_type: OsType) -> Self {
        Self {
            kubernetes_version,
            name: None,
            os_type,
            upgrades: Vec::new(),
        }
    }
}
#[doc = "Properties of the managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ManagedClusterProperties {
    #[doc = "The current deployment or provisioning state, which only appears in the response."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[doc = "The max number of agent pools for the managed cluster."]
    #[serde(rename = "maxAgentPools", default, skip_serializing_if = "Option::is_none")]
    pub max_agent_pools: Option<i32>,
    #[doc = "Version of Kubernetes specified when creating the managed cluster."]
    #[serde(rename = "kubernetesVersion", default, skip_serializing_if = "Option::is_none")]
    pub kubernetes_version: Option<String>,
    #[doc = "DNS prefix specified when creating the managed cluster."]
    #[serde(rename = "dnsPrefix", default, skip_serializing_if = "Option::is_none")]
    pub dns_prefix: Option<String>,
    #[doc = "FQDN for the master pool."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[doc = "FQDN of private cluster."]
    #[serde(rename = "privateFQDN", default, skip_serializing_if = "Option::is_none")]
    pub private_fqdn: Option<String>,
    #[doc = "Properties of the agent pool."]
    #[serde(rename = "agentPoolProfiles", default, skip_serializing_if = "Vec::is_empty")]
    pub agent_pool_profiles: Vec<ManagedClusterAgentPoolProfile>,
    #[doc = "Profile for Linux VMs in the container service cluster."]
    #[serde(rename = "linuxProfile", default, skip_serializing_if = "Option::is_none")]
    pub linux_profile: Option<ContainerServiceLinuxProfile>,
    #[doc = "Profile for Windows VMs in the container service cluster."]
    #[serde(rename = "windowsProfile", default, skip_serializing_if = "Option::is_none")]
    pub windows_profile: Option<ManagedClusterWindowsProfile>,
    #[doc = "Information about a service principal identity for the cluster to use for manipulating Azure APIs."]
    #[serde(rename = "servicePrincipalProfile", default, skip_serializing_if = "Option::is_none")]
    pub service_principal_profile: Option<ManagedClusterServicePrincipalProfile>,
    #[doc = "Profile of managed cluster add-on."]
    #[serde(rename = "addonProfiles", default, skip_serializing_if = "Option::is_none")]
    pub addon_profiles: Option<serde_json::Value>,
    #[doc = "Name of the resource group containing agent pool nodes."]
    #[serde(rename = "nodeResourceGroup", default, skip_serializing_if = "Option::is_none")]
    pub node_resource_group: Option<String>,
    #[doc = "Whether to enable Kubernetes Role-Based Access Control."]
    #[serde(rename = "enableRBAC", default, skip_serializing_if = "Option::is_none")]
    pub enable_rbac: Option<bool>,
    #[doc = "(DEPRECATING) Whether to enable Kubernetes pod security policy (preview). This feature is set for removal on October 15th, 2020. Learn more at aka.ms/aks/azpodpolicy."]
    #[serde(rename = "enablePodSecurityPolicy", default, skip_serializing_if = "Option::is_none")]
    pub enable_pod_security_policy: Option<bool>,
    #[doc = "Profile of network configuration."]
    #[serde(rename = "networkProfile", default, skip_serializing_if = "Option::is_none")]
    pub network_profile: Option<ContainerServiceNetworkProfile>,
    #[doc = "AADProfile specifies attributes for Azure Active Directory integration."]
    #[serde(rename = "aadProfile", default, skip_serializing_if = "Option::is_none")]
    pub aad_profile: Option<ManagedClusterAadProfile>,
    #[doc = "Access profile for managed cluster API server."]
    #[serde(rename = "apiServerAccessProfile", default, skip_serializing_if = "Option::is_none")]
    pub api_server_access_profile: Option<ManagedClusterApiServerAccessProfile>,
    #[doc = "ResourceId of the disk encryption set to use for enabling encryption at rest."]
    #[serde(rename = "diskEncryptionSetID", default, skip_serializing_if = "Option::is_none")]
    pub disk_encryption_set_id: Option<String>,
    #[doc = "Identities associated with the cluster."]
    #[serde(rename = "identityProfile", default, skip_serializing_if = "Option::is_none")]
    pub identity_profile: Option<serde_json::Value>,
}
impl ManagedClusterProperties {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Information about a service principal identity for the cluster to use for manipulating Azure APIs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterServicePrincipalProfile {
    #[doc = "The ID for the service principal."]
    #[serde(rename = "clientId")]
    pub client_id: String,
    #[doc = "The secret password associated with the service principal in plain text."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
}
impl ManagedClusterServicePrincipalProfile {
    pub fn new(client_id: String) -> Self {
        Self { client_id, secret: None }
    }
}
#[doc = "The list of available upgrades for compute pools."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterUpgradeProfile {
    #[doc = "Id of upgrade profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Name of upgrade profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Type of upgrade profile."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "Control plane and agent pool upgrade profiles."]
    pub properties: ManagedClusterUpgradeProfileProperties,
}
impl ManagedClusterUpgradeProfile {
    pub fn new(properties: ManagedClusterUpgradeProfileProperties) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            properties,
        }
    }
}
#[doc = "Control plane and agent pool upgrade profiles."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterUpgradeProfileProperties {
    #[doc = "The list of available upgrade versions."]
    #[serde(rename = "controlPlaneProfile")]
    pub control_plane_profile: ManagedClusterPoolUpgradeProfile,
    #[doc = "The list of available upgrade versions for agent pools."]
    #[serde(rename = "agentPoolProfiles")]
    pub agent_pool_profiles: Vec<ManagedClusterPoolUpgradeProfile>,
}
impl ManagedClusterUpgradeProfileProperties {
    pub fn new(
        control_plane_profile: ManagedClusterPoolUpgradeProfile,
        agent_pool_profiles: Vec<ManagedClusterPoolUpgradeProfile>,
    ) -> Self {
        Self {
            control_plane_profile,
            agent_pool_profiles,
        }
    }
}
#[doc = "Profile for Windows VMs in the container service cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedClusterWindowsProfile {
    #[doc = "Specifies the name of the administrator account. <br><br> **restriction:** Cannot end in \".\" <br><br> **Disallowed values:** \"administrator\", \"admin\", \"user\", \"user1\", \"test\", \"user2\", \"test1\", \"user3\", \"admin1\", \"1\", \"123\", \"a\", \"actuser\", \"adm\", \"admin2\", \"aspnet\", \"backup\", \"console\", \"david\", \"guest\", \"john\", \"owner\", \"root\", \"server\", \"sql\", \"support\", \"support_388945a0\", \"sys\", \"test2\", \"test3\", \"user4\", \"user5\". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters"]
    #[serde(rename = "adminUsername")]
    pub admin_username: String,
    #[doc = "Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\\W_]) <br><br> **Disallowed values:** \"abc@123\", \"P@$$w0rd\", \"P@ssw0rd\", \"P@ssword123\", \"Pa$$word\", \"pass@word1\", \"Password!\", \"Password1\", \"Password22\", \"iloveyou!\""]
    #[serde(rename = "adminPassword", default, skip_serializing_if = "Option::is_none")]
    pub admin_password: Option<String>,
}
impl ManagedClusterWindowsProfile {
    pub fn new(admin_username: String) -> Self {
        Self {
            admin_username,
            admin_password: None,
        }
    }
}
#[doc = "Represents the OpenShift networking configuration"]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct NetworkProfile {
    #[doc = "CIDR for the OpenShift Vnet."]
    #[serde(rename = "vnetCidr", default, skip_serializing_if = "Option::is_none")]
    pub vnet_cidr: Option<String>,
    #[doc = "CIDR of the Vnet to peer."]
    #[serde(rename = "peerVnetId", default, skip_serializing_if = "Option::is_none")]
    pub peer_vnet_id: Option<String>,
    #[doc = "ID of the Vnet created for OSA cluster."]
    #[serde(rename = "vnetId", default, skip_serializing_if = "Option::is_none")]
    pub vnet_id: Option<String>,
}
impl NetworkProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum OsType {
    Linux,
    Windows,
}
impl Default for OsType {
    fn default() -> Self {
        Self::Linux
    }
}
#[doc = "OpenShiftAgentPoolProfileRole represents the role of the AgentPoolProfile."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum OpenShiftAgentPoolProfileRole {
    #[serde(rename = "compute")]
    Compute,
    #[serde(rename = "infra")]
    Infra,
}
#[doc = "Size of OpenShift VMs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum OpenShiftContainerServiceVmSize {
    #[serde(rename = "Standard_D2s_v3")]
    StandardD2sV3,
    #[serde(rename = "Standard_D4s_v3")]
    StandardD4sV3,
    #[serde(rename = "Standard_D8s_v3")]
    StandardD8sV3,
    #[serde(rename = "Standard_D16s_v3")]
    StandardD16sV3,
    #[serde(rename = "Standard_D32s_v3")]
    StandardD32sV3,
    #[serde(rename = "Standard_D64s_v3")]
    StandardD64sV3,
    #[serde(rename = "Standard_DS4_v2")]
    StandardDs4V2,
    #[serde(rename = "Standard_DS5_v2")]
    StandardDs5V2,
    #[serde(rename = "Standard_F8s_v2")]
    StandardF8sV2,
    #[serde(rename = "Standard_F16s_v2")]
    StandardF16sV2,
    #[serde(rename = "Standard_F32s_v2")]
    StandardF32sV2,
    #[serde(rename = "Standard_F64s_v2")]
    StandardF64sV2,
    #[serde(rename = "Standard_F72s_v2")]
    StandardF72sV2,
    #[serde(rename = "Standard_F8s")]
    StandardF8s,
    #[serde(rename = "Standard_F16s")]
    StandardF16s,
    #[serde(rename = "Standard_E4s_v3")]
    StandardE4sV3,
    #[serde(rename = "Standard_E8s_v3")]
    StandardE8sV3,
    #[serde(rename = "Standard_E16s_v3")]
    StandardE16sV3,
    #[serde(rename = "Standard_E20s_v3")]
    StandardE20sV3,
    #[serde(rename = "Standard_E32s_v3")]
    StandardE32sV3,
    #[serde(rename = "Standard_E64s_v3")]
    StandardE64sV3,
    #[serde(rename = "Standard_GS2")]
    StandardGs2,
    #[serde(rename = "Standard_GS3")]
    StandardGs3,
    #[serde(rename = "Standard_GS4")]
    StandardGs4,
    #[serde(rename = "Standard_GS5")]
    StandardGs5,
    #[serde(rename = "Standard_DS12_v2")]
    StandardDs12V2,
    #[serde(rename = "Standard_DS13_v2")]
    StandardDs13V2,
    #[serde(rename = "Standard_DS14_v2")]
    StandardDs14V2,
    #[serde(rename = "Standard_DS15_v2")]
    StandardDs15V2,
    #[serde(rename = "Standard_L4s")]
    StandardL4s,
    #[serde(rename = "Standard_L8s")]
    StandardL8s,
    #[serde(rename = "Standard_L16s")]
    StandardL16s,
    #[serde(rename = "Standard_L32s")]
    StandardL32s,
}
#[doc = "OpenShift Managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OpenShiftManagedCluster {
    #[serde(flatten)]
    pub resource: Resource,
    #[doc = "Used for establishing the purchase context of any 3rd Party artifact through MarketPlace."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plan: Option<PurchasePlan>,
    #[doc = "Properties of the OpenShift managed cluster."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<OpenShiftManagedClusterProperties>,
}
impl OpenShiftManagedCluster {
    pub fn new(resource: Resource) -> Self {
        Self {
            resource,
            plan: None,
            properties: None,
        }
    }
}
#[doc = "Defines the Identity provider for MS AAD."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OpenShiftManagedClusterAadIdentityProvider {
    #[serde(flatten)]
    pub open_shift_managed_cluster_base_identity_provider: OpenShiftManagedClusterBaseIdentityProvider,
    #[doc = "The clientId password associated with the provider."]
    #[serde(rename = "clientId", default, skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    #[doc = "The secret password associated with the provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    #[doc = "The tenantId associated with the provider."]
    #[serde(rename = "tenantId", default, skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<String>,
    #[doc = "The groupId to be granted cluster admin role."]
    #[serde(rename = "customerAdminGroupId", default, skip_serializing_if = "Option::is_none")]
    pub customer_admin_group_id: Option<String>,
}
impl OpenShiftManagedClusterAadIdentityProvider {
    pub fn new(open_shift_managed_cluster_base_identity_provider: OpenShiftManagedClusterBaseIdentityProvider) -> Self {
        Self {
            open_shift_managed_cluster_base_identity_provider,
            client_id: None,
            secret: None,
            tenant_id: None,
            customer_admin_group_id: None,
        }
    }
}
#[doc = "Defines the configuration of the OpenShift cluster VMs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OpenShiftManagedClusterAgentPoolProfile {
    #[doc = "Unique name of the pool profile in the context of the subscription and resource group."]
    pub name: String,
    #[doc = "Number of agents (VMs) to host docker containers."]
    pub count: i32,
    #[doc = "Size of OpenShift VMs."]
    #[serde(rename = "vmSize")]
    pub vm_size: OpenShiftContainerServiceVmSize,
    #[doc = "Subnet CIDR for the peering."]
    #[serde(rename = "subnetCidr", default, skip_serializing_if = "Option::is_none")]
    pub subnet_cidr: Option<String>,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType", default, skip_serializing_if = "Option::is_none")]
    pub os_type: Option<OsType>,
    #[doc = "OpenShiftAgentPoolProfileRole represents the role of the AgentPoolProfile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<OpenShiftAgentPoolProfileRole>,
}
impl OpenShiftManagedClusterAgentPoolProfile {
    pub fn new(name: String, count: i32, vm_size: OpenShiftContainerServiceVmSize) -> Self {
        Self {
            name,
            count,
            vm_size,
            subnet_cidr: None,
            os_type: None,
            role: None,
        }
    }
}
#[doc = "Defines all possible authentication profiles for the OpenShift cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OpenShiftManagedClusterAuthProfile {
    #[doc = "Type of authentication profile to use."]
    #[serde(rename = "identityProviders", default, skip_serializing_if = "Vec::is_empty")]
    pub identity_providers: Vec<OpenShiftManagedClusterIdentityProvider>,
}
impl OpenShiftManagedClusterAuthProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Structure for any Identity provider."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OpenShiftManagedClusterBaseIdentityProvider {
    #[doc = "The kind of the provider."]
    pub kind: String,
}
impl OpenShiftManagedClusterBaseIdentityProvider {
    pub fn new(kind: String) -> Self {
        Self { kind }
    }
}
#[doc = "Defines the configuration of the identity providers to be used in the OpenShift cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OpenShiftManagedClusterIdentityProvider {
    #[doc = "Name of the provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Structure for any Identity provider."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<OpenShiftManagedClusterBaseIdentityProvider>,
}
impl OpenShiftManagedClusterIdentityProvider {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The response from the List OpenShift Managed Clusters operation."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OpenShiftManagedClusterListResult {
    #[doc = "The list of OpenShift managed clusters."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<OpenShiftManagedCluster>,
    #[doc = "The URL to get the next set of OpenShift managed cluster results."]
    #[serde(rename = "nextLink", default, skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
impl OpenShiftManagedClusterListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "OpenShiftManagedClusterMaterPoolProfile contains configuration for OpenShift master VMs."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OpenShiftManagedClusterMasterPoolProfile {
    #[doc = "Unique name of the master pool profile in the context of the subscription and resource group."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Number of masters (VMs) to host docker containers. The default value is 3."]
    pub count: i32,
    #[doc = "Size of OpenShift VMs."]
    #[serde(rename = "vmSize")]
    pub vm_size: OpenShiftContainerServiceVmSize,
    #[doc = "Subnet CIDR for the peering."]
    #[serde(rename = "subnetCidr", default, skip_serializing_if = "Option::is_none")]
    pub subnet_cidr: Option<String>,
    #[doc = "OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux."]
    #[serde(rename = "osType", default, skip_serializing_if = "Option::is_none")]
    pub os_type: Option<OsType>,
}
impl OpenShiftManagedClusterMasterPoolProfile {
    pub fn new(count: i32, vm_size: OpenShiftContainerServiceVmSize) -> Self {
        Self {
            name: None,
            count,
            vm_size,
            subnet_cidr: None,
            os_type: None,
        }
    }
}
#[doc = "Properties of the OpenShift managed cluster."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OpenShiftManagedClusterProperties {
    #[doc = "The current deployment or provisioning state, which only appears in the response."]
    #[serde(rename = "provisioningState", default, skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
    #[doc = "Version of OpenShift specified when creating the cluster."]
    #[serde(rename = "openShiftVersion")]
    pub open_shift_version: String,
    #[doc = "Version of OpenShift specified when creating the cluster."]
    #[serde(rename = "clusterVersion", default, skip_serializing_if = "Option::is_none")]
    pub cluster_version: Option<String>,
    #[doc = "Service generated FQDN for OpenShift API server."]
    #[serde(rename = "publicHostname", default, skip_serializing_if = "Option::is_none")]
    pub public_hostname: Option<String>,
    #[doc = "Service generated FQDN for OpenShift API server loadbalancer internal hostname."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[doc = "Represents the OpenShift networking configuration"]
    #[serde(rename = "networkProfile", default, skip_serializing_if = "Option::is_none")]
    pub network_profile: Option<NetworkProfile>,
    #[doc = "Configuration for OpenShift router(s)."]
    #[serde(rename = "routerProfiles", default, skip_serializing_if = "Vec::is_empty")]
    pub router_profiles: Vec<OpenShiftRouterProfile>,
    #[doc = "OpenShiftManagedClusterMaterPoolProfile contains configuration for OpenShift master VMs."]
    #[serde(rename = "masterPoolProfile", default, skip_serializing_if = "Option::is_none")]
    pub master_pool_profile: Option<OpenShiftManagedClusterMasterPoolProfile>,
    #[doc = "Configuration of OpenShift cluster VMs."]
    #[serde(rename = "agentPoolProfiles", default, skip_serializing_if = "Vec::is_empty")]
    pub agent_pool_profiles: Vec<OpenShiftManagedClusterAgentPoolProfile>,
    #[doc = "Defines all possible authentication profiles for the OpenShift cluster."]
    #[serde(rename = "authProfile", default, skip_serializing_if = "Option::is_none")]
    pub auth_profile: Option<OpenShiftManagedClusterAuthProfile>,
}
impl OpenShiftManagedClusterProperties {
    pub fn new(open_shift_version: String) -> Self {
        Self {
            provisioning_state: None,
            open_shift_version,
            cluster_version: None,
            public_hostname: None,
            fqdn: None,
            network_profile: None,
            router_profiles: Vec::new(),
            master_pool_profile: None,
            agent_pool_profiles: Vec::new(),
            auth_profile: None,
        }
    }
}
#[doc = "Represents an OpenShift router"]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OpenShiftRouterProfile {
    #[doc = "Name of the router profile."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "DNS subdomain for OpenShift router."]
    #[serde(rename = "publicSubdomain", default, skip_serializing_if = "Option::is_none")]
    pub public_subdomain: Option<String>,
    #[doc = "Auto-allocated FQDN for the OpenShift router."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
}
impl OpenShiftRouterProfile {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The List Compute Operation operation response."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationListResult {
    #[doc = "The list of compute operations"]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<OperationValue>,
}
impl OperationListResult {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Describes the properties of a Compute Operation value."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationValue {
    #[doc = "The origin of the compute operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[doc = "The name of the compute operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Describes the properties of a Compute Operation Value Display."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display: Option<OperationValueDisplay>,
}
impl OperationValue {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Describes the properties of a Compute Operation Value Display."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct OperationValueDisplay {
    #[doc = "The display name of the compute operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    #[doc = "The display name of the resource the operation applies to."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    #[doc = "The description of the operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[doc = "The resource provider for the operation."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
}
impl OperationValueDisplay {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Contains information about orchestrator."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrchestratorProfile {
    #[doc = "Orchestrator type."]
    #[serde(rename = "orchestratorType", default, skip_serializing_if = "Option::is_none")]
    pub orchestrator_type: Option<String>,
    #[doc = "Orchestrator version (major, minor, patch)."]
    #[serde(rename = "orchestratorVersion")]
    pub orchestrator_version: String,
    #[doc = "Whether Kubernetes version is currently in preview."]
    #[serde(rename = "isPreview", default, skip_serializing_if = "Option::is_none")]
    pub is_preview: Option<bool>,
}
impl OrchestratorProfile {
    pub fn new(orchestrator_version: String) -> Self {
        Self {
            orchestrator_type: None,
            orchestrator_version,
            is_preview: None,
        }
    }
}
#[doc = "The profile of an orchestrator and its available versions."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrchestratorVersionProfile {
    #[doc = "Orchestrator type."]
    #[serde(rename = "orchestratorType")]
    pub orchestrator_type: String,
    #[doc = "Orchestrator version (major, minor, patch)."]
    #[serde(rename = "orchestratorVersion")]
    pub orchestrator_version: String,
    #[doc = "Installed by default if version is not specified."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<bool>,
    #[doc = "Whether Kubernetes version is currently in preview."]
    #[serde(rename = "isPreview", default, skip_serializing_if = "Option::is_none")]
    pub is_preview: Option<bool>,
    #[doc = "The list of available upgrade versions."]
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub upgrades: Vec<OrchestratorProfile>,
}
impl OrchestratorVersionProfile {
    pub fn new(orchestrator_type: String, orchestrator_version: String) -> Self {
        Self {
            orchestrator_type,
            orchestrator_version,
            default: None,
            is_preview: None,
            upgrades: Vec::new(),
        }
    }
}
#[doc = "The list of versions for supported orchestrators."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrchestratorVersionProfileListResult {
    #[doc = "Id of the orchestrator version profile list result."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Name of the orchestrator version profile list result."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Type of the orchestrator version profile list result."]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "The properties of an orchestrator version profile."]
    pub properties: OrchestratorVersionProfileProperties,
}
impl OrchestratorVersionProfileListResult {
    pub fn new(properties: OrchestratorVersionProfileProperties) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            properties,
        }
    }
}
#[doc = "The properties of an orchestrator version profile."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OrchestratorVersionProfileProperties {
    #[doc = "List of orchestrator version profiles."]
    pub orchestrators: Vec<OrchestratorVersionProfile>,
}
impl OrchestratorVersionProfileProperties {
    pub fn new(orchestrators: Vec<OrchestratorVersionProfile>) -> Self {
        Self { orchestrators }
    }
}
#[doc = "Used for establishing the purchase context of any 3rd Party artifact through MarketPlace."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct PurchasePlan {
    #[doc = "The plan ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub product: Option<String>,
    #[doc = "The promotion code."]
    #[serde(rename = "promotionCode", default, skip_serializing_if = "Option::is_none")]
    pub promotion_code: Option<String>,
    #[doc = "The plan ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub publisher: Option<String>,
}
impl PurchasePlan {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "The Resource model definition."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Resource {
    #[doc = "Resource Id"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "Resource name"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Resource type"]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[doc = "Resource location"]
    pub location: String,
    #[doc = "Resource tags"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
impl Resource {
    pub fn new(location: String) -> Self {
        Self {
            id: None,
            name: None,
            type_: None,
            location,
            tags: None,
        }
    }
}
#[doc = "A reference to an Azure resource."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct ResourceReference {
    #[doc = "The fully qualified Azure resource id."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
impl ResourceReference {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "ScaleSetEvictionPolicy to be used to specify eviction policy for low priority virtual machine scale set. Default to Delete."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ScaleSetEvictionPolicy {
    Delete,
    Deallocate,
}
impl Default for ScaleSetEvictionPolicy {
    fn default() -> Self {
        Self::Delete
    }
}
#[doc = "ScaleSetPriority to be used to specify virtual machine scale set priority. Default to regular."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ScaleSetPriority {
    Low,
    Regular,
}
impl Default for ScaleSetPriority {
    fn default() -> Self {
        Self::Regular
    }
}
#[doc = "Reference to another subresource."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct SubResource {
    #[doc = "Resource ID."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[doc = "The name of the resource that is unique within a resource group. This name can be used to access the resource."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[doc = "Resource type"]
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
impl SubResource {
    pub fn new() -> Self {
        Self::default()
    }
}
#[doc = "Tags object for patch operations."]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct TagsObject {
    #[doc = "Resource tags."]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
impl TagsObject {
    pub fn new() -> Self {
        Self::default()
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub struct UserAssignedIdentity {
    #[doc = "The resource id of the user assigned identity."]
    #[serde(rename = "resourceId", default, skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[doc = "The client id of the user assigned identity."]
    #[serde(rename = "clientId", default, skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    #[doc = "The object id of the user assigned identity."]
    #[serde(rename = "objectId", default, skip_serializing_if = "Option::is_none")]
    pub object_id: Option<String>,
}
impl UserAssignedIdentity {
    pub fn new() -> Self {
        Self::default()
    }
}
