#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayOnDemandProbe {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<ApplicationGatewayProtocol>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<i32>,
    #[serde(rename = "pickHostNameFromBackendHttpSettings", skip_serializing_if = "Option::is_none")]
    pub pick_host_name_from_backend_http_settings: Option<bool>,
    #[serde(rename = "match", skip_serializing_if = "Option::is_none")]
    pub match_: Option<ApplicationGatewayProbeHealthResponseMatch>,
    #[serde(rename = "backendAddressPool", skip_serializing_if = "Option::is_none")]
    pub backend_address_pool: Option<SubResource>,
    #[serde(rename = "backendHttpSettings", skip_serializing_if = "Option::is_none")]
    pub backend_http_settings: Option<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendHealthOnDemand {
    #[serde(rename = "backendAddressPool", skip_serializing_if = "Option::is_none")]
    pub backend_address_pool: Option<ApplicationGatewayBackendAddressPool>,
    #[serde(rename = "backendHealthHttpSettings", skip_serializing_if = "Option::is_none")]
    pub backend_health_http_settings: Option<ApplicationGatewayBackendHealthHttpSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendHealth {
    #[serde(rename = "backendAddressPools", skip_serializing_if = "Vec::is_empty")]
    pub backend_address_pools: Vec<ApplicationGatewayBackendHealthPool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendHealthPool {
    #[serde(rename = "backendAddressPool", skip_serializing_if = "Option::is_none")]
    pub backend_address_pool: Option<ApplicationGatewayBackendAddressPool>,
    #[serde(rename = "backendHttpSettingsCollection", skip_serializing_if = "Vec::is_empty")]
    pub backend_http_settings_collection: Vec<ApplicationGatewayBackendHealthHttpSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendHealthHttpSettings {
    #[serde(rename = "backendHttpSettings", skip_serializing_if = "Option::is_none")]
    pub backend_http_settings: Option<ApplicationGatewayBackendHttpSettings>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub servers: Vec<ApplicationGatewayBackendHealthServer>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendHealthServer {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(rename = "ipConfiguration", skip_serializing_if = "Option::is_none")]
    pub ip_configuration: Option<NetworkInterfaceIpConfiguration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub health: Option<application_gateway_backend_health_server::Health>,
    #[serde(rename = "healthProbeLog", skip_serializing_if = "Option::is_none")]
    pub health_probe_log: Option<String>,
}
pub mod application_gateway_backend_health_server {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Health {
        Unknown,
        Up,
        Down,
        Partial,
        Draining,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewaySku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<application_gateway_sku::Name>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<application_gateway_sku::Tier>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capacity: Option<i32>,
}
pub mod application_gateway_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        #[serde(rename = "Standard_Small")]
        StandardSmall,
        #[serde(rename = "Standard_Medium")]
        StandardMedium,
        #[serde(rename = "Standard_Large")]
        StandardLarge,
        #[serde(rename = "WAF_Medium")]
        WafMedium,
        #[serde(rename = "WAF_Large")]
        WafLarge,
        #[serde(rename = "Standard_v2")]
        StandardV2,
        #[serde(rename = "WAF_v2")]
        WafV2,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Standard,
        #[serde(rename = "WAF")]
        Waf,
        #[serde(rename = "Standard_v2")]
        StandardV2,
        #[serde(rename = "WAF_v2")]
        WafV2,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewaySslPolicy {
    #[serde(rename = "disabledSslProtocols", skip_serializing_if = "Vec::is_empty")]
    pub disabled_ssl_protocols: Vec<ProtocolsEnum>,
    #[serde(rename = "policyType", skip_serializing_if = "Option::is_none")]
    pub policy_type: Option<application_gateway_ssl_policy::PolicyType>,
    #[serde(rename = "policyName", skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<PolicyNameEnum>,
    #[serde(rename = "cipherSuites", skip_serializing_if = "Vec::is_empty")]
    pub cipher_suites: Vec<CipherSuitesEnum>,
    #[serde(rename = "minProtocolVersion", skip_serializing_if = "Option::is_none")]
    pub min_protocol_version: Option<ProtocolsEnum>,
}
pub mod application_gateway_ssl_policy {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PolicyType {
        Predefined,
        Custom,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayClientAuthConfiguration {
    #[serde(rename = "verifyClientCertIssuerDN", skip_serializing_if = "Option::is_none")]
    pub verify_client_cert_issuer_dn: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayIpConfigurationPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayAuthenticationCertificatePropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayAuthenticationCertificate {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayAuthenticationCertificatePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayTrustedRootCertificatePropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    #[serde(rename = "keyVaultSecretId", skip_serializing_if = "Option::is_none")]
    pub key_vault_secret_id: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayTrustedRootCertificate {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayTrustedRootCertificatePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayTrustedClientCertificatePropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayTrustedClientCertificate {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayTrustedClientCertificatePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewaySslCertificatePropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    #[serde(rename = "publicCertData", skip_serializing)]
    pub public_cert_data: Option<String>,
    #[serde(rename = "keyVaultSecretId", skip_serializing_if = "Option::is_none")]
    pub key_vault_secret_id: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewaySslCertificate {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewaySslCertificatePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFrontendIpConfigurationPropertiesFormat {
    #[serde(rename = "privateIPAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<SubResource>,
    #[serde(rename = "publicIPAddress", skip_serializing_if = "Option::is_none")]
    pub public_ip_address: Option<SubResource>,
    #[serde(rename = "privateLinkConfiguration", skip_serializing_if = "Option::is_none")]
    pub private_link_configuration: Option<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFrontendIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayFrontendIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFrontendPortPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFrontendPort {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayFrontendPortPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendAddress {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[serde(rename = "ipAddress", skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendAddressPoolPropertiesFormat {
    #[serde(rename = "backendIPConfigurations", skip_serializing)]
    pub backend_ip_configurations: Vec<NetworkInterfaceIpConfiguration>,
    #[serde(rename = "backendAddresses", skip_serializing_if = "Vec::is_empty")]
    pub backend_addresses: Vec<ApplicationGatewayBackendAddress>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendAddressPool {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayBackendAddressPoolPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendHttpSettingsPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<ApplicationGatewayProtocol>,
    #[serde(rename = "cookieBasedAffinity", skip_serializing_if = "Option::is_none")]
    pub cookie_based_affinity: Option<application_gateway_backend_http_settings_properties_format::CookieBasedAffinity>,
    #[serde(rename = "requestTimeout", skip_serializing_if = "Option::is_none")]
    pub request_timeout: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub probe: Option<SubResource>,
    #[serde(rename = "authenticationCertificates", skip_serializing_if = "Vec::is_empty")]
    pub authentication_certificates: Vec<SubResource>,
    #[serde(rename = "trustedRootCertificates", skip_serializing_if = "Vec::is_empty")]
    pub trusted_root_certificates: Vec<SubResource>,
    #[serde(rename = "connectionDraining", skip_serializing_if = "Option::is_none")]
    pub connection_draining: Option<ApplicationGatewayConnectionDraining>,
    #[serde(rename = "hostName", skip_serializing_if = "Option::is_none")]
    pub host_name: Option<String>,
    #[serde(rename = "pickHostNameFromBackendAddress", skip_serializing_if = "Option::is_none")]
    pub pick_host_name_from_backend_address: Option<bool>,
    #[serde(rename = "affinityCookieName", skip_serializing_if = "Option::is_none")]
    pub affinity_cookie_name: Option<String>,
    #[serde(rename = "probeEnabled", skip_serializing_if = "Option::is_none")]
    pub probe_enabled: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod application_gateway_backend_http_settings_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum CookieBasedAffinity {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayBackendHttpSettings {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayBackendHttpSettingsPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewaySslProfilePropertiesFormat {
    #[serde(rename = "trustedClientCertificates", skip_serializing_if = "Vec::is_empty")]
    pub trusted_client_certificates: Vec<SubResource>,
    #[serde(rename = "sslPolicy", skip_serializing_if = "Option::is_none")]
    pub ssl_policy: Option<ApplicationGatewaySslPolicy>,
    #[serde(rename = "clientAuthConfiguration", skip_serializing_if = "Option::is_none")]
    pub client_auth_configuration: Option<ApplicationGatewayClientAuthConfiguration>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewaySslProfile {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewaySslProfilePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayHttpListenerPropertiesFormat {
    #[serde(rename = "frontendIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub frontend_ip_configuration: Option<SubResource>,
    #[serde(rename = "frontendPort", skip_serializing_if = "Option::is_none")]
    pub frontend_port: Option<SubResource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<ApplicationGatewayProtocol>,
    #[serde(rename = "hostName", skip_serializing_if = "Option::is_none")]
    pub host_name: Option<String>,
    #[serde(rename = "sslCertificate", skip_serializing_if = "Option::is_none")]
    pub ssl_certificate: Option<SubResource>,
    #[serde(rename = "sslProfile", skip_serializing_if = "Option::is_none")]
    pub ssl_profile: Option<SubResource>,
    #[serde(rename = "requireServerNameIndication", skip_serializing_if = "Option::is_none")]
    pub require_server_name_indication: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "customErrorConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub custom_error_configurations: Vec<ApplicationGatewayCustomError>,
    #[serde(rename = "firewallPolicy", skip_serializing_if = "Option::is_none")]
    pub firewall_policy: Option<SubResource>,
    #[serde(rename = "hostNames", skip_serializing_if = "Vec::is_empty")]
    pub host_names: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayHttpListener {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayHttpListenerPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPathRulePropertiesFormat {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub paths: Vec<String>,
    #[serde(rename = "backendAddressPool", skip_serializing_if = "Option::is_none")]
    pub backend_address_pool: Option<SubResource>,
    #[serde(rename = "backendHttpSettings", skip_serializing_if = "Option::is_none")]
    pub backend_http_settings: Option<SubResource>,
    #[serde(rename = "redirectConfiguration", skip_serializing_if = "Option::is_none")]
    pub redirect_configuration: Option<SubResource>,
    #[serde(rename = "rewriteRuleSet", skip_serializing_if = "Option::is_none")]
    pub rewrite_rule_set: Option<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "firewallPolicy", skip_serializing_if = "Option::is_none")]
    pub firewall_policy: Option<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPathRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayPathRulePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayProbePropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<ApplicationGatewayProtocol>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interval: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<i32>,
    #[serde(rename = "unhealthyThreshold", skip_serializing_if = "Option::is_none")]
    pub unhealthy_threshold: Option<i32>,
    #[serde(rename = "pickHostNameFromBackendHttpSettings", skip_serializing_if = "Option::is_none")]
    pub pick_host_name_from_backend_http_settings: Option<bool>,
    #[serde(rename = "minServers", skip_serializing_if = "Option::is_none")]
    pub min_servers: Option<i32>,
    #[serde(rename = "match", skip_serializing_if = "Option::is_none")]
    pub match_: Option<ApplicationGatewayProbeHealthResponseMatch>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayProbeHealthResponseMatch {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[serde(rename = "statusCodes", skip_serializing_if = "Vec::is_empty")]
    pub status_codes: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayProbe {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayProbePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRequestRoutingRulePropertiesFormat {
    #[serde(rename = "ruleType", skip_serializing_if = "Option::is_none")]
    pub rule_type: Option<application_gateway_request_routing_rule_properties_format::RuleType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    #[serde(rename = "backendAddressPool", skip_serializing_if = "Option::is_none")]
    pub backend_address_pool: Option<SubResource>,
    #[serde(rename = "backendHttpSettings", skip_serializing_if = "Option::is_none")]
    pub backend_http_settings: Option<SubResource>,
    #[serde(rename = "httpListener", skip_serializing_if = "Option::is_none")]
    pub http_listener: Option<SubResource>,
    #[serde(rename = "urlPathMap", skip_serializing_if = "Option::is_none")]
    pub url_path_map: Option<SubResource>,
    #[serde(rename = "rewriteRuleSet", skip_serializing_if = "Option::is_none")]
    pub rewrite_rule_set: Option<SubResource>,
    #[serde(rename = "redirectConfiguration", skip_serializing_if = "Option::is_none")]
    pub redirect_configuration: Option<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod application_gateway_request_routing_rule_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RuleType {
        Basic,
        PathBasedRouting,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRequestRoutingRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayRequestRoutingRulePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRewriteRuleSet {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayRewriteRuleSetPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRewriteRuleSetPropertiesFormat {
    #[serde(rename = "rewriteRules", skip_serializing_if = "Vec::is_empty")]
    pub rewrite_rules: Vec<ApplicationGatewayRewriteRule>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRewriteRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "ruleSequence", skip_serializing_if = "Option::is_none")]
    pub rule_sequence: Option<i64>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub conditions: Vec<ApplicationGatewayRewriteRuleCondition>,
    #[serde(rename = "actionSet", skip_serializing_if = "Option::is_none")]
    pub action_set: Option<ApplicationGatewayRewriteRuleActionSet>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRewriteRuleCondition {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variable: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    #[serde(rename = "ignoreCase", skip_serializing_if = "Option::is_none")]
    pub ignore_case: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub negate: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRewriteRuleActionSet {
    #[serde(rename = "requestHeaderConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub request_header_configurations: Vec<ApplicationGatewayHeaderConfiguration>,
    #[serde(rename = "responseHeaderConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub response_header_configurations: Vec<ApplicationGatewayHeaderConfiguration>,
    #[serde(rename = "urlConfiguration", skip_serializing_if = "Option::is_none")]
    pub url_configuration: Option<ApplicationGatewayUrlConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayHeaderConfiguration {
    #[serde(rename = "headerName", skip_serializing_if = "Option::is_none")]
    pub header_name: Option<String>,
    #[serde(rename = "headerValue", skip_serializing_if = "Option::is_none")]
    pub header_value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayUrlConfiguration {
    #[serde(rename = "modifiedPath", skip_serializing_if = "Option::is_none")]
    pub modified_path: Option<String>,
    #[serde(rename = "modifiedQueryString", skip_serializing_if = "Option::is_none")]
    pub modified_query_string: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reroute: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRedirectConfigurationPropertiesFormat {
    #[serde(rename = "redirectType", skip_serializing_if = "Option::is_none")]
    pub redirect_type: Option<RedirectTypeEnum>,
    #[serde(rename = "targetListener", skip_serializing_if = "Option::is_none")]
    pub target_listener: Option<SubResource>,
    #[serde(rename = "targetUrl", skip_serializing_if = "Option::is_none")]
    pub target_url: Option<String>,
    #[serde(rename = "includePath", skip_serializing_if = "Option::is_none")]
    pub include_path: Option<bool>,
    #[serde(rename = "includeQueryString", skip_serializing_if = "Option::is_none")]
    pub include_query_string: Option<bool>,
    #[serde(rename = "requestRoutingRules", skip_serializing_if = "Vec::is_empty")]
    pub request_routing_rules: Vec<SubResource>,
    #[serde(rename = "urlPathMaps", skip_serializing_if = "Vec::is_empty")]
    pub url_path_maps: Vec<SubResource>,
    #[serde(rename = "pathRules", skip_serializing_if = "Vec::is_empty")]
    pub path_rules: Vec<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayRedirectConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayRedirectConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateLinkConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayPrivateLinkConfigurationProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateLinkConfigurationProperties {
    #[serde(rename = "ipConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub ip_configurations: Vec<ApplicationGatewayPrivateLinkIpConfiguration>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateLinkIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayPrivateLinkIpConfigurationProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateLinkIpConfigurationProperties {
    #[serde(rename = "privateIPAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<SubResource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateLinkResource {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayPrivateLinkResourceProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateLinkResourceProperties {
    #[serde(rename = "groupId", skip_serializing)]
    pub group_id: Option<String>,
    #[serde(rename = "requiredMembers", skip_serializing)]
    pub required_members: Vec<String>,
    #[serde(rename = "requiredZoneNames", skip_serializing_if = "Vec::is_empty")]
    pub required_zone_names: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateLinkResourceListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ApplicationGatewayPrivateLinkResource>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateEndpointConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayPrivateEndpointConnectionProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateEndpointConnectionProperties {
    #[serde(rename = "privateEndpoint", skip_serializing_if = "Option::is_none")]
    pub private_endpoint: Option<PrivateEndpoint>,
    #[serde(rename = "privateLinkServiceConnectionState", skip_serializing_if = "Option::is_none")]
    pub private_link_service_connection_state: Option<PrivateLinkServiceConnectionState>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "linkIdentifier", skip_serializing)]
    pub link_identifier: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPrivateEndpointConnectionListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ApplicationGatewayPrivateEndpointConnection>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<ApplicationGatewaySku>,
    #[serde(rename = "sslPolicy", skip_serializing_if = "Option::is_none")]
    pub ssl_policy: Option<ApplicationGatewaySslPolicy>,
    #[serde(rename = "operationalState", skip_serializing)]
    pub operational_state: Option<application_gateway_properties_format::OperationalState>,
    #[serde(rename = "gatewayIPConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub gateway_ip_configurations: Vec<ApplicationGatewayIpConfiguration>,
    #[serde(rename = "authenticationCertificates", skip_serializing_if = "Vec::is_empty")]
    pub authentication_certificates: Vec<ApplicationGatewayAuthenticationCertificate>,
    #[serde(rename = "trustedRootCertificates", skip_serializing_if = "Vec::is_empty")]
    pub trusted_root_certificates: Vec<ApplicationGatewayTrustedRootCertificate>,
    #[serde(rename = "trustedClientCertificates", skip_serializing_if = "Vec::is_empty")]
    pub trusted_client_certificates: Vec<ApplicationGatewayTrustedClientCertificate>,
    #[serde(rename = "sslCertificates", skip_serializing_if = "Vec::is_empty")]
    pub ssl_certificates: Vec<ApplicationGatewaySslCertificate>,
    #[serde(rename = "frontendIPConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub frontend_ip_configurations: Vec<ApplicationGatewayFrontendIpConfiguration>,
    #[serde(rename = "frontendPorts", skip_serializing_if = "Vec::is_empty")]
    pub frontend_ports: Vec<ApplicationGatewayFrontendPort>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub probes: Vec<ApplicationGatewayProbe>,
    #[serde(rename = "backendAddressPools", skip_serializing_if = "Vec::is_empty")]
    pub backend_address_pools: Vec<ApplicationGatewayBackendAddressPool>,
    #[serde(rename = "backendHttpSettingsCollection", skip_serializing_if = "Vec::is_empty")]
    pub backend_http_settings_collection: Vec<ApplicationGatewayBackendHttpSettings>,
    #[serde(rename = "httpListeners", skip_serializing_if = "Vec::is_empty")]
    pub http_listeners: Vec<ApplicationGatewayHttpListener>,
    #[serde(rename = "sslProfiles", skip_serializing_if = "Vec::is_empty")]
    pub ssl_profiles: Vec<ApplicationGatewaySslProfile>,
    #[serde(rename = "urlPathMaps", skip_serializing_if = "Vec::is_empty")]
    pub url_path_maps: Vec<ApplicationGatewayUrlPathMap>,
    #[serde(rename = "requestRoutingRules", skip_serializing_if = "Vec::is_empty")]
    pub request_routing_rules: Vec<ApplicationGatewayRequestRoutingRule>,
    #[serde(rename = "rewriteRuleSets", skip_serializing_if = "Vec::is_empty")]
    pub rewrite_rule_sets: Vec<ApplicationGatewayRewriteRuleSet>,
    #[serde(rename = "redirectConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub redirect_configurations: Vec<ApplicationGatewayRedirectConfiguration>,
    #[serde(rename = "webApplicationFirewallConfiguration", skip_serializing_if = "Option::is_none")]
    pub web_application_firewall_configuration: Option<ApplicationGatewayWebApplicationFirewallConfiguration>,
    #[serde(rename = "firewallPolicy", skip_serializing_if = "Option::is_none")]
    pub firewall_policy: Option<SubResource>,
    #[serde(rename = "enableHttp2", skip_serializing_if = "Option::is_none")]
    pub enable_http2: Option<bool>,
    #[serde(rename = "enableFips", skip_serializing_if = "Option::is_none")]
    pub enable_fips: Option<bool>,
    #[serde(rename = "autoscaleConfiguration", skip_serializing_if = "Option::is_none")]
    pub autoscale_configuration: Option<ApplicationGatewayAutoscaleConfiguration>,
    #[serde(rename = "privateLinkConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub private_link_configurations: Vec<ApplicationGatewayPrivateLinkConfiguration>,
    #[serde(rename = "privateEndpointConnections", skip_serializing)]
    pub private_endpoint_connections: Vec<ApplicationGatewayPrivateEndpointConnection>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "customErrorConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub custom_error_configurations: Vec<ApplicationGatewayCustomError>,
    #[serde(rename = "forceFirewallPolicyAssociation", skip_serializing_if = "Option::is_none")]
    pub force_firewall_policy_association: Option<bool>,
}
pub mod application_gateway_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OperationalState {
        Stopped,
        Starting,
        Running,
        Stopping,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGateway {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub zones: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedServiceIdentity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ApplicationGateway>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayUrlPathMapPropertiesFormat {
    #[serde(rename = "defaultBackendAddressPool", skip_serializing_if = "Option::is_none")]
    pub default_backend_address_pool: Option<SubResource>,
    #[serde(rename = "defaultBackendHttpSettings", skip_serializing_if = "Option::is_none")]
    pub default_backend_http_settings: Option<SubResource>,
    #[serde(rename = "defaultRewriteRuleSet", skip_serializing_if = "Option::is_none")]
    pub default_rewrite_rule_set: Option<SubResource>,
    #[serde(rename = "defaultRedirectConfiguration", skip_serializing_if = "Option::is_none")]
    pub default_redirect_configuration: Option<SubResource>,
    #[serde(rename = "pathRules", skip_serializing_if = "Vec::is_empty")]
    pub path_rules: Vec<ApplicationGatewayPathRule>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayUrlPathMap {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayUrlPathMapPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayWebApplicationFirewallConfiguration {
    pub enabled: bool,
    #[serde(rename = "firewallMode")]
    pub firewall_mode: application_gateway_web_application_firewall_configuration::FirewallMode,
    #[serde(rename = "ruleSetType")]
    pub rule_set_type: String,
    #[serde(rename = "ruleSetVersion")]
    pub rule_set_version: String,
    #[serde(rename = "disabledRuleGroups", skip_serializing_if = "Vec::is_empty")]
    pub disabled_rule_groups: Vec<ApplicationGatewayFirewallDisabledRuleGroup>,
    #[serde(rename = "requestBodyCheck", skip_serializing_if = "Option::is_none")]
    pub request_body_check: Option<bool>,
    #[serde(rename = "maxRequestBodySize", skip_serializing_if = "Option::is_none")]
    pub max_request_body_size: Option<i32>,
    #[serde(rename = "maxRequestBodySizeInKb", skip_serializing_if = "Option::is_none")]
    pub max_request_body_size_in_kb: Option<i32>,
    #[serde(rename = "fileUploadLimitInMb", skip_serializing_if = "Option::is_none")]
    pub file_upload_limit_in_mb: Option<i32>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub exclusions: Vec<ApplicationGatewayFirewallExclusion>,
}
pub mod application_gateway_web_application_firewall_configuration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum FirewallMode {
        Detection,
        Prevention,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayAutoscaleConfiguration {
    #[serde(rename = "minCapacity")]
    pub min_capacity: i32,
    #[serde(rename = "maxCapacity", skip_serializing_if = "Option::is_none")]
    pub max_capacity: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayConnectionDraining {
    pub enabled: bool,
    #[serde(rename = "drainTimeoutInSec")]
    pub drain_timeout_in_sec: i32,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFirewallDisabledRuleGroup {
    #[serde(rename = "ruleGroupName")]
    pub rule_group_name: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<i32>,
}
pub type ApplicationGatewayAvailableServerVariablesResult = Vec<String>;
pub type ApplicationGatewayAvailableRequestHeadersResult = Vec<String>;
pub type ApplicationGatewayAvailableResponseHeadersResult = Vec<String>;
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFirewallExclusion {
    #[serde(rename = "matchVariable")]
    pub match_variable: String,
    #[serde(rename = "selectorMatchOperator")]
    pub selector_match_operator: String,
    pub selector: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayAvailableWafRuleSetsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ApplicationGatewayFirewallRuleSet>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFirewallRuleSet {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayFirewallRuleSetPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFirewallRuleSetPropertiesFormat {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "ruleSetType")]
    pub rule_set_type: String,
    #[serde(rename = "ruleSetVersion")]
    pub rule_set_version: String,
    #[serde(rename = "ruleGroups")]
    pub rule_groups: Vec<ApplicationGatewayFirewallRuleGroup>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFirewallRuleGroup {
    #[serde(rename = "ruleGroupName")]
    pub rule_group_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub rules: Vec<ApplicationGatewayFirewallRule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayFirewallRule {
    #[serde(rename = "ruleId")]
    pub rule_id: i32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayAvailableSslOptions {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewayAvailableSslOptionsPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayAvailableSslOptionsPropertiesFormat {
    #[serde(rename = "predefinedPolicies", skip_serializing_if = "Vec::is_empty")]
    pub predefined_policies: Vec<SubResource>,
    #[serde(rename = "defaultPolicy", skip_serializing_if = "Option::is_none")]
    pub default_policy: Option<PolicyNameEnum>,
    #[serde(rename = "availableCipherSuites", skip_serializing_if = "Vec::is_empty")]
    pub available_cipher_suites: Vec<CipherSuitesEnum>,
    #[serde(rename = "availableProtocols", skip_serializing_if = "Vec::is_empty")]
    pub available_protocols: Vec<ProtocolsEnum>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayAvailableSslPredefinedPolicies {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ApplicationGatewaySslPredefinedPolicy>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewaySslPredefinedPolicy {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationGatewaySslPredefinedPolicyPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewaySslPredefinedPolicyPropertiesFormat {
    #[serde(rename = "cipherSuites", skip_serializing_if = "Vec::is_empty")]
    pub cipher_suites: Vec<CipherSuitesEnum>,
    #[serde(rename = "minProtocolVersion", skip_serializing_if = "Option::is_none")]
    pub min_protocol_version: Option<ProtocolsEnum>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationGatewayCustomError {
    #[serde(rename = "statusCode", skip_serializing_if = "Option::is_none")]
    pub status_code: Option<application_gateway_custom_error::StatusCode>,
    #[serde(rename = "customErrorPageUrl", skip_serializing_if = "Option::is_none")]
    pub custom_error_page_url: Option<String>,
}
pub mod application_gateway_custom_error {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StatusCode {
        HttpStatus403,
        HttpStatus502,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum PolicyNameEnum {
    AppGwSslPolicy20150501,
    AppGwSslPolicy20170401,
    AppGwSslPolicy20170401S,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ProtocolsEnum {
    #[serde(rename = "TLSv1_0")]
    TlSv10,
    #[serde(rename = "TLSv1_1")]
    TlSv11,
    #[serde(rename = "TLSv1_2")]
    TlSv12,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum CipherSuitesEnum {
    #[serde(rename = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384")]
    TlsEcdheRsaWithAes256CbcSha384,
    #[serde(rename = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256")]
    TlsEcdheRsaWithAes128CbcSha256,
    #[serde(rename = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA")]
    TlsEcdheRsaWithAes256CbcSha,
    #[serde(rename = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA")]
    TlsEcdheRsaWithAes128CbcSha,
    #[serde(rename = "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384")]
    TlsDheRsaWithAes256GcmSha384,
    #[serde(rename = "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256")]
    TlsDheRsaWithAes128GcmSha256,
    #[serde(rename = "TLS_DHE_RSA_WITH_AES_256_CBC_SHA")]
    TlsDheRsaWithAes256CbcSha,
    #[serde(rename = "TLS_DHE_RSA_WITH_AES_128_CBC_SHA")]
    TlsDheRsaWithAes128CbcSha,
    #[serde(rename = "TLS_RSA_WITH_AES_256_GCM_SHA384")]
    TlsRsaWithAes256GcmSha384,
    #[serde(rename = "TLS_RSA_WITH_AES_128_GCM_SHA256")]
    TlsRsaWithAes128GcmSha256,
    #[serde(rename = "TLS_RSA_WITH_AES_256_CBC_SHA256")]
    TlsRsaWithAes256CbcSha256,
    #[serde(rename = "TLS_RSA_WITH_AES_128_CBC_SHA256")]
    TlsRsaWithAes128CbcSha256,
    #[serde(rename = "TLS_RSA_WITH_AES_256_CBC_SHA")]
    TlsRsaWithAes256CbcSha,
    #[serde(rename = "TLS_RSA_WITH_AES_128_CBC_SHA")]
    TlsRsaWithAes128CbcSha,
    #[serde(rename = "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")]
    TlsEcdheEcdsaWithAes256GcmSha384,
    #[serde(rename = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")]
    TlsEcdheEcdsaWithAes128GcmSha256,
    #[serde(rename = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")]
    TlsEcdheEcdsaWithAes256CbcSha384,
    #[serde(rename = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")]
    TlsEcdheEcdsaWithAes128CbcSha256,
    #[serde(rename = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")]
    TlsEcdheEcdsaWithAes256CbcSha,
    #[serde(rename = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")]
    TlsEcdheEcdsaWithAes128CbcSha,
    #[serde(rename = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256")]
    TlsDheDssWithAes256CbcSha256,
    #[serde(rename = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256")]
    TlsDheDssWithAes128CbcSha256,
    #[serde(rename = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA")]
    TlsDheDssWithAes256CbcSha,
    #[serde(rename = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA")]
    TlsDheDssWithAes128CbcSha,
    #[serde(rename = "TLS_RSA_WITH_3DES_EDE_CBC_SHA")]
    TlsRsaWith3desEdeCbcSha,
    #[serde(rename = "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA")]
    TlsDheDssWith3desEdeCbcSha,
    #[serde(rename = "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")]
    TlsEcdheRsaWithAes128GcmSha256,
    #[serde(rename = "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384")]
    TlsEcdheRsaWithAes256GcmSha384,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum RedirectTypeEnum {
    Permanent,
    Found,
    SeeOther,
    Temporary,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ApplicationGatewayProtocol {
    Http,
    Https,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorDetails {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Error {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<ErrorDetails>,
    #[serde(rename = "innerError", skip_serializing_if = "Option::is_none")]
    pub inner_error: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudError {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<CloudErrorBody>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudErrorBody {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<CloudErrorBody>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureAsyncOperationResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<azure_async_operation_result::Status>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<Error>,
}
pub mod azure_async_operation_result {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        InProgress,
        Succeeded,
        Failed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Resource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ProxyResource {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubResource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TagsObject {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedServiceIdentity {
    #[serde(rename = "principalId", skip_serializing)]
    pub principal_id: Option<String>,
    #[serde(rename = "tenantId", skip_serializing)]
    pub tenant_id: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<managed_service_identity::Type>,
    #[serde(rename = "userAssignedIdentities", skip_serializing_if = "Option::is_none")]
    pub user_assigned_identities: Option<serde_json::Value>,
}
pub mod managed_service_identity {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        SystemAssigned,
        UserAssigned,
        #[serde(rename = "SystemAssigned, UserAssigned")]
        SystemAssignedUserAssigned,
        None,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ProvisioningState {
    Succeeded,
    Updating,
    Deleting,
    Failed,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum Access {
    Allow,
    Deny,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AuthenticationMethod {
    #[serde(rename = "EAPTLS")]
    Eaptls,
    #[serde(rename = "EAPMSCHAPv2")]
    EapmschaPv2,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IpAllocationMethod {
    Static,
    Dynamic,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IpVersion {
    IPv4,
    IPv6,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ExtendedLocationType {
    EdgeZone,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExtendedLocation {
    pub name: String,
    #[serde(rename = "type")]
    pub type_: ExtendedLocationType,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceTapConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NetworkInterfaceTapConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceTapConfigurationPropertiesFormat {
    #[serde(rename = "virtualNetworkTap", skip_serializing_if = "Option::is_none")]
    pub virtual_network_tap: Option<VirtualNetworkTap>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceIpConfigurationPropertiesFormat {
    #[serde(rename = "virtualNetworkTaps", skip_serializing_if = "Vec::is_empty")]
    pub virtual_network_taps: Vec<VirtualNetworkTap>,
    #[serde(rename = "applicationGatewayBackendAddressPools", skip_serializing_if = "Vec::is_empty")]
    pub application_gateway_backend_address_pools: Vec<ApplicationGatewayBackendAddressPool>,
    #[serde(rename = "loadBalancerBackendAddressPools", skip_serializing_if = "Vec::is_empty")]
    pub load_balancer_backend_address_pools: Vec<BackendAddressPool>,
    #[serde(rename = "loadBalancerInboundNatRules", skip_serializing_if = "Vec::is_empty")]
    pub load_balancer_inbound_nat_rules: Vec<InboundNatRule>,
    #[serde(rename = "privateIPAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(rename = "privateIPAddressVersion", skip_serializing_if = "Option::is_none")]
    pub private_ip_address_version: Option<IpVersion>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<Subnet>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary: Option<bool>,
    #[serde(rename = "publicIPAddress", skip_serializing_if = "Option::is_none")]
    pub public_ip_address: Option<PublicIpAddress>,
    #[serde(rename = "applicationSecurityGroups", skip_serializing_if = "Vec::is_empty")]
    pub application_security_groups: Vec<ApplicationSecurityGroup>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "privateLinkConnectionProperties", skip_serializing_if = "Option::is_none")]
    pub private_link_connection_properties: Option<NetworkInterfaceIpConfigurationPrivateLinkConnectionProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceIpConfigurationPrivateLinkConnectionProperties {
    #[serde(rename = "groupId", skip_serializing)]
    pub group_id: Option<String>,
    #[serde(rename = "requiredMemberName", skip_serializing)]
    pub required_member_name: Option<String>,
    #[serde(skip_serializing)]
    pub fqdns: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NetworkInterfaceIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceDnsSettings {
    #[serde(rename = "dnsServers", skip_serializing_if = "Vec::is_empty")]
    pub dns_servers: Vec<String>,
    #[serde(rename = "appliedDnsServers", skip_serializing)]
    pub applied_dns_servers: Vec<String>,
    #[serde(rename = "internalDnsNameLabel", skip_serializing_if = "Option::is_none")]
    pub internal_dns_name_label: Option<String>,
    #[serde(rename = "internalFqdn", skip_serializing)]
    pub internal_fqdn: Option<String>,
    #[serde(rename = "internalDomainNameSuffix", skip_serializing)]
    pub internal_domain_name_suffix: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfacePropertiesFormat {
    #[serde(rename = "virtualMachine", skip_serializing_if = "Option::is_none")]
    pub virtual_machine: Option<SubResource>,
    #[serde(rename = "networkSecurityGroup", skip_serializing_if = "Option::is_none")]
    pub network_security_group: Option<NetworkSecurityGroup>,
    #[serde(rename = "privateEndpoint", skip_serializing_if = "Option::is_none")]
    pub private_endpoint: Option<PrivateEndpoint>,
    #[serde(rename = "ipConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub ip_configurations: Vec<NetworkInterfaceIpConfiguration>,
    #[serde(rename = "tapConfigurations", skip_serializing)]
    pub tap_configurations: Vec<NetworkInterfaceTapConfiguration>,
    #[serde(rename = "dnsSettings", skip_serializing_if = "Option::is_none")]
    pub dns_settings: Option<NetworkInterfaceDnsSettings>,
    #[serde(rename = "macAddress", skip_serializing)]
    pub mac_address: Option<String>,
    #[serde(skip_serializing)]
    pub primary: Option<bool>,
    #[serde(rename = "enableAcceleratedNetworking", skip_serializing_if = "Option::is_none")]
    pub enable_accelerated_networking: Option<bool>,
    #[serde(rename = "enableIPForwarding", skip_serializing_if = "Option::is_none")]
    pub enable_ip_forwarding: Option<bool>,
    #[serde(rename = "hostedWorkloads", skip_serializing)]
    pub hosted_workloads: Vec<String>,
    #[serde(rename = "dscpConfiguration", skip_serializing_if = "Option::is_none")]
    pub dscp_configuration: Option<SubResource>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "nicType", skip_serializing_if = "Option::is_none")]
    pub nic_type: Option<network_interface_properties_format::NicType>,
    #[serde(rename = "privateLinkService", skip_serializing_if = "Option::is_none")]
    pub private_link_service: Option<PrivateLinkService>,
    #[serde(rename = "migrationPhase", skip_serializing_if = "Option::is_none")]
    pub migration_phase: Option<network_interface_properties_format::MigrationPhase>,
}
pub mod network_interface_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum NicType {
        Standard,
        Elastic,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum MigrationPhase {
        None,
        Prepare,
        Commit,
        Abort,
        Committed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterface {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(rename = "extendedLocation", skip_serializing_if = "Option::is_none")]
    pub extended_location: Option<ExtendedLocation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NetworkInterfacePropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NetworkInterface>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceTapConfigurationListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NetworkInterfaceTapConfiguration>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceIpConfigurationListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NetworkInterfaceIpConfiguration>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceLoadBalancerListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LoadBalancer>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EffectiveNetworkSecurityGroup {
    #[serde(rename = "networkSecurityGroup", skip_serializing_if = "Option::is_none")]
    pub network_security_group: Option<SubResource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub association: Option<EffectiveNetworkSecurityGroupAssociation>,
    #[serde(rename = "effectiveSecurityRules", skip_serializing_if = "Vec::is_empty")]
    pub effective_security_rules: Vec<EffectiveNetworkSecurityRule>,
    #[serde(rename = "tagMap", skip_serializing_if = "Option::is_none")]
    pub tag_map: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EffectiveNetworkSecurityGroupAssociation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<SubResource>,
    #[serde(rename = "networkInterface", skip_serializing_if = "Option::is_none")]
    pub network_interface: Option<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EffectiveNetworkSecurityRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<effective_network_security_rule::Protocol>,
    #[serde(rename = "sourcePortRange", skip_serializing_if = "Option::is_none")]
    pub source_port_range: Option<String>,
    #[serde(rename = "destinationPortRange", skip_serializing_if = "Option::is_none")]
    pub destination_port_range: Option<String>,
    #[serde(rename = "sourcePortRanges", skip_serializing_if = "Vec::is_empty")]
    pub source_port_ranges: Vec<String>,
    #[serde(rename = "destinationPortRanges", skip_serializing_if = "Vec::is_empty")]
    pub destination_port_ranges: Vec<String>,
    #[serde(rename = "sourceAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub source_address_prefix: Option<String>,
    #[serde(rename = "destinationAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub destination_address_prefix: Option<String>,
    #[serde(rename = "sourceAddressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub source_address_prefixes: Vec<String>,
    #[serde(rename = "destinationAddressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub destination_address_prefixes: Vec<String>,
    #[serde(rename = "expandedSourceAddressPrefix", skip_serializing_if = "Vec::is_empty")]
    pub expanded_source_address_prefix: Vec<String>,
    #[serde(rename = "expandedDestinationAddressPrefix", skip_serializing_if = "Vec::is_empty")]
    pub expanded_destination_address_prefix: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access: Option<SecurityRuleAccess>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub direction: Option<SecurityRuleDirection>,
}
pub mod effective_network_security_rule {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        Tcp,
        Udp,
        All,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EffectiveNetworkSecurityGroupListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<EffectiveNetworkSecurityGroup>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EffectiveRoute {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "disableBgpRoutePropagation", skip_serializing_if = "Option::is_none")]
    pub disable_bgp_route_propagation: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<effective_route::Source>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<effective_route::State>,
    #[serde(rename = "addressPrefix", skip_serializing_if = "Vec::is_empty")]
    pub address_prefix: Vec<String>,
    #[serde(rename = "nextHopIpAddress", skip_serializing_if = "Vec::is_empty")]
    pub next_hop_ip_address: Vec<String>,
    #[serde(rename = "nextHopType", skip_serializing_if = "Option::is_none")]
    pub next_hop_type: Option<RouteNextHopType>,
}
pub mod effective_route {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Source {
        Unknown,
        User,
        VirtualNetworkGateway,
        Default,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Active,
        Invalid,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EffectiveRouteListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<EffectiveRoute>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpConfigurationPropertiesFormat {
    #[serde(rename = "privateIPAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<Subnet>,
    #[serde(rename = "publicIPAddress", skip_serializing_if = "Option::is_none")]
    pub public_ip_address: Option<PublicIpAddress>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<IpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkTap {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualNetworkTapPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkTapPropertiesFormat {
    #[serde(rename = "networkInterfaceTapConfigurations", skip_serializing)]
    pub network_interface_tap_configurations: Vec<NetworkInterfaceTapConfiguration>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "destinationNetworkInterfaceIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub destination_network_interface_ip_configuration: Option<NetworkInterfaceIpConfiguration>,
    #[serde(rename = "destinationLoadBalancerFrontEndIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub destination_load_balancer_front_end_ip_configuration: Option<FrontendIpConfiguration>,
    #[serde(rename = "destinationPort", skip_serializing_if = "Option::is_none")]
    pub destination_port: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkTapListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualNetworkTap>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerSku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<load_balancer_sku::Name>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<load_balancer_sku::Tier>,
}
pub mod load_balancer_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        Basic,
        Standard,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Regional,
        Global,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FrontendIpConfigurationPropertiesFormat {
    #[serde(rename = "inboundNatRules", skip_serializing)]
    pub inbound_nat_rules: Vec<SubResource>,
    #[serde(rename = "inboundNatPools", skip_serializing)]
    pub inbound_nat_pools: Vec<SubResource>,
    #[serde(rename = "outboundRules", skip_serializing)]
    pub outbound_rules: Vec<SubResource>,
    #[serde(rename = "loadBalancingRules", skip_serializing)]
    pub load_balancing_rules: Vec<SubResource>,
    #[serde(rename = "privateIPAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(rename = "privateIPAddressVersion", skip_serializing_if = "Option::is_none")]
    pub private_ip_address_version: Option<IpVersion>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<Subnet>,
    #[serde(rename = "publicIPAddress", skip_serializing_if = "Option::is_none")]
    pub public_ip_address: Option<PublicIpAddress>,
    #[serde(rename = "publicIPPrefix", skip_serializing_if = "Option::is_none")]
    pub public_ip_prefix: Option<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FrontendIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<FrontendIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub zones: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerBackendAddressPropertiesFormat {
    #[serde(rename = "virtualNetwork", skip_serializing_if = "Option::is_none")]
    pub virtual_network: Option<SubResource>,
    #[serde(rename = "ipAddress", skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    #[serde(rename = "networkInterfaceIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub network_interface_ip_configuration: Option<SubResource>,
    #[serde(rename = "loadBalancerFrontendIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub load_balancer_frontend_ip_configuration: Option<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerBackendAddress {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<LoadBalancerBackendAddressPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackendAddressPoolPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(rename = "loadBalancerBackendAddresses", skip_serializing_if = "Vec::is_empty")]
    pub load_balancer_backend_addresses: Vec<LoadBalancerBackendAddress>,
    #[serde(rename = "backendIPConfigurations", skip_serializing)]
    pub backend_ip_configurations: Vec<NetworkInterfaceIpConfiguration>,
    #[serde(rename = "loadBalancingRules", skip_serializing)]
    pub load_balancing_rules: Vec<SubResource>,
    #[serde(rename = "outboundRule", skip_serializing_if = "Option::is_none")]
    pub outbound_rule: Option<SubResource>,
    #[serde(rename = "outboundRules", skip_serializing)]
    pub outbound_rules: Vec<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackendAddressPool {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<BackendAddressPoolPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancingRulePropertiesFormat {
    #[serde(rename = "frontendIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub frontend_ip_configuration: Option<SubResource>,
    #[serde(rename = "backendAddressPool", skip_serializing_if = "Option::is_none")]
    pub backend_address_pool: Option<SubResource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub probe: Option<SubResource>,
    pub protocol: TransportProtocol,
    #[serde(rename = "loadDistribution", skip_serializing_if = "Option::is_none")]
    pub load_distribution: Option<load_balancing_rule_properties_format::LoadDistribution>,
    #[serde(rename = "frontendPort")]
    pub frontend_port: i32,
    #[serde(rename = "backendPort", skip_serializing_if = "Option::is_none")]
    pub backend_port: Option<i32>,
    #[serde(rename = "idleTimeoutInMinutes", skip_serializing_if = "Option::is_none")]
    pub idle_timeout_in_minutes: Option<i32>,
    #[serde(rename = "enableFloatingIP", skip_serializing_if = "Option::is_none")]
    pub enable_floating_ip: Option<bool>,
    #[serde(rename = "enableTcpReset", skip_serializing_if = "Option::is_none")]
    pub enable_tcp_reset: Option<bool>,
    #[serde(rename = "disableOutboundSnat", skip_serializing_if = "Option::is_none")]
    pub disable_outbound_snat: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod load_balancing_rule_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum LoadDistribution {
        Default,
        #[serde(rename = "SourceIP")]
        SourceIp,
        #[serde(rename = "SourceIPProtocol")]
        SourceIpProtocol,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancingRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<LoadBalancingRulePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ProbePropertiesFormat {
    #[serde(rename = "loadBalancingRules", skip_serializing)]
    pub load_balancing_rules: Vec<SubResource>,
    pub protocol: probe_properties_format::Protocol,
    pub port: i32,
    #[serde(rename = "intervalInSeconds", skip_serializing_if = "Option::is_none")]
    pub interval_in_seconds: Option<i32>,
    #[serde(rename = "numberOfProbes", skip_serializing_if = "Option::is_none")]
    pub number_of_probes: Option<i32>,
    #[serde(rename = "requestPath", skip_serializing_if = "Option::is_none")]
    pub request_path: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod probe_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        Http,
        Tcp,
        Https,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Probe {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ProbePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InboundNatRulePropertiesFormat {
    #[serde(rename = "frontendIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub frontend_ip_configuration: Option<SubResource>,
    #[serde(rename = "backendIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub backend_ip_configuration: Option<NetworkInterfaceIpConfiguration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<TransportProtocol>,
    #[serde(rename = "frontendPort", skip_serializing_if = "Option::is_none")]
    pub frontend_port: Option<i32>,
    #[serde(rename = "backendPort", skip_serializing_if = "Option::is_none")]
    pub backend_port: Option<i32>,
    #[serde(rename = "idleTimeoutInMinutes", skip_serializing_if = "Option::is_none")]
    pub idle_timeout_in_minutes: Option<i32>,
    #[serde(rename = "enableFloatingIP", skip_serializing_if = "Option::is_none")]
    pub enable_floating_ip: Option<bool>,
    #[serde(rename = "enableTcpReset", skip_serializing_if = "Option::is_none")]
    pub enable_tcp_reset: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InboundNatRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<InboundNatRulePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InboundNatPoolPropertiesFormat {
    #[serde(rename = "frontendIPConfiguration", skip_serializing_if = "Option::is_none")]
    pub frontend_ip_configuration: Option<SubResource>,
    pub protocol: TransportProtocol,
    #[serde(rename = "frontendPortRangeStart")]
    pub frontend_port_range_start: i32,
    #[serde(rename = "frontendPortRangeEnd")]
    pub frontend_port_range_end: i32,
    #[serde(rename = "backendPort")]
    pub backend_port: i32,
    #[serde(rename = "idleTimeoutInMinutes", skip_serializing_if = "Option::is_none")]
    pub idle_timeout_in_minutes: Option<i32>,
    #[serde(rename = "enableFloatingIP", skip_serializing_if = "Option::is_none")]
    pub enable_floating_ip: Option<bool>,
    #[serde(rename = "enableTcpReset", skip_serializing_if = "Option::is_none")]
    pub enable_tcp_reset: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InboundNatPool {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<InboundNatPoolPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OutboundRulePropertiesFormat {
    #[serde(rename = "allocatedOutboundPorts", skip_serializing_if = "Option::is_none")]
    pub allocated_outbound_ports: Option<i32>,
    #[serde(rename = "frontendIPConfigurations")]
    pub frontend_ip_configurations: Vec<SubResource>,
    #[serde(rename = "backendAddressPool")]
    pub backend_address_pool: SubResource,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    pub protocol: outbound_rule_properties_format::Protocol,
    #[serde(rename = "enableTcpReset", skip_serializing_if = "Option::is_none")]
    pub enable_tcp_reset: Option<bool>,
    #[serde(rename = "idleTimeoutInMinutes", skip_serializing_if = "Option::is_none")]
    pub idle_timeout_in_minutes: Option<i64>,
}
pub mod outbound_rule_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        Tcp,
        Udp,
        All,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OutboundRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<OutboundRulePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerPropertiesFormat {
    #[serde(rename = "frontendIPConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub frontend_ip_configurations: Vec<FrontendIpConfiguration>,
    #[serde(rename = "backendAddressPools", skip_serializing_if = "Vec::is_empty")]
    pub backend_address_pools: Vec<BackendAddressPool>,
    #[serde(rename = "loadBalancingRules", skip_serializing_if = "Vec::is_empty")]
    pub load_balancing_rules: Vec<LoadBalancingRule>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub probes: Vec<Probe>,
    #[serde(rename = "inboundNatRules", skip_serializing_if = "Vec::is_empty")]
    pub inbound_nat_rules: Vec<InboundNatRule>,
    #[serde(rename = "inboundNatPools", skip_serializing_if = "Vec::is_empty")]
    pub inbound_nat_pools: Vec<InboundNatPool>,
    #[serde(rename = "outboundRules", skip_serializing_if = "Vec::is_empty")]
    pub outbound_rules: Vec<OutboundRule>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancer {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(rename = "extendedLocation", skip_serializing_if = "Option::is_none")]
    pub extended_location: Option<ExtendedLocation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<LoadBalancerSku>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<LoadBalancerPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LoadBalancer>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InboundNatRuleListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<InboundNatRule>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerBackendAddressPoolListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BackendAddressPool>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerFrontendIpConfigurationListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<FrontendIpConfiguration>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerLoadBalancingRuleListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LoadBalancingRule>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerOutboundRuleListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<OutboundRule>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LoadBalancerProbeListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Probe>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum TransportProtocol {
    Udp,
    Tcp,
    All,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceAssociationLinkPropertiesFormat {
    #[serde(rename = "linkedResourceType", skip_serializing_if = "Option::is_none")]
    pub linked_resource_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub link: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "allowDelete", skip_serializing_if = "Option::is_none")]
    pub allow_delete: Option<bool>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub locations: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceAssociationLink {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ServiceAssociationLinkPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResourceNavigationLinkFormat {
    #[serde(rename = "linkedResourceType", skip_serializing_if = "Option::is_none")]
    pub linked_resource_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub link: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResourceNavigationLink {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ResourceNavigationLinkFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceDelegationPropertiesFormat {
    #[serde(rename = "serviceName", skip_serializing_if = "Option::is_none")]
    pub service_name: Option<String>,
    #[serde(skip_serializing)]
    pub actions: Vec<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Delegation {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ServiceDelegationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubnetPropertiesFormat {
    #[serde(rename = "addressPrefix", skip_serializing_if = "Option::is_none")]
    pub address_prefix: Option<String>,
    #[serde(rename = "addressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub address_prefixes: Vec<String>,
    #[serde(rename = "networkSecurityGroup", skip_serializing_if = "Option::is_none")]
    pub network_security_group: Option<NetworkSecurityGroup>,
    #[serde(rename = "routeTable", skip_serializing_if = "Option::is_none")]
    pub route_table: Option<RouteTable>,
    #[serde(rename = "natGateway", skip_serializing_if = "Option::is_none")]
    pub nat_gateway: Option<SubResource>,
    #[serde(rename = "serviceEndpoints", skip_serializing_if = "Vec::is_empty")]
    pub service_endpoints: Vec<ServiceEndpointPropertiesFormat>,
    #[serde(rename = "serviceEndpointPolicies", skip_serializing_if = "Vec::is_empty")]
    pub service_endpoint_policies: Vec<ServiceEndpointPolicy>,
    #[serde(rename = "privateEndpoints", skip_serializing)]
    pub private_endpoints: Vec<PrivateEndpoint>,
    #[serde(rename = "ipConfigurations", skip_serializing)]
    pub ip_configurations: Vec<IpConfiguration>,
    #[serde(rename = "ipConfigurationProfiles", skip_serializing)]
    pub ip_configuration_profiles: Vec<IpConfigurationProfile>,
    #[serde(rename = "ipAllocations", skip_serializing_if = "Vec::is_empty")]
    pub ip_allocations: Vec<SubResource>,
    #[serde(rename = "resourceNavigationLinks", skip_serializing)]
    pub resource_navigation_links: Vec<ResourceNavigationLink>,
    #[serde(rename = "serviceAssociationLinks", skip_serializing)]
    pub service_association_links: Vec<ServiceAssociationLink>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub delegations: Vec<Delegation>,
    #[serde(skip_serializing)]
    pub purpose: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "privateEndpointNetworkPolicies", skip_serializing_if = "Option::is_none")]
    pub private_endpoint_network_policies: Option<subnet_properties_format::PrivateEndpointNetworkPolicies>,
    #[serde(rename = "privateLinkServiceNetworkPolicies", skip_serializing_if = "Option::is_none")]
    pub private_link_service_network_policies: Option<subnet_properties_format::PrivateLinkServiceNetworkPolicies>,
    #[serde(rename = "applicationGatewayIpConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub application_gateway_ip_configurations: Vec<ApplicationGatewayIpConfiguration>,
}
pub mod subnet_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PrivateEndpointNetworkPolicies {
        Enabled,
        Disabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PrivateLinkServiceNetworkPolicies {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceEndpointPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub locations: Vec<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkPeeringPropertiesFormat {
    #[serde(rename = "allowVirtualNetworkAccess", skip_serializing_if = "Option::is_none")]
    pub allow_virtual_network_access: Option<bool>,
    #[serde(rename = "allowForwardedTraffic", skip_serializing_if = "Option::is_none")]
    pub allow_forwarded_traffic: Option<bool>,
    #[serde(rename = "allowGatewayTransit", skip_serializing_if = "Option::is_none")]
    pub allow_gateway_transit: Option<bool>,
    #[serde(rename = "useRemoteGateways", skip_serializing_if = "Option::is_none")]
    pub use_remote_gateways: Option<bool>,
    #[serde(rename = "remoteVirtualNetwork", skip_serializing_if = "Option::is_none")]
    pub remote_virtual_network: Option<SubResource>,
    #[serde(rename = "remoteAddressSpace", skip_serializing_if = "Option::is_none")]
    pub remote_address_space: Option<AddressSpace>,
    #[serde(rename = "remoteBgpCommunities", skip_serializing_if = "Option::is_none")]
    pub remote_bgp_communities: Option<VirtualNetworkBgpCommunities>,
    #[serde(rename = "peeringState", skip_serializing_if = "Option::is_none")]
    pub peering_state: Option<virtual_network_peering_properties_format::PeeringState>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "doNotVerifyRemoteGateways", skip_serializing_if = "Option::is_none")]
    pub do_not_verify_remote_gateways: Option<bool>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
}
pub mod virtual_network_peering_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PeeringState {
        Initiated,
        Connected,
        Disconnected,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Subnet {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SubnetPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkPeering {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualNetworkPeeringPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubnetListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Subnet>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResourceNavigationLinksListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ResourceNavigationLink>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceAssociationLinksListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ServiceAssociationLink>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkPeeringListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualNetworkPeering>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkPropertiesFormat {
    #[serde(rename = "addressSpace", skip_serializing_if = "Option::is_none")]
    pub address_space: Option<AddressSpace>,
    #[serde(rename = "dhcpOptions", skip_serializing_if = "Option::is_none")]
    pub dhcp_options: Option<DhcpOptions>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub subnets: Vec<Subnet>,
    #[serde(rename = "virtualNetworkPeerings", skip_serializing_if = "Vec::is_empty")]
    pub virtual_network_peerings: Vec<VirtualNetworkPeering>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "enableDdosProtection", skip_serializing_if = "Option::is_none")]
    pub enable_ddos_protection: Option<bool>,
    #[serde(rename = "enableVmProtection", skip_serializing_if = "Option::is_none")]
    pub enable_vm_protection: Option<bool>,
    #[serde(rename = "ddosProtectionPlan", skip_serializing_if = "Option::is_none")]
    pub ddos_protection_plan: Option<SubResource>,
    #[serde(rename = "bgpCommunities", skip_serializing_if = "Option::is_none")]
    pub bgp_communities: Option<VirtualNetworkBgpCommunities>,
    #[serde(rename = "ipAllocations", skip_serializing_if = "Vec::is_empty")]
    pub ip_allocations: Vec<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetwork {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(rename = "extendedLocation", skip_serializing_if = "Option::is_none")]
    pub extended_location: Option<ExtendedLocation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualNetworkPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualNetwork>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AddressSpace {
    #[serde(rename = "addressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub address_prefixes: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DhcpOptions {
    #[serde(rename = "dnsServers", skip_serializing_if = "Vec::is_empty")]
    pub dns_servers: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkBgpCommunities {
    #[serde(rename = "virtualNetworkCommunity")]
    pub virtual_network_community: String,
    #[serde(rename = "regionalCommunity", skip_serializing)]
    pub regional_community: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpAddressAvailabilityResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub available: Option<bool>,
    #[serde(rename = "availableIPAddresses", skip_serializing_if = "Vec::is_empty")]
    pub available_ip_addresses: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkListUsageResult {
    #[serde(skip_serializing)]
    pub value: Vec<VirtualNetworkUsage>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkUsage {
    #[serde(rename = "currentValue", skip_serializing)]
    pub current_value: Option<f64>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub limit: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<VirtualNetworkUsageName>,
    #[serde(skip_serializing)]
    pub unit: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkUsageName {
    #[serde(rename = "localizedValue", skip_serializing)]
    pub localized_value: Option<String>,
    #[serde(skip_serializing)]
    pub value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrepareNetworkPoliciesRequest {
    #[serde(rename = "serviceName", skip_serializing_if = "Option::is_none")]
    pub service_name: Option<String>,
    #[serde(rename = "networkIntentPolicyConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub network_intent_policy_configurations: Vec<NetworkIntentPolicyConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UnprepareNetworkPoliciesRequest {
    #[serde(rename = "serviceName", skip_serializing_if = "Option::is_none")]
    pub service_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkIntentPolicyConfiguration {
    #[serde(rename = "networkIntentPolicyName", skip_serializing_if = "Option::is_none")]
    pub network_intent_policy_name: Option<String>,
    #[serde(rename = "sourceNetworkIntentPolicy", skip_serializing_if = "Option::is_none")]
    pub source_network_intent_policy: Option<NetworkIntentPolicy>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkIntentPolicy {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityRulePropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub protocol: security_rule_properties_format::Protocol,
    #[serde(rename = "sourcePortRange", skip_serializing_if = "Option::is_none")]
    pub source_port_range: Option<String>,
    #[serde(rename = "destinationPortRange", skip_serializing_if = "Option::is_none")]
    pub destination_port_range: Option<String>,
    #[serde(rename = "sourceAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub source_address_prefix: Option<String>,
    #[serde(rename = "sourceAddressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub source_address_prefixes: Vec<String>,
    #[serde(rename = "sourceApplicationSecurityGroups", skip_serializing_if = "Vec::is_empty")]
    pub source_application_security_groups: Vec<ApplicationSecurityGroup>,
    #[serde(rename = "destinationAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub destination_address_prefix: Option<String>,
    #[serde(rename = "destinationAddressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub destination_address_prefixes: Vec<String>,
    #[serde(rename = "destinationApplicationSecurityGroups", skip_serializing_if = "Vec::is_empty")]
    pub destination_application_security_groups: Vec<ApplicationSecurityGroup>,
    #[serde(rename = "sourcePortRanges", skip_serializing_if = "Vec::is_empty")]
    pub source_port_ranges: Vec<String>,
    #[serde(rename = "destinationPortRanges", skip_serializing_if = "Vec::is_empty")]
    pub destination_port_ranges: Vec<String>,
    pub access: SecurityRuleAccess,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    pub direction: SecurityRuleDirection,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod security_rule_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        Tcp,
        Udp,
        Icmp,
        Esp,
        #[serde(rename = "*")]
        Asterisk,
        Ah,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SecurityRulePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityRuleListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<SecurityRule>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSecurityGroupPropertiesFormat {
    #[serde(rename = "securityRules", skip_serializing_if = "Vec::is_empty")]
    pub security_rules: Vec<SecurityRule>,
    #[serde(rename = "defaultSecurityRules", skip_serializing)]
    pub default_security_rules: Vec<SecurityRule>,
    #[serde(rename = "networkInterfaces", skip_serializing)]
    pub network_interfaces: Vec<NetworkInterface>,
    #[serde(skip_serializing)]
    pub subnets: Vec<Subnet>,
    #[serde(rename = "flowLogs", skip_serializing)]
    pub flow_logs: Vec<FlowLog>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSecurityGroup {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NetworkSecurityGroupPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSecurityGroupListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NetworkSecurityGroup>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SecurityRuleAccess {
    Allow,
    Deny,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SecurityRuleDirection {
    Inbound,
    Outbound,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationSecurityGroup {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ApplicationSecurityGroupPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationSecurityGroupPropertiesFormat {
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationSecurityGroupListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ApplicationSecurityGroup>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ErrorResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetails>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkWatcher {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NetworkWatcherPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkWatcherPropertiesFormat {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkWatcherListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NetworkWatcher>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TopologyParameters {
    #[serde(rename = "targetResourceGroupName", skip_serializing_if = "Option::is_none")]
    pub target_resource_group_name: Option<String>,
    #[serde(rename = "targetVirtualNetwork", skip_serializing_if = "Option::is_none")]
    pub target_virtual_network: Option<SubResource>,
    #[serde(rename = "targetSubnet", skip_serializing_if = "Option::is_none")]
    pub target_subnet: Option<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Topology {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(rename = "createdDateTime", skip_serializing)]
    pub created_date_time: Option<String>,
    #[serde(rename = "lastModified", skip_serializing)]
    pub last_modified: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub resources: Vec<TopologyResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TopologyResource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub associations: Vec<TopologyAssociation>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TopologyAssociation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "resourceId", skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[serde(rename = "associationType", skip_serializing_if = "Option::is_none")]
    pub association_type: Option<topology_association::AssociationType>,
}
pub mod topology_association {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AssociationType {
        Associated,
        Contains,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VerificationIpFlowParameters {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
    pub direction: Direction,
    pub protocol: verification_ip_flow_parameters::Protocol,
    #[serde(rename = "localPort")]
    pub local_port: String,
    #[serde(rename = "remotePort")]
    pub remote_port: String,
    #[serde(rename = "localIPAddress")]
    pub local_ip_address: String,
    #[serde(rename = "remoteIPAddress")]
    pub remote_ip_address: String,
    #[serde(rename = "targetNicResourceId", skip_serializing_if = "Option::is_none")]
    pub target_nic_resource_id: Option<String>,
}
pub mod verification_ip_flow_parameters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VerificationIpFlowResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access: Option<Access>,
    #[serde(rename = "ruleName", skip_serializing_if = "Option::is_none")]
    pub rule_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NextHopParameters {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
    #[serde(rename = "sourceIPAddress")]
    pub source_ip_address: String,
    #[serde(rename = "destinationIPAddress")]
    pub destination_ip_address: String,
    #[serde(rename = "targetNicResourceId", skip_serializing_if = "Option::is_none")]
    pub target_nic_resource_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NextHopResult {
    #[serde(rename = "nextHopType", skip_serializing_if = "Option::is_none")]
    pub next_hop_type: Option<next_hop_result::NextHopType>,
    #[serde(rename = "nextHopIpAddress", skip_serializing_if = "Option::is_none")]
    pub next_hop_ip_address: Option<String>,
    #[serde(rename = "routeTableId", skip_serializing_if = "Option::is_none")]
    pub route_table_id: Option<String>,
}
pub mod next_hop_result {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum NextHopType {
        Internet,
        VirtualAppliance,
        VirtualNetworkGateway,
        VnetLocal,
        HyperNetGateway,
        None,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityGroupViewParameters {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityGroupViewResult {
    #[serde(rename = "networkInterfaces", skip_serializing_if = "Vec::is_empty")]
    pub network_interfaces: Vec<SecurityGroupNetworkInterface>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityGroupNetworkInterface {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "securityRuleAssociations", skip_serializing_if = "Option::is_none")]
    pub security_rule_associations: Option<SecurityRuleAssociations>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityRuleAssociations {
    #[serde(rename = "networkInterfaceAssociation", skip_serializing_if = "Option::is_none")]
    pub network_interface_association: Option<NetworkInterfaceAssociation>,
    #[serde(rename = "subnetAssociation", skip_serializing_if = "Option::is_none")]
    pub subnet_association: Option<SubnetAssociation>,
    #[serde(rename = "defaultSecurityRules", skip_serializing_if = "Vec::is_empty")]
    pub default_security_rules: Vec<SecurityRule>,
    #[serde(rename = "effectiveSecurityRules", skip_serializing_if = "Vec::is_empty")]
    pub effective_security_rules: Vec<EffectiveNetworkSecurityRule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceAssociation {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(rename = "securityRules", skip_serializing_if = "Vec::is_empty")]
    pub security_rules: Vec<SecurityRule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SubnetAssociation {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(rename = "securityRules", skip_serializing_if = "Vec::is_empty")]
    pub security_rules: Vec<SecurityRule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PacketCapture {
    pub properties: PacketCaptureParameters,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PacketCaptureParameters {
    pub target: String,
    #[serde(rename = "bytesToCapturePerPacket", skip_serializing_if = "Option::is_none")]
    pub bytes_to_capture_per_packet: Option<i64>,
    #[serde(rename = "totalBytesPerSession", skip_serializing_if = "Option::is_none")]
    pub total_bytes_per_session: Option<i64>,
    #[serde(rename = "timeLimitInSeconds", skip_serializing_if = "Option::is_none")]
    pub time_limit_in_seconds: Option<i32>,
    #[serde(rename = "storageLocation")]
    pub storage_location: PacketCaptureStorageLocation,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub filters: Vec<PacketCaptureFilter>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PacketCaptureStorageLocation {
    #[serde(rename = "storageId", skip_serializing_if = "Option::is_none")]
    pub storage_id: Option<String>,
    #[serde(rename = "storagePath", skip_serializing_if = "Option::is_none")]
    pub storage_path: Option<String>,
    #[serde(rename = "filePath", skip_serializing_if = "Option::is_none")]
    pub file_path: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PacketCaptureFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<packet_capture_filter::Protocol>,
    #[serde(rename = "localIPAddress", skip_serializing_if = "Option::is_none")]
    pub local_ip_address: Option<String>,
    #[serde(rename = "remoteIPAddress", skip_serializing_if = "Option::is_none")]
    pub remote_ip_address: Option<String>,
    #[serde(rename = "localPort", skip_serializing_if = "Option::is_none")]
    pub local_port: Option<String>,
    #[serde(rename = "remotePort", skip_serializing_if = "Option::is_none")]
    pub remote_port: Option<String>,
}
pub mod packet_capture_filter {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
        Any,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PacketCaptureListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PacketCaptureResult>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PacketCaptureResult {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PacketCaptureResultProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PacketCaptureResultProperties {
    #[serde(flatten)]
    pub packet_capture_parameters: PacketCaptureParameters,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PacketCaptureQueryStatusResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "captureStartTime", skip_serializing_if = "Option::is_none")]
    pub capture_start_time: Option<String>,
    #[serde(rename = "packetCaptureStatus", skip_serializing_if = "Option::is_none")]
    pub packet_capture_status: Option<packet_capture_query_status_result::PacketCaptureStatus>,
    #[serde(rename = "stopReason", skip_serializing_if = "Option::is_none")]
    pub stop_reason: Option<String>,
    #[serde(rename = "packetCaptureError", skip_serializing_if = "Vec::is_empty")]
    pub packet_capture_error: Vec<String>,
}
pub mod packet_capture_query_status_result {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PacketCaptureStatus {
        NotStarted,
        Running,
        Stopped,
        Error,
        Unknown,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TroubleshootingParameters {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
    pub properties: TroubleshootingProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QueryTroubleshootingParameters {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TroubleshootingProperties {
    #[serde(rename = "storageId")]
    pub storage_id: String,
    #[serde(rename = "storagePath")]
    pub storage_path: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TroubleshootingResult {
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub results: Vec<TroubleshootingDetails>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TroubleshootingDetails {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "reasonType", skip_serializing_if = "Option::is_none")]
    pub reason_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,
    #[serde(rename = "recommendedActions", skip_serializing_if = "Vec::is_empty")]
    pub recommended_actions: Vec<TroubleshootingRecommendedActions>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TroubleshootingRecommendedActions {
    #[serde(rename = "actionId", skip_serializing_if = "Option::is_none")]
    pub action_id: Option<String>,
    #[serde(rename = "actionText", skip_serializing_if = "Option::is_none")]
    pub action_text: Option<String>,
    #[serde(rename = "actionUri", skip_serializing_if = "Option::is_none")]
    pub action_uri: Option<String>,
    #[serde(rename = "actionUriText", skip_serializing_if = "Option::is_none")]
    pub action_uri_text: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FlowLogListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<FlowLog>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FlowLog {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<FlowLogPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FlowLogPropertiesFormat {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
    #[serde(rename = "targetResourceGuid", skip_serializing)]
    pub target_resource_guid: Option<String>,
    #[serde(rename = "storageId")]
    pub storage_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(rename = "retentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicyParameters>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<FlowLogFormatParameters>,
    #[serde(rename = "flowAnalyticsConfiguration", skip_serializing_if = "Option::is_none")]
    pub flow_analytics_configuration: Option<TrafficAnalyticsProperties>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FlowLogProperties {
    #[serde(rename = "storageId")]
    pub storage_id: String,
    pub enabled: bool,
    #[serde(rename = "retentionPolicy", skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicyParameters>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<FlowLogFormatParameters>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FlowLogStatusParameters {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RetentionPolicyParameters {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FlowLogFormatParameters {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<flow_log_format_parameters::Type>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i32>,
}
pub mod flow_log_format_parameters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        #[serde(rename = "JSON")]
        Json,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FlowLogInformation {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
    pub properties: FlowLogProperties,
    #[serde(rename = "flowAnalyticsConfiguration", skip_serializing_if = "Option::is_none")]
    pub flow_analytics_configuration: Option<TrafficAnalyticsProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrafficAnalyticsProperties {
    #[serde(rename = "networkWatcherFlowAnalyticsConfiguration", skip_serializing_if = "Option::is_none")]
    pub network_watcher_flow_analytics_configuration: Option<TrafficAnalyticsConfigurationProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrafficAnalyticsConfigurationProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(rename = "workspaceId", skip_serializing_if = "Option::is_none")]
    pub workspace_id: Option<String>,
    #[serde(rename = "workspaceRegion", skip_serializing_if = "Option::is_none")]
    pub workspace_region: Option<String>,
    #[serde(rename = "workspaceResourceId", skip_serializing_if = "Option::is_none")]
    pub workspace_resource_id: Option<String>,
    #[serde(rename = "trafficAnalyticsInterval", skip_serializing_if = "Option::is_none")]
    pub traffic_analytics_interval: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectivityParameters {
    pub source: ConnectivitySource,
    pub destination: ConnectivityDestination,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<connectivity_parameters::Protocol>,
    #[serde(rename = "protocolConfiguration", skip_serializing_if = "Option::is_none")]
    pub protocol_configuration: Option<ProtocolConfiguration>,
    #[serde(rename = "preferredIPVersion", skip_serializing_if = "Option::is_none")]
    pub preferred_ip_version: Option<IpVersion>,
}
pub mod connectivity_parameters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        Tcp,
        Http,
        Https,
        Icmp,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectivitySource {
    #[serde(rename = "resourceId")]
    pub resource_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectivityDestination {
    #[serde(rename = "resourceId", skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectivityInformation {
    #[serde(skip_serializing)]
    pub hops: Vec<ConnectivityHop>,
    #[serde(rename = "connectionStatus", skip_serializing)]
    pub connection_status: Option<connectivity_information::ConnectionStatus>,
    #[serde(rename = "avgLatencyInMs", skip_serializing)]
    pub avg_latency_in_ms: Option<i32>,
    #[serde(rename = "minLatencyInMs", skip_serializing)]
    pub min_latency_in_ms: Option<i32>,
    #[serde(rename = "maxLatencyInMs", skip_serializing)]
    pub max_latency_in_ms: Option<i32>,
    #[serde(rename = "probesSent", skip_serializing)]
    pub probes_sent: Option<i32>,
    #[serde(rename = "probesFailed", skip_serializing)]
    pub probes_failed: Option<i32>,
}
pub mod connectivity_information {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ConnectionStatus {
        Unknown,
        Connected,
        Disconnected,
        Degraded,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectivityHop {
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub address: Option<String>,
    #[serde(rename = "resourceId", skip_serializing)]
    pub resource_id: Option<String>,
    #[serde(rename = "nextHopIds", skip_serializing)]
    pub next_hop_ids: Vec<String>,
    #[serde(rename = "previousHopIds", skip_serializing)]
    pub previous_hop_ids: Vec<String>,
    #[serde(skip_serializing)]
    pub links: Vec<HopLink>,
    #[serde(rename = "previousLinks", skip_serializing)]
    pub previous_links: Vec<HopLink>,
    #[serde(skip_serializing)]
    pub issues: Vec<ConnectivityIssue>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HopLink {
    #[serde(rename = "nextHopId", skip_serializing)]
    pub next_hop_id: Option<String>,
    #[serde(rename = "linkType", skip_serializing)]
    pub link_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<HopLinkProperties>,
    #[serde(skip_serializing)]
    pub issues: Vec<ConnectivityIssue>,
    #[serde(skip_serializing)]
    pub context: Option<serde_json::Value>,
    #[serde(rename = "resourceId", skip_serializing)]
    pub resource_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HopLinkProperties {
    #[serde(rename = "roundTripTimeMin", skip_serializing)]
    pub round_trip_time_min: Option<i64>,
    #[serde(rename = "roundTripTimeAvg", skip_serializing)]
    pub round_trip_time_avg: Option<i64>,
    #[serde(rename = "roundTripTimeMax", skip_serializing)]
    pub round_trip_time_max: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectivityIssue {
    #[serde(skip_serializing)]
    pub origin: Option<connectivity_issue::Origin>,
    #[serde(skip_serializing)]
    pub severity: Option<connectivity_issue::Severity>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<connectivity_issue::Type>,
    #[serde(skip_serializing)]
    pub context: Vec<IssueContext>,
}
pub mod connectivity_issue {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Origin {
        Local,
        Inbound,
        Outbound,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Severity {
        Error,
        Warning,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Unknown,
        AgentStopped,
        GuestFirewall,
        DnsResolution,
        SocketBind,
        NetworkSecurityRule,
        UserDefinedRoute,
        PortThrottled,
        Platform,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IssueContext {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ProtocolConfiguration {
    #[serde(rename = "HTTPConfiguration", skip_serializing_if = "Option::is_none")]
    pub http_configuration: Option<HttpConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpConfiguration {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<http_configuration::Method>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub headers: Vec<HttpHeader>,
    #[serde(rename = "validStatusCodes", skip_serializing_if = "Vec::is_empty")]
    pub valid_status_codes: Vec<i32>,
}
pub mod http_configuration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Method {
        Get,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpHeader {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureReachabilityReportParameters {
    #[serde(rename = "providerLocation")]
    pub provider_location: AzureReachabilityReportLocation,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub providers: Vec<String>,
    #[serde(rename = "azureLocations", skip_serializing_if = "Vec::is_empty")]
    pub azure_locations: Vec<String>,
    #[serde(rename = "startTime")]
    pub start_time: String,
    #[serde(rename = "endTime")]
    pub end_time: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureReachabilityReportLocation {
    pub country: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureReachabilityReport {
    #[serde(rename = "aggregationLevel")]
    pub aggregation_level: String,
    #[serde(rename = "providerLocation")]
    pub provider_location: AzureReachabilityReportLocation,
    #[serde(rename = "reachabilityReport")]
    pub reachability_report: Vec<AzureReachabilityReportItem>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureReachabilityReportItem {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    #[serde(rename = "azureLocation", skip_serializing_if = "Option::is_none")]
    pub azure_location: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub latencies: Vec<AzureReachabilityReportLatencyInfo>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureReachabilityReportLatencyInfo {
    #[serde(rename = "timeStamp", skip_serializing_if = "Option::is_none")]
    pub time_stamp: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub score: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProvidersListParameters {
    #[serde(rename = "azureLocations", skip_serializing_if = "Vec::is_empty")]
    pub azure_locations: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProvidersList {
    pub countries: Vec<AvailableProvidersListCountry>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProvidersListCountry {
    #[serde(rename = "countryName", skip_serializing_if = "Option::is_none")]
    pub country_name: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub providers: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub states: Vec<AvailableProvidersListState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProvidersListState {
    #[serde(rename = "stateName", skip_serializing_if = "Option::is_none")]
    pub state_name: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub providers: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub cities: Vec<AvailableProvidersListCity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProvidersListCity {
    #[serde(rename = "cityName", skip_serializing_if = "Option::is_none")]
    pub city_name: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub providers: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkConfigurationDiagnosticParameters {
    #[serde(rename = "targetResourceId")]
    pub target_resource_id: String,
    #[serde(rename = "verbosityLevel", skip_serializing_if = "Option::is_none")]
    pub verbosity_level: Option<network_configuration_diagnostic_parameters::VerbosityLevel>,
    pub profiles: Vec<NetworkConfigurationDiagnosticProfile>,
}
pub mod network_configuration_diagnostic_parameters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VerbosityLevel {
        Normal,
        Minimum,
        Full,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkConfigurationDiagnosticProfile {
    pub direction: Direction,
    pub protocol: String,
    pub source: String,
    pub destination: String,
    #[serde(rename = "destinationPort")]
    pub destination_port: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkConfigurationDiagnosticResponse {
    #[serde(skip_serializing)]
    pub results: Vec<NetworkConfigurationDiagnosticResult>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkConfigurationDiagnosticResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub profile: Option<NetworkConfigurationDiagnosticProfile>,
    #[serde(rename = "networkSecurityGroupResult", skip_serializing_if = "Option::is_none")]
    pub network_security_group_result: Option<NetworkSecurityGroupResult>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSecurityGroupResult {
    #[serde(rename = "securityRuleAccessResult", skip_serializing_if = "Option::is_none")]
    pub security_rule_access_result: Option<SecurityRuleAccess>,
    #[serde(rename = "evaluatedNetworkSecurityGroups", skip_serializing)]
    pub evaluated_network_security_groups: Vec<EvaluatedNetworkSecurityGroup>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EvaluatedNetworkSecurityGroup {
    #[serde(rename = "networkSecurityGroupId", skip_serializing_if = "Option::is_none")]
    pub network_security_group_id: Option<String>,
    #[serde(rename = "appliedTo", skip_serializing_if = "Option::is_none")]
    pub applied_to: Option<String>,
    #[serde(rename = "matchedRule", skip_serializing_if = "Option::is_none")]
    pub matched_rule: Option<MatchedRule>,
    #[serde(rename = "rulesEvaluationResult", skip_serializing)]
    pub rules_evaluation_result: Vec<NetworkSecurityRulesEvaluationResult>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MatchedRule {
    #[serde(rename = "ruleName", skip_serializing_if = "Option::is_none")]
    pub rule_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSecurityRulesEvaluationResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "protocolMatched", skip_serializing_if = "Option::is_none")]
    pub protocol_matched: Option<bool>,
    #[serde(rename = "sourceMatched", skip_serializing_if = "Option::is_none")]
    pub source_matched: Option<bool>,
    #[serde(rename = "sourcePortMatched", skip_serializing_if = "Option::is_none")]
    pub source_port_matched: Option<bool>,
    #[serde(rename = "destinationMatched", skip_serializing_if = "Option::is_none")]
    pub destination_matched: Option<bool>,
    #[serde(rename = "destinationPortMatched", skip_serializing_if = "Option::is_none")]
    pub destination_port_matched: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum Direction {
    Inbound,
    Outbound,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitor {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    pub properties: ConnectionMonitorParameters,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorParameters {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<ConnectionMonitorSource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destination: Option<ConnectionMonitorDestination>,
    #[serde(rename = "autoStart", skip_serializing_if = "Option::is_none")]
    pub auto_start: Option<bool>,
    #[serde(rename = "monitoringIntervalInSeconds", skip_serializing_if = "Option::is_none")]
    pub monitoring_interval_in_seconds: Option<i32>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub endpoints: Vec<ConnectionMonitorEndpoint>,
    #[serde(rename = "testConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub test_configurations: Vec<ConnectionMonitorTestConfiguration>,
    #[serde(rename = "testGroups", skip_serializing_if = "Vec::is_empty")]
    pub test_groups: Vec<ConnectionMonitorTestGroup>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub outputs: Vec<ConnectionMonitorOutput>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notes: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorSource {
    #[serde(rename = "resourceId")]
    pub resource_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorDestination {
    #[serde(rename = "resourceId", skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorEndpoint {
    pub name: String,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<connection_monitor_endpoint::Type>,
    #[serde(rename = "resourceId", skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filter: Option<ConnectionMonitorEndpointFilter>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scope: Option<ConnectionMonitorEndpointScope>,
    #[serde(rename = "coverageLevel", skip_serializing_if = "Option::is_none")]
    pub coverage_level: Option<connection_monitor_endpoint::CoverageLevel>,
}
pub mod connection_monitor_endpoint {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        #[serde(rename = "AzureVM")]
        AzureVm,
        AzureVNet,
        AzureSubnet,
        ExternalAddress,
        #[serde(rename = "MMAWorkspaceMachine")]
        MmaWorkspaceMachine,
        #[serde(rename = "MMAWorkspaceNetwork")]
        MmaWorkspaceNetwork,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum CoverageLevel {
        Default,
        Low,
        BelowAverage,
        Average,
        AboveAverage,
        Full,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorEndpointScope {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub include: Vec<ConnectionMonitorEndpointScopeItem>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub exclude: Vec<ConnectionMonitorEndpointScopeItem>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorEndpointScopeItem {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorEndpointFilter {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<connection_monitor_endpoint_filter::Type>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub items: Vec<ConnectionMonitorEndpointFilterItem>,
}
pub mod connection_monitor_endpoint_filter {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Include,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorEndpointFilterItem {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<connection_monitor_endpoint_filter_item::Type>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}
pub mod connection_monitor_endpoint_filter_item {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        AgentAddress,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorTestGroup {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disable: Option<bool>,
    #[serde(rename = "testConfigurations")]
    pub test_configurations: Vec<String>,
    pub sources: Vec<String>,
    pub destinations: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorTestConfiguration {
    pub name: String,
    #[serde(rename = "testFrequencySec", skip_serializing_if = "Option::is_none")]
    pub test_frequency_sec: Option<i32>,
    pub protocol: connection_monitor_test_configuration::Protocol,
    #[serde(rename = "preferredIPVersion", skip_serializing_if = "Option::is_none")]
    pub preferred_ip_version: Option<connection_monitor_test_configuration::PreferredIpVersion>,
    #[serde(rename = "httpConfiguration", skip_serializing_if = "Option::is_none")]
    pub http_configuration: Option<ConnectionMonitorHttpConfiguration>,
    #[serde(rename = "tcpConfiguration", skip_serializing_if = "Option::is_none")]
    pub tcp_configuration: Option<ConnectionMonitorTcpConfiguration>,
    #[serde(rename = "icmpConfiguration", skip_serializing_if = "Option::is_none")]
    pub icmp_configuration: Option<ConnectionMonitorIcmpConfiguration>,
    #[serde(rename = "successThreshold", skip_serializing_if = "Option::is_none")]
    pub success_threshold: Option<ConnectionMonitorSuccessThreshold>,
}
pub mod connection_monitor_test_configuration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        Tcp,
        Http,
        Icmp,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PreferredIpVersion {
        IPv4,
        IPv6,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorHttpConfiguration {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<connection_monitor_http_configuration::Method>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(rename = "requestHeaders", skip_serializing_if = "Vec::is_empty")]
    pub request_headers: Vec<HttpHeader>,
    #[serde(rename = "validStatusCodeRanges", skip_serializing_if = "Vec::is_empty")]
    pub valid_status_code_ranges: Vec<String>,
    #[serde(rename = "preferHTTPS", skip_serializing_if = "Option::is_none")]
    pub prefer_https: Option<bool>,
}
pub mod connection_monitor_http_configuration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Method {
        Get,
        Post,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorTcpConfiguration {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(rename = "disableTraceRoute", skip_serializing_if = "Option::is_none")]
    pub disable_trace_route: Option<bool>,
    #[serde(rename = "destinationPortBehavior", skip_serializing_if = "Option::is_none")]
    pub destination_port_behavior: Option<connection_monitor_tcp_configuration::DestinationPortBehavior>,
}
pub mod connection_monitor_tcp_configuration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum DestinationPortBehavior {
        None,
        ListenIfAvailable,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorIcmpConfiguration {
    #[serde(rename = "disableTraceRoute", skip_serializing_if = "Option::is_none")]
    pub disable_trace_route: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorSuccessThreshold {
    #[serde(rename = "checksFailedPercent", skip_serializing_if = "Option::is_none")]
    pub checks_failed_percent: Option<i32>,
    #[serde(rename = "roundTripTimeMs", skip_serializing_if = "Option::is_none")]
    pub round_trip_time_ms: Option<f64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorOutput {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<connection_monitor_output::Type>,
    #[serde(rename = "workspaceSettings", skip_serializing_if = "Option::is_none")]
    pub workspace_settings: Option<ConnectionMonitorWorkspaceSettings>,
}
pub mod connection_monitor_output {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Workspace,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorWorkspaceSettings {
    #[serde(rename = "workspaceResourceId", skip_serializing_if = "Option::is_none")]
    pub workspace_resource_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionStateSnapshot {
    #[serde(rename = "connectionState", skip_serializing_if = "Option::is_none")]
    pub connection_state: Option<connection_state_snapshot::ConnectionState>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "evaluationState", skip_serializing_if = "Option::is_none")]
    pub evaluation_state: Option<connection_state_snapshot::EvaluationState>,
    #[serde(rename = "avgLatencyInMs", skip_serializing_if = "Option::is_none")]
    pub avg_latency_in_ms: Option<i64>,
    #[serde(rename = "minLatencyInMs", skip_serializing_if = "Option::is_none")]
    pub min_latency_in_ms: Option<i64>,
    #[serde(rename = "maxLatencyInMs", skip_serializing_if = "Option::is_none")]
    pub max_latency_in_ms: Option<i64>,
    #[serde(rename = "probesSent", skip_serializing_if = "Option::is_none")]
    pub probes_sent: Option<i64>,
    #[serde(rename = "probesFailed", skip_serializing_if = "Option::is_none")]
    pub probes_failed: Option<i64>,
    #[serde(skip_serializing)]
    pub hops: Vec<ConnectivityHop>,
}
pub mod connection_state_snapshot {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ConnectionState {
        Reachable,
        Unreachable,
        Unknown,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EvaluationState {
        NotStarted,
        InProgress,
        Completed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ConnectionMonitorResult>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorResult {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ConnectionMonitorResultProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorResultProperties {
    #[serde(flatten)]
    pub connection_monitor_parameters: ConnectionMonitorParameters,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<String>,
    #[serde(rename = "monitoringStatus", skip_serializing)]
    pub monitoring_status: Option<String>,
    #[serde(rename = "connectionMonitorType", skip_serializing)]
    pub connection_monitor_type: Option<connection_monitor_result_properties::ConnectionMonitorType>,
}
pub mod connection_monitor_result_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ConnectionMonitorType {
        MultiEndpoint,
        SingleSourceDestination,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionMonitorQueryResult {
    #[serde(rename = "sourceStatus", skip_serializing_if = "Option::is_none")]
    pub source_status: Option<connection_monitor_query_result::SourceStatus>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub states: Vec<ConnectionStateSnapshot>,
}
pub mod connection_monitor_query_result {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum SourceStatus {
        Unknown,
        Active,
        Inactive,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RoutePropertiesFormat {
    #[serde(rename = "addressPrefix", skip_serializing_if = "Option::is_none")]
    pub address_prefix: Option<String>,
    #[serde(rename = "nextHopType")]
    pub next_hop_type: RouteNextHopType,
    #[serde(rename = "nextHopIpAddress", skip_serializing_if = "Option::is_none")]
    pub next_hop_ip_address: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "hasBgpOverride", skip_serializing_if = "Option::is_none")]
    pub has_bgp_override: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Route {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<RoutePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteTablePropertiesFormat {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub routes: Vec<Route>,
    #[serde(skip_serializing)]
    pub subnets: Vec<Subnet>,
    #[serde(rename = "disableBgpRoutePropagation", skip_serializing_if = "Option::is_none")]
    pub disable_bgp_route_propagation: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteTable {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<RouteTablePropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteTableListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<RouteTable>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Route>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum RouteNextHopType {
    VirtualNetworkGateway,
    VnetLocal,
    Internet,
    VirtualAppliance,
    None,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceEndpointPolicyDefinitionPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    #[serde(rename = "serviceResources", skip_serializing_if = "Vec::is_empty")]
    pub service_resources: Vec<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceEndpointPolicyDefinition {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ServiceEndpointPolicyDefinitionPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceEndpointPolicyDefinitionListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ServiceEndpointPolicyDefinition>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceEndpointPolicyPropertiesFormat {
    #[serde(rename = "serviceEndpointPolicyDefinitions", skip_serializing_if = "Vec::is_empty")]
    pub service_endpoint_policy_definitions: Vec<ServiceEndpointPolicyDefinition>,
    #[serde(skip_serializing)]
    pub subnets: Vec<Subnet>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceEndpointPolicy {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ServiceEndpointPolicyPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceEndpointPolicyListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ServiceEndpointPolicy>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpoint {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(rename = "extendedLocation", skip_serializing_if = "Option::is_none")]
    pub extended_location: Option<ExtendedLocation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateEndpointProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<Subnet>,
    #[serde(rename = "networkInterfaces", skip_serializing)]
    pub network_interfaces: Vec<NetworkInterface>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "privateLinkServiceConnections", skip_serializing_if = "Vec::is_empty")]
    pub private_link_service_connections: Vec<PrivateLinkServiceConnection>,
    #[serde(rename = "manualPrivateLinkServiceConnections", skip_serializing_if = "Vec::is_empty")]
    pub manual_private_link_service_connections: Vec<PrivateLinkServiceConnection>,
    #[serde(rename = "customDnsConfigs", skip_serializing_if = "Vec::is_empty")]
    pub custom_dns_configs: Vec<CustomDnsConfigPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomDnsConfigPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[serde(rename = "ipAddresses", skip_serializing_if = "Vec::is_empty")]
    pub ip_addresses: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateLinkServiceConnectionProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceConnectionProperties {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "privateLinkServiceId", skip_serializing_if = "Option::is_none")]
    pub private_link_service_id: Option<String>,
    #[serde(rename = "groupIds", skip_serializing_if = "Vec::is_empty")]
    pub group_ids: Vec<String>,
    #[serde(rename = "requestMessage", skip_serializing_if = "Option::is_none")]
    pub request_message: Option<String>,
    #[serde(rename = "privateLinkServiceConnectionState", skip_serializing_if = "Option::is_none")]
    pub private_link_service_connection_state: Option<PrivateLinkServiceConnectionState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateEndpoint>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateDnsZoneGroupListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateDnsZoneGroup>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailablePrivateEndpointTypesResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AvailablePrivateEndpointType>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailablePrivateEndpointType {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[serde(rename = "resourceName", skip_serializing_if = "Option::is_none")]
    pub resource_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateDnsZoneGroup {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateDnsZoneGroupPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateDnsZoneGroupPropertiesFormat {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "privateDnsZoneConfigs", skip_serializing_if = "Vec::is_empty")]
    pub private_dns_zone_configs: Vec<PrivateDnsZoneConfig>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateDnsZoneConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateDnsZonePropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateDnsZonePropertiesFormat {
    #[serde(rename = "privateDnsZoneId", skip_serializing_if = "Option::is_none")]
    pub private_dns_zone_id: Option<String>,
    #[serde(rename = "recordSets", skip_serializing)]
    pub record_sets: Vec<RecordSet>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RecordSet {
    #[serde(rename = "recordType", skip_serializing_if = "Option::is_none")]
    pub record_type: Option<String>,
    #[serde(rename = "recordSetName", skip_serializing_if = "Option::is_none")]
    pub record_set_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
    #[serde(rename = "ipAddresses", skip_serializing_if = "Vec::is_empty")]
    pub ip_addresses: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkService {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(rename = "extendedLocation", skip_serializing_if = "Option::is_none")]
    pub extended_location: Option<ExtendedLocation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateLinkServiceProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceProperties {
    #[serde(rename = "loadBalancerFrontendIpConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub load_balancer_frontend_ip_configurations: Vec<FrontendIpConfiguration>,
    #[serde(rename = "ipConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub ip_configurations: Vec<PrivateLinkServiceIpConfiguration>,
    #[serde(rename = "networkInterfaces", skip_serializing)]
    pub network_interfaces: Vec<NetworkInterface>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "privateEndpointConnections", skip_serializing)]
    pub private_endpoint_connections: Vec<PrivateEndpointConnection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub visibility: Option<serde_json::Value>,
    #[serde(rename = "autoApproval", skip_serializing_if = "Option::is_none")]
    pub auto_approval: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub fqdns: Vec<String>,
    #[serde(skip_serializing)]
    pub alias: Option<String>,
    #[serde(rename = "enableProxyProtocol", skip_serializing_if = "Option::is_none")]
    pub enable_proxy_protocol: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ResourceSet {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub subscriptions: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateLinkServiceIpConfigurationProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceIpConfigurationProperties {
    #[serde(rename = "privateIPAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<Subnet>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "privateIPAddressVersion", skip_serializing_if = "Option::is_none")]
    pub private_ip_address_version: Option<IpVersion>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PrivateEndpointConnectionProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnectionProperties {
    #[serde(rename = "privateEndpoint", skip_serializing_if = "Option::is_none")]
    pub private_endpoint: Option<PrivateEndpoint>,
    #[serde(rename = "privateLinkServiceConnectionState", skip_serializing_if = "Option::is_none")]
    pub private_link_service_connection_state: Option<PrivateLinkServiceConnectionState>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "linkIdentifier", skip_serializing)]
    pub link_identifier: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceConnectionState {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "actionsRequired", skip_serializing_if = "Option::is_none")]
    pub actions_required: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateLinkService>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateEndpointConnectionListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PrivateEndpointConnection>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CheckPrivateLinkServiceVisibilityRequest {
    #[serde(rename = "privateLinkServiceAlias", skip_serializing_if = "Option::is_none")]
    pub private_link_service_alias: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PrivateLinkServiceVisibility {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub visible: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AutoApprovedPrivateLinkServicesResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AutoApprovedPrivateLinkService>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AutoApprovedPrivateLinkService {
    #[serde(rename = "privateLinkService", skip_serializing_if = "Option::is_none")]
    pub private_link_service: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkProfilePropertiesFormat {
    #[serde(rename = "containerNetworkInterfaces", skip_serializing)]
    pub container_network_interfaces: Vec<ContainerNetworkInterface>,
    #[serde(rename = "containerNetworkInterfaceConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub container_network_interface_configurations: Vec<ContainerNetworkInterfaceConfiguration>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkProfile {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NetworkProfilePropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkProfileListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NetworkProfile>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerNetworkInterfacePropertiesFormat {
    #[serde(rename = "containerNetworkInterfaceConfiguration", skip_serializing_if = "Option::is_none")]
    pub container_network_interface_configuration: Option<ContainerNetworkInterfaceConfiguration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub container: Option<Container>,
    #[serde(rename = "ipConfigurations", skip_serializing)]
    pub ip_configurations: Vec<ContainerNetworkInterfaceIpConfiguration>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerNetworkInterface {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ContainerNetworkInterfacePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerNetworkInterfaceConfigurationPropertiesFormat {
    #[serde(rename = "ipConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub ip_configurations: Vec<IpConfigurationProfile>,
    #[serde(rename = "containerNetworkInterfaces", skip_serializing_if = "Vec::is_empty")]
    pub container_network_interfaces: Vec<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerNetworkInterfaceConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ContainerNetworkInterfaceConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpConfigurationProfilePropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<Subnet>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpConfigurationProfile {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<IpConfigurationProfilePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Container {
    #[serde(flatten)]
    pub sub_resource: SubResource,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerNetworkInterfaceIpConfigurationPropertiesFormat {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContainerNetworkInterfaceIpConfiguration {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ContainerNetworkInterfaceIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpAddressSku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<public_ip_address_sku::Name>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<public_ip_address_sku::Tier>,
}
pub mod public_ip_address_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        Basic,
        Standard,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Regional,
        Global,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpAddressPropertiesFormat {
    #[serde(rename = "publicIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub public_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(rename = "publicIPAddressVersion", skip_serializing_if = "Option::is_none")]
    pub public_ip_address_version: Option<IpVersion>,
    #[serde(rename = "ipConfiguration", skip_serializing_if = "Option::is_none")]
    pub ip_configuration: Box<Option<IpConfiguration>>,
    #[serde(rename = "dnsSettings", skip_serializing_if = "Option::is_none")]
    pub dns_settings: Option<PublicIpAddressDnsSettings>,
    #[serde(rename = "ddosSettings", skip_serializing_if = "Option::is_none")]
    pub ddos_settings: Option<DdosSettings>,
    #[serde(rename = "ipTags", skip_serializing_if = "Vec::is_empty")]
    pub ip_tags: Vec<IpTag>,
    #[serde(rename = "ipAddress", skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    #[serde(rename = "publicIPPrefix", skip_serializing_if = "Option::is_none")]
    pub public_ip_prefix: Option<SubResource>,
    #[serde(rename = "idleTimeoutInMinutes", skip_serializing_if = "Option::is_none")]
    pub idle_timeout_in_minutes: Option<i32>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "servicePublicIPAddress", skip_serializing_if = "Option::is_none")]
    pub service_public_ip_address: Option<PublicIpAddress>,
    #[serde(rename = "natGateway", skip_serializing_if = "Option::is_none")]
    pub nat_gateway: Option<NatGateway>,
    #[serde(rename = "migrationPhase", skip_serializing_if = "Option::is_none")]
    pub migration_phase: Option<public_ip_address_properties_format::MigrationPhase>,
    #[serde(rename = "linkedPublicIPAddress", skip_serializing_if = "Option::is_none")]
    pub linked_public_ip_address: Option<PublicIpAddress>,
}
pub mod public_ip_address_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum MigrationPhase {
        None,
        Prepare,
        Commit,
        Abort,
        Committed,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpAddress {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(rename = "extendedLocation", skip_serializing_if = "Option::is_none")]
    pub extended_location: Option<ExtendedLocation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<PublicIpAddressSku>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PublicIpAddressPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub zones: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpAddressListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PublicIpAddress>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpAddressDnsSettings {
    #[serde(rename = "domainNameLabel", skip_serializing_if = "Option::is_none")]
    pub domain_name_label: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[serde(rename = "reverseFqdn", skip_serializing_if = "Option::is_none")]
    pub reverse_fqdn: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DdosSettings {
    #[serde(rename = "ddosCustomPolicy", skip_serializing_if = "Option::is_none")]
    pub ddos_custom_policy: Option<SubResource>,
    #[serde(rename = "protectionCoverage", skip_serializing_if = "Option::is_none")]
    pub protection_coverage: Option<ddos_settings::ProtectionCoverage>,
    #[serde(rename = "protectedIP", skip_serializing_if = "Option::is_none")]
    pub protected_ip: Option<bool>,
}
pub mod ddos_settings {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProtectionCoverage {
        Basic,
        Standard,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpTag {
    #[serde(rename = "ipTagType", skip_serializing_if = "Option::is_none")]
    pub ip_tag_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NatGatewaySku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<nat_gateway_sku::Name>,
}
pub mod nat_gateway_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        Standard,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NatGatewayPropertiesFormat {
    #[serde(rename = "idleTimeoutInMinutes", skip_serializing_if = "Option::is_none")]
    pub idle_timeout_in_minutes: Option<i32>,
    #[serde(rename = "publicIpAddresses", skip_serializing_if = "Vec::is_empty")]
    pub public_ip_addresses: Vec<SubResource>,
    #[serde(rename = "publicIpPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub public_ip_prefixes: Vec<SubResource>,
    #[serde(skip_serializing)]
    pub subnets: Vec<SubResource>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NatGateway {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<NatGatewaySku>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NatGatewayPropertiesFormat>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub zones: Vec<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NatGatewayListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NatGateway>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableDelegationsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AvailableDelegation>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableDelegation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[serde(rename = "serviceName", skip_serializing_if = "Option::is_none")]
    pub service_name: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub actions: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableServiceAlias {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[serde(rename = "resourceName", skip_serializing_if = "Option::is_none")]
    pub resource_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableServiceAliasesResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AvailableServiceAlias>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallIpConfigurationPropertiesFormat {
    #[serde(rename = "privateIPAddress", skip_serializing)]
    pub private_ip_address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<SubResource>,
    #[serde(rename = "publicIPAddress", skip_serializing_if = "Option::is_none")]
    pub public_ip_address: Option<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AzureFirewallIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallPublicIpAddress {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallIpGroups {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(rename = "changeNumber", skip_serializing)]
    pub change_number: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubPublicIpAddresses {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub addresses: Vec<AzureFirewallPublicIpAddress>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubIpAddresses {
    #[serde(rename = "publicIPs", skip_serializing_if = "Option::is_none")]
    pub public_i_ps: Option<HubPublicIpAddresses>,
    #[serde(rename = "privateIPAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
}
pub type IpGroups = Vec<AzureFirewallIpGroups>;
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallPropertiesFormat {
    #[serde(rename = "applicationRuleCollections", skip_serializing_if = "Vec::is_empty")]
    pub application_rule_collections: Vec<AzureFirewallApplicationRuleCollection>,
    #[serde(rename = "natRuleCollections", skip_serializing_if = "Vec::is_empty")]
    pub nat_rule_collections: Vec<AzureFirewallNatRuleCollection>,
    #[serde(rename = "networkRuleCollections", skip_serializing_if = "Vec::is_empty")]
    pub network_rule_collections: Vec<AzureFirewallNetworkRuleCollection>,
    #[serde(rename = "ipConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub ip_configurations: Vec<AzureFirewallIpConfiguration>,
    #[serde(rename = "managementIpConfiguration", skip_serializing_if = "Option::is_none")]
    pub management_ip_configuration: Option<AzureFirewallIpConfiguration>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "threatIntelMode", skip_serializing_if = "Option::is_none")]
    pub threat_intel_mode: Option<AzureFirewallThreatIntelMode>,
    #[serde(rename = "virtualHub", skip_serializing_if = "Option::is_none")]
    pub virtual_hub: Option<SubResource>,
    #[serde(rename = "firewallPolicy", skip_serializing_if = "Option::is_none")]
    pub firewall_policy: Option<SubResource>,
    #[serde(rename = "hubIPAddresses", skip_serializing_if = "Option::is_none")]
    pub hub_ip_addresses: Option<HubIpAddresses>,
    #[serde(rename = "ipGroups", skip_serializing_if = "Option::is_none")]
    pub ip_groups: Option<IpGroups>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<AzureFirewallSku>,
    #[serde(rename = "additionalProperties", skip_serializing_if = "Option::is_none")]
    pub additional_properties: Option<AzureFirewallAdditionalProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewall {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AzureFirewallPropertiesFormat>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub zones: Vec<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AzureFirewall>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AzureFirewallThreatIntelMode {
    Alert,
    Deny,
    Off,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallAdditionalProperties {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallApplicationRuleCollectionPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<AzureFirewallRcAction>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<AzureFirewallApplicationRule>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallApplicationRuleCollection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AzureFirewallApplicationRuleCollectionPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallApplicationRuleProtocol {
    #[serde(rename = "protocolType", skip_serializing_if = "Option::is_none")]
    pub protocol_type: Option<AzureFirewallApplicationRuleProtocolType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallApplicationRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "sourceAddresses", skip_serializing_if = "Vec::is_empty")]
    pub source_addresses: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub protocols: Vec<AzureFirewallApplicationRuleProtocol>,
    #[serde(rename = "targetFqdns", skip_serializing_if = "Vec::is_empty")]
    pub target_fqdns: Vec<String>,
    #[serde(rename = "fqdnTags", skip_serializing_if = "Vec::is_empty")]
    pub fqdn_tags: Vec<String>,
    #[serde(rename = "sourceIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub source_ip_groups: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallNatRuleCollectionProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<AzureFirewallNatRcAction>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<AzureFirewallNatRule>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallNatRuleCollection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AzureFirewallNatRuleCollectionProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallNatRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "sourceAddresses", skip_serializing_if = "Vec::is_empty")]
    pub source_addresses: Vec<String>,
    #[serde(rename = "destinationAddresses", skip_serializing_if = "Vec::is_empty")]
    pub destination_addresses: Vec<String>,
    #[serde(rename = "destinationPorts", skip_serializing_if = "Vec::is_empty")]
    pub destination_ports: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub protocols: Vec<AzureFirewallNetworkRuleProtocol>,
    #[serde(rename = "translatedAddress", skip_serializing_if = "Option::is_none")]
    pub translated_address: Option<String>,
    #[serde(rename = "translatedPort", skip_serializing_if = "Option::is_none")]
    pub translated_port: Option<String>,
    #[serde(rename = "translatedFqdn", skip_serializing_if = "Option::is_none")]
    pub translated_fqdn: Option<String>,
    #[serde(rename = "sourceIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub source_ip_groups: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallNatRcAction {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<AzureFirewallNatRcActionType>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AzureFirewallNatRcActionType {
    Snat,
    Dnat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallNetworkRuleCollectionPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<AzureFirewallRcAction>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<AzureFirewallNetworkRule>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallNetworkRuleCollection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AzureFirewallNetworkRuleCollectionPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallNetworkRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub protocols: Vec<AzureFirewallNetworkRuleProtocol>,
    #[serde(rename = "sourceAddresses", skip_serializing_if = "Vec::is_empty")]
    pub source_addresses: Vec<String>,
    #[serde(rename = "destinationAddresses", skip_serializing_if = "Vec::is_empty")]
    pub destination_addresses: Vec<String>,
    #[serde(rename = "destinationPorts", skip_serializing_if = "Vec::is_empty")]
    pub destination_ports: Vec<String>,
    #[serde(rename = "destinationFqdns", skip_serializing_if = "Vec::is_empty")]
    pub destination_fqdns: Vec<String>,
    #[serde(rename = "sourceIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub source_ip_groups: Vec<String>,
    #[serde(rename = "destinationIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub destination_ip_groups: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallRcAction {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<AzureFirewallRcActionType>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AzureFirewallRcActionType {
    Allow,
    Deny,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AzureFirewallNetworkRuleProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    Any,
    #[serde(rename = "ICMP")]
    Icmp,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AzureFirewallApplicationRuleProtocolType {
    Http,
    Https,
    Mssql,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallSku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<azure_firewall_sku::Name>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<azure_firewall_sku::Tier>,
}
pub mod azure_firewall_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        #[serde(rename = "AZFW_VNet")]
        AzfwVNet,
        #[serde(rename = "AZFW_Hub")]
        AzfwHub,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Standard,
        Premium,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallFqdnTagPropertiesFormat {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "fqdnTagName", skip_serializing)]
    pub fqdn_tag_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallFqdnTag {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AzureFirewallFqdnTagPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureFirewallFqdnTagListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AzureFirewallFqdnTag>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureWebCategoryPropertiesFormat {
    #[serde(skip_serializing)]
    pub group: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureWebCategory {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AzureWebCategoryPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureWebCategoryListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<AzureWebCategory>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionHostIpConfigurationPropertiesFormat {
    pub subnet: SubResource,
    #[serde(rename = "publicIPAddress")]
    pub public_ip_address: SubResource,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionHostIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<BastionHostIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionHostPropertiesFormat {
    #[serde(rename = "ipConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub ip_configurations: Vec<BastionHostIpConfiguration>,
    #[serde(rename = "dnsName", skip_serializing_if = "Option::is_none")]
    pub dns_name: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionHost {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<BastionHostPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionHostListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BastionHost>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionShareableLink {
    pub vm: Vm,
    #[serde(skip_serializing)]
    pub bsl: Option<String>,
    #[serde(rename = "createdAt", skip_serializing)]
    pub created_at: Option<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionShareableLinkListRequest {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub vms: Vec<BastionShareableLink>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionShareableLinkListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BastionShareableLink>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionActiveSession {
    #[serde(rename = "sessionId", skip_serializing)]
    pub session_id: Option<String>,
    #[serde(rename = "startTime", skip_serializing)]
    pub start_time: Option<serde_json::Value>,
    #[serde(rename = "targetSubscriptionId", skip_serializing)]
    pub target_subscription_id: Option<String>,
    #[serde(rename = "resourceType", skip_serializing)]
    pub resource_type: Option<String>,
    #[serde(rename = "targetHostName", skip_serializing)]
    pub target_host_name: Option<String>,
    #[serde(rename = "targetResourceGroup", skip_serializing)]
    pub target_resource_group: Option<String>,
    #[serde(rename = "userName", skip_serializing)]
    pub user_name: Option<String>,
    #[serde(rename = "targetIpAddress", skip_serializing)]
    pub target_ip_address: Option<String>,
    #[serde(skip_serializing)]
    pub protocol: Option<bastion_active_session::Protocol>,
    #[serde(rename = "targetResourceId", skip_serializing)]
    pub target_resource_id: Option<String>,
    #[serde(rename = "sessionDurationInMins", skip_serializing)]
    pub session_duration_in_mins: Option<f64>,
}
pub mod bastion_active_session {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        #[serde(rename = "SSH")]
        Ssh,
        #[serde(rename = "RDP")]
        Rdp,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionActiveSessionListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BastionActiveSession>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionSessionState {
    #[serde(rename = "sessionId", skip_serializing)]
    pub session_id: Option<String>,
    #[serde(skip_serializing)]
    pub message: Option<String>,
    #[serde(skip_serializing)]
    pub state: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BastionSessionDeleteResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BastionSessionState>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Vm {
    #[serde(flatten)]
    pub resource: Resource,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SessionIds {
    #[serde(rename = "sessionIds", skip_serializing_if = "Vec::is_empty")]
    pub session_ids: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DnsNameAvailabilityResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub available: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomIpPrefixPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(rename = "commissionedState", skip_serializing_if = "Option::is_none")]
    pub commissioned_state: Option<custom_ip_prefix_properties_format::CommissionedState>,
    #[serde(rename = "publicIpPrefixes", skip_serializing)]
    pub public_ip_prefixes: Vec<SubResource>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod custom_ip_prefix_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum CommissionedState {
        Provisioning,
        Provisioned,
        Commissioning,
        Commissioned,
        Decommissioning,
        Deprovisioning,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomIpPrefix {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(rename = "extendedLocation", skip_serializing_if = "Option::is_none")]
    pub extended_location: Option<ExtendedLocation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<CustomIpPrefixPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub zones: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CustomIpPrefixListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<CustomIpPrefix>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DdosCustomPolicy {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<DdosCustomPolicyPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DdosCustomPolicyPropertiesFormat {
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "publicIPAddresses", skip_serializing)]
    pub public_ip_addresses: Vec<SubResource>,
    #[serde(rename = "protocolCustomSettings", skip_serializing_if = "Vec::is_empty")]
    pub protocol_custom_settings: Vec<ProtocolCustomSettingsFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ProtocolCustomSettingsFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<protocol_custom_settings_format::Protocol>,
    #[serde(rename = "triggerRateOverride", skip_serializing_if = "Option::is_none")]
    pub trigger_rate_override: Option<String>,
    #[serde(rename = "sourceRateOverride", skip_serializing_if = "Option::is_none")]
    pub source_rate_override: Option<String>,
    #[serde(rename = "triggerSensitivityOverride", skip_serializing_if = "Option::is_none")]
    pub trigger_sensitivity_override: Option<protocol_custom_settings_format::TriggerSensitivityOverride>,
}
pub mod protocol_custom_settings_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        Tcp,
        Udp,
        Syn,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum TriggerSensitivityOverride {
        Relaxed,
        Low,
        Default,
        High,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DdosProtectionPlan {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<DdosProtectionPlanPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DdosProtectionPlanPropertiesFormat {
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "virtualNetworks", skip_serializing)]
    pub virtual_networks: Vec<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DdosProtectionPlanListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<DdosProtectionPlan>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DscpConfiguration {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<DscpConfigurationPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DscpConfigurationPropertiesFormat {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub markings: Vec<i32>,
    #[serde(rename = "sourceIpRanges", skip_serializing_if = "Vec::is_empty")]
    pub source_ip_ranges: Vec<QosIpRange>,
    #[serde(rename = "destinationIpRanges", skip_serializing_if = "Vec::is_empty")]
    pub destination_ip_ranges: Vec<QosIpRange>,
    #[serde(rename = "sourcePortRanges", skip_serializing_if = "Vec::is_empty")]
    pub source_port_ranges: Vec<QosPortRange>,
    #[serde(rename = "destinationPortRanges", skip_serializing_if = "Vec::is_empty")]
    pub destination_port_ranges: Vec<QosPortRange>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<dscp_configuration_properties_format::Protocol>,
    #[serde(rename = "qosCollectionId", skip_serializing)]
    pub qos_collection_id: Option<String>,
    #[serde(rename = "associatedNetworkInterfaces", skip_serializing)]
    pub associated_network_interfaces: Vec<NetworkInterface>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod dscp_configuration_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        DoNotUse,
        Icmp,
        Tcp,
        Udp,
        Gre,
        Esp,
        Ah,
        Vxlan,
        All,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QosIpRange {
    #[serde(rename = "startIP", skip_serializing_if = "Option::is_none")]
    pub start_ip: Option<String>,
    #[serde(rename = "endIP", skip_serializing_if = "Option::is_none")]
    pub end_ip: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct QosPortRange {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DscpConfigurationListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<DscpConfiguration>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EndpointServicesListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<EndpointServiceResult>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EndpointServiceResult {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AuthorizationPropertiesFormat {
    #[serde(rename = "authorizationKey", skip_serializing_if = "Option::is_none")]
    pub authorization_key: Option<String>,
    #[serde(rename = "authorizationUseStatus", skip_serializing_if = "Option::is_none")]
    pub authorization_use_status: Option<authorization_properties_format::AuthorizationUseStatus>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod authorization_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthorizationUseStatus {
        Available,
        InUse,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitAuthorization {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AuthorizationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AuthorizationListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCircuitAuthorization>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitPeeringConfig {
    #[serde(rename = "advertisedPublicPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub advertised_public_prefixes: Vec<String>,
    #[serde(rename = "advertisedCommunities", skip_serializing_if = "Vec::is_empty")]
    pub advertised_communities: Vec<String>,
    #[serde(rename = "advertisedPublicPrefixesState", skip_serializing)]
    pub advertised_public_prefixes_state: Option<express_route_circuit_peering_config::AdvertisedPublicPrefixesState>,
    #[serde(rename = "legacyMode", skip_serializing_if = "Option::is_none")]
    pub legacy_mode: Option<i32>,
    #[serde(rename = "customerASN", skip_serializing_if = "Option::is_none")]
    pub customer_asn: Option<i32>,
    #[serde(rename = "routingRegistryName", skip_serializing_if = "Option::is_none")]
    pub routing_registry_name: Option<String>,
}
pub mod express_route_circuit_peering_config {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AdvertisedPublicPrefixesState {
        NotConfigured,
        Configuring,
        Configured,
        ValidationNeeded,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Ipv6ExpressRouteCircuitPeeringConfig {
    #[serde(rename = "primaryPeerAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub primary_peer_address_prefix: Option<String>,
    #[serde(rename = "secondaryPeerAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub secondary_peer_address_prefix: Option<String>,
    #[serde(rename = "microsoftPeeringConfig", skip_serializing_if = "Option::is_none")]
    pub microsoft_peering_config: Option<ExpressRouteCircuitPeeringConfig>,
    #[serde(rename = "routeFilter", skip_serializing_if = "Option::is_none")]
    pub route_filter: Option<SubResource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<ipv6_express_route_circuit_peering_config::State>,
}
pub mod ipv6_express_route_circuit_peering_config {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Disabled,
        Enabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitStats {
    #[serde(rename = "primarybytesIn", skip_serializing_if = "Option::is_none")]
    pub primarybytes_in: Option<i64>,
    #[serde(rename = "primarybytesOut", skip_serializing_if = "Option::is_none")]
    pub primarybytes_out: Option<i64>,
    #[serde(rename = "secondarybytesIn", skip_serializing_if = "Option::is_none")]
    pub secondarybytes_in: Option<i64>,
    #[serde(rename = "secondarybytesOut", skip_serializing_if = "Option::is_none")]
    pub secondarybytes_out: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitPeeringPropertiesFormat {
    #[serde(rename = "peeringType", skip_serializing_if = "Option::is_none")]
    pub peering_type: Option<ExpressRoutePeeringType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<ExpressRoutePeeringState>,
    #[serde(rename = "azureASN", skip_serializing_if = "Option::is_none")]
    pub azure_asn: Option<i32>,
    #[serde(rename = "peerASN", skip_serializing_if = "Option::is_none")]
    pub peer_asn: Option<i64>,
    #[serde(rename = "primaryPeerAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub primary_peer_address_prefix: Option<String>,
    #[serde(rename = "secondaryPeerAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub secondary_peer_address_prefix: Option<String>,
    #[serde(rename = "primaryAzurePort", skip_serializing_if = "Option::is_none")]
    pub primary_azure_port: Option<String>,
    #[serde(rename = "secondaryAzurePort", skip_serializing_if = "Option::is_none")]
    pub secondary_azure_port: Option<String>,
    #[serde(rename = "sharedKey", skip_serializing_if = "Option::is_none")]
    pub shared_key: Option<String>,
    #[serde(rename = "vlanId", skip_serializing_if = "Option::is_none")]
    pub vlan_id: Option<i32>,
    #[serde(rename = "microsoftPeeringConfig", skip_serializing_if = "Option::is_none")]
    pub microsoft_peering_config: Option<ExpressRouteCircuitPeeringConfig>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stats: Option<ExpressRouteCircuitStats>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "gatewayManagerEtag", skip_serializing_if = "Option::is_none")]
    pub gateway_manager_etag: Option<String>,
    #[serde(rename = "lastModifiedBy", skip_serializing)]
    pub last_modified_by: Option<String>,
    #[serde(rename = "routeFilter", skip_serializing_if = "Option::is_none")]
    pub route_filter: Option<SubResource>,
    #[serde(rename = "ipv6PeeringConfig", skip_serializing_if = "Option::is_none")]
    pub ipv6_peering_config: Option<Ipv6ExpressRouteCircuitPeeringConfig>,
    #[serde(rename = "expressRouteConnection", skip_serializing_if = "Option::is_none")]
    pub express_route_connection: Option<ExpressRouteConnectionId>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub connections: Vec<ExpressRouteCircuitConnection>,
    #[serde(rename = "peeredConnections", skip_serializing)]
    pub peered_connections: Vec<PeerExpressRouteCircuitConnection>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitPeering {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteCircuitPeeringPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitPeeringListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCircuitPeering>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ExpressRoutePeeringType {
    AzurePublicPeering,
    AzurePrivatePeering,
    MicrosoftPeering,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ExpressRoutePeeringState {
    Disabled,
    Enabled,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Ipv6CircuitConnectionConfig {
    #[serde(rename = "addressPrefix", skip_serializing_if = "Option::is_none")]
    pub address_prefix: Option<String>,
    #[serde(rename = "circuitConnectionStatus", skip_serializing)]
    pub circuit_connection_status: Option<CircuitConnectionStatus>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitConnectionPropertiesFormat {
    #[serde(rename = "expressRouteCircuitPeering", skip_serializing_if = "Option::is_none")]
    pub express_route_circuit_peering: Option<SubResource>,
    #[serde(rename = "peerExpressRouteCircuitPeering", skip_serializing_if = "Option::is_none")]
    pub peer_express_route_circuit_peering: Option<SubResource>,
    #[serde(rename = "addressPrefix", skip_serializing_if = "Option::is_none")]
    pub address_prefix: Option<String>,
    #[serde(rename = "authorizationKey", skip_serializing_if = "Option::is_none")]
    pub authorization_key: Option<String>,
    #[serde(rename = "ipv6CircuitConnectionConfig", skip_serializing_if = "Option::is_none")]
    pub ipv6_circuit_connection_config: Option<Ipv6CircuitConnectionConfig>,
    #[serde(rename = "circuitConnectionStatus", skip_serializing)]
    pub circuit_connection_status: Option<CircuitConnectionStatus>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteCircuitConnectionPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitConnectionListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCircuitConnection>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PeerExpressRouteCircuitConnectionPropertiesFormat {
    #[serde(rename = "expressRouteCircuitPeering", skip_serializing_if = "Option::is_none")]
    pub express_route_circuit_peering: Option<SubResource>,
    #[serde(rename = "peerExpressRouteCircuitPeering", skip_serializing_if = "Option::is_none")]
    pub peer_express_route_circuit_peering: Option<SubResource>,
    #[serde(rename = "addressPrefix", skip_serializing_if = "Option::is_none")]
    pub address_prefix: Option<String>,
    #[serde(rename = "circuitConnectionStatus", skip_serializing)]
    pub circuit_connection_status: Option<CircuitConnectionStatus>,
    #[serde(rename = "connectionName", skip_serializing_if = "Option::is_none")]
    pub connection_name: Option<String>,
    #[serde(rename = "authResourceGuid", skip_serializing_if = "Option::is_none")]
    pub auth_resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PeerExpressRouteCircuitConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PeerExpressRouteCircuitConnectionPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PeerExpressRouteCircuitConnectionListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PeerExpressRouteCircuitConnection>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitSku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<express_route_circuit_sku::Tier>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub family: Option<express_route_circuit_sku::Family>,
}
pub mod express_route_circuit_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Standard,
        Premium,
        Basic,
        Local,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Family {
        UnlimitedData,
        MeteredData,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitServiceProviderProperties {
    #[serde(rename = "serviceProviderName", skip_serializing_if = "Option::is_none")]
    pub service_provider_name: Option<String>,
    #[serde(rename = "peeringLocation", skip_serializing_if = "Option::is_none")]
    pub peering_location: Option<String>,
    #[serde(rename = "bandwidthInMbps", skip_serializing_if = "Option::is_none")]
    pub bandwidth_in_mbps: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitPropertiesFormat {
    #[serde(rename = "allowClassicOperations", skip_serializing_if = "Option::is_none")]
    pub allow_classic_operations: Option<bool>,
    #[serde(rename = "circuitProvisioningState", skip_serializing_if = "Option::is_none")]
    pub circuit_provisioning_state: Option<String>,
    #[serde(rename = "serviceProviderProvisioningState", skip_serializing_if = "Option::is_none")]
    pub service_provider_provisioning_state: Option<ServiceProviderProvisioningState>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub authorizations: Vec<ExpressRouteCircuitAuthorization>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub peerings: Vec<ExpressRouteCircuitPeering>,
    #[serde(rename = "serviceKey", skip_serializing_if = "Option::is_none")]
    pub service_key: Option<String>,
    #[serde(rename = "serviceProviderNotes", skip_serializing_if = "Option::is_none")]
    pub service_provider_notes: Option<String>,
    #[serde(rename = "serviceProviderProperties", skip_serializing_if = "Option::is_none")]
    pub service_provider_properties: Option<ExpressRouteCircuitServiceProviderProperties>,
    #[serde(rename = "expressRoutePort", skip_serializing_if = "Option::is_none")]
    pub express_route_port: Option<SubResource>,
    #[serde(rename = "bandwidthInGbps", skip_serializing_if = "Option::is_none")]
    pub bandwidth_in_gbps: Option<f64>,
    #[serde(skip_serializing)]
    pub stag: Option<i32>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "gatewayManagerEtag", skip_serializing_if = "Option::is_none")]
    pub gateway_manager_etag: Option<String>,
    #[serde(rename = "globalReachEnabled", skip_serializing_if = "Option::is_none")]
    pub global_reach_enabled: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuit {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<ExpressRouteCircuitSku>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteCircuitPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitArpTable {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interface: Option<String>,
    #[serde(rename = "ipAddress", skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    #[serde(rename = "macAddress", skip_serializing_if = "Option::is_none")]
    pub mac_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitsArpTableListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCircuitArpTable>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitRoutesTable {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    #[serde(rename = "nextHop", skip_serializing_if = "Option::is_none")]
    pub next_hop: Option<String>,
    #[serde(rename = "locPrf", skip_serializing_if = "Option::is_none")]
    pub loc_prf: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weight: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitsRoutesTableListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCircuitRoutesTable>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitRoutesTableSummary {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub neighbor: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub v: Option<i32>,
    #[serde(rename = "as", skip_serializing_if = "Option::is_none")]
    pub as_: Option<i32>,
    #[serde(rename = "upDown", skip_serializing_if = "Option::is_none")]
    pub up_down: Option<String>,
    #[serde(rename = "statePfxRcd", skip_serializing_if = "Option::is_none")]
    pub state_pfx_rcd: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitsRoutesTableSummaryListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCircuitRoutesTableSummary>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCircuit>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteServiceProviderBandwidthsOffered {
    #[serde(rename = "offerName", skip_serializing_if = "Option::is_none")]
    pub offer_name: Option<String>,
    #[serde(rename = "valueInMbps", skip_serializing_if = "Option::is_none")]
    pub value_in_mbps: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteServiceProviderPropertiesFormat {
    #[serde(rename = "peeringLocations", skip_serializing_if = "Vec::is_empty")]
    pub peering_locations: Vec<String>,
    #[serde(rename = "bandwidthsOffered", skip_serializing_if = "Vec::is_empty")]
    pub bandwidths_offered: Vec<ExpressRouteServiceProviderBandwidthsOffered>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteServiceProvider {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteServiceProviderPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteServiceProviderListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteServiceProvider>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum CircuitConnectionStatus {
    Connected,
    Connecting,
    Disconnected,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ServiceProviderProvisioningState {
    NotProvisioned,
    Provisioning,
    Provisioned,
    Deprovisioning,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualWanProperties {
    #[serde(rename = "disableVpnEncryption", skip_serializing_if = "Option::is_none")]
    pub disable_vpn_encryption: Option<bool>,
    #[serde(rename = "virtualHubs", skip_serializing)]
    pub virtual_hubs: Vec<SubResource>,
    #[serde(rename = "vpnSites", skip_serializing)]
    pub vpn_sites: Vec<SubResource>,
    #[serde(rename = "allowBranchToBranchTraffic", skip_serializing_if = "Option::is_none")]
    pub allow_branch_to_branch_traffic: Option<bool>,
    #[serde(rename = "allowVnetToVnetTraffic", skip_serializing_if = "Option::is_none")]
    pub allow_vnet_to_vnet_traffic: Option<bool>,
    #[serde(rename = "office365LocalBreakoutCategory", skip_serializing)]
    pub office365_local_breakout_category: Option<OfficeTrafficCategory>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualWan {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualWanProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVirtualWaNsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualWan>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnSiteProperties {
    #[serde(rename = "virtualWan", skip_serializing_if = "Option::is_none")]
    pub virtual_wan: Option<SubResource>,
    #[serde(rename = "deviceProperties", skip_serializing_if = "Option::is_none")]
    pub device_properties: Option<DeviceProperties>,
    #[serde(rename = "ipAddress", skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    #[serde(rename = "siteKey", skip_serializing_if = "Option::is_none")]
    pub site_key: Option<String>,
    #[serde(rename = "addressSpace", skip_serializing_if = "Option::is_none")]
    pub address_space: Option<AddressSpace>,
    #[serde(rename = "bgpProperties", skip_serializing_if = "Option::is_none")]
    pub bgp_properties: Option<BgpSettings>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "isSecuritySite", skip_serializing_if = "Option::is_none")]
    pub is_security_site: Option<bool>,
    #[serde(rename = "vpnSiteLinks", skip_serializing_if = "Vec::is_empty")]
    pub vpn_site_links: Vec<VpnSiteLink>,
    #[serde(rename = "o365Policy", skip_serializing_if = "Option::is_none")]
    pub o365_policy: Option<O365PolicyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnSite {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VpnSiteProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVpnSitesResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VpnSite>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnSiteLinkProperties {
    #[serde(rename = "linkProperties", skip_serializing_if = "Option::is_none")]
    pub link_properties: Option<VpnLinkProviderProperties>,
    #[serde(rename = "ipAddress", skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[serde(rename = "bgpProperties", skip_serializing_if = "Option::is_none")]
    pub bgp_properties: Option<VpnLinkBgpSettings>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnSiteLink {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VpnSiteLinkProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVpnSiteLinksResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VpnSiteLink>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GetVpnSitesConfigurationRequest {
    #[serde(rename = "vpnSites", skip_serializing_if = "Vec::is_empty")]
    pub vpn_sites: Vec<String>,
    #[serde(rename = "outputBlobSasUrl")]
    pub output_blob_sas_url: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubProperties {
    #[serde(rename = "virtualWan", skip_serializing_if = "Option::is_none")]
    pub virtual_wan: Option<SubResource>,
    #[serde(rename = "vpnGateway", skip_serializing_if = "Option::is_none")]
    pub vpn_gateway: Option<SubResource>,
    #[serde(rename = "p2SVpnGateway", skip_serializing_if = "Option::is_none")]
    pub p2_s_vpn_gateway: Option<SubResource>,
    #[serde(rename = "expressRouteGateway", skip_serializing_if = "Option::is_none")]
    pub express_route_gateway: Option<SubResource>,
    #[serde(rename = "azureFirewall", skip_serializing_if = "Option::is_none")]
    pub azure_firewall: Option<SubResource>,
    #[serde(rename = "securityPartnerProvider", skip_serializing_if = "Option::is_none")]
    pub security_partner_provider: Option<SubResource>,
    #[serde(rename = "addressPrefix", skip_serializing_if = "Option::is_none")]
    pub address_prefix: Option<String>,
    #[serde(rename = "routeTable", skip_serializing_if = "Option::is_none")]
    pub route_table: Option<VirtualHubRouteTable>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "securityProviderName", skip_serializing_if = "Option::is_none")]
    pub security_provider_name: Option<String>,
    #[serde(rename = "virtualHubRouteTableV2s", skip_serializing_if = "Vec::is_empty")]
    pub virtual_hub_route_table_v2s: Vec<VirtualHubRouteTableV2>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<String>,
    #[serde(rename = "routingState", skip_serializing)]
    pub routing_state: Option<RoutingState>,
    #[serde(rename = "bgpConnections", skip_serializing)]
    pub bgp_connections: Vec<SubResource>,
    #[serde(rename = "ipConfigurations", skip_serializing)]
    pub ip_configurations: Vec<SubResource>,
    #[serde(rename = "virtualRouterAsn", skip_serializing_if = "Option::is_none")]
    pub virtual_router_asn: Option<i64>,
    #[serde(rename = "virtualRouterIps", skip_serializing_if = "Vec::is_empty")]
    pub virtual_router_ips: Vec<String>,
    #[serde(rename = "allowBranchToBranchTraffic", skip_serializing_if = "Option::is_none")]
    pub allow_branch_to_branch_traffic: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum RoutingState {
    None,
    Provisioned,
    Provisioning,
    Failed,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<BgpConnectionProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpConnectionProperties {
    #[serde(rename = "peerAsn", skip_serializing_if = "Option::is_none")]
    pub peer_asn: Option<i64>,
    #[serde(rename = "peerIp", skip_serializing_if = "Option::is_none")]
    pub peer_ip: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "connectionState", skip_serializing)]
    pub connection_state: Option<bgp_connection_properties::ConnectionState>,
}
pub mod bgp_connection_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ConnectionState {
        Unknown,
        Connecting,
        Connected,
        NotConnected,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PeerRoute {
    #[serde(rename = "localAddress", skip_serializing)]
    pub local_address: Option<String>,
    #[serde(skip_serializing)]
    pub network: Option<String>,
    #[serde(rename = "nextHop", skip_serializing)]
    pub next_hop: Option<String>,
    #[serde(rename = "sourcePeer", skip_serializing)]
    pub source_peer: Option<String>,
    #[serde(skip_serializing)]
    pub origin: Option<String>,
    #[serde(rename = "asPath", skip_serializing)]
    pub as_path: Option<String>,
    #[serde(skip_serializing)]
    pub weight: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PeerRouteList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PeerRoute>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<HubIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubIpConfigurationPropertiesFormat {
    #[serde(rename = "privateIPAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<Subnet>,
    #[serde(rename = "publicIPAddress", skip_serializing_if = "Option::is_none")]
    pub public_ip_address: Option<PublicIpAddress>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubRouteTable {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub routes: Vec<VirtualHubRoute>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubRoute {
    #[serde(rename = "addressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub address_prefixes: Vec<String>,
    #[serde(rename = "nextHopIpAddress", skip_serializing_if = "Option::is_none")]
    pub next_hop_ip_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHub {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualHubProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVirtualHubsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualHub>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnGatewayProperties {
    #[serde(rename = "virtualHub", skip_serializing_if = "Option::is_none")]
    pub virtual_hub: Option<SubResource>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub connections: Vec<VpnConnection>,
    #[serde(rename = "bgpSettings", skip_serializing_if = "Option::is_none")]
    pub bgp_settings: Option<BgpSettings>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "vpnGatewayScaleUnit", skip_serializing_if = "Option::is_none")]
    pub vpn_gateway_scale_unit: Option<i32>,
    #[serde(rename = "ipConfigurations", skip_serializing)]
    pub ip_configurations: Vec<VpnGatewayIpConfiguration>,
    #[serde(rename = "isRoutingPreferenceInternet", skip_serializing_if = "Option::is_none")]
    pub is_routing_preference_internet: Option<bool>,
    #[serde(rename = "natRules", skip_serializing_if = "Vec::is_empty")]
    pub nat_rules: Vec<VpnGatewayNatRule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnGateway {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VpnGatewayProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnGatewayIpConfiguration {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "publicIpAddress", skip_serializing_if = "Option::is_none")]
    pub public_ip_address: Option<String>,
    #[serde(rename = "privateIpAddress", skip_serializing_if = "Option::is_none")]
    pub private_ip_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVpnGatewaysResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VpnGateway>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnNatRuleMapping {
    #[serde(rename = "addressSpace", skip_serializing_if = "Option::is_none")]
    pub address_space: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnGatewayNatRuleProperties {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<vpn_gateway_nat_rule_properties::Type>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<vpn_gateway_nat_rule_properties::Mode>,
    #[serde(rename = "internalMappings", skip_serializing_if = "Vec::is_empty")]
    pub internal_mappings: Vec<VpnNatRuleMapping>,
    #[serde(rename = "externalMappings", skip_serializing_if = "Vec::is_empty")]
    pub external_mappings: Vec<VpnNatRuleMapping>,
    #[serde(rename = "ipConfigurationId", skip_serializing_if = "Option::is_none")]
    pub ip_configuration_id: Option<String>,
    #[serde(rename = "egressVpnSiteLinkConnections", skip_serializing)]
    pub egress_vpn_site_link_connections: Vec<SubResource>,
    #[serde(rename = "ingressVpnSiteLinkConnections", skip_serializing)]
    pub ingress_vpn_site_link_connections: Vec<SubResource>,
}
pub mod vpn_gateway_nat_rule_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        Static,
        Dynamic,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Mode {
        EgressSnat,
        IngressSnat,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnGatewayNatRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VpnGatewayNatRuleProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVpnGatewayNatRulesResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VpnGatewayNatRule>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnConnectionProperties {
    #[serde(rename = "remoteVpnSite", skip_serializing_if = "Option::is_none")]
    pub remote_vpn_site: Option<SubResource>,
    #[serde(rename = "routingWeight", skip_serializing_if = "Option::is_none")]
    pub routing_weight: Option<i32>,
    #[serde(rename = "dpdTimeoutSeconds", skip_serializing_if = "Option::is_none")]
    pub dpd_timeout_seconds: Option<i32>,
    #[serde(rename = "connectionStatus", skip_serializing)]
    pub connection_status: Option<VpnConnectionStatus>,
    #[serde(rename = "vpnConnectionProtocolType", skip_serializing_if = "Option::is_none")]
    pub vpn_connection_protocol_type: Option<ConnectionProtocol>,
    #[serde(rename = "ingressBytesTransferred", skip_serializing)]
    pub ingress_bytes_transferred: Option<i64>,
    #[serde(rename = "egressBytesTransferred", skip_serializing)]
    pub egress_bytes_transferred: Option<i64>,
    #[serde(rename = "connectionBandwidth", skip_serializing_if = "Option::is_none")]
    pub connection_bandwidth: Option<i32>,
    #[serde(rename = "sharedKey", skip_serializing_if = "Option::is_none")]
    pub shared_key: Option<String>,
    #[serde(rename = "enableBgp", skip_serializing_if = "Option::is_none")]
    pub enable_bgp: Option<bool>,
    #[serde(rename = "usePolicyBasedTrafficSelectors", skip_serializing_if = "Option::is_none")]
    pub use_policy_based_traffic_selectors: Option<bool>,
    #[serde(rename = "ipsecPolicies", skip_serializing_if = "Vec::is_empty")]
    pub ipsec_policies: Vec<IpsecPolicy>,
    #[serde(rename = "enableRateLimiting", skip_serializing_if = "Option::is_none")]
    pub enable_rate_limiting: Option<bool>,
    #[serde(rename = "enableInternetSecurity", skip_serializing_if = "Option::is_none")]
    pub enable_internet_security: Option<bool>,
    #[serde(rename = "useLocalAzureIpAddress", skip_serializing_if = "Option::is_none")]
    pub use_local_azure_ip_address: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "vpnLinkConnections", skip_serializing_if = "Vec::is_empty")]
    pub vpn_link_connections: Vec<VpnSiteLinkConnection>,
    #[serde(rename = "routingConfiguration", skip_serializing_if = "Option::is_none")]
    pub routing_configuration: Option<RoutingConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VpnConnectionProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVpnConnectionsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VpnConnection>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnConnectionPacketCaptureStartParameters {
    #[serde(rename = "filterData", skip_serializing_if = "Option::is_none")]
    pub filter_data: Option<String>,
    #[serde(rename = "linkConnectionNames", skip_serializing_if = "Vec::is_empty")]
    pub link_connection_names: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnConnectionPacketCaptureStopParameters {
    #[serde(rename = "sasUrl", skip_serializing_if = "Option::is_none")]
    pub sas_url: Option<String>,
    #[serde(rename = "linkConnectionNames", skip_serializing_if = "Vec::is_empty")]
    pub link_connection_names: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnGatewayPacketCaptureStartParameters {
    #[serde(rename = "filterData", skip_serializing_if = "Option::is_none")]
    pub filter_data: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnGatewayPacketCaptureStopParameters {
    #[serde(rename = "sasUrl", skip_serializing_if = "Option::is_none")]
    pub sas_url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnSiteLinkConnectionProperties {
    #[serde(rename = "vpnSiteLink", skip_serializing_if = "Option::is_none")]
    pub vpn_site_link: Option<SubResource>,
    #[serde(rename = "routingWeight", skip_serializing_if = "Option::is_none")]
    pub routing_weight: Option<i32>,
    #[serde(rename = "vpnLinkConnectionMode", skip_serializing_if = "Option::is_none")]
    pub vpn_link_connection_mode: Option<vpn_site_link_connection_properties::VpnLinkConnectionMode>,
    #[serde(rename = "connectionStatus", skip_serializing)]
    pub connection_status: Option<VpnConnectionStatus>,
    #[serde(rename = "vpnConnectionProtocolType", skip_serializing_if = "Option::is_none")]
    pub vpn_connection_protocol_type: Option<ConnectionProtocol>,
    #[serde(rename = "ingressBytesTransferred", skip_serializing)]
    pub ingress_bytes_transferred: Option<i64>,
    #[serde(rename = "egressBytesTransferred", skip_serializing)]
    pub egress_bytes_transferred: Option<i64>,
    #[serde(rename = "connectionBandwidth", skip_serializing_if = "Option::is_none")]
    pub connection_bandwidth: Option<i32>,
    #[serde(rename = "sharedKey", skip_serializing_if = "Option::is_none")]
    pub shared_key: Option<String>,
    #[serde(rename = "enableBgp", skip_serializing_if = "Option::is_none")]
    pub enable_bgp: Option<bool>,
    #[serde(rename = "usePolicyBasedTrafficSelectors", skip_serializing_if = "Option::is_none")]
    pub use_policy_based_traffic_selectors: Option<bool>,
    #[serde(rename = "ipsecPolicies", skip_serializing_if = "Vec::is_empty")]
    pub ipsec_policies: Vec<IpsecPolicy>,
    #[serde(rename = "enableRateLimiting", skip_serializing_if = "Option::is_none")]
    pub enable_rate_limiting: Option<bool>,
    #[serde(rename = "useLocalAzureIpAddress", skip_serializing_if = "Option::is_none")]
    pub use_local_azure_ip_address: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "ingressNatRules", skip_serializing_if = "Vec::is_empty")]
    pub ingress_nat_rules: Vec<SubResource>,
    #[serde(rename = "egressNatRules", skip_serializing_if = "Vec::is_empty")]
    pub egress_nat_rules: Vec<SubResource>,
}
pub mod vpn_site_link_connection_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VpnLinkConnectionMode {
        Default,
        ResponderOnly,
        InitiatorOnly,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnSiteLinkConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VpnSiteLinkConnectionProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVpnSiteLinkConnectionsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VpnSiteLinkConnection>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubVirtualNetworkConnectionProperties {
    #[serde(rename = "remoteVirtualNetwork", skip_serializing_if = "Option::is_none")]
    pub remote_virtual_network: Option<SubResource>,
    #[serde(rename = "allowHubToRemoteVnetTransit", skip_serializing_if = "Option::is_none")]
    pub allow_hub_to_remote_vnet_transit: Option<bool>,
    #[serde(rename = "allowRemoteVnetToUseHubVnetGateways", skip_serializing_if = "Option::is_none")]
    pub allow_remote_vnet_to_use_hub_vnet_gateways: Option<bool>,
    #[serde(rename = "enableInternetSecurity", skip_serializing_if = "Option::is_none")]
    pub enable_internet_security: Option<bool>,
    #[serde(rename = "routingConfiguration", skip_serializing_if = "Option::is_none")]
    pub routing_configuration: Option<RoutingConfiguration>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubVirtualNetworkConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<HubVirtualNetworkConnectionProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListHubVirtualNetworkConnectionsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<HubVirtualNetworkConnection>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubRouteTableProperties {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub routes: Vec<HubRoute>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<String>,
    #[serde(rename = "associatedConnections", skip_serializing)]
    pub associated_connections: Vec<String>,
    #[serde(rename = "propagatingConnections", skip_serializing)]
    pub propagating_connections: Vec<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubRouteTable {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<HubRouteTableProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HubRoute {
    pub name: String,
    #[serde(rename = "destinationType")]
    pub destination_type: String,
    pub destinations: Vec<String>,
    #[serde(rename = "nextHopType")]
    pub next_hop_type: String,
    #[serde(rename = "nextHop")]
    pub next_hop: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListHubRouteTablesResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<HubRouteTable>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnSiteId {
    #[serde(rename = "vpnSite", skip_serializing)]
    pub vpn_site: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DeviceProperties {
    #[serde(rename = "deviceVendor", skip_serializing_if = "Option::is_none")]
    pub device_vendor: Option<String>,
    #[serde(rename = "deviceModel", skip_serializing_if = "Option::is_none")]
    pub device_model: Option<String>,
    #[serde(rename = "linkSpeedInMbps", skip_serializing_if = "Option::is_none")]
    pub link_speed_in_mbps: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualWanSecurityProviders {
    #[serde(rename = "supportedProviders", skip_serializing_if = "Vec::is_empty")]
    pub supported_providers: Vec<VirtualWanSecurityProvider>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualWanSecurityProvider {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<VirtualWanSecurityProviderType>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum VpnConnectionStatus {
    Unknown,
    Connecting,
    Connected,
    NotConnected,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum TunnelConnectionStatus {
    Unknown,
    Connecting,
    Connected,
    NotConnected,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum HubVirtualNetworkConnectionStatus {
    Unknown,
    Connecting,
    Connected,
    NotConnected,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum OfficeTrafficCategory {
    Optimize,
    OptimizeAndAllow,
    All,
    None,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum VirtualWanSecurityProviderType {
    External,
    Native,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnServerConfigVpnClientRootCertificate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "publicCertData", skip_serializing_if = "Option::is_none")]
    pub public_cert_data: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnServerConfigRadiusServerRootCertificate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "publicCertData", skip_serializing_if = "Option::is_none")]
    pub public_cert_data: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnServerConfigVpnClientRevokedCertificate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thumbprint: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnServerConfigRadiusClientRootCertificate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thumbprint: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AadAuthenticationParameters {
    #[serde(rename = "aadTenant", skip_serializing_if = "Option::is_none")]
    pub aad_tenant: Option<String>,
    #[serde(rename = "aadAudience", skip_serializing_if = "Option::is_none")]
    pub aad_audience: Option<String>,
    #[serde(rename = "aadIssuer", skip_serializing_if = "Option::is_none")]
    pub aad_issuer: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnServerConfigurationProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "vpnProtocols", skip_serializing_if = "Vec::is_empty")]
    pub vpn_protocols: Vec<String>,
    #[serde(rename = "vpnAuthenticationTypes", skip_serializing_if = "Vec::is_empty")]
    pub vpn_authentication_types: Vec<String>,
    #[serde(rename = "vpnClientRootCertificates", skip_serializing_if = "Vec::is_empty")]
    pub vpn_client_root_certificates: Vec<VpnServerConfigVpnClientRootCertificate>,
    #[serde(rename = "vpnClientRevokedCertificates", skip_serializing_if = "Vec::is_empty")]
    pub vpn_client_revoked_certificates: Vec<VpnServerConfigVpnClientRevokedCertificate>,
    #[serde(rename = "radiusServerRootCertificates", skip_serializing_if = "Vec::is_empty")]
    pub radius_server_root_certificates: Vec<VpnServerConfigRadiusServerRootCertificate>,
    #[serde(rename = "radiusClientRootCertificates", skip_serializing_if = "Vec::is_empty")]
    pub radius_client_root_certificates: Vec<VpnServerConfigRadiusClientRootCertificate>,
    #[serde(rename = "vpnClientIpsecPolicies", skip_serializing_if = "Vec::is_empty")]
    pub vpn_client_ipsec_policies: Vec<IpsecPolicy>,
    #[serde(rename = "radiusServerAddress", skip_serializing_if = "Option::is_none")]
    pub radius_server_address: Option<String>,
    #[serde(rename = "radiusServerSecret", skip_serializing_if = "Option::is_none")]
    pub radius_server_secret: Option<String>,
    #[serde(rename = "radiusServers", skip_serializing_if = "Vec::is_empty")]
    pub radius_servers: Vec<RadiusServer>,
    #[serde(rename = "aadAuthenticationParameters", skip_serializing_if = "Option::is_none")]
    pub aad_authentication_parameters: Option<AadAuthenticationParameters>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<String>,
    #[serde(rename = "p2SVpnGateways", skip_serializing)]
    pub p2_s_vpn_gateways: Vec<P2sVpnGateway>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnServerConfiguration {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VpnServerConfigurationProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVpnServerConfigurationsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VpnServerConfiguration>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientConnectionHealth {
    #[serde(rename = "totalIngressBytesTransferred", skip_serializing)]
    pub total_ingress_bytes_transferred: Option<i64>,
    #[serde(rename = "totalEgressBytesTransferred", skip_serializing)]
    pub total_egress_bytes_transferred: Option<i64>,
    #[serde(rename = "vpnClientConnectionsCount", skip_serializing_if = "Option::is_none")]
    pub vpn_client_connections_count: Option<i32>,
    #[serde(rename = "allocatedIpAddresses", skip_serializing_if = "Vec::is_empty")]
    pub allocated_ip_addresses: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2sVpnGatewayProperties {
    #[serde(rename = "virtualHub", skip_serializing_if = "Option::is_none")]
    pub virtual_hub: Option<SubResource>,
    #[serde(rename = "p2SConnectionConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub p2_s_connection_configurations: Vec<P2sConnectionConfiguration>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "vpnGatewayScaleUnit", skip_serializing_if = "Option::is_none")]
    pub vpn_gateway_scale_unit: Option<i32>,
    #[serde(rename = "vpnServerConfiguration", skip_serializing_if = "Option::is_none")]
    pub vpn_server_configuration: Option<SubResource>,
    #[serde(rename = "vpnClientConnectionHealth", skip_serializing_if = "Option::is_none")]
    pub vpn_client_connection_health: Option<VpnClientConnectionHealth>,
    #[serde(rename = "customDnsServers", skip_serializing_if = "Vec::is_empty")]
    pub custom_dns_servers: Vec<String>,
    #[serde(rename = "isRoutingPreferenceInternet", skip_serializing_if = "Option::is_none")]
    pub is_routing_preference_internet: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2sVpnGateway {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<P2sVpnGatewayProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListP2sVpnGatewaysResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<P2sVpnGateway>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2sVpnProfileParameters {
    #[serde(rename = "authenticationMethod", skip_serializing_if = "Option::is_none")]
    pub authentication_method: Option<AuthenticationMethod>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnProfileResponse {
    #[serde(rename = "profileUrl", skip_serializing_if = "Option::is_none")]
    pub profile_url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnLinkBgpSettings {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub asn: Option<i64>,
    #[serde(rename = "bgpPeeringAddress", skip_serializing_if = "Option::is_none")]
    pub bgp_peering_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnLinkProviderProperties {
    #[serde(rename = "linkProviderName", skip_serializing_if = "Option::is_none")]
    pub link_provider_name: Option<String>,
    #[serde(rename = "linkSpeedInMbps", skip_serializing_if = "Option::is_none")]
    pub link_speed_in_mbps: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnServerConfigurationsResponse {
    #[serde(rename = "vpnServerConfigurationResourceIds", skip_serializing_if = "Vec::is_empty")]
    pub vpn_server_configuration_resource_ids: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualWanVpnProfileParameters {
    #[serde(rename = "vpnServerConfigurationResourceId", skip_serializing_if = "Option::is_none")]
    pub vpn_server_configuration_resource_id: Option<String>,
    #[serde(rename = "authenticationMethod", skip_serializing_if = "Option::is_none")]
    pub authentication_method: Option<AuthenticationMethod>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2sVpnConnectionHealthRequest {
    #[serde(rename = "vpnUserNamesFilter", skip_serializing_if = "Vec::is_empty")]
    pub vpn_user_names_filter: Vec<String>,
    #[serde(rename = "outputBlobSasUrl", skip_serializing_if = "Option::is_none")]
    pub output_blob_sas_url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2sVpnConnectionHealth {
    #[serde(rename = "sasUrl", skip_serializing_if = "Option::is_none")]
    pub sas_url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2sConnectionConfigurationProperties {
    #[serde(rename = "vpnClientAddressPool", skip_serializing_if = "Option::is_none")]
    pub vpn_client_address_pool: Option<AddressSpace>,
    #[serde(rename = "routingConfiguration", skip_serializing_if = "Option::is_none")]
    pub routing_configuration: Option<RoutingConfiguration>,
    #[serde(rename = "enableInternetSecurity", skip_serializing_if = "Option::is_none")]
    pub enable_internet_security: Option<bool>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2sConnectionConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<P2sConnectionConfigurationProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubRouteTableV2Properties {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub routes: Vec<VirtualHubRouteV2>,
    #[serde(rename = "attachedConnections", skip_serializing_if = "Vec::is_empty")]
    pub attached_connections: Vec<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubRouteTableV2 {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualHubRouteTableV2Properties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubRouteV2 {
    #[serde(rename = "destinationType", skip_serializing_if = "Option::is_none")]
    pub destination_type: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub destinations: Vec<String>,
    #[serde(rename = "nextHopType", skip_serializing_if = "Option::is_none")]
    pub next_hop_type: Option<String>,
    #[serde(rename = "nextHops", skip_serializing_if = "Vec::is_empty")]
    pub next_hops: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVirtualHubRouteTableV2sResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualHubRouteTableV2>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2sVpnConnectionRequest {
    #[serde(rename = "vpnConnectionIds", skip_serializing_if = "Vec::is_empty")]
    pub vpn_connection_ids: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubId {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitPeeringId {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteConnectionId {
    #[serde(skip_serializing)]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteGatewayProperties {
    #[serde(rename = "autoScaleConfiguration", skip_serializing_if = "Option::is_none")]
    pub auto_scale_configuration: Option<express_route_gateway_properties::AutoScaleConfiguration>,
    #[serde(rename = "expressRouteConnections", skip_serializing)]
    pub express_route_connections: Vec<ExpressRouteConnection>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "virtualHub")]
    pub virtual_hub: VirtualHubId,
}
pub mod express_route_gateway_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct AutoScaleConfiguration {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub bounds: Option<auto_scale_configuration::Bounds>,
    }
    pub mod auto_scale_configuration {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
        pub struct Bounds {
            #[serde(skip_serializing_if = "Option::is_none")]
            pub min: Option<i64>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub max: Option<i64>,
        }
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteGateway {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteGatewayProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteGatewayList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteGateway>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteConnectionProperties {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "expressRouteCircuitPeering")]
    pub express_route_circuit_peering: ExpressRouteCircuitPeeringId,
    #[serde(rename = "authorizationKey", skip_serializing_if = "Option::is_none")]
    pub authorization_key: Option<String>,
    #[serde(rename = "routingWeight", skip_serializing_if = "Option::is_none")]
    pub routing_weight: Option<i64>,
    #[serde(rename = "enableInternetSecurity", skip_serializing_if = "Option::is_none")]
    pub enable_internet_security: Option<bool>,
    #[serde(rename = "expressRouteGatewayBypass", skip_serializing_if = "Option::is_none")]
    pub express_route_gateway_bypass: Option<bool>,
    #[serde(rename = "routingConfiguration", skip_serializing_if = "Option::is_none")]
    pub routing_configuration: Option<RoutingConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteConnection {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteConnectionProperties>,
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteConnectionList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteConnection>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVirtualHubBgpConnectionResults {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BgpConnection>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListVirtualHubIpConfigurationResults {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<HubIpConfiguration>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RoutingConfiguration {
    #[serde(rename = "associatedRouteTable", skip_serializing_if = "Option::is_none")]
    pub associated_route_table: Option<SubResource>,
    #[serde(rename = "propagatedRouteTables", skip_serializing_if = "Option::is_none")]
    pub propagated_route_tables: Option<PropagatedRouteTable>,
    #[serde(rename = "vnetRoutes", skip_serializing_if = "Option::is_none")]
    pub vnet_routes: Option<VnetRoute>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PropagatedRouteTable {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub labels: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub ids: Vec<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VnetRoute {
    #[serde(rename = "staticRoutes", skip_serializing_if = "Vec::is_empty")]
    pub static_routes: Vec<StaticRoute>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StaticRoute {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "addressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub address_prefixes: Vec<String>,
    #[serde(rename = "nextHopIpAddress", skip_serializing_if = "Option::is_none")]
    pub next_hop_ip_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubEffectiveRouteList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualHubEffectiveRoute>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualHubEffectiveRoute {
    #[serde(rename = "addressPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub address_prefixes: Vec<String>,
    #[serde(rename = "nextHops", skip_serializing_if = "Vec::is_empty")]
    pub next_hops: Vec<String>,
    #[serde(rename = "nextHopType", skip_serializing_if = "Option::is_none")]
    pub next_hop_type: Option<String>,
    #[serde(rename = "asPath", skip_serializing_if = "Option::is_none")]
    pub as_path: Option<String>,
    #[serde(rename = "routeOrigin", skip_serializing_if = "Option::is_none")]
    pub route_origin: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EffectiveRoutesParameters {
    #[serde(rename = "resourceId", skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[serde(rename = "virtualWanResourceType", skip_serializing_if = "Option::is_none")]
    pub virtual_wan_resource_type: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct O365PolicyProperties {
    #[serde(rename = "breakOutCategories", skip_serializing_if = "Option::is_none")]
    pub break_out_categories: Option<O365BreakOutCategoryPolicies>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct O365BreakOutCategoryPolicies {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub optimize: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayIpConfigurationPropertiesFormat {
    #[serde(rename = "privateIPAllocationMethod", skip_serializing_if = "Option::is_none")]
    pub private_ip_allocation_method: Option<IpAllocationMethod>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<SubResource>,
    #[serde(rename = "publicIPAddress", skip_serializing_if = "Option::is_none")]
    pub public_ip_address: Option<SubResource>,
    #[serde(rename = "privateIPAddress", skip_serializing)]
    pub private_ip_address: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayIpConfiguration {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualNetworkGatewayIpConfigurationPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayPropertiesFormat {
    #[serde(rename = "ipConfigurations", skip_serializing_if = "Vec::is_empty")]
    pub ip_configurations: Vec<VirtualNetworkGatewayIpConfiguration>,
    #[serde(rename = "gatewayType", skip_serializing_if = "Option::is_none")]
    pub gateway_type: Option<virtual_network_gateway_properties_format::GatewayType>,
    #[serde(rename = "vpnType", skip_serializing_if = "Option::is_none")]
    pub vpn_type: Option<virtual_network_gateway_properties_format::VpnType>,
    #[serde(rename = "vpnGatewayGeneration", skip_serializing_if = "Option::is_none")]
    pub vpn_gateway_generation: Option<virtual_network_gateway_properties_format::VpnGatewayGeneration>,
    #[serde(rename = "enableBgp", skip_serializing_if = "Option::is_none")]
    pub enable_bgp: Option<bool>,
    #[serde(rename = "enablePrivateIpAddress", skip_serializing_if = "Option::is_none")]
    pub enable_private_ip_address: Option<bool>,
    #[serde(rename = "activeActive", skip_serializing_if = "Option::is_none")]
    pub active_active: Option<bool>,
    #[serde(rename = "gatewayDefaultSite", skip_serializing_if = "Option::is_none")]
    pub gateway_default_site: Option<SubResource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<VirtualNetworkGatewaySku>,
    #[serde(rename = "vpnClientConfiguration", skip_serializing_if = "Option::is_none")]
    pub vpn_client_configuration: Option<VpnClientConfiguration>,
    #[serde(rename = "bgpSettings", skip_serializing_if = "Option::is_none")]
    pub bgp_settings: Option<BgpSettings>,
    #[serde(rename = "customRoutes", skip_serializing_if = "Option::is_none")]
    pub custom_routes: Option<AddressSpace>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "enableDnsForwarding", skip_serializing_if = "Option::is_none")]
    pub enable_dns_forwarding: Option<bool>,
    #[serde(rename = "inboundDnsForwardingEndpoint", skip_serializing)]
    pub inbound_dns_forwarding_endpoint: Option<String>,
    #[serde(rename = "vNetExtendedLocationResourceId", skip_serializing_if = "Option::is_none")]
    pub v_net_extended_location_resource_id: Option<String>,
    #[serde(rename = "virtualNetworkExtendedLocation", skip_serializing_if = "Option::is_none")]
    pub virtual_network_extended_location: Option<ExtendedLocation>,
}
pub mod virtual_network_gateway_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum GatewayType {
        Vpn,
        ExpressRoute,
        LocalGateway,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VpnType {
        PolicyBased,
        RouteBased,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VpnGatewayGeneration {
        None,
        Generation1,
        Generation2,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientRootCertificatePropertiesFormat {
    #[serde(rename = "publicCertData")]
    pub public_cert_data: String,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientRootCertificate {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub properties: VpnClientRootCertificatePropertiesFormat,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientRevokedCertificatePropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thumbprint: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientRevokedCertificate {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VpnClientRevokedCertificatePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RadiusServer {
    #[serde(rename = "radiusServerAddress")]
    pub radius_server_address: String,
    #[serde(rename = "radiusServerScore", skip_serializing_if = "Option::is_none")]
    pub radius_server_score: Option<i64>,
    #[serde(rename = "radiusServerSecret", skip_serializing_if = "Option::is_none")]
    pub radius_server_secret: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientConfiguration {
    #[serde(rename = "vpnClientAddressPool", skip_serializing_if = "Option::is_none")]
    pub vpn_client_address_pool: Option<AddressSpace>,
    #[serde(rename = "vpnClientRootCertificates", skip_serializing_if = "Vec::is_empty")]
    pub vpn_client_root_certificates: Vec<VpnClientRootCertificate>,
    #[serde(rename = "vpnClientRevokedCertificates", skip_serializing_if = "Vec::is_empty")]
    pub vpn_client_revoked_certificates: Vec<VpnClientRevokedCertificate>,
    #[serde(rename = "vpnClientProtocols", skip_serializing_if = "Vec::is_empty")]
    pub vpn_client_protocols: Vec<String>,
    #[serde(rename = "vpnClientIpsecPolicies", skip_serializing_if = "Vec::is_empty")]
    pub vpn_client_ipsec_policies: Vec<IpsecPolicy>,
    #[serde(rename = "radiusServerAddress", skip_serializing_if = "Option::is_none")]
    pub radius_server_address: Option<String>,
    #[serde(rename = "radiusServerSecret", skip_serializing_if = "Option::is_none")]
    pub radius_server_secret: Option<String>,
    #[serde(rename = "radiusServers", skip_serializing_if = "Vec::is_empty")]
    pub radius_servers: Vec<RadiusServer>,
    #[serde(rename = "aadTenant", skip_serializing_if = "Option::is_none")]
    pub aad_tenant: Option<String>,
    #[serde(rename = "aadAudience", skip_serializing_if = "Option::is_none")]
    pub aad_audience: Option<String>,
    #[serde(rename = "aadIssuer", skip_serializing_if = "Option::is_none")]
    pub aad_issuer: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewaySku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<virtual_network_gateway_sku::Name>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<virtual_network_gateway_sku::Tier>,
    #[serde(skip_serializing)]
    pub capacity: Option<i32>,
}
pub mod virtual_network_gateway_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        Basic,
        HighPerformance,
        Standard,
        UltraPerformance,
        VpnGw1,
        VpnGw2,
        VpnGw3,
        VpnGw4,
        VpnGw5,
        #[serde(rename = "VpnGw1AZ")]
        VpnGw1Az,
        #[serde(rename = "VpnGw2AZ")]
        VpnGw2Az,
        #[serde(rename = "VpnGw3AZ")]
        VpnGw3Az,
        #[serde(rename = "VpnGw4AZ")]
        VpnGw4Az,
        #[serde(rename = "VpnGw5AZ")]
        VpnGw5Az,
        #[serde(rename = "ErGw1AZ")]
        ErGw1Az,
        #[serde(rename = "ErGw2AZ")]
        ErGw2Az,
        #[serde(rename = "ErGw3AZ")]
        ErGw3Az,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Basic,
        HighPerformance,
        Standard,
        UltraPerformance,
        VpnGw1,
        VpnGw2,
        VpnGw3,
        VpnGw4,
        VpnGw5,
        #[serde(rename = "VpnGw1AZ")]
        VpnGw1Az,
        #[serde(rename = "VpnGw2AZ")]
        VpnGw2Az,
        #[serde(rename = "VpnGw3AZ")]
        VpnGw3Az,
        #[serde(rename = "VpnGw4AZ")]
        VpnGw4Az,
        #[serde(rename = "VpnGw5AZ")]
        VpnGw5Az,
        #[serde(rename = "ErGw1AZ")]
        ErGw1Az,
        #[serde(rename = "ErGw2AZ")]
        ErGw2Az,
        #[serde(rename = "ErGw3AZ")]
        ErGw3Az,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpSettings {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub asn: Option<i64>,
    #[serde(rename = "bgpPeeringAddress", skip_serializing_if = "Option::is_none")]
    pub bgp_peering_address: Option<String>,
    #[serde(rename = "peerWeight", skip_serializing_if = "Option::is_none")]
    pub peer_weight: Option<i32>,
    #[serde(rename = "bgpPeeringAddresses", skip_serializing_if = "Vec::is_empty")]
    pub bgp_peering_addresses: Vec<IpConfigurationBgpPeeringAddress>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpPeerStatus {
    #[serde(rename = "localAddress", skip_serializing)]
    pub local_address: Option<String>,
    #[serde(skip_serializing)]
    pub neighbor: Option<String>,
    #[serde(skip_serializing)]
    pub asn: Option<i64>,
    #[serde(skip_serializing)]
    pub state: Option<bgp_peer_status::State>,
    #[serde(rename = "connectedDuration", skip_serializing)]
    pub connected_duration: Option<String>,
    #[serde(rename = "routesReceived", skip_serializing)]
    pub routes_received: Option<i64>,
    #[serde(rename = "messagesSent", skip_serializing)]
    pub messages_sent: Option<i64>,
    #[serde(rename = "messagesReceived", skip_serializing)]
    pub messages_received: Option<i64>,
}
pub mod bgp_peer_status {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Unknown,
        Stopped,
        Idle,
        Connecting,
        Connected,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GatewayRoute {
    #[serde(rename = "localAddress", skip_serializing)]
    pub local_address: Option<String>,
    #[serde(skip_serializing)]
    pub network: Option<String>,
    #[serde(rename = "nextHop", skip_serializing)]
    pub next_hop: Option<String>,
    #[serde(rename = "sourcePeer", skip_serializing)]
    pub source_peer: Option<String>,
    #[serde(skip_serializing)]
    pub origin: Option<String>,
    #[serde(rename = "asPath", skip_serializing)]
    pub as_path: Option<String>,
    #[serde(skip_serializing)]
    pub weight: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGateway {
    #[serde(flatten)]
    pub resource: Resource,
    pub properties: VirtualNetworkGatewayPropertiesFormat,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientParameters {
    #[serde(rename = "processorArchitecture", skip_serializing_if = "Option::is_none")]
    pub processor_architecture: Option<vpn_client_parameters::ProcessorArchitecture>,
    #[serde(rename = "authenticationMethod", skip_serializing_if = "Option::is_none")]
    pub authentication_method: Option<AuthenticationMethod>,
    #[serde(rename = "radiusServerAuthCertificate", skip_serializing_if = "Option::is_none")]
    pub radius_server_auth_certificate: Option<String>,
    #[serde(rename = "clientRootCertificates", skip_serializing_if = "Vec::is_empty")]
    pub client_root_certificates: Vec<String>,
}
pub mod vpn_client_parameters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ProcessorArchitecture {
        Amd64,
        X86,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualNetworkGateway>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpPeerStatusListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BgpPeerStatus>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GatewayRouteListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<GatewayRoute>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TunnelConnectionHealth {
    #[serde(skip_serializing)]
    pub tunnel: Option<String>,
    #[serde(rename = "connectionStatus", skip_serializing_if = "Option::is_none")]
    pub connection_status: Option<VirtualNetworkGatewayConnectionStatus>,
    #[serde(rename = "ingressBytesTransferred", skip_serializing)]
    pub ingress_bytes_transferred: Option<i64>,
    #[serde(rename = "egressBytesTransferred", skip_serializing)]
    pub egress_bytes_transferred: Option<i64>,
    #[serde(rename = "lastConnectionEstablishedUtcTime", skip_serializing)]
    pub last_connection_established_utc_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayConnectionPropertiesFormat {
    #[serde(rename = "authorizationKey", skip_serializing_if = "Option::is_none")]
    pub authorization_key: Option<String>,
    #[serde(rename = "virtualNetworkGateway1")]
    pub virtual_network_gateway1: VirtualNetworkGateway,
    #[serde(rename = "virtualNetworkGateway2", skip_serializing_if = "Option::is_none")]
    pub virtual_network_gateway2: Option<VirtualNetworkGateway>,
    #[serde(rename = "localNetworkGateway2", skip_serializing_if = "Option::is_none")]
    pub local_network_gateway2: Option<LocalNetworkGateway>,
    #[serde(rename = "connectionType")]
    pub connection_type: VirtualNetworkGatewayConnectionType,
    #[serde(rename = "connectionProtocol", skip_serializing_if = "Option::is_none")]
    pub connection_protocol: Option<ConnectionProtocol>,
    #[serde(rename = "routingWeight", skip_serializing_if = "Option::is_none")]
    pub routing_weight: Option<i32>,
    #[serde(rename = "dpdTimeoutSeconds", skip_serializing_if = "Option::is_none")]
    pub dpd_timeout_seconds: Option<i32>,
    #[serde(rename = "connectionMode", skip_serializing_if = "Option::is_none")]
    pub connection_mode: Option<VirtualNetworkGatewayConnectionMode>,
    #[serde(rename = "sharedKey", skip_serializing_if = "Option::is_none")]
    pub shared_key: Option<String>,
    #[serde(rename = "connectionStatus", skip_serializing_if = "Option::is_none")]
    pub connection_status: Option<VirtualNetworkGatewayConnectionStatus>,
    #[serde(rename = "tunnelConnectionStatus", skip_serializing)]
    pub tunnel_connection_status: Vec<TunnelConnectionHealth>,
    #[serde(rename = "egressBytesTransferred", skip_serializing)]
    pub egress_bytes_transferred: Option<i64>,
    #[serde(rename = "ingressBytesTransferred", skip_serializing)]
    pub ingress_bytes_transferred: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer: Option<SubResource>,
    #[serde(rename = "enableBgp", skip_serializing_if = "Option::is_none")]
    pub enable_bgp: Option<bool>,
    #[serde(rename = "useLocalAzureIpAddress", skip_serializing_if = "Option::is_none")]
    pub use_local_azure_ip_address: Option<bool>,
    #[serde(rename = "usePolicyBasedTrafficSelectors", skip_serializing_if = "Option::is_none")]
    pub use_policy_based_traffic_selectors: Option<bool>,
    #[serde(rename = "ipsecPolicies", skip_serializing_if = "Vec::is_empty")]
    pub ipsec_policies: Vec<IpsecPolicy>,
    #[serde(rename = "trafficSelectorPolicies", skip_serializing_if = "Vec::is_empty")]
    pub traffic_selector_policies: Vec<TrafficSelectorPolicy>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "expressRouteGatewayBypass", skip_serializing_if = "Option::is_none")]
    pub express_route_gateway_bypass: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayConnection {
    #[serde(flatten)]
    pub resource: Resource,
    pub properties: VirtualNetworkGatewayConnectionPropertiesFormat,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayConnectionListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualNetworkGatewayConnection>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionResetSharedKey {
    #[serde(rename = "keyLength")]
    pub key_length: i32,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConnectionSharedKey {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    pub value: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpsecPolicy {
    #[serde(rename = "saLifeTimeSeconds")]
    pub sa_life_time_seconds: i32,
    #[serde(rename = "saDataSizeKilobytes")]
    pub sa_data_size_kilobytes: i32,
    #[serde(rename = "ipsecEncryption")]
    pub ipsec_encryption: IpsecEncryption,
    #[serde(rename = "ipsecIntegrity")]
    pub ipsec_integrity: IpsecIntegrity,
    #[serde(rename = "ikeEncryption")]
    pub ike_encryption: IkeEncryption,
    #[serde(rename = "ikeIntegrity")]
    pub ike_integrity: IkeIntegrity,
    #[serde(rename = "dhGroup")]
    pub dh_group: DhGroup,
    #[serde(rename = "pfsGroup")]
    pub pfs_group: PfsGroup,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrafficSelectorPolicy {
    #[serde(rename = "localAddressRanges")]
    pub local_address_ranges: Vec<String>,
    #[serde(rename = "remoteAddressRanges")]
    pub remote_address_ranges: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ConnectionProtocol {
    #[serde(rename = "IKEv2")]
    IkEv2,
    #[serde(rename = "IKEv1")]
    IkEv1,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientIPsecParameters {
    #[serde(rename = "saLifeTimeSeconds")]
    pub sa_life_time_seconds: i32,
    #[serde(rename = "saDataSizeKilobytes")]
    pub sa_data_size_kilobytes: i32,
    #[serde(rename = "ipsecEncryption")]
    pub ipsec_encryption: IpsecEncryption,
    #[serde(rename = "ipsecIntegrity")]
    pub ipsec_integrity: IpsecIntegrity,
    #[serde(rename = "ikeEncryption")]
    pub ike_encryption: IkeEncryption,
    #[serde(rename = "ikeIntegrity")]
    pub ike_integrity: IkeIntegrity,
    #[serde(rename = "dhGroup")]
    pub dh_group: DhGroup,
    #[serde(rename = "pfsGroup")]
    pub pfs_group: PfsGroup,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LocalNetworkGatewayPropertiesFormat {
    #[serde(rename = "localNetworkAddressSpace", skip_serializing_if = "Option::is_none")]
    pub local_network_address_space: Option<AddressSpace>,
    #[serde(rename = "gatewayIpAddress", skip_serializing_if = "Option::is_none")]
    pub gateway_ip_address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,
    #[serde(rename = "bgpSettings", skip_serializing_if = "Option::is_none")]
    pub bgp_settings: Option<BgpSettings>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LocalNetworkGateway {
    #[serde(flatten)]
    pub resource: Resource,
    pub properties: LocalNetworkGatewayPropertiesFormat,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LocalNetworkGatewayListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LocalNetworkGateway>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkConnectionGatewayReference {
    pub id: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayConnectionListEntityPropertiesFormat {
    #[serde(rename = "authorizationKey", skip_serializing_if = "Option::is_none")]
    pub authorization_key: Option<String>,
    #[serde(rename = "virtualNetworkGateway1")]
    pub virtual_network_gateway1: VirtualNetworkConnectionGatewayReference,
    #[serde(rename = "virtualNetworkGateway2", skip_serializing_if = "Option::is_none")]
    pub virtual_network_gateway2: Option<VirtualNetworkConnectionGatewayReference>,
    #[serde(rename = "localNetworkGateway2", skip_serializing_if = "Option::is_none")]
    pub local_network_gateway2: Option<VirtualNetworkConnectionGatewayReference>,
    #[serde(rename = "connectionType")]
    pub connection_type: VirtualNetworkGatewayConnectionType,
    #[serde(rename = "connectionProtocol", skip_serializing_if = "Option::is_none")]
    pub connection_protocol: Option<ConnectionProtocol>,
    #[serde(rename = "routingWeight", skip_serializing_if = "Option::is_none")]
    pub routing_weight: Option<i32>,
    #[serde(rename = "connectionMode", skip_serializing_if = "Option::is_none")]
    pub connection_mode: Option<VirtualNetworkGatewayConnectionMode>,
    #[serde(rename = "sharedKey", skip_serializing_if = "Option::is_none")]
    pub shared_key: Option<String>,
    #[serde(rename = "connectionStatus", skip_serializing_if = "Option::is_none")]
    pub connection_status: Option<VirtualNetworkGatewayConnectionStatus>,
    #[serde(rename = "tunnelConnectionStatus", skip_serializing)]
    pub tunnel_connection_status: Vec<TunnelConnectionHealth>,
    #[serde(rename = "egressBytesTransferred", skip_serializing)]
    pub egress_bytes_transferred: Option<i64>,
    #[serde(rename = "ingressBytesTransferred", skip_serializing)]
    pub ingress_bytes_transferred: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer: Option<SubResource>,
    #[serde(rename = "enableBgp", skip_serializing_if = "Option::is_none")]
    pub enable_bgp: Option<bool>,
    #[serde(rename = "usePolicyBasedTrafficSelectors", skip_serializing_if = "Option::is_none")]
    pub use_policy_based_traffic_selectors: Option<bool>,
    #[serde(rename = "ipsecPolicies", skip_serializing_if = "Vec::is_empty")]
    pub ipsec_policies: Vec<IpsecPolicy>,
    #[serde(rename = "trafficSelectorPolicies", skip_serializing_if = "Vec::is_empty")]
    pub traffic_selector_policies: Vec<TrafficSelectorPolicy>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "expressRouteGatewayBypass", skip_serializing_if = "Option::is_none")]
    pub express_route_gateway_bypass: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayConnectionListEntity {
    #[serde(flatten)]
    pub resource: Resource,
    pub properties: VirtualNetworkGatewayConnectionListEntityPropertiesFormat,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualNetworkGatewayListConnectionsResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualNetworkGatewayConnectionListEntity>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnDeviceScriptParameters {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vendor: Option<String>,
    #[serde(rename = "deviceFamily", skip_serializing_if = "Option::is_none")]
    pub device_family: Option<String>,
    #[serde(rename = "firmwareVersion", skip_serializing_if = "Option::is_none")]
    pub firmware_version: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum DhGroup {
    None,
    #[serde(rename = "DHGroup1")]
    DhGroup1,
    #[serde(rename = "DHGroup2")]
    DhGroup2,
    #[serde(rename = "DHGroup14")]
    DhGroup14,
    #[serde(rename = "DHGroup2048")]
    DhGroup2048,
    #[serde(rename = "ECP256")]
    Ecp256,
    #[serde(rename = "ECP384")]
    Ecp384,
    #[serde(rename = "DHGroup24")]
    DhGroup24,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IkeEncryption {
    #[serde(rename = "DES")]
    Des,
    #[serde(rename = "DES3")]
    Des3,
    #[serde(rename = "AES128")]
    Aes128,
    #[serde(rename = "AES192")]
    Aes192,
    #[serde(rename = "AES256")]
    Aes256,
    #[serde(rename = "GCMAES256")]
    Gcmaes256,
    #[serde(rename = "GCMAES128")]
    Gcmaes128,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IkeIntegrity {
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "SHA384")]
    Sha384,
    #[serde(rename = "GCMAES256")]
    Gcmaes256,
    #[serde(rename = "GCMAES128")]
    Gcmaes128,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IpsecEncryption {
    None,
    #[serde(rename = "DES")]
    Des,
    #[serde(rename = "DES3")]
    Des3,
    #[serde(rename = "AES128")]
    Aes128,
    #[serde(rename = "AES192")]
    Aes192,
    #[serde(rename = "AES256")]
    Aes256,
    #[serde(rename = "GCMAES128")]
    Gcmaes128,
    #[serde(rename = "GCMAES192")]
    Gcmaes192,
    #[serde(rename = "GCMAES256")]
    Gcmaes256,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IpsecIntegrity {
    #[serde(rename = "MD5")]
    Md5,
    #[serde(rename = "SHA1")]
    Sha1,
    #[serde(rename = "SHA256")]
    Sha256,
    #[serde(rename = "GCMAES128")]
    Gcmaes128,
    #[serde(rename = "GCMAES192")]
    Gcmaes192,
    #[serde(rename = "GCMAES256")]
    Gcmaes256,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum PfsGroup {
    None,
    #[serde(rename = "PFS1")]
    Pfs1,
    #[serde(rename = "PFS2")]
    Pfs2,
    #[serde(rename = "PFS2048")]
    Pfs2048,
    #[serde(rename = "ECP256")]
    Ecp256,
    #[serde(rename = "ECP384")]
    Ecp384,
    #[serde(rename = "PFS24")]
    Pfs24,
    #[serde(rename = "PFS14")]
    Pfs14,
    #[serde(rename = "PFSMM")]
    Pfsmm,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum VirtualNetworkGatewayConnectionStatus {
    Unknown,
    Connecting,
    Connected,
    NotConnected,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum VirtualNetworkGatewayConnectionType {
    IPsec,
    Vnet2Vnet,
    ExpressRoute,
    #[serde(rename = "VPNClient")]
    VpnClient,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum VirtualNetworkGatewayConnectionMode {
    Default,
    ResponderOnly,
    InitiatorOnly,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientConnectionHealthDetailListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VpnClientConnectionHealthDetail>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnClientConnectionHealthDetail {
    #[serde(rename = "vpnConnectionId", skip_serializing)]
    pub vpn_connection_id: Option<String>,
    #[serde(rename = "vpnConnectionDuration", skip_serializing)]
    pub vpn_connection_duration: Option<i64>,
    #[serde(rename = "vpnConnectionTime", skip_serializing)]
    pub vpn_connection_time: Option<String>,
    #[serde(rename = "publicIpAddress", skip_serializing)]
    pub public_ip_address: Option<String>,
    #[serde(rename = "privateIpAddress", skip_serializing)]
    pub private_ip_address: Option<String>,
    #[serde(rename = "vpnUserName", skip_serializing)]
    pub vpn_user_name: Option<String>,
    #[serde(rename = "maxBandwidth", skip_serializing)]
    pub max_bandwidth: Option<i64>,
    #[serde(rename = "egressPacketsTransferred", skip_serializing)]
    pub egress_packets_transferred: Option<i64>,
    #[serde(rename = "egressBytesTransferred", skip_serializing)]
    pub egress_bytes_transferred: Option<i64>,
    #[serde(rename = "ingressPacketsTransferred", skip_serializing)]
    pub ingress_packets_transferred: Option<i64>,
    #[serde(rename = "ingressBytesTransferred", skip_serializing)]
    pub ingress_bytes_transferred: Option<i64>,
    #[serde(rename = "maxPacketsPerSecond", skip_serializing)]
    pub max_packets_per_second: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnPacketCaptureStopParameters {
    #[serde(rename = "sasUrl", skip_serializing_if = "Option::is_none")]
    pub sas_url: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VpnPacketCaptureStartParameters {
    #[serde(rename = "filterData", skip_serializing_if = "Option::is_none")]
    pub filter_data: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpConfigurationBgpPeeringAddress {
    #[serde(rename = "ipconfigurationId", skip_serializing_if = "Option::is_none")]
    pub ipconfiguration_id: Option<String>,
    #[serde(rename = "defaultBgpIpAddresses", skip_serializing)]
    pub default_bgp_ip_addresses: Vec<String>,
    #[serde(rename = "customBgpIpAddresses", skip_serializing_if = "Vec::is_empty")]
    pub custom_bgp_ip_addresses: Vec<String>,
    #[serde(rename = "tunnelIpAddresses", skip_serializing)]
    pub tunnel_ip_addresses: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCrossConnectionRoutesTableSummary {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub neighbor: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub asn: Option<i32>,
    #[serde(rename = "upDown", skip_serializing_if = "Option::is_none")]
    pub up_down: Option<String>,
    #[serde(rename = "stateOrPrefixesReceived", skip_serializing_if = "Option::is_none")]
    pub state_or_prefixes_received: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCrossConnectionsRoutesTableSummaryListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCrossConnectionRoutesTableSummary>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCircuitReference {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCrossConnectionProperties {
    #[serde(rename = "primaryAzurePort", skip_serializing)]
    pub primary_azure_port: Option<String>,
    #[serde(rename = "secondaryAzurePort", skip_serializing)]
    pub secondary_azure_port: Option<String>,
    #[serde(rename = "sTag", skip_serializing)]
    pub s_tag: Option<i64>,
    #[serde(rename = "peeringLocation", skip_serializing)]
    pub peering_location: Option<String>,
    #[serde(rename = "bandwidthInMbps", skip_serializing)]
    pub bandwidth_in_mbps: Option<i32>,
    #[serde(rename = "expressRouteCircuit", skip_serializing_if = "Option::is_none")]
    pub express_route_circuit: Option<ExpressRouteCircuitReference>,
    #[serde(rename = "serviceProviderProvisioningState", skip_serializing_if = "Option::is_none")]
    pub service_provider_provisioning_state: Option<ServiceProviderProvisioningState>,
    #[serde(rename = "serviceProviderNotes", skip_serializing_if = "Option::is_none")]
    pub service_provider_notes: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub peerings: Vec<ExpressRouteCrossConnectionPeering>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCrossConnection {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteCrossConnectionProperties>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCrossConnectionListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCrossConnection>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCrossConnectionPeeringProperties {
    #[serde(rename = "peeringType", skip_serializing_if = "Option::is_none")]
    pub peering_type: Option<ExpressRoutePeeringType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<ExpressRoutePeeringState>,
    #[serde(rename = "azureASN", skip_serializing)]
    pub azure_asn: Option<i32>,
    #[serde(rename = "peerASN", skip_serializing_if = "Option::is_none")]
    pub peer_asn: Option<i64>,
    #[serde(rename = "primaryPeerAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub primary_peer_address_prefix: Option<String>,
    #[serde(rename = "secondaryPeerAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub secondary_peer_address_prefix: Option<String>,
    #[serde(rename = "primaryAzurePort", skip_serializing)]
    pub primary_azure_port: Option<String>,
    #[serde(rename = "secondaryAzurePort", skip_serializing)]
    pub secondary_azure_port: Option<String>,
    #[serde(rename = "sharedKey", skip_serializing_if = "Option::is_none")]
    pub shared_key: Option<String>,
    #[serde(rename = "vlanId", skip_serializing_if = "Option::is_none")]
    pub vlan_id: Option<i32>,
    #[serde(rename = "microsoftPeeringConfig", skip_serializing_if = "Option::is_none")]
    pub microsoft_peering_config: Option<ExpressRouteCircuitPeeringConfig>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "gatewayManagerEtag", skip_serializing_if = "Option::is_none")]
    pub gateway_manager_etag: Option<String>,
    #[serde(rename = "lastModifiedBy", skip_serializing)]
    pub last_modified_by: Option<String>,
    #[serde(rename = "ipv6PeeringConfig", skip_serializing_if = "Option::is_none")]
    pub ipv6_peering_config: Option<Ipv6ExpressRouteCircuitPeeringConfig>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCrossConnectionPeering {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteCrossConnectionPeeringProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteCrossConnectionPeeringList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteCrossConnectionPeering>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRoutePortsLocationBandwidths {
    #[serde(rename = "offerName", skip_serializing)]
    pub offer_name: Option<String>,
    #[serde(rename = "valueInGbps", skip_serializing)]
    pub value_in_gbps: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRoutePortsLocationPropertiesFormat {
    #[serde(skip_serializing)]
    pub address: Option<String>,
    #[serde(skip_serializing)]
    pub contact: Option<String>,
    #[serde(rename = "availableBandwidths", skip_serializing_if = "Vec::is_empty")]
    pub available_bandwidths: Vec<ExpressRoutePortsLocationBandwidths>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRoutePortsLocation {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRoutePortsLocationPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRoutePortsLocationListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRoutePortsLocation>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteLinkMacSecConfig {
    #[serde(rename = "cknSecretIdentifier", skip_serializing_if = "Option::is_none")]
    pub ckn_secret_identifier: Option<String>,
    #[serde(rename = "cakSecretIdentifier", skip_serializing_if = "Option::is_none")]
    pub cak_secret_identifier: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cipher: Option<express_route_link_mac_sec_config::Cipher>,
    #[serde(rename = "sciState", skip_serializing_if = "Option::is_none")]
    pub sci_state: Option<express_route_link_mac_sec_config::SciState>,
}
pub mod express_route_link_mac_sec_config {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Cipher {
        GcmAes256,
        GcmAes128,
        GcmAesXpn128,
        GcmAesXpn256,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum SciState {
        Disabled,
        Enabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteLinkPropertiesFormat {
    #[serde(rename = "routerName", skip_serializing)]
    pub router_name: Option<String>,
    #[serde(rename = "interfaceName", skip_serializing)]
    pub interface_name: Option<String>,
    #[serde(rename = "patchPanelId", skip_serializing)]
    pub patch_panel_id: Option<String>,
    #[serde(rename = "rackId", skip_serializing)]
    pub rack_id: Option<String>,
    #[serde(rename = "connectorType", skip_serializing)]
    pub connector_type: Option<express_route_link_properties_format::ConnectorType>,
    #[serde(rename = "adminState", skip_serializing_if = "Option::is_none")]
    pub admin_state: Option<express_route_link_properties_format::AdminState>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "macSecConfig", skip_serializing_if = "Option::is_none")]
    pub mac_sec_config: Option<ExpressRouteLinkMacSecConfig>,
}
pub mod express_route_link_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ConnectorType {
        #[serde(rename = "LC")]
        Lc,
        #[serde(rename = "SC")]
        Sc,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AdminState {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteLink {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRouteLinkPropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRouteLinkListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRouteLink>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRoutePortPropertiesFormat {
    #[serde(rename = "peeringLocation", skip_serializing_if = "Option::is_none")]
    pub peering_location: Option<String>,
    #[serde(rename = "bandwidthInGbps", skip_serializing_if = "Option::is_none")]
    pub bandwidth_in_gbps: Option<i64>,
    #[serde(rename = "provisionedBandwidthInGbps", skip_serializing)]
    pub provisioned_bandwidth_in_gbps: Option<f64>,
    #[serde(skip_serializing)]
    pub mtu: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encapsulation: Option<express_route_port_properties_format::Encapsulation>,
    #[serde(rename = "etherType", skip_serializing)]
    pub ether_type: Option<String>,
    #[serde(rename = "allocationDate", skip_serializing)]
    pub allocation_date: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub links: Vec<ExpressRouteLink>,
    #[serde(skip_serializing)]
    pub circuits: Vec<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
}
pub mod express_route_port_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Encapsulation {
        Dot1Q,
        QinQ,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRoutePort {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ExpressRoutePortPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedServiceIdentity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExpressRoutePortListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<ExpressRoutePort>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GenerateExpressRoutePortsLoaRequest {
    #[serde(rename = "customerName")]
    pub customer_name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GenerateExpressRoutePortsLoaResult {
    #[serde(rename = "encodedContent", skip_serializing_if = "Option::is_none")]
    pub encoded_content: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicy {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<FirewallPolicyPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedServiceIdentity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyPropertiesFormat {
    #[serde(rename = "ruleCollectionGroups", skip_serializing)]
    pub rule_collection_groups: Vec<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "basePolicy", skip_serializing_if = "Option::is_none")]
    pub base_policy: Option<SubResource>,
    #[serde(skip_serializing)]
    pub firewalls: Vec<SubResource>,
    #[serde(rename = "childPolicies", skip_serializing)]
    pub child_policies: Vec<SubResource>,
    #[serde(rename = "threatIntelMode", skip_serializing_if = "Option::is_none")]
    pub threat_intel_mode: Option<AzureFirewallThreatIntelMode>,
    #[serde(rename = "threatIntelWhitelist", skip_serializing_if = "Option::is_none")]
    pub threat_intel_whitelist: Option<FirewallPolicyThreatIntelWhitelist>,
    #[serde(rename = "dnsSettings", skip_serializing_if = "Option::is_none")]
    pub dns_settings: Option<DnsSettings>,
    #[serde(rename = "intrusionDetection", skip_serializing_if = "Option::is_none")]
    pub intrusion_detection: Option<FirewallPolicyIntrusionDetection>,
    #[serde(rename = "transportSecurity", skip_serializing_if = "Option::is_none")]
    pub transport_security: Option<FirewallPolicyTransportSecurity>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<FirewallPolicySku>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyRuleCollectionGroup {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<FirewallPolicyRuleCollectionGroupProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyRuleCollectionGroupProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    #[serde(rename = "ruleCollections", skip_serializing_if = "Vec::is_empty")]
    pub rule_collections: Vec<FirewallPolicyRuleCollection>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyRuleCollection {
    #[serde(rename = "ruleCollectionType")]
    pub rule_collection_type: firewall_policy_rule_collection::RuleCollectionType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
}
pub mod firewall_policy_rule_collection {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RuleCollectionType {
        FirewallPolicyNatRuleCollection,
        FirewallPolicyFilterRuleCollection,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyNatRuleCollection {
    #[serde(flatten)]
    pub firewall_policy_rule_collection: FirewallPolicyRuleCollection,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<FirewallPolicyNatRuleCollectionAction>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<FirewallPolicyRule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyFilterRuleCollection {
    #[serde(flatten)]
    pub firewall_policy_rule_collection: FirewallPolicyRuleCollection,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<FirewallPolicyFilterRuleCollectionAction>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<FirewallPolicyRule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "ruleType")]
    pub rule_type: firewall_policy_rule::RuleType,
}
pub mod firewall_policy_rule {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RuleType {
        ApplicationRule,
        NetworkRule,
        NatRule,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationRule {
    #[serde(flatten)]
    pub firewall_policy_rule: FirewallPolicyRule,
    #[serde(rename = "sourceAddresses", skip_serializing_if = "Vec::is_empty")]
    pub source_addresses: Vec<String>,
    #[serde(rename = "destinationAddresses", skip_serializing_if = "Vec::is_empty")]
    pub destination_addresses: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub protocols: Vec<FirewallPolicyRuleApplicationProtocol>,
    #[serde(rename = "targetFqdns", skip_serializing_if = "Vec::is_empty")]
    pub target_fqdns: Vec<String>,
    #[serde(rename = "targetUrls", skip_serializing_if = "Vec::is_empty")]
    pub target_urls: Vec<String>,
    #[serde(rename = "fqdnTags", skip_serializing_if = "Vec::is_empty")]
    pub fqdn_tags: Vec<String>,
    #[serde(rename = "sourceIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub source_ip_groups: Vec<String>,
    #[serde(rename = "terminateTLS", skip_serializing_if = "Option::is_none")]
    pub terminate_tls: Option<bool>,
    #[serde(rename = "webCategories", skip_serializing_if = "Vec::is_empty")]
    pub web_categories: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NatRule {
    #[serde(flatten)]
    pub firewall_policy_rule: FirewallPolicyRule,
    #[serde(rename = "ipProtocols", skip_serializing_if = "Vec::is_empty")]
    pub ip_protocols: Vec<FirewallPolicyRuleNetworkProtocol>,
    #[serde(rename = "sourceAddresses", skip_serializing_if = "Vec::is_empty")]
    pub source_addresses: Vec<String>,
    #[serde(rename = "destinationAddresses", skip_serializing_if = "Vec::is_empty")]
    pub destination_addresses: Vec<String>,
    #[serde(rename = "destinationPorts", skip_serializing_if = "Vec::is_empty")]
    pub destination_ports: Vec<String>,
    #[serde(rename = "translatedAddress", skip_serializing_if = "Option::is_none")]
    pub translated_address: Option<String>,
    #[serde(rename = "translatedPort", skip_serializing_if = "Option::is_none")]
    pub translated_port: Option<String>,
    #[serde(rename = "sourceIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub source_ip_groups: Vec<String>,
    #[serde(rename = "translatedFqdn", skip_serializing_if = "Option::is_none")]
    pub translated_fqdn: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkRule {
    #[serde(flatten)]
    pub firewall_policy_rule: FirewallPolicyRule,
    #[serde(rename = "ipProtocols", skip_serializing_if = "Vec::is_empty")]
    pub ip_protocols: Vec<FirewallPolicyRuleNetworkProtocol>,
    #[serde(rename = "sourceAddresses", skip_serializing_if = "Vec::is_empty")]
    pub source_addresses: Vec<String>,
    #[serde(rename = "destinationAddresses", skip_serializing_if = "Vec::is_empty")]
    pub destination_addresses: Vec<String>,
    #[serde(rename = "destinationPorts", skip_serializing_if = "Vec::is_empty")]
    pub destination_ports: Vec<String>,
    #[serde(rename = "sourceIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub source_ip_groups: Vec<String>,
    #[serde(rename = "destinationIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub destination_ip_groups: Vec<String>,
    #[serde(rename = "destinationFqdns", skip_serializing_if = "Vec::is_empty")]
    pub destination_fqdns: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyRuleApplicationProtocol {
    #[serde(rename = "protocolType", skip_serializing_if = "Option::is_none")]
    pub protocol_type: Option<FirewallPolicyRuleApplicationProtocolType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum FirewallPolicyRuleApplicationProtocolType {
    Http,
    Https,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum FirewallPolicyNatRuleCollectionActionType {
    #[serde(rename = "DNAT")]
    Dnat,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyNatRuleCollectionAction {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<FirewallPolicyNatRuleCollectionActionType>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum FirewallPolicyFilterRuleCollectionActionType {
    Allow,
    Deny,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyFilterRuleCollectionAction {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<FirewallPolicyFilterRuleCollectionActionType>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum FirewallPolicyRuleNetworkProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    Any,
    #[serde(rename = "ICMP")]
    Icmp,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<FirewallPolicy>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyRuleCollectionGroupListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<FirewallPolicyRuleCollectionGroup>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyThreatIntelWhitelist {
    #[serde(rename = "ipAddresses", skip_serializing_if = "Vec::is_empty")]
    pub ip_addresses: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub fqdns: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DnsSettings {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub servers: Vec<String>,
    #[serde(rename = "enableProxy", skip_serializing_if = "Option::is_none")]
    pub enable_proxy: Option<bool>,
    #[serde(rename = "requireProxyForNetworkRules", skip_serializing_if = "Option::is_none")]
    pub require_proxy_for_network_rules: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyIntrusionDetection {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<FirewallPolicyIntrusionDetectionStateOptions>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub configuration: Option<FirewallPolicyIntrusionDetectionConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum FirewallPolicyIntrusionDetectionStateOptions {
    Off,
    Alert,
    Deny,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyIntrusionDetectionConfiguration {
    #[serde(rename = "signatureOverrides", skip_serializing_if = "Vec::is_empty")]
    pub signature_overrides: Vec<FirewallPolicyIntrusionDetectionSignatureSpecification>,
    #[serde(rename = "bypassTrafficSettings", skip_serializing_if = "Vec::is_empty")]
    pub bypass_traffic_settings: Vec<FirewallPolicyIntrusionDetectionBypassTrafficSpecifications>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyIntrusionDetectionSignatureSpecification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<FirewallPolicyIntrusionDetectionStateOptions>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyIntrusionDetectionBypassTrafficSpecifications {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<FirewallPolicyIntrusionDetectionBypassTrafficProtocol>,
    #[serde(rename = "sourceAddresses", skip_serializing_if = "Vec::is_empty")]
    pub source_addresses: Vec<String>,
    #[serde(rename = "destinationAddresses", skip_serializing_if = "Vec::is_empty")]
    pub destination_addresses: Vec<String>,
    #[serde(rename = "destinationPorts", skip_serializing_if = "Vec::is_empty")]
    pub destination_ports: Vec<String>,
    #[serde(rename = "sourceIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub source_ip_groups: Vec<String>,
    #[serde(rename = "destinationIpGroups", skip_serializing_if = "Vec::is_empty")]
    pub destination_ip_groups: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum FirewallPolicyIntrusionDetectionBypassTrafficProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "ICMP")]
    Icmp,
    #[serde(rename = "ANY")]
    Any,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyTransportSecurity {
    #[serde(rename = "certificateAuthority", skip_serializing_if = "Option::is_none")]
    pub certificate_authority: Option<FirewallPolicyCertificateAuthority>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicyCertificateAuthority {
    #[serde(rename = "keyVaultSecretId", skip_serializing_if = "Option::is_none")]
    pub key_vault_secret_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FirewallPolicySku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<firewall_policy_sku::Tier>,
}
pub mod firewall_policy_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Standard,
        Premium,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpAllocationPropertiesFormat {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subnet: Option<SubResource>,
    #[serde(rename = "virtualNetwork", skip_serializing_if = "Option::is_none")]
    pub virtual_network: Option<SubResource>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<IpAllocationType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(rename = "prefixLength", skip_serializing_if = "Option::is_none")]
    pub prefix_length: Option<i64>,
    #[serde(rename = "prefixType", skip_serializing_if = "Option::is_none")]
    pub prefix_type: Option<IpVersion>,
    #[serde(rename = "ipamAllocationId", skip_serializing_if = "Option::is_none")]
    pub ipam_allocation_id: Option<String>,
    #[serde(rename = "allocationTags", skip_serializing_if = "Option::is_none")]
    pub allocation_tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpAllocation {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<IpAllocationPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpAllocationListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<IpAllocation>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum IpAllocationType {
    Undefined,
    Hypernet,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpGroup {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<IpGroupPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpGroupListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<IpGroup>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IpGroupPropertiesFormat {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "ipAddresses", skip_serializing_if = "Vec::is_empty")]
    pub ip_addresses: Vec<String>,
    #[serde(skip_serializing)]
    pub firewalls: Vec<SubResource>,
    #[serde(rename = "firewallPolicies", skip_serializing)]
    pub firewall_policies: Vec<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkVirtualAppliance {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NetworkVirtualAppliancePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identity: Option<ManagedServiceIdentity>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkVirtualAppliancePropertiesFormat {
    #[serde(rename = "nvaSku", skip_serializing_if = "Option::is_none")]
    pub nva_sku: Option<VirtualApplianceSkuProperties>,
    #[serde(rename = "addressPrefix", skip_serializing)]
    pub address_prefix: Option<String>,
    #[serde(rename = "bootStrapConfigurationBlobs", skip_serializing_if = "Vec::is_empty")]
    pub boot_strap_configuration_blobs: Vec<String>,
    #[serde(rename = "virtualHub", skip_serializing_if = "Option::is_none")]
    pub virtual_hub: Option<SubResource>,
    #[serde(rename = "cloudInitConfigurationBlobs", skip_serializing_if = "Vec::is_empty")]
    pub cloud_init_configuration_blobs: Vec<String>,
    #[serde(rename = "cloudInitConfiguration", skip_serializing_if = "Option::is_none")]
    pub cloud_init_configuration: Option<String>,
    #[serde(rename = "virtualApplianceAsn", skip_serializing_if = "Option::is_none")]
    pub virtual_appliance_asn: Option<i64>,
    #[serde(rename = "virtualApplianceNics", skip_serializing)]
    pub virtual_appliance_nics: Vec<VirtualApplianceNicProperties>,
    #[serde(rename = "virtualApplianceSites", skip_serializing)]
    pub virtual_appliance_sites: Vec<SubResource>,
    #[serde(rename = "inboundSecurityRules", skip_serializing)]
    pub inbound_security_rules: Vec<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualApplianceSkuProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vendor: Option<String>,
    #[serde(rename = "bundledScaleUnit", skip_serializing_if = "Option::is_none")]
    pub bundled_scale_unit: Option<String>,
    #[serde(rename = "marketPlaceVersion", skip_serializing_if = "Option::is_none")]
    pub market_place_version: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualApplianceNicProperties {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "publicIpAddress", skip_serializing)]
    pub public_ip_address: Option<String>,
    #[serde(rename = "privateIpAddress", skip_serializing)]
    pub private_ip_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualApplianceSite {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualApplianceSiteProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualApplianceSiteProperties {
    #[serde(rename = "addressPrefix", skip_serializing_if = "Option::is_none")]
    pub address_prefix: Option<String>,
    #[serde(rename = "o365Policy", skip_serializing_if = "Option::is_none")]
    pub o365_policy: Option<Office365PolicyProperties>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Office365PolicyProperties {
    #[serde(rename = "breakOutCategories", skip_serializing_if = "Option::is_none")]
    pub break_out_categories: Option<BreakOutCategoryPolicies>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BreakOutCategoryPolicies {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub optimize: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<bool>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkVirtualApplianceSku {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<NetworkVirtualApplianceSkuPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkVirtualApplianceSkuPropertiesFormat {
    #[serde(skip_serializing)]
    pub vendor: Option<String>,
    #[serde(rename = "availableVersions", skip_serializing)]
    pub available_versions: Vec<String>,
    #[serde(rename = "availableScaleUnits", skip_serializing_if = "Vec::is_empty")]
    pub available_scale_units: Vec<NetworkVirtualApplianceSkuInstances>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkVirtualApplianceSkuInstances {
    #[serde(rename = "scaleUnit", skip_serializing)]
    pub scale_unit: Option<String>,
    #[serde(rename = "instanceCount", skip_serializing)]
    pub instance_count: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkVirtualApplianceListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NetworkVirtualAppliance>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkVirtualApplianceSiteListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualApplianceSite>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkVirtualApplianceSkuListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<NetworkVirtualApplianceSku>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InboundSecurityRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<InboundSecurityRuleProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InboundSecurityRuleProperties {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<InboundSecurityRules>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InboundSecurityRules {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<inbound_security_rules::Protocol>,
    #[serde(rename = "sourceAddressPrefix", skip_serializing_if = "Option::is_none")]
    pub source_address_prefix: Option<String>,
    #[serde(rename = "destinationPortRange", skip_serializing_if = "Option::is_none")]
    pub destination_port_range: Option<i32>,
}
pub mod inbound_security_rules {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Protocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Operation>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Operation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display: Option<operation::Display>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<OperationPropertiesFormat>,
}
pub mod operation {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct Display {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub provider: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub resource: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub operation: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OperationPropertiesFormat {
    #[serde(rename = "serviceSpecification", skip_serializing_if = "Option::is_none")]
    pub service_specification: Option<operation_properties_format::ServiceSpecification>,
}
pub mod operation_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct ServiceSpecification {
        #[serde(rename = "metricSpecifications", skip_serializing_if = "Vec::is_empty")]
        pub metric_specifications: Vec<MetricSpecification>,
        #[serde(rename = "logSpecifications", skip_serializing_if = "Vec::is_empty")]
        pub log_specifications: Vec<LogSpecification>,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LogSpecification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "blobDuration", skip_serializing_if = "Option::is_none")]
    pub blob_duration: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricSpecification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "displayDescription", skip_serializing_if = "Option::is_none")]
    pub display_description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    #[serde(rename = "aggregationType", skip_serializing_if = "Option::is_none")]
    pub aggregation_type: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub availabilities: Vec<Availability>,
    #[serde(rename = "enableRegionalMdmAccount", skip_serializing_if = "Option::is_none")]
    pub enable_regional_mdm_account: Option<bool>,
    #[serde(rename = "fillGapWithZero", skip_serializing_if = "Option::is_none")]
    pub fill_gap_with_zero: Option<bool>,
    #[serde(rename = "metricFilterPattern", skip_serializing_if = "Option::is_none")]
    pub metric_filter_pattern: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub dimensions: Vec<Dimension>,
    #[serde(rename = "isInternal", skip_serializing_if = "Option::is_none")]
    pub is_internal: Option<bool>,
    #[serde(rename = "sourceMdmAccount", skip_serializing_if = "Option::is_none")]
    pub source_mdm_account: Option<String>,
    #[serde(rename = "sourceMdmNamespace", skip_serializing_if = "Option::is_none")]
    pub source_mdm_namespace: Option<String>,
    #[serde(rename = "resourceIdDimensionNameOverride", skip_serializing_if = "Option::is_none")]
    pub resource_id_dimension_name_override: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Dimension {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(rename = "internalName", skip_serializing_if = "Option::is_none")]
    pub internal_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Availability {
    #[serde(rename = "timeGrain", skip_serializing_if = "Option::is_none")]
    pub time_grain: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention: Option<String>,
    #[serde(rename = "blobDuration", skip_serializing_if = "Option::is_none")]
    pub blob_duration: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpPrefixSku {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<public_ip_prefix_sku::Name>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tier: Option<public_ip_prefix_sku::Tier>,
}
pub mod public_ip_prefix_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        Standard,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Tier {
        Regional,
        Global,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpPrefixPropertiesFormat {
    #[serde(rename = "publicIPAddressVersion", skip_serializing_if = "Option::is_none")]
    pub public_ip_address_version: Option<IpVersion>,
    #[serde(rename = "ipTags", skip_serializing_if = "Vec::is_empty")]
    pub ip_tags: Vec<IpTag>,
    #[serde(rename = "prefixLength", skip_serializing_if = "Option::is_none")]
    pub prefix_length: Option<i32>,
    #[serde(rename = "ipPrefix", skip_serializing)]
    pub ip_prefix: Option<String>,
    #[serde(rename = "publicIPAddresses", skip_serializing)]
    pub public_ip_addresses: Vec<ReferencedPublicIpAddress>,
    #[serde(rename = "loadBalancerFrontendIpConfiguration", skip_serializing_if = "Option::is_none")]
    pub load_balancer_frontend_ip_configuration: Option<SubResource>,
    #[serde(rename = "customIPPrefix", skip_serializing_if = "Option::is_none")]
    pub custom_ip_prefix: Option<SubResource>,
    #[serde(rename = "resourceGuid", skip_serializing)]
    pub resource_guid: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "natGateway", skip_serializing_if = "Option::is_none")]
    pub nat_gateway: Option<NatGateway>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpPrefix {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(rename = "extendedLocation", skip_serializing_if = "Option::is_none")]
    pub extended_location: Option<ExtendedLocation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<PublicIpPrefixSku>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<PublicIpPrefixPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub zones: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicIpPrefixListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PublicIpPrefix>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ReferencedPublicIpAddress {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteFilterRulePropertiesFormat {
    pub access: Access,
    #[serde(rename = "routeFilterRuleType")]
    pub route_filter_rule_type: route_filter_rule_properties_format::RouteFilterRuleType,
    pub communities: Vec<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
pub mod route_filter_rule_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RouteFilterRuleType {
        Community,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteFilterRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<RouteFilterRulePropertiesFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PatchRouteFilterRule {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<RouteFilterRulePropertiesFormat>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteFilterPropertiesFormat {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<RouteFilterRule>,
    #[serde(skip_serializing)]
    pub peerings: Vec<ExpressRouteCircuitPeering>,
    #[serde(rename = "ipv6Peerings", skip_serializing)]
    pub ipv6_peerings: Vec<ExpressRouteCircuitPeering>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteFilter {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<RouteFilterPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PatchRouteFilter {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<RouteFilterPropertiesFormat>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteFilterListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<RouteFilter>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouteFilterRuleListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<RouteFilterRule>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityPartnerProviderPropertiesFormat {
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "securityProviderName", skip_serializing_if = "Option::is_none")]
    pub security_provider_name: Option<SecurityPartnerProvidersecurityProviderName>,
    #[serde(rename = "connectionStatus", skip_serializing)]
    pub connection_status: Option<SecurityPartnerProviderConnectionStatus>,
    #[serde(rename = "virtualHub", skip_serializing_if = "Option::is_none")]
    pub virtual_hub: Option<SubResource>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityPartnerProvider {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<SecurityPartnerProviderPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecurityPartnerProviderListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<SecurityPartnerProvider>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SecurityPartnerProvidersecurityProviderName {
    ZScaler,
    IBoss,
    Checkpoint,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SecurityPartnerProviderConnectionStatus {
    Unknown,
    PartiallyConnected,
    Connected,
    NotConnected,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpCommunity {
    #[serde(rename = "serviceSupportedRegion", skip_serializing_if = "Option::is_none")]
    pub service_supported_region: Option<String>,
    #[serde(rename = "communityName", skip_serializing_if = "Option::is_none")]
    pub community_name: Option<String>,
    #[serde(rename = "communityValue", skip_serializing_if = "Option::is_none")]
    pub community_value: Option<String>,
    #[serde(rename = "communityPrefixes", skip_serializing_if = "Vec::is_empty")]
    pub community_prefixes: Vec<String>,
    #[serde(rename = "isAuthorizedToUse", skip_serializing_if = "Option::is_none")]
    pub is_authorized_to_use: Option<bool>,
    #[serde(rename = "serviceGroup", skip_serializing_if = "Option::is_none")]
    pub service_group: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpServiceCommunityPropertiesFormat {
    #[serde(rename = "serviceName", skip_serializing_if = "Option::is_none")]
    pub service_name: Option<String>,
    #[serde(rename = "bgpCommunities", skip_serializing_if = "Vec::is_empty")]
    pub bgp_communities: Vec<BgpCommunity>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpServiceCommunity {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<BgpServiceCommunityPropertiesFormat>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BgpServiceCommunityListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<BgpServiceCommunity>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceTagsListResult {
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(rename = "changeNumber", skip_serializing)]
    pub change_number: Option<String>,
    #[serde(skip_serializing)]
    pub cloud: Option<String>,
    #[serde(skip_serializing)]
    pub values: Vec<ServiceTagInformation>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceTagInformation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ServiceTagInformationPropertiesFormat>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ServiceTagInformationPropertiesFormat {
    #[serde(rename = "changeNumber", skip_serializing)]
    pub change_number: Option<String>,
    #[serde(skip_serializing)]
    pub region: Option<String>,
    #[serde(rename = "systemService", skip_serializing)]
    pub system_service: Option<String>,
    #[serde(rename = "addressPrefixes", skip_serializing)]
    pub address_prefixes: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UsageName {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(rename = "localizedValue", skip_serializing_if = "Option::is_none")]
    pub localized_value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Usage {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    pub unit: usage::Unit,
    #[serde(rename = "currentValue")]
    pub current_value: i64,
    pub limit: i64,
    pub name: UsageName,
}
pub mod usage {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Unit {
        Count,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UsagesListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Usage>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualRouter {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualRouterPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualRouterPropertiesFormat {
    #[serde(rename = "virtualRouterAsn", skip_serializing_if = "Option::is_none")]
    pub virtual_router_asn: Option<i64>,
    #[serde(rename = "virtualRouterIps", skip_serializing_if = "Vec::is_empty")]
    pub virtual_router_ips: Vec<String>,
    #[serde(rename = "hostedSubnet", skip_serializing_if = "Option::is_none")]
    pub hosted_subnet: Option<SubResource>,
    #[serde(rename = "hostedGateway", skip_serializing_if = "Option::is_none")]
    pub hosted_gateway: Option<SubResource>,
    #[serde(skip_serializing)]
    pub peerings: Vec<SubResource>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualRouterPeering {
    #[serde(flatten)]
    pub sub_resource: SubResource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<VirtualRouterPeeringProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualRouterPeeringProperties {
    #[serde(rename = "peerAsn", skip_serializing_if = "Option::is_none")]
    pub peer_asn: Option<i64>,
    #[serde(rename = "peerIp", skip_serializing_if = "Option::is_none")]
    pub peer_ip: Option<String>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualRouterListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualRouter>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VirtualRouterPeeringListResult {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<VirtualRouterPeering>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebApplicationFirewallPolicy {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<WebApplicationFirewallPolicyPropertiesFormat>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebApplicationFirewallPolicyPropertiesFormat {
    #[serde(rename = "policySettings", skip_serializing_if = "Option::is_none")]
    pub policy_settings: Option<PolicySettings>,
    #[serde(rename = "customRules", skip_serializing_if = "Vec::is_empty")]
    pub custom_rules: Vec<WebApplicationFirewallCustomRule>,
    #[serde(rename = "applicationGateways", skip_serializing)]
    pub application_gateways: Vec<ApplicationGateway>,
    #[serde(rename = "provisioningState", skip_serializing)]
    pub provisioning_state: Option<ProvisioningState>,
    #[serde(rename = "resourceState", skip_serializing)]
    pub resource_state: Option<web_application_firewall_policy_properties_format::ResourceState>,
    #[serde(rename = "managedRules")]
    pub managed_rules: ManagedRulesDefinition,
    #[serde(rename = "httpListeners", skip_serializing)]
    pub http_listeners: Vec<SubResource>,
    #[serde(rename = "pathBasedRules", skip_serializing)]
    pub path_based_rules: Vec<SubResource>,
}
pub mod web_application_firewall_policy_properties_format {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ResourceState {
        Creating,
        Enabling,
        Enabled,
        Disabling,
        Disabled,
        Deleting,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebApplicationFirewallPolicyListResult {
    #[serde(skip_serializing)]
    pub value: Vec<WebApplicationFirewallPolicy>,
    #[serde(rename = "nextLink", skip_serializing)]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedRulesDefinition {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub exclusions: Vec<OwaspCrsExclusionEntry>,
    #[serde(rename = "managedRuleSets")]
    pub managed_rule_sets: Vec<ManagedRuleSet>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PolicySettings {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<policy_settings::State>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<policy_settings::Mode>,
    #[serde(rename = "requestBodyCheck", skip_serializing_if = "Option::is_none")]
    pub request_body_check: Option<bool>,
    #[serde(rename = "maxRequestBodySizeInKb", skip_serializing_if = "Option::is_none")]
    pub max_request_body_size_in_kb: Option<i32>,
    #[serde(rename = "fileUploadLimitInMb", skip_serializing_if = "Option::is_none")]
    pub file_upload_limit_in_mb: Option<i32>,
}
pub mod policy_settings {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Disabled,
        Enabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Mode {
        Prevention,
        Detection,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebApplicationFirewallCustomRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing)]
    pub etag: Option<String>,
    pub priority: i64,
    #[serde(rename = "ruleType")]
    pub rule_type: web_application_firewall_custom_rule::RuleType,
    #[serde(rename = "matchConditions")]
    pub match_conditions: Vec<MatchCondition>,
    pub action: web_application_firewall_custom_rule::Action,
}
pub mod web_application_firewall_custom_rule {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RuleType {
        MatchRule,
        Invalid,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Action {
        Allow,
        Block,
        Log,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum Transform {
    Lowercase,
    Trim,
    UrlDecode,
    UrlEncode,
    RemoveNulls,
    HtmlEntityDecode,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MatchVariable {
    #[serde(rename = "variableName")]
    pub variable_name: match_variable::VariableName,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
}
pub mod match_variable {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VariableName {
        RemoteAddr,
        RequestMethod,
        QueryString,
        PostArgs,
        RequestUri,
        RequestHeaders,
        RequestBody,
        RequestCookies,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MatchCondition {
    #[serde(rename = "matchVariables")]
    pub match_variables: Vec<MatchVariable>,
    pub operator: match_condition::Operator,
    #[serde(rename = "negationConditon", skip_serializing_if = "Option::is_none")]
    pub negation_conditon: Option<bool>,
    #[serde(rename = "matchValues")]
    pub match_values: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub transforms: Vec<Transform>,
}
pub mod match_condition {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Operator {
        #[serde(rename = "IPMatch")]
        IpMatch,
        Equal,
        Contains,
        LessThan,
        GreaterThan,
        LessThanOrEqual,
        GreaterThanOrEqual,
        BeginsWith,
        EndsWith,
        Regex,
        GeoMatch,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedRuleSet {
    #[serde(rename = "ruleSetType")]
    pub rule_set_type: String,
    #[serde(rename = "ruleSetVersion")]
    pub rule_set_version: String,
    #[serde(rename = "ruleGroupOverrides", skip_serializing_if = "Vec::is_empty")]
    pub rule_group_overrides: Vec<ManagedRuleGroupOverride>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedRuleGroupOverride {
    #[serde(rename = "ruleGroupName")]
    pub rule_group_name: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub rules: Vec<ManagedRuleOverride>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagedRuleOverride {
    #[serde(rename = "ruleId")]
    pub rule_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<managed_rule_override::State>,
}
pub mod managed_rule_override {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OwaspCrsExclusionEntry {
    #[serde(rename = "matchVariable")]
    pub match_variable: owasp_crs_exclusion_entry::MatchVariable,
    #[serde(rename = "selectorMatchOperator")]
    pub selector_match_operator: owasp_crs_exclusion_entry::SelectorMatchOperator,
    pub selector: String,
}
pub mod owasp_crs_exclusion_entry {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum MatchVariable {
        RequestHeaderNames,
        RequestCookieNames,
        RequestArgNames,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum SelectorMatchOperator {
        Equals,
        Contains,
        StartsWith,
        EndsWith,
        EqualsAny,
    }
}
