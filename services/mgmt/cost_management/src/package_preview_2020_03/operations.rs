#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use crate::models::*;
use reqwest::StatusCode;
use snafu::{ResultExt, Snafu};
pub mod views {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(operation_config: &crate::OperationConfig) -> std::result::Result<ViewListResult, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!("{}/providers/Microsoft.CostManagement/views", operation_config.base_path(),);
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ViewListResult = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_by_scope(
        operation_config: &crate::OperationConfig,
        scope: &str,
    ) -> std::result::Result<ViewListResult, list_by_scope::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/views",
            operation_config.base_path(),
            scope
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_scope::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_by_scope::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_scope::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_scope::ResponseBytesError)?;
                let rsp_value: ViewListResult = serde_json::from_slice(&body).context(list_by_scope::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_scope::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(list_by_scope::DeserializeError { body })?;
                list_by_scope::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_by_scope {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(operation_config: &crate::OperationConfig, view_name: &str) -> std::result::Result<View, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.CostManagement/views/{}",
            operation_config.base_path(),
            view_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: View = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        view_name: &str,
        parameters: &View,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.CostManagement/views/{}",
            operation_config.base_path(),
            view_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(parameters);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: View = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: View = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(View),
            Created201(View),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        view_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.CostManagement/views/{}",
            operation_config.base_path(),
            view_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get_by_scope(
        operation_config: &crate::OperationConfig,
        scope: &str,
        view_name: &str,
    ) -> std::result::Result<View, get_by_scope::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/views/{}",
            operation_config.base_path(),
            scope,
            view_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_by_scope::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_by_scope::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_by_scope::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_by_scope::ResponseBytesError)?;
                let rsp_value: View = serde_json::from_slice(&body).context(get_by_scope::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_by_scope::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(get_by_scope::DeserializeError { body })?;
                get_by_scope::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get_by_scope {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update_by_scope(
        operation_config: &crate::OperationConfig,
        scope: &str,
        view_name: &str,
        parameters: &View,
    ) -> std::result::Result<create_or_update_by_scope::Response, create_or_update_by_scope::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/views/{}",
            operation_config.base_path(),
            scope,
            view_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update_by_scope::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(parameters);
        let req = req_builder.build().context(create_or_update_by_scope::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update_by_scope::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update_by_scope::ResponseBytesError)?;
                let rsp_value: View = serde_json::from_slice(&body).context(create_or_update_by_scope::DeserializeError { body })?;
                Ok(create_or_update_by_scope::Response::Ok200(rsp_value))
            }
            StatusCode::CREATED => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update_by_scope::ResponseBytesError)?;
                let rsp_value: View = serde_json::from_slice(&body).context(create_or_update_by_scope::DeserializeError { body })?;
                Ok(create_or_update_by_scope::Response::Created201(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update_by_scope::ResponseBytesError)?;
                let rsp_value: ErrorResponse =
                    serde_json::from_slice(&body).context(create_or_update_by_scope::DeserializeError { body })?;
                create_or_update_by_scope::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update_by_scope {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(View),
            Created201(View),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete_by_scope(
        operation_config: &crate::OperationConfig,
        scope: &str,
        view_name: &str,
    ) -> std::result::Result<delete_by_scope::Response, delete_by_scope::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/views/{}",
            operation_config.base_path(),
            scope,
            view_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_by_scope::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_by_scope::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_by_scope::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete_by_scope::Response::Ok200),
            StatusCode::NO_CONTENT => Ok(delete_by_scope::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_by_scope::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(delete_by_scope::DeserializeError { body })?;
                delete_by_scope::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete_by_scope {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod alerts {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(operation_config: &crate::OperationConfig, scope: &str) -> std::result::Result<AlertsResult, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/alerts",
            operation_config.base_path(),
            scope
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: AlertsResult = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(operation_config: &crate::OperationConfig, scope: &str, alert_id: &str) -> std::result::Result<Alert, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/alerts/{}",
            operation_config.base_path(),
            scope,
            alert_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: Alert = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn dismiss(
        operation_config: &crate::OperationConfig,
        scope: &str,
        alert_id: &str,
        parameters: &DismissAlertPayload,
    ) -> std::result::Result<Alert, dismiss::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/alerts/{}",
            operation_config.base_path(),
            scope,
            alert_id
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(dismiss::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(parameters);
        let req = req_builder.build().context(dismiss::BuildRequestError)?;
        let rsp = client.execute(req).await.context(dismiss::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(dismiss::ResponseBytesError)?;
                let rsp_value: Alert = serde_json::from_slice(&body).context(dismiss::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(dismiss::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(dismiss::DeserializeError { body })?;
                dismiss::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod dismiss {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_external(
        operation_config: &crate::OperationConfig,
        external_cloud_provider_type: &str,
        external_cloud_provider_id: &str,
    ) -> std::result::Result<AlertsResult, list_external::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.CostManagement/{}/{}/alerts",
            operation_config.base_path(),
            external_cloud_provider_type,
            external_cloud_provider_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_external::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_external::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_external::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_external::ResponseBytesError)?;
                let rsp_value: AlertsResult = serde_json::from_slice(&body).context(list_external::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_external::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(list_external::DeserializeError { body })?;
                list_external::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_external {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod forecast {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn usage(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        scope: &str,
        parameters: &ForecastDefinition,
    ) -> std::result::Result<QueryResult, usage::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/forecast",
            operation_config.base_path(),
            scope
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(usage::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(filter) = filter {
            req_builder = req_builder.query(&[("$filter", filter)]);
        }
        req_builder = req_builder.json(parameters);
        let req = req_builder.build().context(usage::BuildRequestError)?;
        let rsp = client.execute(req).await.context(usage::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(usage::ResponseBytesError)?;
                let rsp_value: QueryResult = serde_json::from_slice(&body).context(usage::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(usage::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(usage::DeserializeError { body })?;
                usage::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod usage {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn external_cloud_provider_usage(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        external_cloud_provider_type: &str,
        external_cloud_provider_id: &str,
        parameters: &ForecastDefinition,
    ) -> std::result::Result<QueryResult, external_cloud_provider_usage::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.CostManagement/{}/{}/forecast",
            operation_config.base_path(),
            external_cloud_provider_type,
            external_cloud_provider_id
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(external_cloud_provider_usage::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(filter) = filter {
            req_builder = req_builder.query(&[("$filter", filter)]);
        }
        req_builder = req_builder.json(parameters);
        let req = req_builder.build().context(external_cloud_provider_usage::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(external_cloud_provider_usage::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(external_cloud_provider_usage::ResponseBytesError)?;
                let rsp_value: QueryResult =
                    serde_json::from_slice(&body).context(external_cloud_provider_usage::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(external_cloud_provider_usage::ResponseBytesError)?;
                let rsp_value: ErrorResponse =
                    serde_json::from_slice(&body).context(external_cloud_provider_usage::DeserializeError { body })?;
                external_cloud_provider_usage::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod external_cloud_provider_usage {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod dimensions {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        scope: &str,
        filter: Option<&str>,
        expand: Option<&str>,
        skiptoken: Option<&str>,
        top: Option<i64>,
    ) -> std::result::Result<DimensionsListResult, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/dimensions",
            operation_config.base_path(),
            scope
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(filter) = filter {
            req_builder = req_builder.query(&[("$filter", filter)]);
        }
        if let Some(expand) = expand {
            req_builder = req_builder.query(&[("$expand", expand)]);
        }
        if let Some(skiptoken) = skiptoken {
            req_builder = req_builder.query(&[("$skiptoken", skiptoken)]);
        }
        if let Some(top) = top {
            req_builder = req_builder.query(&[("$top", top)]);
        }
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: DimensionsListResult = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn by_external_cloud_provider_type(
        operation_config: &crate::OperationConfig,
        external_cloud_provider_type: &str,
        external_cloud_provider_id: &str,
        filter: Option<&str>,
        expand: Option<&str>,
        skiptoken: Option<&str>,
        top: Option<i64>,
    ) -> std::result::Result<DimensionsListResult, by_external_cloud_provider_type::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.CostManagement/{}/{}/dimensions",
            operation_config.base_path(),
            external_cloud_provider_type,
            external_cloud_provider_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(by_external_cloud_provider_type::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(filter) = filter {
            req_builder = req_builder.query(&[("$filter", filter)]);
        }
        if let Some(expand) = expand {
            req_builder = req_builder.query(&[("$expand", expand)]);
        }
        if let Some(skiptoken) = skiptoken {
            req_builder = req_builder.query(&[("$skiptoken", skiptoken)]);
        }
        if let Some(top) = top {
            req_builder = req_builder.query(&[("$top", top)]);
        }
        let req = req_builder.build().context(by_external_cloud_provider_type::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(by_external_cloud_provider_type::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(by_external_cloud_provider_type::ResponseBytesError)?;
                let rsp_value: DimensionsListResult =
                    serde_json::from_slice(&body).context(by_external_cloud_provider_type::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(by_external_cloud_provider_type::ResponseBytesError)?;
                let rsp_value: ErrorResponse =
                    serde_json::from_slice(&body).context(by_external_cloud_provider_type::DeserializeError { body })?;
                by_external_cloud_provider_type::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod by_external_cloud_provider_type {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod query {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn usage(
        operation_config: &crate::OperationConfig,
        scope: &str,
        parameters: &QueryDefinition,
    ) -> std::result::Result<QueryResult, usage::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/{}/providers/Microsoft.CostManagement/query",
            operation_config.base_path(),
            scope
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(usage::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(parameters);
        let req = req_builder.build().context(usage::BuildRequestError)?;
        let rsp = client.execute(req).await.context(usage::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(usage::ResponseBytesError)?;
                let rsp_value: QueryResult = serde_json::from_slice(&body).context(usage::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(usage::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(usage::DeserializeError { body })?;
                usage::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod usage {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn usage_by_external_cloud_provider_type(
        operation_config: &crate::OperationConfig,
        external_cloud_provider_type: &str,
        external_cloud_provider_id: &str,
        parameters: &QueryDefinition,
    ) -> std::result::Result<QueryResult, usage_by_external_cloud_provider_type::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.CostManagement/{}/{}/query",
            operation_config.base_path(),
            external_cloud_provider_type,
            external_cloud_provider_id
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(usage_by_external_cloud_provider_type::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(parameters);
        let req = req_builder
            .build()
            .context(usage_by_external_cloud_provider_type::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(usage_by_external_cloud_provider_type::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp
                    .bytes()
                    .await
                    .context(usage_by_external_cloud_provider_type::ResponseBytesError)?;
                let rsp_value: QueryResult =
                    serde_json::from_slice(&body).context(usage_by_external_cloud_provider_type::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp
                    .bytes()
                    .await
                    .context(usage_by_external_cloud_provider_type::ResponseBytesError)?;
                let rsp_value: ErrorResponse =
                    serde_json::from_slice(&body).context(usage_by_external_cloud_provider_type::DeserializeError { body })?;
                usage_by_external_cloud_provider_type::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod usage_by_external_cloud_provider_type {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod operations {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(operation_config: &crate::OperationConfig) -> std::result::Result<OperationListResult, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!("{}/providers/Microsoft.CostManagement/operations", operation_config.base_path(),);
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: OperationListResult = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod cost_allocation_rules {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        billing_account_id: &str,
    ) -> std::result::Result<CostAllocationRuleList, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.Billing/billingAccounts/{}/providers/Microsoft.CostManagement/costAllocationRules",
            operation_config.base_path(),
            billing_account_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: CostAllocationRuleList = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                list::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn check_name_availability(
        operation_config: &crate::OperationConfig,
        billing_account_id: &str,
        cost_allocation_rule_check_name_availability_request: &CostAllocationRuleCheckNameAvailabilityRequest,
    ) -> std::result::Result<CostAllocationRuleCheckNameAvailabilityResponse, check_name_availability::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/providers/Microsoft.Billing/billingAccounts/{}/providers/Microsoft.CostManagement/costAllocationRules/checkNameAvailability" , operation_config . base_path () , billing_account_id) ;
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(check_name_availability::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(cost_allocation_rule_check_name_availability_request);
        let req = req_builder.build().context(check_name_availability::BuildRequestError)?;
        let rsp = client.execute(req).await.context(check_name_availability::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(check_name_availability::ResponseBytesError)?;
                let rsp_value: CostAllocationRuleCheckNameAvailabilityResponse =
                    serde_json::from_slice(&body).context(check_name_availability::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(check_name_availability::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(check_name_availability::DeserializeError { body })?;
                check_name_availability::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod check_name_availability {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        billing_account_id: &str,
        rule_name: &str,
    ) -> std::result::Result<CostAllocationRuleDefinition, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.Billing/billingAccounts/{}/providers/Microsoft.CostManagement/costAllocationRules/{}",
            operation_config.base_path(),
            billing_account_id,
            rule_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: CostAllocationRuleDefinition = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        billing_account_id: &str,
        rule_name: &str,
        cost_allocation_rule: &CostAllocationRuleDefinition,
    ) -> std::result::Result<CostAllocationRuleDefinition, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.Billing/billingAccounts/{}/providers/Microsoft.CostManagement/costAllocationRules/{}",
            operation_config.base_path(),
            billing_account_id,
            rule_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(cost_allocation_rule);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: CostAllocationRuleDefinition =
                    serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        billing_account_id: &str,
        rule_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.Billing/billingAccounts/{}/providers/Microsoft.CostManagement/costAllocationRules/{}",
            operation_config.base_path(),
            billing_account_id,
            rule_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(delete::Response::Ok200),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
