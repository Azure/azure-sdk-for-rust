#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use crate::models::*;
use reqwest::StatusCode;
use snafu::{ResultExt, Snafu};
pub mod database_accounts {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<DatabaseAccountGetResults, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: DatabaseAccountGetResults = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                get::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        create_update_parameters: &DatabaseAccountCreateUpdateParameters,
    ) -> std::result::Result<DatabaseAccountGetResults, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_parameters);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: DatabaseAccountGetResults =
                    serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                create_or_update::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        update_parameters: &DatabaseAccountUpdateParameters,
    ) -> std::result::Result<DatabaseAccountGetResults, update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.patch(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_parameters);
        let req = req_builder.build().context(update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                let rsp_value: DatabaseAccountGetResults = serde_json::from_slice(&body).context(update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update::ResponseBytesError)?;
                update::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                delete::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn failover_priority_change(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        failover_parameters: &FailoverPolicies,
    ) -> std::result::Result<failover_priority_change::Response, failover_priority_change::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/failoverPriorityChange",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(failover_priority_change::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(failover_parameters);
        let req = req_builder.build().context(failover_priority_change::BuildRequestError)?;
        let rsp = client.execute(req).await.context(failover_priority_change::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(failover_priority_change::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(failover_priority_change::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(failover_priority_change::ResponseBytesError)?;
                failover_priority_change::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod failover_priority_change {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
    ) -> std::result::Result<DatabaseAccountsListResult, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/providers/Microsoft.DocumentDB/databaseAccounts",
            operation_config.base_path(),
            subscription_id
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: DatabaseAccountsListResult = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                list::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_by_resource_group(
        operation_config: &crate::OperationConfig,
        resource_group_name: &str,
        subscription_id: &str,
    ) -> std::result::Result<DatabaseAccountsListResult, list_by_resource_group::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts",
            operation_config.base_path(),
            subscription_id,
            resource_group_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_resource_group::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_by_resource_group::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_resource_group::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_resource_group::ResponseBytesError)?;
                let rsp_value: DatabaseAccountsListResult =
                    serde_json::from_slice(&body).context(list_by_resource_group::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_resource_group::ResponseBytesError)?;
                list_by_resource_group::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_by_resource_group {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_keys(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<DatabaseAccountListKeysResult, list_keys::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/listKeys",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_keys::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(list_keys::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_keys::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_keys::ResponseBytesError)?;
                let rsp_value: DatabaseAccountListKeysResult =
                    serde_json::from_slice(&body).context(list_keys::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_keys::ResponseBytesError)?;
                list_keys::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_keys {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_connection_strings(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<DatabaseAccountListConnectionStringsResult, list_connection_strings::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/listConnectionStrings",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_connection_strings::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(list_connection_strings::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_connection_strings::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_connection_strings::ResponseBytesError)?;
                let rsp_value: DatabaseAccountListConnectionStringsResult =
                    serde_json::from_slice(&body).context(list_connection_strings::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_connection_strings::ResponseBytesError)?;
                list_connection_strings::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_connection_strings {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn offline_region(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        region_parameter_for_offline: &RegionForOnlineOffline,
    ) -> std::result::Result<offline_region::Response, offline_region::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/offlineRegion",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(offline_region::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(region_parameter_for_offline);
        let req = req_builder.build().context(offline_region::BuildRequestError)?;
        let rsp = client.execute(req).await.context(offline_region::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(offline_region::Response::Ok200),
            StatusCode::ACCEPTED => Ok(offline_region::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(offline_region::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(offline_region::DeserializeError { body })?;
                offline_region::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod offline_region {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn online_region(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        region_parameter_for_online: &RegionForOnlineOffline,
    ) -> std::result::Result<online_region::Response, online_region::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/onlineRegion",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(online_region::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(region_parameter_for_online);
        let req = req_builder.build().context(online_region::BuildRequestError)?;
        let rsp = client.execute(req).await.context(online_region::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(online_region::Response::Ok200),
            StatusCode::ACCEPTED => Ok(online_region::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(online_region::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(online_region::DeserializeError { body })?;
                online_region::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod online_region {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get_read_only_keys(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<DatabaseAccountListReadOnlyKeysResult, get_read_only_keys::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/readonlykeys",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_read_only_keys::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_read_only_keys::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_read_only_keys::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_read_only_keys::ResponseBytesError)?;
                let rsp_value: DatabaseAccountListReadOnlyKeysResult =
                    serde_json::from_slice(&body).context(get_read_only_keys::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_read_only_keys::ResponseBytesError)?;
                get_read_only_keys::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_read_only_keys {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_read_only_keys(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<DatabaseAccountListReadOnlyKeysResult, list_read_only_keys::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/readonlykeys",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_read_only_keys::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(list_read_only_keys::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_read_only_keys::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_read_only_keys::ResponseBytesError)?;
                let rsp_value: DatabaseAccountListReadOnlyKeysResult =
                    serde_json::from_slice(&body).context(list_read_only_keys::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_read_only_keys::ResponseBytesError)?;
                list_read_only_keys::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_read_only_keys {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn regenerate_key(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        key_to_regenerate: &DatabaseAccountRegenerateKeyParameters,
    ) -> std::result::Result<regenerate_key::Response, regenerate_key::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/regenerateKey",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(regenerate_key::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(key_to_regenerate);
        let req = req_builder.build().context(regenerate_key::BuildRequestError)?;
        let rsp = client.execute(req).await.context(regenerate_key::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(regenerate_key::Response::Ok200),
            StatusCode::ACCEPTED => Ok(regenerate_key::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(regenerate_key::ResponseBytesError)?;
                regenerate_key::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod regenerate_key {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn check_name_exists(
        operation_config: &crate::OperationConfig,
        account_name: &str,
    ) -> std::result::Result<(), check_name_exists::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/providers/Microsoft.DocumentDB/databaseAccountNames/{}",
            operation_config.base_path(),
            account_name
        );
        let mut req_builder = client.head(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(check_name_exists::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(check_name_exists::BuildRequestError)?;
        let rsp = client.execute(req).await.context(check_name_exists::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(()),
            StatusCode::NOT_FOUND => check_name_exists::NotFound404 {}.fail(),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(check_name_exists::ResponseBytesError)?;
                check_name_exists::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod check_name_exists {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            NotFound404 {},
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        filter: &str,
    ) -> std::result::Result<MetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/metrics",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: MetricListResult = serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_usages(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        filter: Option<&str>,
    ) -> std::result::Result<UsagesResult, list_usages::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/usages",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_usages::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(filter) = filter {
            req_builder = req_builder.query(&[("$filter", filter)]);
        }
        let req = req_builder.build().context(list_usages::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_usages::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_usages::ResponseBytesError)?;
                let rsp_value: UsagesResult = serde_json::from_slice(&body).context(list_usages::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_usages::ResponseBytesError)?;
                list_usages::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_usages {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_metric_definitions(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<MetricDefinitionsListResult, list_metric_definitions::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/metricDefinitions",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metric_definitions::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_metric_definitions::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metric_definitions::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metric_definitions::ResponseBytesError)?;
                let rsp_value: MetricDefinitionsListResult =
                    serde_json::from_slice(&body).context(list_metric_definitions::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metric_definitions::ResponseBytesError)?;
                list_metric_definitions::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metric_definitions {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod operations {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list(operation_config: &crate::OperationConfig) -> std::result::Result<OperationListResult, list::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!("{}/providers/Microsoft.DocumentDB/operations", operation_config.base_path(),);
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                let rsp_value: OperationListResult = serde_json::from_slice(&body).context(list::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list::ResponseBytesError)?;
                list::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod database {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
        filter: &str,
    ) -> std::result::Result<MetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/metrics",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_rid
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: MetricListResult = serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_usages(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
        filter: Option<&str>,
    ) -> std::result::Result<UsagesResult, list_usages::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/usages",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_rid
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_usages::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(filter) = filter {
            req_builder = req_builder.query(&[("$filter", filter)]);
        }
        let req = req_builder.build().context(list_usages::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_usages::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_usages::ResponseBytesError)?;
                let rsp_value: UsagesResult = serde_json::from_slice(&body).context(list_usages::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_usages::ResponseBytesError)?;
                list_usages::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_usages {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_metric_definitions(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
    ) -> std::result::Result<MetricDefinitionsListResult, list_metric_definitions::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/metricDefinitions",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_rid
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metric_definitions::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_metric_definitions::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metric_definitions::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metric_definitions::ResponseBytesError)?;
                let rsp_value: MetricDefinitionsListResult =
                    serde_json::from_slice(&body).context(list_metric_definitions::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metric_definitions::ResponseBytesError)?;
                list_metric_definitions::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metric_definitions {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod collection {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
        collection_rid: &str,
        filter: &str,
    ) -> std::result::Result<MetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/collections/{}/metrics",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_rid,
            collection_rid
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: MetricListResult = serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_usages(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
        collection_rid: &str,
        filter: Option<&str>,
    ) -> std::result::Result<UsagesResult, list_usages::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/collections/{}/usages",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_rid,
            collection_rid
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_usages::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(filter) = filter {
            req_builder = req_builder.query(&[("$filter", filter)]);
        }
        let req = req_builder.build().context(list_usages::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_usages::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_usages::ResponseBytesError)?;
                let rsp_value: UsagesResult = serde_json::from_slice(&body).context(list_usages::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_usages::ResponseBytesError)?;
                list_usages::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_usages {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_metric_definitions(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
        collection_rid: &str,
    ) -> std::result::Result<MetricDefinitionsListResult, list_metric_definitions::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/collections/{}/metricDefinitions" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_rid , collection_rid) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metric_definitions::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_metric_definitions::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metric_definitions::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metric_definitions::ResponseBytesError)?;
                let rsp_value: MetricDefinitionsListResult =
                    serde_json::from_slice(&body).context(list_metric_definitions::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metric_definitions::ResponseBytesError)?;
                list_metric_definitions::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metric_definitions {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod collection_region {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        region: &str,
        database_rid: &str,
        collection_rid: &str,
        filter: &str,
    ) -> std::result::Result<MetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/region/{}/databases/{}/collections/{}/metrics" , operation_config . base_path () , subscription_id , resource_group_name , account_name , region , database_rid , collection_rid) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: MetricListResult = serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod database_account_region {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        region: &str,
        filter: &str,
    ) -> std::result::Result<MetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/region/{}/metrics",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            region
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: MetricListResult = serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod percentile_source_target {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        source_region: &str,
        target_region: &str,
        filter: &str,
    ) -> std::result::Result<PercentileMetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sourceRegion/{}/targetRegion/{}/percentile/metrics" , operation_config . base_path () , subscription_id , resource_group_name , account_name , source_region , target_region) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: PercentileMetricListResult =
                    serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod percentile_target {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        target_region: &str,
        filter: &str,
    ) -> std::result::Result<PercentileMetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/targetRegion/{}/percentile/metrics",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            target_region
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: PercentileMetricListResult =
                    serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod percentile {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        filter: &str,
    ) -> std::result::Result<PercentileMetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/percentile/metrics",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: PercentileMetricListResult =
                    serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod collection_partition_region {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        region: &str,
        database_rid: &str,
        collection_rid: &str,
        filter: &str,
    ) -> std::result::Result<PartitionMetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/region/{}/databases/{}/collections/{}/partitions/metrics" , operation_config . base_path () , subscription_id , resource_group_name , account_name , region , database_rid , collection_rid) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: PartitionMetricListResult =
                    serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod collection_partition {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
        collection_rid: &str,
        filter: &str,
    ) -> std::result::Result<PartitionMetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/collections/{}/partitions/metrics" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_rid , collection_rid) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: PartitionMetricListResult =
                    serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_usages(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
        collection_rid: &str,
        filter: Option<&str>,
    ) -> std::result::Result<PartitionUsagesResult, list_usages::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/collections/{}/partitions/usages" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_rid , collection_rid) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_usages::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        if let Some(filter) = filter {
            req_builder = req_builder.query(&[("$filter", filter)]);
        }
        let req = req_builder.build().context(list_usages::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_usages::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_usages::ResponseBytesError)?;
                let rsp_value: PartitionUsagesResult = serde_json::from_slice(&body).context(list_usages::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_usages::ResponseBytesError)?;
                list_usages::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_usages {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod partition_key_range_id {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_rid: &str,
        collection_rid: &str,
        partition_key_range_id: &str,
        filter: &str,
    ) -> std::result::Result<PartitionMetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/databases/{}/collections/{}/partitionKeyRangeId/{}/metrics" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_rid , collection_rid , partition_key_range_id) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: PartitionMetricListResult =
                    serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod partition_key_range_id_region {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_metrics(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        region: &str,
        database_rid: &str,
        collection_rid: &str,
        partition_key_range_id: &str,
        filter: &str,
    ) -> std::result::Result<PartitionMetricListResult, list_metrics::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/region/{}/databases/{}/collections/{}/partitionKeyRangeId/{}/metrics" , operation_config . base_path () , subscription_id , resource_group_name , account_name , region , database_rid , collection_rid , partition_key_range_id) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_metrics::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.query(&[("$filter", filter)]);
        let req = req_builder.build().context(list_metrics::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_metrics::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                let rsp_value: PartitionMetricListResult =
                    serde_json::from_slice(&body).context(list_metrics::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_metrics::ResponseBytesError)?;
                list_metrics::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_metrics {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod sql_resources {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_sql_databases(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<SqlDatabaseListResult, list_sql_databases::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_sql_databases::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_sql_databases::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_sql_databases::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_databases::ResponseBytesError)?;
                let rsp_value: SqlDatabaseListResult =
                    serde_json::from_slice(&body).context(list_sql_databases::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_databases::ResponseBytesError)?;
                list_sql_databases::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_sql_databases {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_sql_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<SqlDatabaseGetResults, get_sql_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_sql_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_sql_database::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_sql_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_database::ResponseBytesError)?;
                let rsp_value: SqlDatabaseGetResults =
                    serde_json::from_slice(&body).context(get_sql_database::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_database::ResponseBytesError)?;
                get_sql_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_sql_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_sql_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        create_update_sql_database_parameters: &SqlDatabaseCreateUpdateParameters,
    ) -> std::result::Result<create_update_sql_database::Response, create_update_sql_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_sql_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_sql_database_parameters);
        let req = req_builder.build().context(create_update_sql_database::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_update_sql_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_sql_database::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_sql_database::ResponseBytesError)?;
                let rsp_value: SqlDatabaseGetResults =
                    serde_json::from_slice(&body).context(create_update_sql_database::DeserializeError { body })?;
                Ok(create_update_sql_database::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_sql_database::ResponseBytesError)?;
                create_update_sql_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_sql_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(SqlDatabaseGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_sql_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<delete_sql_database::Response, delete_sql_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_sql_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_sql_database::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_sql_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_sql_database::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_sql_database::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_sql_database::ResponseBytesError)?;
                delete_sql_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_sql_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_sql_database_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_sql_database_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_sql_database_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_sql_database_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_sql_database_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_database_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_sql_database_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_database_throughput::ResponseBytesError)?;
                get_sql_database_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_sql_database_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_sql_database_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_sql_database_throughput::Response, update_sql_database_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_sql_database_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder.build().context(update_sql_database_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(update_sql_database_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_sql_database_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_sql_database_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_sql_database_throughput::DeserializeError { body })?;
                Ok(update_sql_database_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_sql_database_throughput::ResponseBytesError)?;
                update_sql_database_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_sql_database_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_sql_containers(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<SqlContainerListResult, list_sql_containers::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_sql_containers::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_sql_containers::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_sql_containers::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_containers::ResponseBytesError)?;
                let rsp_value: SqlContainerListResult =
                    serde_json::from_slice(&body).context(list_sql_containers::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_containers::ResponseBytesError)?;
                list_sql_containers::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_sql_containers {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_sql_container(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
    ) -> std::result::Result<SqlContainerGetResults, get_sql_container::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            container_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_sql_container::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_sql_container::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_sql_container::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_container::ResponseBytesError)?;
                let rsp_value: SqlContainerGetResults =
                    serde_json::from_slice(&body).context(get_sql_container::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_container::ResponseBytesError)?;
                get_sql_container::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_sql_container {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_sql_container(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        create_update_sql_container_parameters: &SqlContainerCreateUpdateParameters,
    ) -> std::result::Result<create_update_sql_container::Response, create_update_sql_container::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            container_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_sql_container::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_sql_container_parameters);
        let req = req_builder.build().context(create_update_sql_container::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_sql_container::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_sql_container::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_sql_container::ResponseBytesError)?;
                let rsp_value: SqlContainerGetResults =
                    serde_json::from_slice(&body).context(create_update_sql_container::DeserializeError { body })?;
                Ok(create_update_sql_container::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_sql_container::ResponseBytesError)?;
                create_update_sql_container::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_sql_container {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(SqlContainerGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_sql_container(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
    ) -> std::result::Result<delete_sql_container::Response, delete_sql_container::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            container_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_sql_container::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_sql_container::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_sql_container::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_sql_container::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_sql_container::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_sql_container::ResponseBytesError)?;
                delete_sql_container::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_sql_container {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_sql_container_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_sql_container_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_sql_container_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_sql_container_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_sql_container_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_container_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_sql_container_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_container_throughput::ResponseBytesError)?;
                get_sql_container_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_sql_container_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_sql_container_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_sql_container_throughput::Response, update_sql_container_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_sql_container_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder.build().context(update_sql_container_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(update_sql_container_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_sql_container_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_sql_container_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_sql_container_throughput::DeserializeError { body })?;
                Ok(update_sql_container_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_sql_container_throughput::ResponseBytesError)?;
                update_sql_container_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_sql_container_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_sql_stored_procedures(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
    ) -> std::result::Result<SqlStoredProcedureListResult, list_sql_stored_procedures::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/storedProcedures" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_sql_stored_procedures::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_sql_stored_procedures::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_sql_stored_procedures::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_stored_procedures::ResponseBytesError)?;
                let rsp_value: SqlStoredProcedureListResult =
                    serde_json::from_slice(&body).context(list_sql_stored_procedures::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_stored_procedures::ResponseBytesError)?;
                list_sql_stored_procedures::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_sql_stored_procedures {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_sql_stored_procedure(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        stored_procedure_name: &str,
    ) -> std::result::Result<SqlStoredProcedureGetResults, get_sql_stored_procedure::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/storedProcedures/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , stored_procedure_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_sql_stored_procedure::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_sql_stored_procedure::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_sql_stored_procedure::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_stored_procedure::ResponseBytesError)?;
                let rsp_value: SqlStoredProcedureGetResults =
                    serde_json::from_slice(&body).context(get_sql_stored_procedure::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_stored_procedure::ResponseBytesError)?;
                get_sql_stored_procedure::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_sql_stored_procedure {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_sql_stored_procedure(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        stored_procedure_name: &str,
        create_update_sql_stored_procedure_parameters: &SqlStoredProcedureCreateUpdateParameters,
    ) -> std::result::Result<create_update_sql_stored_procedure::Response, create_update_sql_stored_procedure::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/storedProcedures/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , stored_procedure_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_sql_stored_procedure::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_sql_stored_procedure_parameters);
        let req = req_builder.build().context(create_update_sql_stored_procedure::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_sql_stored_procedure::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_sql_stored_procedure::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_sql_stored_procedure::ResponseBytesError)?;
                let rsp_value: SqlStoredProcedureGetResults =
                    serde_json::from_slice(&body).context(create_update_sql_stored_procedure::DeserializeError { body })?;
                Ok(create_update_sql_stored_procedure::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_sql_stored_procedure::ResponseBytesError)?;
                create_update_sql_stored_procedure::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_sql_stored_procedure {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(SqlStoredProcedureGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_sql_stored_procedure(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        stored_procedure_name: &str,
    ) -> std::result::Result<delete_sql_stored_procedure::Response, delete_sql_stored_procedure::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/storedProcedures/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , stored_procedure_name) ;
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_sql_stored_procedure::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_sql_stored_procedure::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(delete_sql_stored_procedure::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_sql_stored_procedure::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_sql_stored_procedure::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_sql_stored_procedure::ResponseBytesError)?;
                delete_sql_stored_procedure::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_sql_stored_procedure {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_sql_user_defined_functions(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
    ) -> std::result::Result<SqlUserDefinedFunctionListResult, list_sql_user_defined_functions::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/userDefinedFunctions" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_sql_user_defined_functions::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_sql_user_defined_functions::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(list_sql_user_defined_functions::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_user_defined_functions::ResponseBytesError)?;
                let rsp_value: SqlUserDefinedFunctionListResult =
                    serde_json::from_slice(&body).context(list_sql_user_defined_functions::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_user_defined_functions::ResponseBytesError)?;
                list_sql_user_defined_functions::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_sql_user_defined_functions {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_sql_user_defined_function(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        user_defined_function_name: &str,
    ) -> std::result::Result<SqlUserDefinedFunctionGetResults, get_sql_user_defined_function::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/userDefinedFunctions/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , user_defined_function_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_sql_user_defined_function::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_sql_user_defined_function::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_sql_user_defined_function::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_user_defined_function::ResponseBytesError)?;
                let rsp_value: SqlUserDefinedFunctionGetResults =
                    serde_json::from_slice(&body).context(get_sql_user_defined_function::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_user_defined_function::ResponseBytesError)?;
                get_sql_user_defined_function::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_sql_user_defined_function {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_sql_user_defined_function(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        user_defined_function_name: &str,
        create_update_sql_user_defined_function_parameters: &SqlUserDefinedFunctionCreateUpdateParameters,
    ) -> std::result::Result<create_update_sql_user_defined_function::Response, create_update_sql_user_defined_function::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/userDefinedFunctions/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , user_defined_function_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_sql_user_defined_function::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_sql_user_defined_function_parameters);
        let req = req_builder
            .build()
            .context(create_update_sql_user_defined_function::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_sql_user_defined_function::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_sql_user_defined_function::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp
                    .bytes()
                    .await
                    .context(create_update_sql_user_defined_function::ResponseBytesError)?;
                let rsp_value: SqlUserDefinedFunctionGetResults =
                    serde_json::from_slice(&body).context(create_update_sql_user_defined_function::DeserializeError { body })?;
                Ok(create_update_sql_user_defined_function::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp
                    .bytes()
                    .await
                    .context(create_update_sql_user_defined_function::ResponseBytesError)?;
                create_update_sql_user_defined_function::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_sql_user_defined_function {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(SqlUserDefinedFunctionGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_sql_user_defined_function(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        user_defined_function_name: &str,
    ) -> std::result::Result<delete_sql_user_defined_function::Response, delete_sql_user_defined_function::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/userDefinedFunctions/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , user_defined_function_name) ;
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_sql_user_defined_function::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_sql_user_defined_function::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(delete_sql_user_defined_function::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_sql_user_defined_function::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_sql_user_defined_function::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_sql_user_defined_function::ResponseBytesError)?;
                delete_sql_user_defined_function::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_sql_user_defined_function {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_sql_triggers(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
    ) -> std::result::Result<SqlTriggerListResult, list_sql_triggers::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/triggers" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_sql_triggers::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_sql_triggers::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_sql_triggers::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_triggers::ResponseBytesError)?;
                let rsp_value: SqlTriggerListResult =
                    serde_json::from_slice(&body).context(list_sql_triggers::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_sql_triggers::ResponseBytesError)?;
                list_sql_triggers::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_sql_triggers {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_sql_trigger(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        trigger_name: &str,
    ) -> std::result::Result<SqlTriggerGetResults, get_sql_trigger::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/triggers/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , trigger_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_sql_trigger::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_sql_trigger::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_sql_trigger::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_trigger::ResponseBytesError)?;
                let rsp_value: SqlTriggerGetResults = serde_json::from_slice(&body).context(get_sql_trigger::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_sql_trigger::ResponseBytesError)?;
                get_sql_trigger::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_sql_trigger {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_sql_trigger(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        trigger_name: &str,
        create_update_sql_trigger_parameters: &SqlTriggerCreateUpdateParameters,
    ) -> std::result::Result<create_update_sql_trigger::Response, create_update_sql_trigger::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/triggers/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , trigger_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_sql_trigger::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_sql_trigger_parameters);
        let req = req_builder.build().context(create_update_sql_trigger::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_update_sql_trigger::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_sql_trigger::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_sql_trigger::ResponseBytesError)?;
                let rsp_value: SqlTriggerGetResults =
                    serde_json::from_slice(&body).context(create_update_sql_trigger::DeserializeError { body })?;
                Ok(create_update_sql_trigger::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_sql_trigger::ResponseBytesError)?;
                create_update_sql_trigger::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_sql_trigger {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(SqlTriggerGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_sql_trigger(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        container_name: &str,
        trigger_name: &str,
    ) -> std::result::Result<delete_sql_trigger::Response, delete_sql_trigger::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/sqlDatabases/{}/containers/{}/triggers/{}" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , container_name , trigger_name) ;
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_sql_trigger::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_sql_trigger::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_sql_trigger::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_sql_trigger::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_sql_trigger::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_sql_trigger::ResponseBytesError)?;
                delete_sql_trigger::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_sql_trigger {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod mongo_db_resources {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_mongo_db_databases(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<MongoDbDatabaseListResult, list_mongo_db_databases::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_mongo_db_databases::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_mongo_db_databases::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_mongo_db_databases::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_mongo_db_databases::ResponseBytesError)?;
                let rsp_value: MongoDbDatabaseListResult =
                    serde_json::from_slice(&body).context(list_mongo_db_databases::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_mongo_db_databases::ResponseBytesError)?;
                list_mongo_db_databases::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_mongo_db_databases {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_mongo_db_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<MongoDbDatabaseGetResults, get_mongo_db_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_mongo_db_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_mongo_db_database::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_mongo_db_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_mongo_db_database::ResponseBytesError)?;
                let rsp_value: MongoDbDatabaseGetResults =
                    serde_json::from_slice(&body).context(get_mongo_db_database::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_mongo_db_database::ResponseBytesError)?;
                get_mongo_db_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_mongo_db_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_mongo_db_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        create_update_mongo_db_database_parameters: &MongoDbDatabaseCreateUpdateParameters,
    ) -> std::result::Result<create_update_mongo_db_database::Response, create_update_mongo_db_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_mongo_db_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_mongo_db_database_parameters);
        let req = req_builder.build().context(create_update_mongo_db_database::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_mongo_db_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_mongo_db_database::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_mongo_db_database::ResponseBytesError)?;
                let rsp_value: MongoDbDatabaseGetResults =
                    serde_json::from_slice(&body).context(create_update_mongo_db_database::DeserializeError { body })?;
                Ok(create_update_mongo_db_database::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_mongo_db_database::ResponseBytesError)?;
                create_update_mongo_db_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_mongo_db_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(MongoDbDatabaseGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_mongo_db_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<delete_mongo_db_database::Response, delete_mongo_db_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_mongo_db_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_mongo_db_database::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_mongo_db_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_mongo_db_database::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_mongo_db_database::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_mongo_db_database::ResponseBytesError)?;
                delete_mongo_db_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_mongo_db_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_mongo_db_database_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_mongo_db_database_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_mongo_db_database_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_mongo_db_database_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_mongo_db_database_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_mongo_db_database_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_mongo_db_database_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_mongo_db_database_throughput::ResponseBytesError)?;
                get_mongo_db_database_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_mongo_db_database_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_mongo_db_database_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_mongo_db_database_throughput::Response, update_mongo_db_database_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_mongo_db_database_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder
            .build()
            .context(update_mongo_db_database_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(update_mongo_db_database_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_mongo_db_database_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_mongo_db_database_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_mongo_db_database_throughput::DeserializeError { body })?;
                Ok(update_mongo_db_database_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_mongo_db_database_throughput::ResponseBytesError)?;
                update_mongo_db_database_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_mongo_db_database_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_mongo_db_collections(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<MongoDbCollectionListResult, list_mongo_db_collections::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}/collections",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_mongo_db_collections::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_mongo_db_collections::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_mongo_db_collections::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_mongo_db_collections::ResponseBytesError)?;
                let rsp_value: MongoDbCollectionListResult =
                    serde_json::from_slice(&body).context(list_mongo_db_collections::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_mongo_db_collections::ResponseBytesError)?;
                list_mongo_db_collections::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_mongo_db_collections {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_mongo_db_collection(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        collection_name: &str,
    ) -> std::result::Result<MongoDbCollectionGetResults, get_mongo_db_collection::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}/collections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            collection_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_mongo_db_collection::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_mongo_db_collection::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_mongo_db_collection::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_mongo_db_collection::ResponseBytesError)?;
                let rsp_value: MongoDbCollectionGetResults =
                    serde_json::from_slice(&body).context(get_mongo_db_collection::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_mongo_db_collection::ResponseBytesError)?;
                get_mongo_db_collection::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_mongo_db_collection {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_mongo_db_collection(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        collection_name: &str,
        create_update_mongo_db_collection_parameters: &MongoDbCollectionCreateUpdateParameters,
    ) -> std::result::Result<create_update_mongo_db_collection::Response, create_update_mongo_db_collection::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}/collections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            collection_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_mongo_db_collection::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_mongo_db_collection_parameters);
        let req = req_builder.build().context(create_update_mongo_db_collection::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_mongo_db_collection::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_mongo_db_collection::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_mongo_db_collection::ResponseBytesError)?;
                let rsp_value: MongoDbCollectionGetResults =
                    serde_json::from_slice(&body).context(create_update_mongo_db_collection::DeserializeError { body })?;
                Ok(create_update_mongo_db_collection::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_mongo_db_collection::ResponseBytesError)?;
                create_update_mongo_db_collection::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_mongo_db_collection {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(MongoDbCollectionGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_mongo_db_collection(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        collection_name: &str,
    ) -> std::result::Result<delete_mongo_db_collection::Response, delete_mongo_db_collection::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}/collections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            collection_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_mongo_db_collection::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_mongo_db_collection::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_mongo_db_collection::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_mongo_db_collection::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_mongo_db_collection::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_mongo_db_collection::ResponseBytesError)?;
                delete_mongo_db_collection::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_mongo_db_collection {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_mongo_db_collection_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        collection_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_mongo_db_collection_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}/collections/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , collection_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_mongo_db_collection_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_mongo_db_collection_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_mongo_db_collection_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_mongo_db_collection_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_mongo_db_collection_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_mongo_db_collection_throughput::ResponseBytesError)?;
                get_mongo_db_collection_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_mongo_db_collection_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_mongo_db_collection_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        collection_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_mongo_db_collection_throughput::Response, update_mongo_db_collection_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/mongodbDatabases/{}/collections/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , collection_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_mongo_db_collection_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder
            .build()
            .context(update_mongo_db_collection_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(update_mongo_db_collection_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_mongo_db_collection_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp
                    .bytes()
                    .await
                    .context(update_mongo_db_collection_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_mongo_db_collection_throughput::DeserializeError { body })?;
                Ok(update_mongo_db_collection_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp
                    .bytes()
                    .await
                    .context(update_mongo_db_collection_throughput::ResponseBytesError)?;
                update_mongo_db_collection_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_mongo_db_collection_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod table_resources {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_tables(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<TableListResult, list_tables::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/tables",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_tables::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_tables::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_tables::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_tables::ResponseBytesError)?;
                let rsp_value: TableListResult = serde_json::from_slice(&body).context(list_tables::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_tables::ResponseBytesError)?;
                list_tables::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_tables {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_table(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        table_name: &str,
    ) -> std::result::Result<TableGetResults, get_table::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/tables/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            table_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_table::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_table::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_table::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_table::ResponseBytesError)?;
                let rsp_value: TableGetResults = serde_json::from_slice(&body).context(get_table::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_table::ResponseBytesError)?;
                get_table::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_table {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_table(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        table_name: &str,
        create_update_table_parameters: &TableCreateUpdateParameters,
    ) -> std::result::Result<create_update_table::Response, create_update_table::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/tables/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            table_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_table::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_table_parameters);
        let req = req_builder.build().context(create_update_table::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_update_table::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_table::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_table::ResponseBytesError)?;
                let rsp_value: TableGetResults = serde_json::from_slice(&body).context(create_update_table::DeserializeError { body })?;
                Ok(create_update_table::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_table::ResponseBytesError)?;
                create_update_table::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_table {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(TableGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_table(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        table_name: &str,
    ) -> std::result::Result<delete_table::Response, delete_table::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/tables/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            table_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_table::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_table::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_table::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_table::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_table::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_table::ResponseBytesError)?;
                delete_table::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_table {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_table_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        table_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_table_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/tables/{}/throughputSettings/default",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            table_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_table_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_table_throughput::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_table_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_table_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_table_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_table_throughput::ResponseBytesError)?;
                get_table_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_table_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_table_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        table_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_table_throughput::Response, update_table_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/tables/{}/throughputSettings/default",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            table_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_table_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder.build().context(update_table_throughput::BuildRequestError)?;
        let rsp = client.execute(req).await.context(update_table_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_table_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_table_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_table_throughput::DeserializeError { body })?;
                Ok(update_table_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_table_throughput::ResponseBytesError)?;
                update_table_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_table_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod cassandra_resources {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_cassandra_keyspaces(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<CassandraKeyspaceListResult, list_cassandra_keyspaces::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_cassandra_keyspaces::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_cassandra_keyspaces::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_cassandra_keyspaces::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_cassandra_keyspaces::ResponseBytesError)?;
                let rsp_value: CassandraKeyspaceListResult =
                    serde_json::from_slice(&body).context(list_cassandra_keyspaces::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_cassandra_keyspaces::ResponseBytesError)?;
                list_cassandra_keyspaces::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_cassandra_keyspaces {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_cassandra_keyspace(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
    ) -> std::result::Result<CassandraKeyspaceGetResults, get_cassandra_keyspace::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            keyspace_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_cassandra_keyspace::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_cassandra_keyspace::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_cassandra_keyspace::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_cassandra_keyspace::ResponseBytesError)?;
                let rsp_value: CassandraKeyspaceGetResults =
                    serde_json::from_slice(&body).context(get_cassandra_keyspace::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_cassandra_keyspace::ResponseBytesError)?;
                get_cassandra_keyspace::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_cassandra_keyspace {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_cassandra_keyspace(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
        create_update_cassandra_keyspace_parameters: &CassandraKeyspaceCreateUpdateParameters,
    ) -> std::result::Result<create_update_cassandra_keyspace::Response, create_update_cassandra_keyspace::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            keyspace_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_cassandra_keyspace::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_cassandra_keyspace_parameters);
        let req = req_builder.build().context(create_update_cassandra_keyspace::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_cassandra_keyspace::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_cassandra_keyspace::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_cassandra_keyspace::ResponseBytesError)?;
                let rsp_value: CassandraKeyspaceGetResults =
                    serde_json::from_slice(&body).context(create_update_cassandra_keyspace::DeserializeError { body })?;
                Ok(create_update_cassandra_keyspace::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_cassandra_keyspace::ResponseBytesError)?;
                create_update_cassandra_keyspace::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_cassandra_keyspace {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(CassandraKeyspaceGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_cassandra_keyspace(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
    ) -> std::result::Result<delete_cassandra_keyspace::Response, delete_cassandra_keyspace::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            keyspace_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_cassandra_keyspace::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_cassandra_keyspace::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_cassandra_keyspace::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_cassandra_keyspace::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_cassandra_keyspace::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_cassandra_keyspace::ResponseBytesError)?;
                delete_cassandra_keyspace::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_cassandra_keyspace {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_cassandra_keyspace_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_cassandra_keyspace_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , keyspace_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_cassandra_keyspace_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_cassandra_keyspace_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_cassandra_keyspace_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_cassandra_keyspace_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_cassandra_keyspace_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_cassandra_keyspace_throughput::ResponseBytesError)?;
                get_cassandra_keyspace_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_cassandra_keyspace_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_cassandra_keyspace_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_cassandra_keyspace_throughput::Response, update_cassandra_keyspace_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , keyspace_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_cassandra_keyspace_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder
            .build()
            .context(update_cassandra_keyspace_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(update_cassandra_keyspace_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_cassandra_keyspace_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp
                    .bytes()
                    .await
                    .context(update_cassandra_keyspace_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_cassandra_keyspace_throughput::DeserializeError { body })?;
                Ok(update_cassandra_keyspace_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp
                    .bytes()
                    .await
                    .context(update_cassandra_keyspace_throughput::ResponseBytesError)?;
                update_cassandra_keyspace_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_cassandra_keyspace_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_cassandra_tables(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
    ) -> std::result::Result<CassandraTableListResult, list_cassandra_tables::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}/tables",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            keyspace_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_cassandra_tables::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_cassandra_tables::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_cassandra_tables::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_cassandra_tables::ResponseBytesError)?;
                let rsp_value: CassandraTableListResult =
                    serde_json::from_slice(&body).context(list_cassandra_tables::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_cassandra_tables::ResponseBytesError)?;
                list_cassandra_tables::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_cassandra_tables {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_cassandra_table(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
        table_name: &str,
    ) -> std::result::Result<CassandraTableGetResults, get_cassandra_table::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}/tables/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            keyspace_name,
            table_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_cassandra_table::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_cassandra_table::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_cassandra_table::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_cassandra_table::ResponseBytesError)?;
                let rsp_value: CassandraTableGetResults =
                    serde_json::from_slice(&body).context(get_cassandra_table::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_cassandra_table::ResponseBytesError)?;
                get_cassandra_table::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_cassandra_table {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_cassandra_table(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
        table_name: &str,
        create_update_cassandra_table_parameters: &CassandraTableCreateUpdateParameters,
    ) -> std::result::Result<create_update_cassandra_table::Response, create_update_cassandra_table::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}/tables/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            keyspace_name,
            table_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_cassandra_table::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_cassandra_table_parameters);
        let req = req_builder.build().context(create_update_cassandra_table::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_cassandra_table::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_cassandra_table::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_cassandra_table::ResponseBytesError)?;
                let rsp_value: CassandraTableGetResults =
                    serde_json::from_slice(&body).context(create_update_cassandra_table::DeserializeError { body })?;
                Ok(create_update_cassandra_table::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_cassandra_table::ResponseBytesError)?;
                create_update_cassandra_table::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_cassandra_table {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(CassandraTableGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_cassandra_table(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
        table_name: &str,
    ) -> std::result::Result<delete_cassandra_table::Response, delete_cassandra_table::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}/tables/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            keyspace_name,
            table_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_cassandra_table::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_cassandra_table::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_cassandra_table::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_cassandra_table::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_cassandra_table::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_cassandra_table::ResponseBytesError)?;
                delete_cassandra_table::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_cassandra_table {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_cassandra_table_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
        table_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_cassandra_table_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}/tables/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , keyspace_name , table_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_cassandra_table_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_cassandra_table_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_cassandra_table_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_cassandra_table_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_cassandra_table_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_cassandra_table_throughput::ResponseBytesError)?;
                get_cassandra_table_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_cassandra_table_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_cassandra_table_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        keyspace_name: &str,
        table_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_cassandra_table_throughput::Response, update_cassandra_table_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/cassandraKeyspaces/{}/tables/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , keyspace_name , table_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_cassandra_table_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder.build().context(update_cassandra_table_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(update_cassandra_table_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_cassandra_table_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_cassandra_table_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_cassandra_table_throughput::DeserializeError { body })?;
                Ok(update_cassandra_table_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_cassandra_table_throughput::ResponseBytesError)?;
                update_cassandra_table_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_cassandra_table_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod gremlin_resources {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_gremlin_databases(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<GremlinDatabaseListResult, list_gremlin_databases::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_gremlin_databases::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_gremlin_databases::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_gremlin_databases::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_gremlin_databases::ResponseBytesError)?;
                let rsp_value: GremlinDatabaseListResult =
                    serde_json::from_slice(&body).context(list_gremlin_databases::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_gremlin_databases::ResponseBytesError)?;
                list_gremlin_databases::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_gremlin_databases {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_gremlin_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<GremlinDatabaseGetResults, get_gremlin_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_gremlin_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_gremlin_database::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_gremlin_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gremlin_database::ResponseBytesError)?;
                let rsp_value: GremlinDatabaseGetResults =
                    serde_json::from_slice(&body).context(get_gremlin_database::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gremlin_database::ResponseBytesError)?;
                get_gremlin_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_gremlin_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_gremlin_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        create_update_gremlin_database_parameters: &GremlinDatabaseCreateUpdateParameters,
    ) -> std::result::Result<create_update_gremlin_database::Response, create_update_gremlin_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_gremlin_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_gremlin_database_parameters);
        let req = req_builder.build().context(create_update_gremlin_database::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_gremlin_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_gremlin_database::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_gremlin_database::ResponseBytesError)?;
                let rsp_value: GremlinDatabaseGetResults =
                    serde_json::from_slice(&body).context(create_update_gremlin_database::DeserializeError { body })?;
                Ok(create_update_gremlin_database::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_gremlin_database::ResponseBytesError)?;
                create_update_gremlin_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_gremlin_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(GremlinDatabaseGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_gremlin_database(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<delete_gremlin_database::Response, delete_gremlin_database::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_gremlin_database::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_gremlin_database::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_gremlin_database::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_gremlin_database::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_gremlin_database::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_gremlin_database::ResponseBytesError)?;
                delete_gremlin_database::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_gremlin_database {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_gremlin_database_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_gremlin_database_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_gremlin_database_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_gremlin_database_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_gremlin_database_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gremlin_database_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_gremlin_database_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gremlin_database_throughput::ResponseBytesError)?;
                get_gremlin_database_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_gremlin_database_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_gremlin_database_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_gremlin_database_throughput::Response, update_gremlin_database_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_gremlin_database_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder.build().context(update_gremlin_database_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(update_gremlin_database_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_gremlin_database_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_gremlin_database_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_gremlin_database_throughput::DeserializeError { body })?;
                Ok(update_gremlin_database_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_gremlin_database_throughput::ResponseBytesError)?;
                update_gremlin_database_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_gremlin_database_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn list_gremlin_graphs(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
    ) -> std::result::Result<GremlinGraphListResult, list_gremlin_graphs::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}/graphs",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_gremlin_graphs::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_gremlin_graphs::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_gremlin_graphs::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_gremlin_graphs::ResponseBytesError)?;
                let rsp_value: GremlinGraphListResult =
                    serde_json::from_slice(&body).context(list_gremlin_graphs::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_gremlin_graphs::ResponseBytesError)?;
                list_gremlin_graphs::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_gremlin_graphs {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_gremlin_graph(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        graph_name: &str,
    ) -> std::result::Result<GremlinGraphGetResults, get_gremlin_graph::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}/graphs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            graph_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_gremlin_graph::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_gremlin_graph::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get_gremlin_graph::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gremlin_graph::ResponseBytesError)?;
                let rsp_value: GremlinGraphGetResults =
                    serde_json::from_slice(&body).context(get_gremlin_graph::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gremlin_graph::ResponseBytesError)?;
                get_gremlin_graph::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_gremlin_graph {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_update_gremlin_graph(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        graph_name: &str,
        create_update_gremlin_graph_parameters: &GremlinGraphCreateUpdateParameters,
    ) -> std::result::Result<create_update_gremlin_graph::Response, create_update_gremlin_graph::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}/graphs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            graph_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_update_gremlin_graph::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(create_update_gremlin_graph_parameters);
        let req = req_builder.build().context(create_update_gremlin_graph::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(create_update_gremlin_graph::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(create_update_gremlin_graph::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_gremlin_graph::ResponseBytesError)?;
                let rsp_value: GremlinGraphGetResults =
                    serde_json::from_slice(&body).context(create_update_gremlin_graph::DeserializeError { body })?;
                Ok(create_update_gremlin_graph::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_update_gremlin_graph::ResponseBytesError)?;
                create_update_gremlin_graph::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod create_update_gremlin_graph {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(GremlinGraphGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn delete_gremlin_graph(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        graph_name: &str,
    ) -> std::result::Result<delete_gremlin_graph::Response, delete_gremlin_graph::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}/graphs/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            database_name,
            graph_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete_gremlin_graph::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete_gremlin_graph::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete_gremlin_graph::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete_gremlin_graph::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete_gremlin_graph::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete_gremlin_graph::ResponseBytesError)?;
                delete_gremlin_graph::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod delete_gremlin_graph {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get_gremlin_graph_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        graph_name: &str,
    ) -> std::result::Result<ThroughputSettingsGetResults, get_gremlin_graph_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}/graphs/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , graph_name) ;
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get_gremlin_graph_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get_gremlin_graph_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(get_gremlin_graph_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gremlin_graph_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(get_gremlin_graph_throughput::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get_gremlin_graph_throughput::ResponseBytesError)?;
                get_gremlin_graph_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get_gremlin_graph_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn update_gremlin_graph_throughput(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        database_name: &str,
        graph_name: &str,
        update_throughput_parameters: &ThroughputSettingsUpdateParameters,
    ) -> std::result::Result<update_gremlin_graph_throughput::Response, update_gremlin_graph_throughput::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/gremlinDatabases/{}/graphs/{}/throughputSettings/default" , operation_config . base_path () , subscription_id , resource_group_name , account_name , database_name , graph_name) ;
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(update_gremlin_graph_throughput::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(update_throughput_parameters);
        let req = req_builder.build().context(update_gremlin_graph_throughput::BuildRequestError)?;
        let rsp = client
            .execute(req)
            .await
            .context(update_gremlin_graph_throughput::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(update_gremlin_graph_throughput::Response::Accepted202),
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_gremlin_graph_throughput::ResponseBytesError)?;
                let rsp_value: ThroughputSettingsGetResults =
                    serde_json::from_slice(&body).context(update_gremlin_graph_throughput::DeserializeError { body })?;
                Ok(update_gremlin_graph_throughput::Response::Ok200(rsp_value))
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(update_gremlin_graph_throughput::ResponseBytesError)?;
                update_gremlin_graph_throughput::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod update_gremlin_graph_throughput {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(ThroughputSettingsGetResults),
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod notebook_workspaces {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_by_database_account(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<NotebookWorkspaceListResult, list_by_database_account::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/notebookWorkspaces",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_database_account::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_by_database_account::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_database_account::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_database_account::ResponseBytesError)?;
                let rsp_value: NotebookWorkspaceListResult =
                    serde_json::from_slice(&body).context(list_by_database_account::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_database_account::ResponseBytesError)?;
                let rsp_value: ErrorResponse =
                    serde_json::from_slice(&body).context(list_by_database_account::DeserializeError { body })?;
                list_by_database_account::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_by_database_account {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        notebook_workspace_name: &str,
    ) -> std::result::Result<NotebookWorkspace, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/notebookWorkspaces/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            notebook_workspace_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: NotebookWorkspace = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                get::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        notebook_workspace_name: &str,
        notebook_create_update_parameters: &NotebookWorkspaceCreateUpdateParameters,
    ) -> std::result::Result<NotebookWorkspace, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/notebookWorkspaces/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            notebook_workspace_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(notebook_create_update_parameters);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: NotebookWorkspace = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        notebook_workspace_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/notebookWorkspaces/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            notebook_workspace_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn list_connection_info(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        notebook_workspace_name: &str,
    ) -> std::result::Result<NotebookWorkspaceConnectionInfoResult, list_connection_info::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/notebookWorkspaces/{}/listConnectionInfo" , operation_config . base_path () , subscription_id , resource_group_name , account_name , notebook_workspace_name) ;
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_connection_info::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(list_connection_info::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_connection_info::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_connection_info::ResponseBytesError)?;
                let rsp_value: NotebookWorkspaceConnectionInfoResult =
                    serde_json::from_slice(&body).context(list_connection_info::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_connection_info::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(list_connection_info::DeserializeError { body })?;
                list_connection_info::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod list_connection_info {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn regenerate_auth_token(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        notebook_workspace_name: &str,
    ) -> std::result::Result<regenerate_auth_token::Response, regenerate_auth_token::Error> {
        let client = operation_config.http_client();
        let uri_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/notebookWorkspaces/{}/regenerateAuthToken" , operation_config . base_path () , subscription_id , resource_group_name , account_name , notebook_workspace_name) ;
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(regenerate_auth_token::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(regenerate_auth_token::BuildRequestError)?;
        let rsp = client.execute(req).await.context(regenerate_auth_token::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(regenerate_auth_token::Response::Ok200),
            StatusCode::ACCEPTED => Ok(regenerate_auth_token::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(regenerate_auth_token::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(regenerate_auth_token::DeserializeError { body })?;
                regenerate_auth_token::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod regenerate_auth_token {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn start(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        notebook_workspace_name: &str,
    ) -> std::result::Result<start::Response, start::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/notebookWorkspaces/{}/start",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            notebook_workspace_name
        );
        let mut req_builder = client.post(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(start::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.header(reqwest::header::CONTENT_LENGTH, 0);
        let req = req_builder.build().context(start::BuildRequestError)?;
        let rsp = client.execute(req).await.context(start::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => Ok(start::Response::Ok200),
            StatusCode::ACCEPTED => Ok(start::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(start::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(start::DeserializeError { body })?;
                start::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod start {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
pub mod private_link_resources {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_by_database_account(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<PrivateLinkResourceListResult, list_by_database_account::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/privateLinkResources",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_database_account::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_by_database_account::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_database_account::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_database_account::ResponseBytesError)?;
                let rsp_value: PrivateLinkResourceListResult =
                    serde_json::from_slice(&body).context(list_by_database_account::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_database_account::ResponseBytesError)?;
                list_by_database_account::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_by_database_account {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        group_name: &str,
    ) -> std::result::Result<PrivateLinkResource, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/privateLinkResources/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            group_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: PrivateLinkResource = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                get::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
}
pub mod private_endpoint_connections {
    use crate::models::*;
    use reqwest::StatusCode;
    use snafu::{ResultExt, Snafu};
    pub async fn list_by_database_account(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
    ) -> std::result::Result<PrivateEndpointConnectionListResult, list_by_database_account::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/privateEndpointConnections",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(list_by_database_account::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(list_by_database_account::BuildRequestError)?;
        let rsp = client.execute(req).await.context(list_by_database_account::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_database_account::ResponseBytesError)?;
                let rsp_value: PrivateEndpointConnectionListResult =
                    serde_json::from_slice(&body).context(list_by_database_account::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(list_by_database_account::ResponseBytesError)?;
                list_by_database_account::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod list_by_database_account {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        private_endpoint_connection_name: &str,
    ) -> std::result::Result<PrivateEndpointConnection, get::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/privateEndpointConnections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            private_endpoint_connection_name
        );
        let mut req_builder = client.get(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(get::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(get::BuildRequestError)?;
        let rsp = client.execute(req).await.context(get::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                let rsp_value: PrivateEndpointConnection = serde_json::from_slice(&body).context(get::DeserializeError { body })?;
                Ok(rsp_value)
            }
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(get::ResponseBytesError)?;
                get::UnexpectedResponse { status_code, body: body }.fail()
            }
        }
    }
    pub mod get {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            UnexpectedResponse { status_code: StatusCode, body: bytes::Bytes },
            BuildRequestError { source: reqwest::Error },
            ExecuteRequestError { source: reqwest::Error },
            ResponseBytesError { source: reqwest::Error },
            DeserializeError { source: serde_json::Error, body: bytes::Bytes },
            GetTokenError { source: azure_core::errors::AzureError },
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        private_endpoint_connection_name: &str,
        parameters: &PrivateEndpointConnection,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/privateEndpointConnections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            private_endpoint_connection_name
        );
        let mut req_builder = client.put(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(create_or_update::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        req_builder = req_builder.json(parameters);
        let req = req_builder.build().context(create_or_update::BuildRequestError)?;
        let rsp = client.execute(req).await.context(create_or_update::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::OK => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: PrivateEndpointConnection =
                    serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            StatusCode::ACCEPTED => Ok(create_or_update::Response::Accepted202),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(create_or_update::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(create_or_update::DeserializeError { body })?;
                create_or_update::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod create_or_update {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Ok200(PrivateEndpointConnection),
            Accepted202,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        account_name: &str,
        private_endpoint_connection_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let client = operation_config.http_client();
        let uri_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.DocumentDB/databaseAccounts/{}/privateEndpointConnections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            account_name,
            private_endpoint_connection_name
        );
        let mut req_builder = client.delete(uri_str);
        if let Some(user_agent) = operation_config.user_agent() {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent);
        }
        let token_response = operation_config
            .token_credential()
            .get_token(operation_config.token_credential_resource())
            .await
            .context(delete::GetTokenError)?;
        req_builder = req_builder.bearer_auth(token_response.token.secret());
        req_builder = req_builder.query(&[("api-version", operation_config.api_version())]);
        let req = req_builder.build().context(delete::BuildRequestError)?;
        let rsp = client.execute(req).await.context(delete::ExecuteRequestError)?;
        match rsp.status() {
            StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let body: bytes::Bytes = rsp.bytes().await.context(delete::ResponseBytesError)?;
                let rsp_value: ErrorResponse = serde_json::from_slice(&body).context(delete::DeserializeError { body })?;
                delete::DefaultResponse {
                    status_code,
                    value: rsp_value,
                }
                .fail()
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        use reqwest::StatusCode;
        use snafu::Snafu;
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, Snafu)]
        #[snafu(visibility(pub(crate)))]
        pub enum Error {
            DefaultResponse {
                status_code: StatusCode,
                value: models::ErrorResponse,
            },
            BuildRequestError {
                source: reqwest::Error,
            },
            ExecuteRequestError {
                source: reqwest::Error,
            },
            ResponseBytesError {
                source: reqwest::Error,
            },
            DeserializeError {
                source: serde_json::Error,
                body: bytes::Bytes,
            },
            GetTokenError {
                source: azure_core::errors::AzureError,
            },
        }
    }
}
