#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use crate::*;
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AccessControlRecord {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: AccessControlRecordProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AccessControlRecordList {
    pub value: Vec<AccessControlRecord>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AccessControlRecordProperties {
    #[serde(rename = "initiatorName")]
    pub initiator_name: String,
    #[serde(rename = "volumeCount", skip_serializing)]
    pub volume_count: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AcsConfiguration {
    pub namespace: String,
    pub realm: String,
    #[serde(rename = "serviceUrl")]
    pub service_url: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Alert {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: AlertProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AlertErrorDetails {
    #[serde(rename = "errorCode", skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    #[serde(rename = "errorMessage", skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub occurences: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AlertFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<alert_filter::Status>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub severity: Option<alert_filter::Severity>,
    #[serde(rename = "sourceType", skip_serializing_if = "Option::is_none")]
    pub source_type: Option<alert_filter::SourceType>,
    #[serde(rename = "sourceName", skip_serializing_if = "Option::is_none")]
    pub source_name: Option<String>,
    #[serde(rename = "appearedOnTime", skip_serializing_if = "Option::is_none")]
    pub appeared_on_time: Option<String>,
}
mod alert_filter {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Active,
        Cleared,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Severity {
        Informational,
        Warning,
        Critical,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum SourceType {
        Resource,
        Device,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AlertList {
    pub value: Vec<Alert>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AlertNotificationProperties {
    #[serde(rename = "emailNotification")]
    pub email_notification: alert_notification_properties::EmailNotification,
    #[serde(rename = "alertNotificationCulture", skip_serializing_if = "Option::is_none")]
    pub alert_notification_culture: Option<String>,
    #[serde(rename = "notificationToServiceOwners", skip_serializing_if = "Option::is_none")]
    pub notification_to_service_owners: Option<alert_notification_properties::NotificationToServiceOwners>,
    #[serde(rename = "additionalRecipientEmailList", skip_serializing_if = "Vec::is_empty")]
    pub additional_recipient_email_list: Vec<String>,
}
mod alert_notification_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EmailNotification {
        Enabled,
        Disabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum NotificationToServiceOwners {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AlertProperties {
    pub title: String,
    pub scope: alert_properties::Scope,
    #[serde(rename = "alertType")]
    pub alert_type: String,
    #[serde(rename = "appearedAtTime")]
    pub appeared_at_time: String,
    #[serde(rename = "appearedAtSourceTime")]
    pub appeared_at_source_time: String,
    #[serde(rename = "clearedAtTime", skip_serializing_if = "Option::is_none")]
    pub cleared_at_time: Option<String>,
    #[serde(rename = "clearedAtSourceTime", skip_serializing_if = "Option::is_none")]
    pub cleared_at_source_time: Option<String>,
    pub source: AlertSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendation: Option<String>,
    #[serde(rename = "resolutionReason", skip_serializing_if = "Option::is_none")]
    pub resolution_reason: Option<String>,
    pub severity: alert_properties::Severity,
    pub status: alert_properties::Status,
    #[serde(rename = "errorDetails", skip_serializing_if = "Option::is_none")]
    pub error_details: Option<AlertErrorDetails>,
    #[serde(rename = "detailedInformation", skip_serializing_if = "Option::is_none")]
    pub detailed_information: Option<serde_json::Value>,
}
mod alert_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Scope {
        Resource,
        Device,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Severity {
        Informational,
        Warning,
        Critical,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Active,
        Cleared,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AlertSettings {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: AlertNotificationProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AlertSource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "timeZone", skip_serializing_if = "Option::is_none")]
    pub time_zone: Option<String>,
    #[serde(rename = "alertSourceType", skip_serializing_if = "Option::is_none")]
    pub alert_source_type: Option<alert_source::AlertSourceType>,
}
mod alert_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AlertSourceType {
        Resource,
        Device,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AsymmetricEncryptedSecret {
    pub value: String,
    #[serde(rename = "encryptionCertThumbprint", skip_serializing_if = "Option::is_none")]
    pub encryption_cert_thumbprint: Option<String>,
    #[serde(rename = "encryptionAlgorithm")]
    pub encryption_algorithm: asymmetric_encrypted_secret::EncryptionAlgorithm,
}
mod asymmetric_encrypted_secret {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EncryptionAlgorithm {
        None,
        #[serde(rename = "AES256")]
        Aes256,
        #[serde(rename = "RSAES_PKCS1_v_1_5")]
        RsaesPkcs1V15,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProviderOperation {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display: Option<AvailableProviderOperationDisplay>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<AvailableProviderOperationProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProviderOperationDisplay {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProviderOperationList {
    pub value: Vec<AvailableProviderOperation>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AvailableProviderOperationProperties {}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Backup {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: BackupProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupElement {
    #[serde(rename = "elementId")]
    pub element_id: String,
    #[serde(rename = "elementName")]
    pub element_name: String,
    #[serde(rename = "elementType")]
    pub element_type: String,
    #[serde(rename = "sizeInBytes")]
    pub size_in_bytes: i64,
    #[serde(rename = "volumeName")]
    pub volume_name: String,
    #[serde(rename = "volumeContainerId")]
    pub volume_container_id: String,
    #[serde(rename = "volumeType", skip_serializing_if = "Option::is_none")]
    pub volume_type: Option<backup_element::VolumeType>,
}
mod backup_element {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VolumeType {
        Tiered,
        Archival,
        LocallyPinned,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupFilter {
    #[serde(rename = "backupPolicyId", skip_serializing_if = "Option::is_none")]
    pub backup_policy_id: Option<String>,
    #[serde(rename = "volumeId", skip_serializing_if = "Option::is_none")]
    pub volume_id: Option<String>,
    #[serde(rename = "createdTime", skip_serializing_if = "Option::is_none")]
    pub created_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupList {
    pub value: Vec<Backup>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupPolicy {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: BackupPolicyProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupPolicyList {
    pub value: Vec<BackupPolicy>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupPolicyProperties {
    #[serde(rename = "volumeIds")]
    pub volume_ids: Vec<String>,
    #[serde(rename = "nextBackupTime", skip_serializing)]
    pub next_backup_time: Option<String>,
    #[serde(rename = "lastBackupTime", skip_serializing)]
    pub last_backup_time: Option<String>,
    #[serde(rename = "schedulesCount", skip_serializing)]
    pub schedules_count: Option<i64>,
    #[serde(rename = "scheduledBackupStatus", skip_serializing)]
    pub scheduled_backup_status: Option<backup_policy_properties::ScheduledBackupStatus>,
    #[serde(rename = "backupPolicyCreationType", skip_serializing)]
    pub backup_policy_creation_type: Option<backup_policy_properties::BackupPolicyCreationType>,
    #[serde(rename = "ssmHostName", skip_serializing)]
    pub ssm_host_name: Option<String>,
}
mod backup_policy_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ScheduledBackupStatus {
        Disabled,
        Enabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum BackupPolicyCreationType {
        BySaaS,
        #[serde(rename = "BySSM")]
        BySsm,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupProperties {
    #[serde(rename = "createdOn")]
    pub created_on: String,
    #[serde(rename = "sizeInBytes")]
    pub size_in_bytes: i64,
    #[serde(rename = "backupType", skip_serializing_if = "Option::is_none")]
    pub backup_type: Option<backup_properties::BackupType>,
    #[serde(rename = "backupJobCreationType", skip_serializing_if = "Option::is_none")]
    pub backup_job_creation_type: Option<backup_properties::BackupJobCreationType>,
    #[serde(rename = "backupPolicyId", skip_serializing_if = "Option::is_none")]
    pub backup_policy_id: Option<String>,
    #[serde(rename = "ssmHostName", skip_serializing_if = "Option::is_none")]
    pub ssm_host_name: Option<String>,
    pub elements: Vec<BackupElement>,
}
mod backup_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum BackupType {
        LocalSnapshot,
        CloudSnapshot,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum BackupJobCreationType {
        Adhoc,
        BySchedule,
        #[serde(rename = "BySSM")]
        BySsm,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupSchedule {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: BackupScheduleProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupScheduleList {
    pub value: Vec<BackupSchedule>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BackupScheduleProperties {
    #[serde(rename = "scheduleRecurrence")]
    pub schedule_recurrence: ScheduleRecurrence,
    #[serde(rename = "backupType")]
    pub backup_type: backup_schedule_properties::BackupType,
    #[serde(rename = "retentionCount")]
    pub retention_count: i64,
    #[serde(rename = "startTime")]
    pub start_time: String,
    #[serde(rename = "scheduleStatus")]
    pub schedule_status: backup_schedule_properties::ScheduleStatus,
    #[serde(rename = "lastSuccessfulRun", skip_serializing)]
    pub last_successful_run: Option<String>,
}
mod backup_schedule_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum BackupType {
        LocalSnapshot,
        CloudSnapshot,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ScheduleStatus {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BandwidthRateSettingProperties {
    pub schedules: Vec<BandwidthSchedule>,
    #[serde(rename = "volumeCount", skip_serializing)]
    pub volume_count: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BandwidthSchedule {
    pub start: Time,
    pub stop: Time,
    #[serde(rename = "rateInMbps")]
    pub rate_in_mbps: i32,
    pub days: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BandwidthSetting {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: BandwidthRateSettingProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BandwidthSettingList {
    pub value: Vec<BandwidthSetting>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct BaseModel {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<base_model::Kind>,
}
mod base_model {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Kind {
        Series8000,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ChapSettings {
    #[serde(rename = "initiatorUser", skip_serializing_if = "Option::is_none")]
    pub initiator_user: Option<String>,
    #[serde(rename = "initiatorSecret", skip_serializing_if = "Option::is_none")]
    pub initiator_secret: Option<AsymmetricEncryptedSecret>,
    #[serde(rename = "targetUser", skip_serializing_if = "Option::is_none")]
    pub target_user: Option<String>,
    #[serde(rename = "targetSecret", skip_serializing_if = "Option::is_none")]
    pub target_secret: Option<AsymmetricEncryptedSecret>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ClearAlertRequest {
    #[serde(rename = "resolutionMessage", skip_serializing_if = "Option::is_none")]
    pub resolution_message: Option<String>,
    pub alerts: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloneRequest {
    #[serde(rename = "targetDeviceId")]
    pub target_device_id: String,
    #[serde(rename = "targetVolumeName")]
    pub target_volume_name: String,
    #[serde(rename = "targetAccessControlRecordIds")]
    pub target_access_control_record_ids: Vec<String>,
    #[serde(rename = "backupElement")]
    pub backup_element: BackupElement,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudAppliance {
    pub name: String,
    #[serde(rename = "vnetName", skip_serializing_if = "Option::is_none")]
    pub vnet_name: Option<String>,
    #[serde(rename = "vnetRegion")]
    pub vnet_region: String,
    #[serde(rename = "isVnetDnsConfigured", skip_serializing_if = "Option::is_none")]
    pub is_vnet_dns_configured: Option<bool>,
    #[serde(rename = "isVnetExpressConfigured", skip_serializing_if = "Option::is_none")]
    pub is_vnet_express_configured: Option<bool>,
    #[serde(rename = "subnetName", skip_serializing_if = "Option::is_none")]
    pub subnet_name: Option<String>,
    #[serde(rename = "storageAccountName", skip_serializing_if = "Option::is_none")]
    pub storage_account_name: Option<String>,
    #[serde(rename = "storageAccountType", skip_serializing_if = "Option::is_none")]
    pub storage_account_type: Option<String>,
    #[serde(rename = "vmType", skip_serializing_if = "Option::is_none")]
    pub vm_type: Option<String>,
    #[serde(rename = "vmImageName", skip_serializing_if = "Option::is_none")]
    pub vm_image_name: Option<String>,
    #[serde(rename = "modelNumber", skip_serializing_if = "Option::is_none")]
    pub model_number: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudApplianceConfiguration {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: CloudApplianceConfigurationProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudApplianceConfigurationList {
    pub value: Vec<CloudApplianceConfiguration>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudApplianceConfigurationProperties {
    #[serde(rename = "modelNumber")]
    pub model_number: String,
    #[serde(rename = "cloudPlatform")]
    pub cloud_platform: String,
    #[serde(rename = "acsConfiguration")]
    pub acs_configuration: AcsConfiguration,
    #[serde(rename = "supportedStorageAccountTypes")]
    pub supported_storage_account_types: Vec<String>,
    #[serde(rename = "supportedRegions")]
    pub supported_regions: Vec<String>,
    #[serde(rename = "supportedVmTypes")]
    pub supported_vm_types: Vec<String>,
    #[serde(rename = "supportedVmImages")]
    pub supported_vm_images: Vec<VmImage>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CloudApplianceSettings {
    #[serde(rename = "serviceDataEncryptionKey", skip_serializing_if = "Option::is_none")]
    pub service_data_encryption_key: Option<AsymmetricEncryptedSecret>,
    #[serde(rename = "channelIntegrityKey", skip_serializing_if = "Option::is_none")]
    pub channel_integrity_key: Option<AsymmetricEncryptedSecret>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConfigureDeviceRequest {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: ConfigureDeviceRequestProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConfigureDeviceRequestProperties {
    #[serde(rename = "friendlyName")]
    pub friendly_name: String,
    #[serde(rename = "currentDeviceName")]
    pub current_device_name: String,
    #[serde(rename = "timeZone")]
    pub time_zone: String,
    #[serde(rename = "dnsSettings", skip_serializing_if = "Option::is_none")]
    pub dns_settings: Option<SecondaryDnsSettings>,
    #[serde(rename = "networkInterfaceData0Settings", skip_serializing_if = "Option::is_none")]
    pub network_interface_data0_settings: Option<NetworkInterfaceData0Settings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ControllerPowerStateChangeRequest {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: ControllerPowerStateChangeRequestProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ControllerPowerStateChangeRequestProperties {
    pub action: controller_power_state_change_request_properties::Action,
    #[serde(rename = "activeController")]
    pub active_controller: controller_power_state_change_request_properties::ActiveController,
    #[serde(rename = "controller0State")]
    pub controller0_state: controller_power_state_change_request_properties::Controller0State,
    #[serde(rename = "controller1State")]
    pub controller1_state: controller_power_state_change_request_properties::Controller1State,
}
mod controller_power_state_change_request_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Action {
        Start,
        Restart,
        Shutdown,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ActiveController {
        Unknown,
        None,
        Controller0,
        Controller1,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Controller0State {
        NotPresent,
        PoweredOff,
        Ok,
        Recovering,
        Warning,
        Failure,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Controller1State {
        NotPresent,
        PoweredOff,
        Ok,
        Recovering,
        Warning,
        Failure,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DataStatistics {
    #[serde(rename = "totalData", skip_serializing_if = "Option::is_none")]
    pub total_data: Option<i64>,
    #[serde(rename = "processedData", skip_serializing_if = "Option::is_none")]
    pub processed_data: Option<i64>,
    #[serde(rename = "cloudData", skip_serializing_if = "Option::is_none")]
    pub cloud_data: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub throughput: Option<i64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Device {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: DeviceProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DeviceDetails {
    #[serde(rename = "endpointCount", skip_serializing_if = "Option::is_none")]
    pub endpoint_count: Option<i32>,
    #[serde(rename = "volumeContainerCount", skip_serializing_if = "Option::is_none")]
    pub volume_container_count: Option<i32>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DeviceList {
    pub value: Vec<Device>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DevicePatch {
    pub properties: DevicePatchProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DevicePatchProperties {
    #[serde(rename = "deviceDescription", skip_serializing_if = "Option::is_none")]
    pub device_description: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DeviceProperties {
    #[serde(rename = "friendlyName")]
    pub friendly_name: String,
    #[serde(rename = "activationTime")]
    pub activation_time: String,
    pub culture: String,
    #[serde(rename = "deviceDescription")]
    pub device_description: String,
    #[serde(rename = "deviceSoftwareVersion")]
    pub device_software_version: String,
    #[serde(rename = "friendlySoftwareName", skip_serializing_if = "Option::is_none")]
    pub friendly_software_name: Option<String>,
    #[serde(rename = "deviceConfigurationStatus")]
    pub device_configuration_status: device_properties::DeviceConfigurationStatus,
    #[serde(rename = "targetIqn")]
    pub target_iqn: String,
    #[serde(rename = "modelDescription")]
    pub model_description: String,
    pub status: device_properties::Status,
    #[serde(rename = "serialNumber")]
    pub serial_number: String,
    #[serde(rename = "deviceType")]
    pub device_type: device_properties::DeviceType,
    #[serde(rename = "activeController")]
    pub active_controller: device_properties::ActiveController,
    #[serde(rename = "friendlySoftwareVersion")]
    pub friendly_software_version: String,
    #[serde(rename = "availableLocalStorageInBytes", skip_serializing_if = "Option::is_none")]
    pub available_local_storage_in_bytes: Option<i64>,
    #[serde(rename = "availableTieredStorageInBytes", skip_serializing_if = "Option::is_none")]
    pub available_tiered_storage_in_bytes: Option<i64>,
    #[serde(rename = "provisionedTieredStorageInBytes", skip_serializing_if = "Option::is_none")]
    pub provisioned_tiered_storage_in_bytes: Option<i64>,
    #[serde(rename = "provisionedLocalStorageInBytes", skip_serializing_if = "Option::is_none")]
    pub provisioned_local_storage_in_bytes: Option<i64>,
    #[serde(rename = "provisionedVolumeSizeInBytes", skip_serializing_if = "Option::is_none")]
    pub provisioned_volume_size_in_bytes: Option<i64>,
    #[serde(rename = "usingStorageInBytes", skip_serializing_if = "Option::is_none")]
    pub using_storage_in_bytes: Option<i64>,
    #[serde(rename = "totalTieredStorageInBytes", skip_serializing_if = "Option::is_none")]
    pub total_tiered_storage_in_bytes: Option<i64>,
    #[serde(rename = "agentGroupVersion", skip_serializing_if = "Option::is_none")]
    pub agent_group_version: Option<i32>,
    #[serde(rename = "networkInterfaceCardCount", skip_serializing_if = "Option::is_none")]
    pub network_interface_card_count: Option<i32>,
    #[serde(rename = "deviceLocation", skip_serializing_if = "Option::is_none")]
    pub device_location: Option<String>,
    #[serde(rename = "virtualMachineApiType", skip_serializing)]
    pub virtual_machine_api_type: Option<device_properties::VirtualMachineApiType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<DeviceDetails>,
    #[serde(rename = "rolloverDetails", skip_serializing_if = "Option::is_none")]
    pub rollover_details: Option<DeviceRolloverDetails>,
}
mod device_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum DeviceConfigurationStatus {
        Complete,
        Pending,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Unknown,
        Online,
        Offline,
        Deactivated,
        RequiresAttention,
        MaintenanceMode,
        Creating,
        Provisioning,
        Deactivating,
        Deleted,
        ReadyToSetup,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum DeviceType {
        Invalid,
        Series8000VirtualAppliance,
        Series8000PhysicalAppliance,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ActiveController {
        Unknown,
        None,
        Controller0,
        Controller1,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VirtualMachineApiType {
        Classic,
        Arm,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DeviceRolloverDetails {
    #[serde(rename = "authorizationEligibility", skip_serializing_if = "Option::is_none")]
    pub authorization_eligibility: Option<device_rollover_details::AuthorizationEligibility>,
    #[serde(rename = "authorizationStatus", skip_serializing_if = "Option::is_none")]
    pub authorization_status: Option<device_rollover_details::AuthorizationStatus>,
    #[serde(rename = "inEligibilityReason", skip_serializing_if = "Option::is_none")]
    pub in_eligibility_reason: Option<device_rollover_details::InEligibilityReason>,
}
mod device_rollover_details {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthorizationEligibility {
        InEligible,
        Eligible,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum AuthorizationStatus {
        Disabled,
        Enabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum InEligibilityReason {
        DeviceNotOnline,
        NotSupportedAppliance,
        RolloverPending,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DimensionFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub values: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DnsSettings {
    #[serde(rename = "primaryDnsServer", skip_serializing_if = "Option::is_none")]
    pub primary_dns_server: Option<String>,
    #[serde(rename = "primaryIpv6DnsServer", skip_serializing_if = "Option::is_none")]
    pub primary_ipv6_dns_server: Option<String>,
    #[serde(rename = "secondaryDnsServers", skip_serializing_if = "Vec::is_empty")]
    pub secondary_dns_servers: Vec<String>,
    #[serde(rename = "secondaryIpv6DnsServers", skip_serializing_if = "Vec::is_empty")]
    pub secondary_ipv6_dns_servers: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EncryptionSettings {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: EncryptionSettingsProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EncryptionSettingsProperties {
    #[serde(rename = "encryptionStatus")]
    pub encryption_status: encryption_settings_properties::EncryptionStatus,
    #[serde(rename = "keyRolloverStatus")]
    pub key_rollover_status: encryption_settings_properties::KeyRolloverStatus,
}
mod encryption_settings_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EncryptionStatus {
        Enabled,
        Disabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum KeyRolloverStatus {
        Required,
        NotRequired,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FailoverRequest {
    #[serde(rename = "targetDeviceId", skip_serializing_if = "Option::is_none")]
    pub target_device_id: Option<String>,
    #[serde(rename = "volumeContainers", skip_serializing_if = "Vec::is_empty")]
    pub volume_containers: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FailoverSet {
    #[serde(rename = "volumeContainers", skip_serializing_if = "Vec::is_empty")]
    pub volume_containers: Vec<VolumeContainerFailoverMetadata>,
    #[serde(rename = "eligibilityResult", skip_serializing_if = "Option::is_none")]
    pub eligibility_result: Option<FailoverSetEligibilityResult>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FailoverSetEligibilityResult {
    #[serde(rename = "isEligibleForFailover", skip_serializing_if = "Option::is_none")]
    pub is_eligible_for_failover: Option<bool>,
    #[serde(rename = "errorMessage", skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FailoverSetsList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<FailoverSet>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FailoverTarget {
    #[serde(rename = "deviceId", skip_serializing_if = "Option::is_none")]
    pub device_id: Option<String>,
    #[serde(rename = "deviceStatus", skip_serializing_if = "Option::is_none")]
    pub device_status: Option<failover_target::DeviceStatus>,
    #[serde(rename = "modelDescription", skip_serializing_if = "Option::is_none")]
    pub model_description: Option<String>,
    #[serde(rename = "deviceSoftwareVersion", skip_serializing_if = "Option::is_none")]
    pub device_software_version: Option<String>,
    #[serde(rename = "dataContainersCount", skip_serializing_if = "Option::is_none")]
    pub data_containers_count: Option<i32>,
    #[serde(rename = "volumesCount", skip_serializing_if = "Option::is_none")]
    pub volumes_count: Option<i32>,
    #[serde(rename = "availableLocalStorageInBytes", skip_serializing_if = "Option::is_none")]
    pub available_local_storage_in_bytes: Option<i64>,
    #[serde(rename = "availableTieredStorageInBytes", skip_serializing_if = "Option::is_none")]
    pub available_tiered_storage_in_bytes: Option<i64>,
    #[serde(rename = "deviceLocation", skip_serializing_if = "Option::is_none")]
    pub device_location: Option<String>,
    #[serde(rename = "friendlyDeviceSoftwareVersion", skip_serializing_if = "Option::is_none")]
    pub friendly_device_software_version: Option<String>,
    #[serde(rename = "eligibilityResult", skip_serializing_if = "Option::is_none")]
    pub eligibility_result: Option<TargetEligibilityResult>,
}
mod failover_target {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum DeviceStatus {
        Unknown,
        Online,
        Offline,
        Deactivated,
        RequiresAttention,
        MaintenanceMode,
        Creating,
        Provisioning,
        Deactivating,
        Deleted,
        ReadyToSetup,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FailoverTargetsList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<FailoverTarget>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Feature {
    pub name: String,
    pub status: feature::Status,
}
mod feature {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        NotAvailable,
        UnsupportedDeviceVersion,
        Supported,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FeatureFilter {
    #[serde(rename = "deviceId", skip_serializing_if = "Option::is_none")]
    pub device_id: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FeatureList {
    pub value: Vec<Feature>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HardwareComponent {
    #[serde(rename = "componentId")]
    pub component_id: String,
    #[serde(rename = "displayName")]
    pub display_name: String,
    pub status: hardware_component::Status,
    #[serde(rename = "statusDisplayName")]
    pub status_display_name: String,
}
mod hardware_component {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Unknown,
        NotPresent,
        PoweredOff,
        Ok,
        Recovering,
        Warning,
        Failure,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HardwareComponentGroup {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: HardwareComponentGroupProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HardwareComponentGroupList {
    pub value: Vec<HardwareComponentGroup>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HardwareComponentGroupProperties {
    #[serde(rename = "displayName")]
    pub display_name: String,
    #[serde(rename = "lastUpdatedTime")]
    pub last_updated_time: String,
    pub components: Vec<HardwareComponent>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Job {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub status: job::Status,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "percentComplete")]
    pub percent_complete: i32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<JobErrorDetails>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<JobProperties>,
}
mod job {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Status {
        Running,
        Succeeded,
        Failed,
        Canceled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobErrorDetails {
    #[serde(rename = "errorDetails", skip_serializing_if = "Vec::is_empty")]
    pub error_details: Vec<JobErrorItem>,
    pub code: String,
    pub message: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobErrorItem {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub recommendations: Vec<String>,
    pub code: String,
    pub message: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(rename = "jobType", skip_serializing_if = "Option::is_none")]
    pub job_type: Option<String>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobList {
    pub value: Vec<Job>,
    #[serde(rename = "nextLink", skip_serializing_if = "Option::is_none")]
    pub next_link: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobProperties {
    #[serde(rename = "jobType")]
    pub job_type: job_properties::JobType,
    #[serde(rename = "dataStats", skip_serializing_if = "Option::is_none")]
    pub data_stats: Option<DataStatistics>,
    #[serde(rename = "entityLabel", skip_serializing_if = "Option::is_none")]
    pub entity_label: Option<String>,
    #[serde(rename = "entityType", skip_serializing_if = "Option::is_none")]
    pub entity_type: Option<String>,
    #[serde(rename = "jobStages", skip_serializing_if = "Vec::is_empty")]
    pub job_stages: Vec<JobStage>,
    #[serde(rename = "deviceId", skip_serializing_if = "Option::is_none")]
    pub device_id: Option<String>,
    #[serde(rename = "isCancellable", skip_serializing_if = "Option::is_none")]
    pub is_cancellable: Option<bool>,
    #[serde(rename = "backupType", skip_serializing_if = "Option::is_none")]
    pub backup_type: Option<job_properties::BackupType>,
    #[serde(rename = "sourceDeviceId", skip_serializing_if = "Option::is_none")]
    pub source_device_id: Option<String>,
    #[serde(rename = "backupPointInTime", skip_serializing_if = "Option::is_none")]
    pub backup_point_in_time: Option<String>,
}
mod job_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum JobType {
        ScheduledBackup,
        ManualBackup,
        RestoreBackup,
        CloneVolume,
        FailoverVolumeContainers,
        CreateLocallyPinnedVolume,
        ModifyVolume,
        InstallUpdates,
        SupportPackageLogs,
        CreateCloudAppliance,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum BackupType {
        LocalSnapshot,
        CloudSnapshot,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobStage {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(rename = "stageStatus")]
    pub stage_status: job_stage::StageStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,
    #[serde(rename = "errorCode", skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
}
mod job_stage {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum StageStatus {
        Running,
        Succeeded,
        Failed,
        Canceled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Key {
    #[serde(rename = "activationKey")]
    pub activation_key: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ListFailoverTargetsRequest {
    #[serde(rename = "volumeContainers", skip_serializing_if = "Vec::is_empty")]
    pub volume_containers: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Manager {
    #[serde(flatten)]
    pub resource: Resource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagerProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagerExtendedInfo {
    #[serde(flatten)]
    pub base_model: BaseModel,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ManagerExtendedInfoProperties>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagerExtendedInfoProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    #[serde(rename = "integrityKey")]
    pub integrity_key: String,
    #[serde(rename = "encryptionKey", skip_serializing_if = "Option::is_none")]
    pub encryption_key: Option<String>,
    #[serde(rename = "encryptionKeyThumbprint", skip_serializing_if = "Option::is_none")]
    pub encryption_key_thumbprint: Option<String>,
    #[serde(rename = "portalCertificateThumbprint", skip_serializing_if = "Option::is_none")]
    pub portal_certificate_thumbprint: Option<String>,
    pub algorithm: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagerIntrinsicSettings {
    #[serde(rename = "type")]
    pub type_: manager_intrinsic_settings::Type,
}
mod manager_intrinsic_settings {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        GardaV1,
        HelsinkiV1,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagerList {
    pub value: Vec<Manager>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagerPatch {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagerProperties {
    #[serde(rename = "cisIntrinsicSettings", skip_serializing_if = "Option::is_none")]
    pub cis_intrinsic_settings: Option<ManagerIntrinsicSettings>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sku: Option<ManagerSku>,
    #[serde(rename = "provisioningState", skip_serializing_if = "Option::is_none")]
    pub provisioning_state: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ManagerSku {
    pub name: manager_sku::Name,
}
mod manager_sku {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Name {
        Standard,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricAvailablity {
    #[serde(rename = "timeGrain", skip_serializing_if = "Option::is_none")]
    pub time_grain: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricData {
    #[serde(rename = "timeStamp", skip_serializing_if = "Option::is_none")]
    pub time_stamp: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sum: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub average: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f64>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricDefinition {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<MetricName>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit: Option<metric_definition::Unit>,
    #[serde(rename = "primaryAggregationType", skip_serializing_if = "Option::is_none")]
    pub primary_aggregation_type: Option<metric_definition::PrimaryAggregationType>,
    #[serde(rename = "resourceId", skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[serde(rename = "metricAvailabilities", skip_serializing_if = "Vec::is_empty")]
    pub metric_availabilities: Vec<MetricAvailablity>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub dimensions: Vec<MetricDimension>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub category: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}
mod metric_definition {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Unit {
        Bytes,
        BytesPerSecond,
        Count,
        CountPerSecond,
        Percent,
        Seconds,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PrimaryAggregationType {
        Average,
        Last,
        Maximum,
        Minimum,
        None,
        Total,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricDefinitionList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<MetricDefinition>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricDimension {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<MetricNameFilter>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "timeGrain", skip_serializing_if = "Option::is_none")]
    pub time_grain: Option<String>,
    pub category: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dimensions: Option<DimensionFilter>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricList {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<Metrics>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricName {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(rename = "localizedValue", skip_serializing_if = "Option::is_none")]
    pub localized_value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricNameFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Metrics {
    #[serde(rename = "resourceId", skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    #[serde(rename = "endTime", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "timeGrain", skip_serializing_if = "Option::is_none")]
    pub time_grain: Option<String>,
    #[serde(rename = "primaryAggregation", skip_serializing_if = "Option::is_none")]
    pub primary_aggregation: Option<metrics::PrimaryAggregation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<MetricName>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub dimensions: Vec<MetricDimension>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit: Option<metrics::Unit>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub values: Vec<MetricData>,
}
mod metrics {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PrimaryAggregation {
        Average,
        Last,
        Maximum,
        Minimum,
        None,
        Total,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Unit {
        Bytes,
        BytesPerSecond,
        Count,
        CountPerSecond,
        Percent,
        Seconds,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkAdapterList {
    pub value: Vec<NetworkAdapters>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkAdapters {
    #[serde(rename = "interfaceId")]
    pub interface_id: network_adapters::InterfaceId,
    #[serde(rename = "netInterfaceStatus")]
    pub net_interface_status: network_adapters::NetInterfaceStatus,
    #[serde(rename = "isDefault", skip_serializing_if = "Option::is_none")]
    pub is_default: Option<bool>,
    #[serde(rename = "iscsiAndCloudStatus")]
    pub iscsi_and_cloud_status: network_adapters::IscsiAndCloudStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub speed: Option<i64>,
    pub mode: network_adapters::Mode,
    #[serde(rename = "nicIpv4Settings", skip_serializing_if = "Option::is_none")]
    pub nic_ipv4_settings: Option<NicIPv4>,
    #[serde(rename = "nicIpv6Settings", skip_serializing_if = "Option::is_none")]
    pub nic_ipv6_settings: Option<NicIPv6>,
}
mod network_adapters {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum InterfaceId {
        Invalid,
        Data0,
        Data1,
        Data2,
        Data3,
        Data4,
        Data5,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum NetInterfaceStatus {
        Enabled,
        Disabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum IscsiAndCloudStatus {
        Disabled,
        IscsiEnabled,
        CloudEnabled,
        IscsiAndCloudEnabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Mode {
        Invalid,
        #[serde(rename = "IPV4")]
        Ipv4,
        #[serde(rename = "IPV6")]
        Ipv6,
        #[serde(rename = "BOTH")]
        Both,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkInterfaceData0Settings {
    #[serde(rename = "controllerZeroIp", skip_serializing_if = "Option::is_none")]
    pub controller_zero_ip: Option<String>,
    #[serde(rename = "controllerOneIp", skip_serializing_if = "Option::is_none")]
    pub controller_one_ip: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSettings {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: NetworkSettingsProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSettingsPatch {
    pub properties: NetworkSettingsPatchProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSettingsPatchProperties {
    #[serde(rename = "dnsSettings", skip_serializing_if = "Option::is_none")]
    pub dns_settings: Option<DnsSettings>,
    #[serde(rename = "networkAdapters", skip_serializing_if = "Option::is_none")]
    pub network_adapters: Option<NetworkAdapterList>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NetworkSettingsProperties {
    #[serde(rename = "dnsSettings")]
    pub dns_settings: DnsSettings,
    #[serde(rename = "networkAdapters")]
    pub network_adapters: NetworkAdapterList,
    #[serde(rename = "webproxySettings")]
    pub webproxy_settings: WebproxySettings,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NicIPv4 {
    #[serde(rename = "ipv4Address", skip_serializing_if = "Option::is_none")]
    pub ipv4_address: Option<String>,
    #[serde(rename = "ipv4Netmask", skip_serializing_if = "Option::is_none")]
    pub ipv4_netmask: Option<String>,
    #[serde(rename = "ipv4Gateway", skip_serializing_if = "Option::is_none")]
    pub ipv4_gateway: Option<String>,
    #[serde(rename = "controller0Ipv4Address", skip_serializing_if = "Option::is_none")]
    pub controller0_ipv4_address: Option<String>,
    #[serde(rename = "controller1Ipv4Address", skip_serializing_if = "Option::is_none")]
    pub controller1_ipv4_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NicIPv6 {
    #[serde(rename = "ipv6Address", skip_serializing_if = "Option::is_none")]
    pub ipv6_address: Option<String>,
    #[serde(rename = "ipv6Prefix", skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix: Option<String>,
    #[serde(rename = "ipv6Gateway", skip_serializing_if = "Option::is_none")]
    pub ipv6_gateway: Option<String>,
    #[serde(rename = "controller0Ipv6Address", skip_serializing_if = "Option::is_none")]
    pub controller0_ipv6_address: Option<String>,
    #[serde(rename = "controller1Ipv6Address", skip_serializing_if = "Option::is_none")]
    pub controller1_ipv6_address: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PublicKey {
    pub key: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RemoteManagementSettings {
    #[serde(rename = "remoteManagementMode")]
    pub remote_management_mode: remote_management_settings::RemoteManagementMode,
    #[serde(rename = "remoteManagementCertificate", skip_serializing_if = "Option::is_none")]
    pub remote_management_certificate: Option<String>,
}
mod remote_management_settings {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RemoteManagementMode {
        Unknown,
        Disabled,
        HttpsEnabled,
        HttpsAndHttpEnabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RemoteManagementSettingsPatch {
    #[serde(rename = "remoteManagementMode")]
    pub remote_management_mode: remote_management_settings_patch::RemoteManagementMode,
}
mod remote_management_settings_patch {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RemoteManagementMode {
        Unknown,
        Disabled,
        HttpsEnabled,
        HttpsAndHttpEnabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Resource {
    #[serde(skip_serializing)]
    pub id: Option<String>,
    #[serde(skip_serializing)]
    pub name: Option<String>,
    #[serde(rename = "type", skip_serializing)]
    pub type_: Option<String>,
    pub location: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<serde_json::Value>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ScheduleRecurrence {
    #[serde(rename = "recurrenceType")]
    pub recurrence_type: schedule_recurrence::RecurrenceType,
    #[serde(rename = "recurrenceValue")]
    pub recurrence_value: i32,
    #[serde(rename = "weeklyDaysList", skip_serializing_if = "Vec::is_empty")]
    pub weekly_days_list: Vec<String>,
}
mod schedule_recurrence {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum RecurrenceType {
        Minutes,
        Hourly,
        Daily,
        Weekly,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecondaryDnsSettings {
    #[serde(rename = "secondaryDnsServers", skip_serializing_if = "Vec::is_empty")]
    pub secondary_dns_servers: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecuritySettings {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: SecuritySettingsProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecuritySettingsPatch {
    pub properties: SecuritySettingsPatchProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecuritySettingsPatchProperties {
    #[serde(rename = "remoteManagementSettings", skip_serializing_if = "Option::is_none")]
    pub remote_management_settings: Option<RemoteManagementSettingsPatch>,
    #[serde(rename = "deviceAdminPassword", skip_serializing_if = "Option::is_none")]
    pub device_admin_password: Option<AsymmetricEncryptedSecret>,
    #[serde(rename = "snapshotPassword", skip_serializing_if = "Option::is_none")]
    pub snapshot_password: Option<AsymmetricEncryptedSecret>,
    #[serde(rename = "chapSettings", skip_serializing_if = "Option::is_none")]
    pub chap_settings: Option<ChapSettings>,
    #[serde(rename = "cloudApplianceSettings", skip_serializing_if = "Option::is_none")]
    pub cloud_appliance_settings: Option<CloudApplianceSettings>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SecuritySettingsProperties {
    #[serde(rename = "remoteManagementSettings")]
    pub remote_management_settings: RemoteManagementSettings,
    #[serde(rename = "chapSettings")]
    pub chap_settings: ChapSettings,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SendTestAlertEmailRequest {
    #[serde(rename = "emailList")]
    pub email_list: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StorageAccountCredential {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: StorageAccountCredentialProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StorageAccountCredentialList {
    pub value: Vec<StorageAccountCredential>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StorageAccountCredentialProperties {
    #[serde(rename = "endPoint")]
    pub end_point: String,
    #[serde(rename = "sslStatus")]
    pub ssl_status: storage_account_credential_properties::SslStatus,
    #[serde(rename = "accessKey", skip_serializing_if = "Option::is_none")]
    pub access_key: Option<AsymmetricEncryptedSecret>,
    #[serde(rename = "volumesCount", skip_serializing)]
    pub volumes_count: Option<i32>,
}
mod storage_account_credential_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum SslStatus {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SymmetricEncryptedSecret {
    pub value: String,
    #[serde(rename = "valueCertificateThumbprint", skip_serializing_if = "Option::is_none")]
    pub value_certificate_thumbprint: Option<String>,
    #[serde(rename = "encryptionAlgorithm")]
    pub encryption_algorithm: symmetric_encrypted_secret::EncryptionAlgorithm,
}
mod symmetric_encrypted_secret {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EncryptionAlgorithm {
        None,
        #[serde(rename = "AES256")]
        Aes256,
        #[serde(rename = "RSAES_PKCS1_v_1_5")]
        RsaesPkcs1V15,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TargetEligibilityErrorMessage {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolution: Option<String>,
    #[serde(rename = "resultCode", skip_serializing_if = "Option::is_none")]
    pub result_code: Option<target_eligibility_error_message::ResultCode>,
}
mod target_eligibility_error_message {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ResultCode {
        TargetAndSourceCannotBeSameError,
        TargetIsNotOnlineError,
        TargetSourceIncompatibleVersionError,
        LocalToTieredVolumesConversionWarning,
        TargetInsufficientCapacityError,
        TargetInsufficientLocalVolumeMemoryError,
        TargetInsufficientTieredVolumeMemoryError,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TargetEligibilityResult {
    #[serde(rename = "eligibilityStatus", skip_serializing_if = "Option::is_none")]
    pub eligibility_status: Option<target_eligibility_result::EligibilityStatus>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub messages: Vec<TargetEligibilityErrorMessage>,
}
mod target_eligibility_result {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EligibilityStatus {
        NotEligible,
        Eligible,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Time {
    pub hours: i32,
    pub minutes: i32,
    pub seconds: i32,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TimeSettings {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: TimeSettingsProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TimeSettingsProperties {
    #[serde(rename = "timeZone")]
    pub time_zone: String,
    #[serde(rename = "primaryTimeServer", skip_serializing_if = "Option::is_none")]
    pub primary_time_server: Option<String>,
    #[serde(rename = "secondaryTimeServer", skip_serializing_if = "Vec::is_empty")]
    pub secondary_time_server: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Updates {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: UpdatesProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UpdatesProperties {
    #[serde(rename = "regularUpdatesAvailable", skip_serializing_if = "Option::is_none")]
    pub regular_updates_available: Option<bool>,
    #[serde(rename = "maintenanceModeUpdatesAvailable", skip_serializing_if = "Option::is_none")]
    pub maintenance_mode_updates_available: Option<bool>,
    #[serde(rename = "isUpdateInProgress", skip_serializing_if = "Option::is_none")]
    pub is_update_in_progress: Option<bool>,
    #[serde(rename = "lastUpdatedTime", skip_serializing_if = "Option::is_none")]
    pub last_updated_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VmImage {
    pub name: String,
    pub version: String,
    pub offer: String,
    pub publisher: String,
    pub sku: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Volume {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: VolumeProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VolumeContainer {
    #[serde(flatten)]
    pub base_model: BaseModel,
    pub properties: VolumeContainerProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VolumeContainerFailoverMetadata {
    #[serde(rename = "volumeContainerId", skip_serializing_if = "Option::is_none")]
    pub volume_container_id: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub volumes: Vec<VolumeFailoverMetadata>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VolumeContainerList {
    pub value: Vec<VolumeContainer>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VolumeContainerProperties {
    #[serde(rename = "encryptionKey", skip_serializing_if = "Option::is_none")]
    pub encryption_key: Option<AsymmetricEncryptedSecret>,
    #[serde(rename = "encryptionStatus", skip_serializing)]
    pub encryption_status: Option<volume_container_properties::EncryptionStatus>,
    #[serde(rename = "volumeCount", skip_serializing)]
    pub volume_count: Option<i32>,
    #[serde(rename = "storageAccountCredentialId")]
    pub storage_account_credential_id: String,
    #[serde(rename = "ownerShipStatus", skip_serializing)]
    pub owner_ship_status: Option<volume_container_properties::OwnerShipStatus>,
    #[serde(rename = "bandWidthRateInMbps", skip_serializing_if = "Option::is_none")]
    pub band_width_rate_in_mbps: Option<i32>,
    #[serde(rename = "bandwidthSettingId", skip_serializing_if = "Option::is_none")]
    pub bandwidth_setting_id: Option<String>,
    #[serde(rename = "totalCloudStorageUsageInBytes", skip_serializing)]
    pub total_cloud_storage_usage_in_bytes: Option<i64>,
}
mod volume_container_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EncryptionStatus {
        Enabled,
        Disabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OwnerShipStatus {
        Owned,
        NotOwned,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VolumeFailoverMetadata {
    #[serde(rename = "volumeId", skip_serializing_if = "Option::is_none")]
    pub volume_id: Option<String>,
    #[serde(rename = "volumeType", skip_serializing_if = "Option::is_none")]
    pub volume_type: Option<volume_failover_metadata::VolumeType>,
    #[serde(rename = "sizeInBytes", skip_serializing_if = "Option::is_none")]
    pub size_in_bytes: Option<i64>,
    #[serde(rename = "backupCreatedDate", skip_serializing_if = "Option::is_none")]
    pub backup_created_date: Option<String>,
    #[serde(rename = "backupElementId", skip_serializing_if = "Option::is_none")]
    pub backup_element_id: Option<String>,
    #[serde(rename = "backupId", skip_serializing_if = "Option::is_none")]
    pub backup_id: Option<String>,
    #[serde(rename = "backupPolicyId", skip_serializing_if = "Option::is_none")]
    pub backup_policy_id: Option<String>,
}
mod volume_failover_metadata {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VolumeType {
        Tiered,
        Archival,
        LocallyPinned,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VolumeList {
    pub value: Vec<Volume>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VolumeProperties {
    #[serde(rename = "sizeInBytes")]
    pub size_in_bytes: i64,
    #[serde(rename = "volumeType")]
    pub volume_type: volume_properties::VolumeType,
    #[serde(rename = "volumeContainerId", skip_serializing)]
    pub volume_container_id: Option<String>,
    #[serde(rename = "accessControlRecordIds")]
    pub access_control_record_ids: Vec<String>,
    #[serde(rename = "volumeStatus")]
    pub volume_status: volume_properties::VolumeStatus,
    #[serde(rename = "operationStatus", skip_serializing)]
    pub operation_status: Option<volume_properties::OperationStatus>,
    #[serde(rename = "backupStatus", skip_serializing)]
    pub backup_status: Option<volume_properties::BackupStatus>,
    #[serde(rename = "monitoringStatus")]
    pub monitoring_status: volume_properties::MonitoringStatus,
    #[serde(rename = "backupPolicyIds", skip_serializing)]
    pub backup_policy_ids: Vec<String>,
}
mod volume_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VolumeType {
        Tiered,
        Archival,
        LocallyPinned,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum VolumeStatus {
        Online,
        Offline,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum OperationStatus {
        None,
        Updating,
        Deleting,
        Restoring,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum BackupStatus {
        Enabled,
        Disabled,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum MonitoringStatus {
        Enabled,
        Disabled,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct WebproxySettings {
    #[serde(rename = "connectionUri", skip_serializing_if = "Option::is_none")]
    pub connection_uri: Option<String>,
    pub authentication: webproxy_settings::Authentication,
    pub username: String,
}
mod webproxy_settings {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Authentication {
        Invalid,
        None,
        Basic,
        #[serde(rename = "NTLM")]
        Ntlm,
    }
}
