#![doc = "generated by AutoRust 0.1.0"]
#![allow(non_camel_case_types)]
#![allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipeline {
    pub name: String,
    #[serde(rename = "systemData", default, skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<LivePipelineProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "topologyName", default, skip_serializing_if = "Option::is_none")]
    pub topology_name: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<ParameterDefinition>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<live_pipeline_properties::State>,
}
pub mod live_pipeline_properties {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum State {
        #[serde(rename = "inactive")]
        Inactive,
        #[serde(rename = "activating")]
        Activating,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "deactivating")]
        Deactivating,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParameterDefinition {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<LivePipeline>,
    #[serde(rename = "@continuationToken", default, skip_serializing_if = "Option::is_none")]
    pub continuation_token: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopologyCollection {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub value: Vec<PipelineTopology>,
    #[serde(rename = "@continuationToken", default, skip_serializing_if = "Option::is_none")]
    pub continuation_token: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopology {
    pub name: String,
    #[serde(rename = "systemData", default, skip_serializing_if = "Option::is_none")]
    pub system_data: Option<SystemData>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<PipelineTopologyProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopologyProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<ParameterDeclaration>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub sources: Vec<SourceNodeBase>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub processors: Vec<ProcessorNodeBase>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub sinks: Vec<SinkNodeBase>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SystemData {
    #[serde(rename = "createdAt", default, skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(rename = "lastModifiedAt", default, skip_serializing_if = "Option::is_none")]
    pub last_modified_at: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ParameterDeclaration {
    pub name: String,
    #[serde(rename = "type")]
    pub type_: parameter_declaration::Type,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<String>,
}
pub mod parameter_declaration {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Type {
        #[serde(rename = "string")]
        String,
        #[serde(rename = "secretString")]
        SecretString,
        #[serde(rename = "int")]
        Int,
        #[serde(rename = "double")]
        Double,
        #[serde(rename = "bool")]
        Bool,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SourceNodeBase {
    #[serde(rename = "@type")]
    pub type_: String,
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct RtspSource {
    #[serde(flatten)]
    pub source_node_base: SourceNodeBase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transport: Option<rtsp_source::Transport>,
    pub endpoint: EndpointBase,
}
pub mod rtsp_source {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Transport {
        #[serde(rename = "http")]
        Http,
        #[serde(rename = "tcp")]
        Tcp,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IotHubMessageSource {
    #[serde(flatten)]
    pub source_node_base: SourceNodeBase,
    #[serde(rename = "hubInputName", default, skip_serializing_if = "Option::is_none")]
    pub hub_input_name: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IotHubMessageSink {
    #[serde(flatten)]
    pub sink_node_base: SinkNodeBase,
    #[serde(rename = "hubOutputName")]
    pub hub_output_name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct EndpointBase {
    #[serde(rename = "@type")]
    pub type_: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<CredentialsBase>,
    pub url: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CredentialsBase {
    #[serde(rename = "@type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UsernamePasswordCredentials {
    #[serde(flatten)]
    pub credentials_base: CredentialsBase,
    pub username: String,
    pub password: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpHeaderCredentials {
    #[serde(flatten)]
    pub credentials_base: CredentialsBase,
    #[serde(rename = "headerName")]
    pub header_name: String,
    #[serde(rename = "headerValue")]
    pub header_value: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UnsecuredEndpoint {
    #[serde(flatten)]
    pub endpoint_base: EndpointBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TlsEndpoint {
    #[serde(flatten)]
    pub endpoint_base: EndpointBase,
    #[serde(rename = "trustedCertificates", default, skip_serializing_if = "Option::is_none")]
    pub trusted_certificates: Option<CertificateSource>,
    #[serde(rename = "validationOptions", default, skip_serializing_if = "Option::is_none")]
    pub validation_options: Option<TlsValidationOptions>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CertificateSource {
    #[serde(rename = "@type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TlsValidationOptions {
    #[serde(rename = "ignoreHostname", default, skip_serializing_if = "Option::is_none")]
    pub ignore_hostname: Option<String>,
    #[serde(rename = "ignoreSignature", default, skip_serializing_if = "Option::is_none")]
    pub ignore_signature: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PemCertificateList {
    #[serde(flatten)]
    pub certificate_source: CertificateSource,
    pub certificates: Vec<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SinkNodeBase {
    #[serde(rename = "@type")]
    pub type_: String,
    pub name: String,
    pub inputs: Vec<NodeInput>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NodeInput {
    #[serde(rename = "nodeName")]
    pub node_name: String,
    #[serde(rename = "outputSelectors", default, skip_serializing_if = "Vec::is_empty")]
    pub output_selectors: Vec<OutputSelector>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct OutputSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub property: Option<output_selector::Property>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<output_selector::Operator>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
pub mod output_selector {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Property {
        #[serde(rename = "mediaType")]
        MediaType,
    }
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Operator {
        #[serde(rename = "is")]
        Is,
        #[serde(rename = "isNot")]
        IsNot,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct FileSink {
    #[serde(flatten)]
    pub sink_node_base: SinkNodeBase,
    #[serde(rename = "baseDirectoryPath")]
    pub base_directory_path: String,
    #[serde(rename = "fileNamePattern")]
    pub file_name_pattern: String,
    #[serde(rename = "maximumSizeMiB")]
    pub maximum_size_mi_b: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoCreationProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "segmentLength", default, skip_serializing_if = "Option::is_none")]
    pub segment_length: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct VideoSink {
    #[serde(flatten)]
    pub sink_node_base: SinkNodeBase,
    #[serde(rename = "videoName")]
    pub video_name: String,
    #[serde(rename = "videoCreationProperties", default, skip_serializing_if = "Option::is_none")]
    pub video_creation_properties: Option<VideoCreationProperties>,
    #[serde(rename = "localMediaCachePath")]
    pub local_media_cache_path: String,
    #[serde(rename = "localMediaCacheMaximumSizeMiB")]
    pub local_media_cache_maximum_size_mi_b: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ProcessorNodeBase {
    #[serde(rename = "@type")]
    pub type_: String,
    pub name: String,
    pub inputs: Vec<NodeInput>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MotionDetectionProcessor {
    #[serde(flatten)]
    pub processor_node_base: ProcessorNodeBase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sensitivity: Option<motion_detection_processor::Sensitivity>,
    #[serde(rename = "outputMotionRegion", default, skip_serializing_if = "Option::is_none")]
    pub output_motion_region: Option<bool>,
    #[serde(rename = "eventAggregationWindow", default, skip_serializing_if = "Option::is_none")]
    pub event_aggregation_window: Option<String>,
}
pub mod motion_detection_processor {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Sensitivity {
        #[serde(rename = "low")]
        Low,
        #[serde(rename = "medium")]
        Medium,
        #[serde(rename = "high")]
        High,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ObjectTrackingProcessor {
    #[serde(flatten)]
    pub processor_node_base: ProcessorNodeBase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub accuracy: Option<object_tracking_processor::Accuracy>,
}
pub mod object_tracking_processor {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Accuracy {
        #[serde(rename = "low")]
        Low,
        #[serde(rename = "medium")]
        Medium,
        #[serde(rename = "high")]
        High,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LineCrossingProcessor {
    #[serde(flatten)]
    pub processor_node_base: ProcessorNodeBase,
    pub lines: Vec<NamedLineBase>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExtensionProcessorBase {
    #[serde(flatten)]
    pub processor_node_base: ProcessorNodeBase,
    pub endpoint: EndpointBase,
    pub image: ImageProperties,
    #[serde(rename = "samplingOptions", default, skip_serializing_if = "Option::is_none")]
    pub sampling_options: Option<SamplingOptions>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GrpcExtension {
    #[serde(flatten)]
    pub extension_processor_base: ExtensionProcessorBase,
    #[serde(rename = "dataTransfer")]
    pub data_transfer: GrpcExtensionDataTransfer,
    #[serde(rename = "extensionConfiguration", default, skip_serializing_if = "Option::is_none")]
    pub extension_configuration: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct GrpcExtensionDataTransfer {
    #[serde(rename = "sharedMemorySizeMiB", default, skip_serializing_if = "Option::is_none")]
    pub shared_memory_size_mi_b: Option<String>,
    pub mode: grpc_extension_data_transfer::Mode,
}
pub mod grpc_extension_data_transfer {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Mode {
        #[serde(rename = "embedded")]
        Embedded,
        #[serde(rename = "sharedMemory")]
        SharedMemory,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpExtension {
    #[serde(flatten)]
    pub extension_processor_base: ExtensionProcessorBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageProperties {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<ImageScale>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<ImageFormatProperties>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SamplingOptions {
    #[serde(rename = "skipSamplesWithoutAnnotation", default, skip_serializing_if = "Option::is_none")]
    pub skip_samples_without_annotation: Option<String>,
    #[serde(rename = "maximumSamplesPerSecond", default, skip_serializing_if = "Option::is_none")]
    pub maximum_samples_per_second: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageScale {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<image_scale::Mode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<String>,
}
pub mod image_scale {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Mode {
        #[serde(rename = "preserveAspectRatio")]
        PreserveAspectRatio,
        #[serde(rename = "pad")]
        Pad,
        #[serde(rename = "stretch")]
        Stretch,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageFormatProperties {
    #[serde(rename = "@type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageFormatRaw {
    #[serde(flatten)]
    pub image_format_properties: ImageFormatProperties,
    #[serde(rename = "pixelFormat")]
    pub pixel_format: image_format_raw::PixelFormat,
}
pub mod image_format_raw {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum PixelFormat {
        #[serde(rename = "yuv420p")]
        Yuv420p,
        #[serde(rename = "rgb565be")]
        Rgb565be,
        #[serde(rename = "rgb565le")]
        Rgb565le,
        #[serde(rename = "rgb555be")]
        Rgb555be,
        #[serde(rename = "rgb555le")]
        Rgb555le,
        #[serde(rename = "rgb24")]
        Rgb24,
        #[serde(rename = "bgr24")]
        Bgr24,
        #[serde(rename = "argb")]
        Argb,
        #[serde(rename = "rgba")]
        Rgba,
        #[serde(rename = "abgr")]
        Abgr,
        #[serde(rename = "bgra")]
        Bgra,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageFormatJpeg {
    #[serde(flatten)]
    pub image_format_properties: ImageFormatProperties,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quality: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageFormatBmp {
    #[serde(flatten)]
    pub image_format_properties: ImageFormatProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ImageFormatPng {
    #[serde(flatten)]
    pub image_format_properties: ImageFormatProperties,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NamedLineBase {
    #[serde(rename = "@type")]
    pub type_: String,
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NamedLineString {
    #[serde(flatten)]
    pub named_line_base: NamedLineBase,
    pub line: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NamedPolygonBase {
    #[serde(rename = "@type")]
    pub type_: String,
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct NamedPolygonString {
    #[serde(flatten)]
    pub named_polygon_base: NamedPolygonBase,
    pub polygon: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SignalGateProcessor {
    #[serde(flatten)]
    pub processor_node_base: ProcessorNodeBase,
    #[serde(rename = "activationEvaluationWindow", default, skip_serializing_if = "Option::is_none")]
    pub activation_evaluation_window: Option<String>,
    #[serde(rename = "activationSignalOffset", default, skip_serializing_if = "Option::is_none")]
    pub activation_signal_offset: Option<String>,
    #[serde(rename = "minimumActivationTime", default, skip_serializing_if = "Option::is_none")]
    pub minimum_activation_time: Option<String>,
    #[serde(rename = "maximumActivationTime", default, skip_serializing_if = "Option::is_none")]
    pub maximum_activation_time: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisOperationBase {
    #[serde(rename = "@type")]
    pub type_: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisCustomOperation {
    #[serde(flatten)]
    pub spatial_analysis_operation_base: SpatialAnalysisOperationBase,
    #[serde(rename = "extensionConfiguration")]
    pub extension_configuration: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisTypedOperationBase {
    #[serde(flatten)]
    pub spatial_analysis_operation_base: SpatialAnalysisOperationBase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<String>,
    #[serde(rename = "cameraConfiguration", default, skip_serializing_if = "Option::is_none")]
    pub camera_configuration: Option<String>,
    #[serde(rename = "detectorNodeConfiguration", default, skip_serializing_if = "Option::is_none")]
    pub detector_node_configuration: Option<String>,
    #[serde(rename = "enableFaceMaskClassifier", default, skip_serializing_if = "Option::is_none")]
    pub enable_face_mask_classifier: Option<String>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisOperationEventBase {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub threshold: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub focus: Option<spatial_analysis_operation_event_base::Focus>,
}
pub mod spatial_analysis_operation_event_base {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Focus {
        #[serde(rename = "center")]
        Center,
        #[serde(rename = "bottomCenter")]
        BottomCenter,
        #[serde(rename = "footprint")]
        Footprint,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonCountEvent {
    #[serde(flatten)]
    pub spatial_analysis_operation_event_base: SpatialAnalysisOperationEventBase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trigger: Option<spatial_analysis_person_count_event::Trigger>,
    #[serde(rename = "outputFrequency", default, skip_serializing_if = "Option::is_none")]
    pub output_frequency: Option<String>,
}
pub mod spatial_analysis_person_count_event {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Trigger {
        #[serde(rename = "event")]
        Event,
        #[serde(rename = "interval")]
        Interval,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonCountZoneEvents {
    pub zone: NamedPolygonBase,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub events: Vec<SpatialAnalysisPersonCountEvent>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonCountOperation {
    #[serde(flatten)]
    pub spatial_analysis_typed_operation_base: SpatialAnalysisTypedOperationBase,
    pub zones: Vec<SpatialAnalysisPersonCountZoneEvents>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonZoneCrossingEvent {
    #[serde(flatten)]
    pub spatial_analysis_operation_event_base: SpatialAnalysisOperationEventBase,
    #[serde(rename = "eventType", default, skip_serializing_if = "Option::is_none")]
    pub event_type: Option<spatial_analysis_person_zone_crossing_event::EventType>,
}
pub mod spatial_analysis_person_zone_crossing_event {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum EventType {
        #[serde(rename = "zoneCrossing")]
        ZoneCrossing,
        #[serde(rename = "zoneDwellTime")]
        ZoneDwellTime,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonZoneCrossingZoneEvents {
    pub zone: NamedPolygonBase,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub events: Vec<SpatialAnalysisPersonZoneCrossingEvent>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonZoneCrossingOperation {
    #[serde(flatten)]
    pub spatial_analysis_typed_operation_base: SpatialAnalysisTypedOperationBase,
    pub zones: Vec<SpatialAnalysisPersonZoneCrossingZoneEvents>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonDistanceEvent {
    #[serde(flatten)]
    pub spatial_analysis_operation_event_base: SpatialAnalysisOperationEventBase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trigger: Option<spatial_analysis_person_distance_event::Trigger>,
    #[serde(rename = "outputFrequency", default, skip_serializing_if = "Option::is_none")]
    pub output_frequency: Option<String>,
    #[serde(rename = "minimumDistanceThreshold", default, skip_serializing_if = "Option::is_none")]
    pub minimum_distance_threshold: Option<String>,
    #[serde(rename = "maximumDistanceThreshold", default, skip_serializing_if = "Option::is_none")]
    pub maximum_distance_threshold: Option<String>,
}
pub mod spatial_analysis_person_distance_event {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum Trigger {
        #[serde(rename = "event")]
        Event,
        #[serde(rename = "interval")]
        Interval,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonDistanceZoneEvents {
    pub zone: NamedPolygonBase,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub events: Vec<SpatialAnalysisPersonDistanceEvent>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonDistanceOperation {
    #[serde(flatten)]
    pub spatial_analysis_typed_operation_base: SpatialAnalysisTypedOperationBase,
    pub zones: Vec<SpatialAnalysisPersonDistanceZoneEvents>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonLineCrossingEvent {
    #[serde(flatten)]
    pub spatial_analysis_operation_event_base: SpatialAnalysisOperationEventBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonLineCrossingLineEvents {
    pub line: NamedLineBase,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub events: Vec<SpatialAnalysisPersonLineCrossingEvent>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SpatialAnalysisPersonLineCrossingOperation {
    #[serde(flatten)]
    pub spatial_analysis_typed_operation_base: SpatialAnalysisTypedOperationBase,
    pub lines: Vec<SpatialAnalysisPersonLineCrossingLineEvents>,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CognitiveServicesVisionProcessor {
    #[serde(flatten)]
    pub processor_node_base: ProcessorNodeBase,
    pub endpoint: EndpointBase,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<ImageProperties>,
    #[serde(rename = "samplingOptions", default, skip_serializing_if = "Option::is_none")]
    pub sampling_options: Option<SamplingOptions>,
    pub operation: SpatialAnalysisOperationBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MethodRequest {
    #[serde(rename = "methodName")]
    pub method_name: String,
    #[serde(rename = "@apiVersion", default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<method_request::ApiVersion>,
}
pub mod method_request {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub enum ApiVersion {
        #[serde(rename = "1.0")]
        _1_0,
    }
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopologySetRequest {
    #[serde(flatten)]
    pub method_request: MethodRequest,
    #[serde(rename = "pipelineTopology")]
    pub pipeline_topology: PipelineTopology,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopologySetRequestBody {
    #[serde(flatten)]
    pub method_request: MethodRequest,
    #[serde(flatten)]
    pub pipeline_topology: PipelineTopology,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineSetRequest {
    #[serde(flatten)]
    pub method_request: MethodRequest,
    #[serde(rename = "livePipeline")]
    pub live_pipeline: LivePipeline,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineSetRequestBody {
    #[serde(flatten)]
    pub method_request: MethodRequest,
    #[serde(flatten)]
    pub live_pipeline: LivePipeline,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MethodRequestEmptyBodyBase {
    #[serde(flatten)]
    pub method_request: MethodRequest,
    pub name: String,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopologyListRequest {
    #[serde(flatten)]
    pub method_request: MethodRequest,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopologyGetRequest {
    #[serde(flatten)]
    pub method_request_empty_body_base: MethodRequestEmptyBodyBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct PipelineTopologyDeleteRequest {
    #[serde(flatten)]
    pub method_request_empty_body_base: MethodRequestEmptyBodyBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineListRequest {
    #[serde(flatten)]
    pub method_request: MethodRequest,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineGetRequest {
    #[serde(flatten)]
    pub method_request_empty_body_base: MethodRequestEmptyBodyBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineActivateRequest {
    #[serde(flatten)]
    pub method_request_empty_body_base: MethodRequestEmptyBodyBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineDeactivateRequest {
    #[serde(flatten)]
    pub method_request_empty_body_base: MethodRequestEmptyBodyBase,
}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct LivePipelineDeleteRequest {
    #[serde(flatten)]
    pub method_request_empty_body_base: MethodRequestEmptyBodyBase,
}
