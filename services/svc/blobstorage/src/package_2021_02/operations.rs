#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, models::*, API_VERSION};
pub mod service {
    use super::{models, models::*, API_VERSION};
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<StorageServiceProperties, get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?restype=service&comp=properties", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: StorageServiceProperties =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_properties(
        operation_config: &crate::OperationConfig,
        restype: &str,
        comp: &str,
        storage_service_properties: &StorageServiceProperties,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), set_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?restype=service&comp=properties", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(set_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(storage_service_properties).map_err(set_properties::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_properties {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_statistics(
        operation_config: &crate::OperationConfig,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<StorageServiceStats, get_statistics::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?restype=service&comp=stats", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_statistics::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_statistics::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_statistics::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_statistics::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: StorageServiceStats =
                    serde_json::from_slice(rsp_body).map_err(|source| get_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_statistics::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_statistics {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_containers_segment(
        operation_config: &crate::OperationConfig,
        comp: &str,
        prefix: Option<&str>,
        marker: Option<&str>,
        maxresults: Option<i64>,
        include: &[&str],
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<ListContainersSegmentResponse, list_containers_segment::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?comp=list", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list_containers_segment::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_containers_segment::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(prefix) = prefix {
            url.query_pairs_mut().append_pair("prefix", prefix);
        }
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_containers_segment::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_containers_segment::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ListContainersSegmentResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_containers_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_containers_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_containers_segment::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_containers_segment {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_user_delegation_key(
        operation_config: &crate::OperationConfig,
        restype: &str,
        comp: &str,
        key_info: &KeyInfo,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<UserDelegationKey, get_user_delegation_key::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?restype=service&comp=userdelegationkey", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_user_delegation_key::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_user_delegation_key::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(key_info).map_err(get_user_delegation_key::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_user_delegation_key::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_user_delegation_key::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: UserDelegationKey = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_user_delegation_key::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_user_delegation_key::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_user_delegation_key::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_user_delegation_key {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_account_info(
        operation_config: &crate::OperationConfig,
        restype: &str,
        comp: &str,
        x_ms_version: &str,
    ) -> std::result::Result<(), get_account_info::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?restype=account&comp=properties", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_account_info::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_account_info::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_account_info::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_account_info::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_account_info::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_account_info::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_account_info {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn submit_batch(
        operation_config: &crate::OperationConfig,
        comp: &str,
        body: &serde_json::Value,
        content_length: i64,
        content_type: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<serde_json::Value, submit_batch::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?comp=batch", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(submit_batch::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(submit_batch::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        let req_body = azure_core::to_json(body).map_err(submit_batch::Error::SerializeError)?;
        req_builder = req_builder.header("Content-Length", content_length);
        req_builder = req_builder.header("Content-Type", content_type);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(submit_batch::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(submit_batch::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| submit_batch::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| submit_batch::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(submit_batch::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod submit_batch {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn filter_blobs(
        operation_config: &crate::OperationConfig,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        where_: Option<&str>,
        marker: Option<&str>,
        maxresults: Option<i64>,
    ) -> std::result::Result<FilterBlobSegment, filter_blobs::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?comp=blobs", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(filter_blobs::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(filter_blobs::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(where_) = where_ {
            url.query_pairs_mut().append_pair("where", where_);
        }
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(filter_blobs::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(filter_blobs::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: FilterBlobSegment =
                    serde_json::from_slice(rsp_body).map_err(|source| filter_blobs::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| filter_blobs::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(filter_blobs::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod filter_blobs {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod container {
    use super::{models, models::*, API_VERSION};
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=container", operation_config.base_path(), container_name);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_blob_public_access: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_default_encryption_scope: Option<&str>,
        x_ms_deny_encryption_scope_override: Option<bool>,
    ) -> std::result::Result<(), create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=container", operation_config.base_path(), container_name);
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_blob_public_access) = x_ms_blob_public_access {
            req_builder = req_builder.header("x-ms-blob-public-access", x_ms_blob_public_access);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_default_encryption_scope) = x_ms_default_encryption_scope {
            req_builder = req_builder.header("x-ms-default-encryption-scope", x_ms_default_encryption_scope);
        }
        if let Some(x_ms_deny_encryption_scope_override) = x_ms_deny_encryption_scope_override {
            req_builder = req_builder.header(
                "x-ms-deny-encryption-scope-override",
                x_ms_deny_encryption_scope_override.to_string(),
            );
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=container", operation_config.base_path(), container_name);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_metadata(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_meta: Option<&str>,
        if_modified_since: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), set_metadata::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?restype=container&comp=metadata",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(set_metadata::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_metadata::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_metadata::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_metadata::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_metadata::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_metadata::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_metadata {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_access_policy(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<SignedIdentifiers, get_access_policy::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=container&comp=acl", operation_config.base_path(), container_name);
        let mut url = url::Url::parse(url_str).map_err(get_access_policy::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_access_policy::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_access_policy::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_access_policy::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: SignedIdentifiers = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_access_policy::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_access_policy::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_access_policy::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_access_policy {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_access_policy(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        container_acl: Option<&SignedIdentifiers>,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_blob_public_access: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), set_access_policy::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=container&comp=acl", operation_config.base_path(), container_name);
        let mut url = url::Url::parse(url_str).map_err(set_access_policy::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_access_policy::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        let req_body = if let Some(container_acl) = container_acl {
            req_builder = req_builder.header("content-type", "application/json");
            azure_core::to_json(container_acl).map_err(set_access_policy::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_blob_public_access) = x_ms_blob_public_access {
            req_builder = req_builder.header("x-ms-blob-public-access", x_ms_blob_public_access);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_access_policy::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_access_policy::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| set_access_policy::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_access_policy::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_access_policy {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn restore(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_deleted_container_name: Option<&str>,
        x_ms_deleted_container_version: Option<&str>,
    ) -> std::result::Result<(), restore::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?restype=container&comp=undelete",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(restore::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(restore::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_deleted_container_name) = x_ms_deleted_container_name {
            req_builder = req_builder.header("x-ms-deleted-container-name", x_ms_deleted_container_name);
        }
        if let Some(x_ms_deleted_container_version) = x_ms_deleted_container_version {
            req_builder = req_builder.header("x-ms-deleted-container-version", x_ms_deleted_container_version);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(restore::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(restore::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| restore::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(restore::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod restore {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_source_container_name: &str,
        x_ms_source_lease_id: Option<&str>,
    ) -> std::result::Result<(), rename::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=container&comp=rename", operation_config.base_path(), container_name);
        let mut url = url::Url::parse(url_str).map_err(rename::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("x-ms-source-container-name", x_ms_source_container_name);
        if let Some(x_ms_source_lease_id) = x_ms_source_lease_id {
            req_builder = req_builder.header("x-ms-source-lease-id", x_ms_source_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(rename::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(rename::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| rename::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn submit_batch(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        body: &serde_json::Value,
        content_length: i64,
        content_type: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<serde_json::Value, submit_batch::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=container&comp=batch", operation_config.base_path(), container_name);
        let mut url = url::Url::parse(url_str).map_err(submit_batch::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(submit_batch::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        let req_body = azure_core::to_json(body).map_err(submit_batch::Error::SerializeError)?;
        req_builder = req_builder.header("Content-Length", content_length);
        req_builder = req_builder.header("Content-Type", content_type);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(submit_batch::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(submit_batch::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| submit_batch::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| submit_batch::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(submit_batch::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod submit_batch {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn acquire_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        comp: &str,
        restype: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_duration: Option<i64>,
        x_ms_proposed_lease_id: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), acquire_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?comp=lease&restype=container&acquire",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(acquire_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(acquire_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        url.query_pairs_mut().append_pair("restype", restype);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_duration) = x_ms_lease_duration {
            req_builder = req_builder.header("x-ms-lease-duration", x_ms_lease_duration);
        }
        if let Some(x_ms_proposed_lease_id) = x_ms_proposed_lease_id {
            req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(acquire_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(acquire_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| acquire_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(acquire_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod acquire_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn release_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        comp: &str,
        restype: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), release_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?comp=lease&restype=container&release",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(release_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(release_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        url.query_pairs_mut().append_pair("restype", restype);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(release_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(release_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| release_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(release_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod release_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn renew_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        comp: &str,
        restype: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), renew_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?comp=lease&restype=container&renew",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(renew_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(renew_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        url.query_pairs_mut().append_pair("restype", restype);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(renew_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(renew_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| renew_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(renew_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod renew_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn break_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        comp: &str,
        restype: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_break_period: Option<i64>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), break_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?comp=lease&restype=container&break",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(break_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(break_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        url.query_pairs_mut().append_pair("restype", restype);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_break_period) = x_ms_lease_break_period {
            req_builder = req_builder.header("x-ms-lease-break-period", x_ms_lease_break_period);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(break_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(break_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| break_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(break_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod break_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn change_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        comp: &str,
        restype: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        x_ms_proposed_lease_id: &str,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), change_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?comp=lease&restype=container&change",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(change_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(change_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        url.query_pairs_mut().append_pair("restype", restype);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(change_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(change_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| change_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(change_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod change_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_blob_flat_segment(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        prefix: Option<&str>,
        marker: Option<&str>,
        maxresults: Option<i64>,
        include: &[&str],
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<ListBlobsFlatSegmentResponse, list_blob_flat_segment::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?restype=container&comp=list&flat",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(list_blob_flat_segment::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_blob_flat_segment::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(prefix) = prefix {
            url.query_pairs_mut().append_pair("prefix", prefix);
        }
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_blob_flat_segment::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_blob_flat_segment::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ListBlobsFlatSegmentResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_blob_flat_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_blob_flat_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_blob_flat_segment::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_blob_flat_segment {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_blob_hierarchy_segment(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        prefix: Option<&str>,
        delimiter: &str,
        marker: Option<&str>,
        maxresults: Option<i64>,
        include: &[&str],
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<ListBlobsHierarchySegmentResponse, list_blob_hierarchy_segment::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?restype=container&comp=list&hierarchy",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(list_blob_hierarchy_segment::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_blob_hierarchy_segment::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(prefix) = prefix {
            url.query_pairs_mut().append_pair("prefix", prefix);
        }
        url.query_pairs_mut().append_pair("delimiter", delimiter);
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_blob_hierarchy_segment::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_blob_hierarchy_segment::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ListBlobsHierarchySegmentResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_blob_hierarchy_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_blob_hierarchy_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_blob_hierarchy_segment::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_blob_hierarchy_segment {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_account_info(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        restype: &str,
        comp: &str,
        x_ms_version: &str,
    ) -> std::result::Result<(), get_account_info::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?restype=account&comp=properties",
            operation_config.base_path(),
            container_name
        );
        let mut url = url::Url::parse(url_str).map_err(get_account_info::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_account_info::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_account_info::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_account_info::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_account_info::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_account_info::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_account_info {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod blob {
    use super::{models, models::*, API_VERSION};
    pub async fn download(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        snapshot: Option<&str>,
        versionid: Option<&str>,
        timeout: Option<i64>,
        x_ms_range: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_range_get_content_md5: Option<bool>,
        x_ms_range_get_content_crc64: Option<bool>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<download::Response, download::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(download::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(download::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        if let Some(versionid) = versionid {
            url.query_pairs_mut().append_pair("versionid", versionid);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_range) = x_ms_range {
            req_builder = req_builder.header("x-ms-range", x_ms_range);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_range_get_content_md5) = x_ms_range_get_content_md5 {
            req_builder = req_builder.header("x-ms-range-get-content-md5", x_ms_range_get_content_md5.to_string());
        }
        if let Some(x_ms_range_get_content_crc64) = x_ms_range_get_content_crc64 {
            req_builder = req_builder.header("x-ms-range-get-content-crc64", x_ms_range_get_content_crc64.to_string());
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(download::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(download::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| download::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(download::Response::Ok200(rsp_value))
            }
            http::StatusCode::PARTIAL_CONTENT => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| download::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(download::Response::PartialContent206(rsp_value))
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| download::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(download::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod download {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(serde_json::Value),
            PartialContent206(serde_json::Value),
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        snapshot: Option<&str>,
        versionid: Option<&str>,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_delete_snapshots: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        deletetype: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        if let Some(versionid) = versionid {
            url.query_pairs_mut().append_pair("versionid", versionid);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_delete_snapshots) = x_ms_delete_snapshots {
            req_builder = req_builder.header("x-ms-delete-snapshots", x_ms_delete_snapshots);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(deletetype) = deletetype {
            url.query_pairs_mut().append_pair("deletetype", deletetype);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        snapshot: Option<&str>,
        versionid: Option<&str>,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        if let Some(versionid) = versionid {
            url.query_pairs_mut().append_pair("versionid", versionid);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn undelete(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), undelete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=undelete", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(undelete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(undelete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(undelete::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(undelete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| undelete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(undelete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod undelete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_expiry(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_expiry_option: &str,
        x_ms_expiry_time: Option<&str>,
    ) -> std::result::Result<(), set_expiry::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=expiry", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(set_expiry::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_expiry::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("x-ms-expiry-option", x_ms_expiry_option);
        if let Some(x_ms_expiry_time) = x_ms_expiry_time {
            req_builder = req_builder.header("x-ms-expiry-time", x_ms_expiry_time);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_expiry::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_expiry::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_expiry::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_expiry::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_expiry {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_http_headers(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_blob_cache_control: Option<&str>,
        x_ms_blob_content_type: Option<&str>,
        x_ms_blob_content_md5: Option<&str>,
        x_ms_blob_content_encoding: Option<&str>,
        x_ms_blob_content_language: Option<&str>,
        x_ms_lease_id: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_blob_content_disposition: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), set_http_headers::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?comp=properties&SetHTTPHeaders",
            operation_config.base_path(),
            container_name,
            blob
        );
        let mut url = url::Url::parse(url_str).map_err(set_http_headers::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_http_headers::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_blob_cache_control) = x_ms_blob_cache_control {
            req_builder = req_builder.header("x-ms-blob-cache-control", x_ms_blob_cache_control);
        }
        if let Some(x_ms_blob_content_type) = x_ms_blob_content_type {
            req_builder = req_builder.header("x-ms-blob-content-type", x_ms_blob_content_type);
        }
        if let Some(x_ms_blob_content_md5) = x_ms_blob_content_md5 {
            req_builder = req_builder.header("x-ms-blob-content-md5", x_ms_blob_content_md5);
        }
        if let Some(x_ms_blob_content_encoding) = x_ms_blob_content_encoding {
            req_builder = req_builder.header("x-ms-blob-content-encoding", x_ms_blob_content_encoding);
        }
        if let Some(x_ms_blob_content_language) = x_ms_blob_content_language {
            req_builder = req_builder.header("x-ms-blob-content-language", x_ms_blob_content_language);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        if let Some(x_ms_blob_content_disposition) = x_ms_blob_content_disposition {
            req_builder = req_builder.header("x-ms-blob-content-disposition", x_ms_blob_content_disposition);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_http_headers::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_http_headers::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| set_http_headers::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_http_headers::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_http_headers {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_immutability_policy(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_immutability_policy_until_date: Option<&str>,
        x_ms_immutability_policy_mode: Option<&str>,
    ) -> std::result::Result<(), set_immutability_policy::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?comp=immutabilityPolicies",
            operation_config.base_path(),
            container_name,
            blob
        );
        let mut url = url::Url::parse(url_str).map_err(set_immutability_policy::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_immutability_policy::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(x_ms_immutability_policy_until_date) = x_ms_immutability_policy_until_date {
            req_builder = req_builder.header("x-ms-immutability-policy-until-date", x_ms_immutability_policy_until_date);
        }
        if let Some(x_ms_immutability_policy_mode) = x_ms_immutability_policy_mode {
            req_builder = req_builder.header("x-ms-immutability-policy-mode", x_ms_immutability_policy_mode);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(set_immutability_policy::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_immutability_policy::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| set_immutability_policy::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_immutability_policy::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_immutability_policy {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_immutability_policy(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), delete_immutability_policy::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?comp=immutabilityPolicies",
            operation_config.base_path(),
            container_name,
            blob
        );
        let mut url = url::Url::parse(url_str).map_err(delete_immutability_policy::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_immutability_policy::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(delete_immutability_policy::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_immutability_policy::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_immutability_policy::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_immutability_policy::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_immutability_policy {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_legal_hold(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_legal_hold: bool,
    ) -> std::result::Result<(), set_legal_hold::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=legalhold", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(set_legal_hold::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_legal_hold::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("x-ms-legal-hold", x_ms_legal_hold.to_string());
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_legal_hold::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_legal_hold::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_legal_hold::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_legal_hold::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_legal_hold {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_metadata(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), set_metadata::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=metadata", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(set_metadata::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_metadata::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_metadata::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_metadata::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_metadata::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_metadata::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_metadata {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn acquire_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_duration: Option<i64>,
        x_ms_proposed_lease_id: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), acquire_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=lease&acquire", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(acquire_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(acquire_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_duration) = x_ms_lease_duration {
            req_builder = req_builder.header("x-ms-lease-duration", x_ms_lease_duration);
        }
        if let Some(x_ms_proposed_lease_id) = x_ms_proposed_lease_id {
            req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(acquire_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(acquire_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| acquire_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(acquire_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod acquire_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn release_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), release_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=lease&release", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(release_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(release_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(release_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(release_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| release_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(release_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod release_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn renew_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), renew_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=lease&renew", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(renew_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(renew_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(renew_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(renew_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| renew_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(renew_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod renew_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn change_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        x_ms_proposed_lease_id: &str,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), change_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=lease&change", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(change_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(change_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(change_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(change_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| change_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(change_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod change_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn break_lease(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_break_period: Option<i64>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), break_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=lease&break", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(break_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(break_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_break_period) = x_ms_lease_break_period {
            req_builder = req_builder.header("x-ms-lease-break-period", x_ms_lease_break_period);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(break_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(break_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| break_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(break_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod break_lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_snapshot(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), create_snapshot::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=snapshot", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(create_snapshot::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_snapshot::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_snapshot::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_snapshot::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_snapshot::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_snapshot::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_snapshot {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn start_copy_from_url(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_access_tier: Option<&str>,
        x_ms_rehydrate_priority: Option<&str>,
        x_ms_source_if_modified_since: Option<&str>,
        x_ms_source_if_unmodified_since: Option<&str>,
        x_ms_source_if_match: Option<&str>,
        x_ms_source_if_none_match: Option<&str>,
        x_ms_source_if_tags: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_copy_source: &str,
        x_ms_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_tags: Option<&str>,
        x_ms_seal_blob: Option<bool>,
        x_ms_immutability_policy_until_date: Option<&str>,
        x_ms_immutability_policy_mode: Option<&str>,
        x_ms_legal_hold: Option<bool>,
    ) -> std::result::Result<(), start_copy_from_url::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=copy", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(start_copy_from_url::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(start_copy_from_url::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_access_tier) = x_ms_access_tier {
            req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        }
        if let Some(x_ms_rehydrate_priority) = x_ms_rehydrate_priority {
            req_builder = req_builder.header("x-ms-rehydrate-priority", x_ms_rehydrate_priority);
        }
        if let Some(x_ms_source_if_modified_since) = x_ms_source_if_modified_since {
            req_builder = req_builder.header("x-ms-source-if-modified-since", x_ms_source_if_modified_since);
        }
        if let Some(x_ms_source_if_unmodified_since) = x_ms_source_if_unmodified_since {
            req_builder = req_builder.header("x-ms-source-if-unmodified-since", x_ms_source_if_unmodified_since);
        }
        if let Some(x_ms_source_if_match) = x_ms_source_if_match {
            req_builder = req_builder.header("x-ms-source-if-match", x_ms_source_if_match);
        }
        if let Some(x_ms_source_if_none_match) = x_ms_source_if_none_match {
            req_builder = req_builder.header("x-ms-source-if-none-match", x_ms_source_if_none_match);
        }
        if let Some(x_ms_source_if_tags) = x_ms_source_if_tags {
            req_builder = req_builder.header("x-ms-source-if-tags", x_ms_source_if_tags);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_tags) = x_ms_tags {
            req_builder = req_builder.header("x-ms-tags", x_ms_tags);
        }
        if let Some(x_ms_seal_blob) = x_ms_seal_blob {
            req_builder = req_builder.header("x-ms-seal-blob", x_ms_seal_blob.to_string());
        }
        if let Some(x_ms_immutability_policy_until_date) = x_ms_immutability_policy_until_date {
            req_builder = req_builder.header("x-ms-immutability-policy-until-date", x_ms_immutability_policy_until_date);
        }
        if let Some(x_ms_immutability_policy_mode) = x_ms_immutability_policy_mode {
            req_builder = req_builder.header("x-ms-immutability-policy-mode", x_ms_immutability_policy_mode);
        }
        if let Some(x_ms_legal_hold) = x_ms_legal_hold {
            req_builder = req_builder.header("x-ms-legal-hold", x_ms_legal_hold.to_string());
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(start_copy_from_url::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(start_copy_from_url::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| start_copy_from_url::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(start_copy_from_url::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod start_copy_from_url {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn copy_from_url(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        x_ms_requires_sync: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_access_tier: Option<&str>,
        x_ms_source_if_modified_since: Option<&str>,
        x_ms_source_if_unmodified_since: Option<&str>,
        x_ms_source_if_match: Option<&str>,
        x_ms_source_if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_copy_source: &str,
        x_ms_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_source_content_md5: Option<&str>,
        x_ms_tags: Option<&str>,
        x_ms_immutability_policy_until_date: Option<&str>,
        x_ms_immutability_policy_mode: Option<&str>,
        x_ms_legal_hold: Option<bool>,
        x_ms_copy_source_authorization: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
    ) -> std::result::Result<(), copy_from_url::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=copy&sync", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(copy_from_url::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(copy_from_url::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        req_builder = req_builder.header("x-ms-requires-sync", x_ms_requires_sync);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_access_tier) = x_ms_access_tier {
            req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        }
        if let Some(x_ms_source_if_modified_since) = x_ms_source_if_modified_since {
            req_builder = req_builder.header("x-ms-source-if-modified-since", x_ms_source_if_modified_since);
        }
        if let Some(x_ms_source_if_unmodified_since) = x_ms_source_if_unmodified_since {
            req_builder = req_builder.header("x-ms-source-if-unmodified-since", x_ms_source_if_unmodified_since);
        }
        if let Some(x_ms_source_if_match) = x_ms_source_if_match {
            req_builder = req_builder.header("x-ms-source-if-match", x_ms_source_if_match);
        }
        if let Some(x_ms_source_if_none_match) = x_ms_source_if_none_match {
            req_builder = req_builder.header("x-ms-source-if-none-match", x_ms_source_if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_source_content_md5) = x_ms_source_content_md5 {
            req_builder = req_builder.header("x-ms-source-content-md5", x_ms_source_content_md5);
        }
        if let Some(x_ms_tags) = x_ms_tags {
            req_builder = req_builder.header("x-ms-tags", x_ms_tags);
        }
        if let Some(x_ms_immutability_policy_until_date) = x_ms_immutability_policy_until_date {
            req_builder = req_builder.header("x-ms-immutability-policy-until-date", x_ms_immutability_policy_until_date);
        }
        if let Some(x_ms_immutability_policy_mode) = x_ms_immutability_policy_mode {
            req_builder = req_builder.header("x-ms-immutability-policy-mode", x_ms_immutability_policy_mode);
        }
        if let Some(x_ms_legal_hold) = x_ms_legal_hold {
            req_builder = req_builder.header("x-ms-legal-hold", x_ms_legal_hold.to_string());
        }
        if let Some(x_ms_copy_source_authorization) = x_ms_copy_source_authorization {
            req_builder = req_builder.header("x-ms-copy-source-authorization", x_ms_copy_source_authorization);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(copy_from_url::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(copy_from_url::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| copy_from_url::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(copy_from_url::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod copy_from_url {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn abort_copy_from_url(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_copy_action: &str,
        copyid: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), abort_copy_from_url::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=copy&copyid", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(abort_copy_from_url::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(abort_copy_from_url::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-copy-action", x_ms_copy_action);
        url.query_pairs_mut().append_pair("copyid", copyid);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(abort_copy_from_url::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(abort_copy_from_url::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| abort_copy_from_url::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(abort_copy_from_url::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod abort_copy_from_url {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_tier(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        snapshot: Option<&str>,
        versionid: Option<&str>,
        timeout: Option<i64>,
        x_ms_access_tier: &str,
        x_ms_rehydrate_priority: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_if_tags: Option<&str>,
    ) -> std::result::Result<set_tier::Response, set_tier::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=tier", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(set_tier::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_tier::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        if let Some(versionid) = versionid {
            url.query_pairs_mut().append_pair("versionid", versionid);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        if let Some(x_ms_rehydrate_priority) = x_ms_rehydrate_priority {
            req_builder = req_builder.header("x-ms-rehydrate-priority", x_ms_rehydrate_priority);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_tier::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_tier::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(set_tier::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(set_tier::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_tier::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_tier::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_tier {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_account_info(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        restype: &str,
        comp: &str,
        x_ms_version: &str,
    ) -> std::result::Result<(), get_account_info::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?restype=account&comp=properties",
            operation_config.base_path(),
            container_name,
            blob
        );
        let mut url = url::Url::parse(url_str).map_err(get_account_info::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_account_info::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_account_info::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_account_info::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_account_info::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_account_info::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_account_info {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn query(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        query_request: Option<&QueryRequest>,
        snapshot: Option<&str>,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<query::Response, query::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=query", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(query::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(query::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        let req_body = if let Some(query_request) = query_request {
            req_builder = req_builder.header("content-type", "application/json");
            azure_core::to_json(query_request).map_err(query::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(query::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(query::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| query::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(query::Response::Ok200(rsp_value))
            }
            http::StatusCode::PARTIAL_CONTENT => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| query::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(query::Response::PartialContent206(rsp_value))
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| query::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(query::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod query {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(serde_json::Value),
            PartialContent206(serde_json::Value),
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_tags(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        snapshot: Option<&str>,
        versionid: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<BlobTags, get_tags::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=tags", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(get_tags::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_tags::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        if let Some(versionid) = versionid {
            url.query_pairs_mut().append_pair("versionid", versionid);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_tags::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_tags::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: BlobTags =
                    serde_json::from_slice(rsp_body).map_err(|source| get_tags::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_tags::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_tags::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_tags {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_tags(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_version: &str,
        timeout: Option<i64>,
        versionid: Option<&str>,
        content_md5: Option<&str>,
        x_ms_content_crc64: Option<&str>,
        x_ms_client_request_id: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_lease_id: Option<&str>,
        tags: Option<&BlobTags>,
    ) -> std::result::Result<(), set_tags::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=tags", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(set_tags::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_tags::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(versionid) = versionid {
            url.query_pairs_mut().append_pair("versionid", versionid);
        }
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        if let Some(x_ms_content_crc64) = x_ms_content_crc64 {
            req_builder = req_builder.header("x-ms-content-crc64", x_ms_content_crc64);
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = if let Some(tags) = tags {
            req_builder = req_builder.header("content-type", "application/json");
            azure_core::to_json(tags).map_err(set_tags::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_tags::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_tags::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_tags::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_tags::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_tags {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod page_blob {
    use super::{models, models::*, API_VERSION};
    pub async fn create(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        x_ms_blob_type: &str,
        timeout: Option<i64>,
        content_length: i64,
        x_ms_access_tier: Option<&str>,
        x_ms_blob_content_type: Option<&str>,
        x_ms_blob_content_encoding: Option<&str>,
        x_ms_blob_content_language: Option<&str>,
        x_ms_blob_content_md5: Option<&str>,
        x_ms_blob_cache_control: Option<&str>,
        x_ms_meta: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_blob_content_disposition: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_blob_content_length: i64,
        x_ms_blob_sequence_number: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_tags: Option<&str>,
        x_ms_immutability_policy_until_date: Option<&str>,
        x_ms_immutability_policy_mode: Option<&str>,
        x_ms_legal_hold: Option<bool>,
    ) -> std::result::Result<(), create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?PageBlob", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        req_builder = req_builder.header("x-ms-blob-type", x_ms_blob_type);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(x_ms_access_tier) = x_ms_access_tier {
            req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        }
        if let Some(x_ms_blob_content_type) = x_ms_blob_content_type {
            req_builder = req_builder.header("x-ms-blob-content-type", x_ms_blob_content_type);
        }
        if let Some(x_ms_blob_content_encoding) = x_ms_blob_content_encoding {
            req_builder = req_builder.header("x-ms-blob-content-encoding", x_ms_blob_content_encoding);
        }
        if let Some(x_ms_blob_content_language) = x_ms_blob_content_language {
            req_builder = req_builder.header("x-ms-blob-content-language", x_ms_blob_content_language);
        }
        if let Some(x_ms_blob_content_md5) = x_ms_blob_content_md5 {
            req_builder = req_builder.header("x-ms-blob-content-md5", x_ms_blob_content_md5);
        }
        if let Some(x_ms_blob_cache_control) = x_ms_blob_cache_control {
            req_builder = req_builder.header("x-ms-blob-cache-control", x_ms_blob_cache_control);
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_blob_content_disposition) = x_ms_blob_content_disposition {
            req_builder = req_builder.header("x-ms-blob-content-disposition", x_ms_blob_content_disposition);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-blob-content-length", x_ms_blob_content_length);
        if let Some(x_ms_blob_sequence_number) = x_ms_blob_sequence_number {
            req_builder = req_builder.header("x-ms-blob-sequence-number", x_ms_blob_sequence_number);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_tags) = x_ms_tags {
            req_builder = req_builder.header("x-ms-tags", x_ms_tags);
        }
        if let Some(x_ms_immutability_policy_until_date) = x_ms_immutability_policy_until_date {
            req_builder = req_builder.header("x-ms-immutability-policy-until-date", x_ms_immutability_policy_until_date);
        }
        if let Some(x_ms_immutability_policy_mode) = x_ms_immutability_policy_mode {
            req_builder = req_builder.header("x-ms-immutability-policy-mode", x_ms_immutability_policy_mode);
        }
        if let Some(x_ms_legal_hold) = x_ms_legal_hold {
            req_builder = req_builder.header("x-ms-legal-hold", x_ms_legal_hold.to_string());
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upload_pages(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_page_write: &str,
        body: &serde_json::Value,
        content_length: i64,
        content_md5: Option<&str>,
        x_ms_content_crc64: Option<&str>,
        timeout: Option<i64>,
        x_ms_range: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_if_sequence_number_le: Option<i64>,
        x_ms_if_sequence_number_lt: Option<i64>,
        x_ms_if_sequence_number_eq: Option<i64>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), upload_pages::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=page&update", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(upload_pages::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upload_pages::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-page-write", x_ms_page_write);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(body).map_err(upload_pages::Error::SerializeError)?;
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        if let Some(x_ms_content_crc64) = x_ms_content_crc64 {
            req_builder = req_builder.header("x-ms-content-crc64", x_ms_content_crc64);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_range) = x_ms_range {
            req_builder = req_builder.header("x-ms-range", x_ms_range);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(x_ms_if_sequence_number_le) = x_ms_if_sequence_number_le {
            req_builder = req_builder.header("x-ms-if-sequence-number-le", x_ms_if_sequence_number_le);
        }
        if let Some(x_ms_if_sequence_number_lt) = x_ms_if_sequence_number_lt {
            req_builder = req_builder.header("x-ms-if-sequence-number-lt", x_ms_if_sequence_number_lt);
        }
        if let Some(x_ms_if_sequence_number_eq) = x_ms_if_sequence_number_eq {
            req_builder = req_builder.header("x-ms-if-sequence-number-eq", x_ms_if_sequence_number_eq);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(upload_pages::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(upload_pages::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| upload_pages::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upload_pages::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upload_pages {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn clear_pages(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_page_write: &str,
        content_length: i64,
        timeout: Option<i64>,
        x_ms_range: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_if_sequence_number_le: Option<i64>,
        x_ms_if_sequence_number_lt: Option<i64>,
        x_ms_if_sequence_number_eq: Option<i64>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), clear_pages::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=page&clear", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(clear_pages::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(clear_pages::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-page-write", x_ms_page_write);
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_range) = x_ms_range {
            req_builder = req_builder.header("x-ms-range", x_ms_range);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(x_ms_if_sequence_number_le) = x_ms_if_sequence_number_le {
            req_builder = req_builder.header("x-ms-if-sequence-number-le", x_ms_if_sequence_number_le);
        }
        if let Some(x_ms_if_sequence_number_lt) = x_ms_if_sequence_number_lt {
            req_builder = req_builder.header("x-ms-if-sequence-number-lt", x_ms_if_sequence_number_lt);
        }
        if let Some(x_ms_if_sequence_number_eq) = x_ms_if_sequence_number_eq {
            req_builder = req_builder.header("x-ms-if-sequence-number-eq", x_ms_if_sequence_number_eq);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(clear_pages::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(clear_pages::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| clear_pages::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(clear_pages::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod clear_pages {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upload_pages_from_url(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_page_write: &str,
        x_ms_copy_source: &str,
        x_ms_source_range: &str,
        x_ms_source_content_md5: Option<&str>,
        x_ms_source_content_crc64: Option<&str>,
        content_length: i64,
        timeout: Option<i64>,
        x_ms_range: &str,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_if_sequence_number_le: Option<i64>,
        x_ms_if_sequence_number_lt: Option<i64>,
        x_ms_if_sequence_number_eq: Option<i64>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_source_if_modified_since: Option<&str>,
        x_ms_source_if_unmodified_since: Option<&str>,
        x_ms_source_if_match: Option<&str>,
        x_ms_source_if_none_match: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_copy_source_authorization: Option<&str>,
    ) -> std::result::Result<(), upload_pages_from_url::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?comp=page&update&fromUrl",
            operation_config.base_path(),
            container_name,
            blob
        );
        let mut url = url::Url::parse(url_str).map_err(upload_pages_from_url::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upload_pages_from_url::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-page-write", x_ms_page_write);
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        req_builder = req_builder.header("x-ms-source-range", x_ms_source_range);
        if let Some(x_ms_source_content_md5) = x_ms_source_content_md5 {
            req_builder = req_builder.header("x-ms-source-content-md5", x_ms_source_content_md5);
        }
        if let Some(x_ms_source_content_crc64) = x_ms_source_content_crc64 {
            req_builder = req_builder.header("x-ms-source-content-crc64", x_ms_source_content_crc64);
        }
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-range", x_ms_range);
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_if_sequence_number_le) = x_ms_if_sequence_number_le {
            req_builder = req_builder.header("x-ms-if-sequence-number-le", x_ms_if_sequence_number_le);
        }
        if let Some(x_ms_if_sequence_number_lt) = x_ms_if_sequence_number_lt {
            req_builder = req_builder.header("x-ms-if-sequence-number-lt", x_ms_if_sequence_number_lt);
        }
        if let Some(x_ms_if_sequence_number_eq) = x_ms_if_sequence_number_eq {
            req_builder = req_builder.header("x-ms-if-sequence-number-eq", x_ms_if_sequence_number_eq);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        if let Some(x_ms_source_if_modified_since) = x_ms_source_if_modified_since {
            req_builder = req_builder.header("x-ms-source-if-modified-since", x_ms_source_if_modified_since);
        }
        if let Some(x_ms_source_if_unmodified_since) = x_ms_source_if_unmodified_since {
            req_builder = req_builder.header("x-ms-source-if-unmodified-since", x_ms_source_if_unmodified_since);
        }
        if let Some(x_ms_source_if_match) = x_ms_source_if_match {
            req_builder = req_builder.header("x-ms-source-if-match", x_ms_source_if_match);
        }
        if let Some(x_ms_source_if_none_match) = x_ms_source_if_none_match {
            req_builder = req_builder.header("x-ms-source-if-none-match", x_ms_source_if_none_match);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_copy_source_authorization) = x_ms_copy_source_authorization {
            req_builder = req_builder.header("x-ms-copy-source-authorization", x_ms_copy_source_authorization);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(upload_pages_from_url::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(upload_pages_from_url::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| upload_pages_from_url::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upload_pages_from_url::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upload_pages_from_url {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_page_ranges(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        snapshot: Option<&str>,
        timeout: Option<i64>,
        x_ms_range: Option<&str>,
        x_ms_lease_id: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<PageList, get_page_ranges::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=pagelist", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(get_page_ranges::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_page_ranges::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_range) = x_ms_range {
            req_builder = req_builder.header("x-ms-range", x_ms_range);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_page_ranges::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_page_ranges::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: PageList = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_page_ranges::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_page_ranges::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_page_ranges::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_page_ranges {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_page_ranges_diff(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        snapshot: Option<&str>,
        timeout: Option<i64>,
        prevsnapshot: Option<&str>,
        x_ms_previous_snapshot_url: Option<&str>,
        x_ms_range: Option<&str>,
        x_ms_lease_id: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<PageList, get_page_ranges_diff::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=pagelist&diff", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(get_page_ranges_diff::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_page_ranges_diff::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(prevsnapshot) = prevsnapshot {
            url.query_pairs_mut().append_pair("prevsnapshot", prevsnapshot);
        }
        if let Some(x_ms_previous_snapshot_url) = x_ms_previous_snapshot_url {
            req_builder = req_builder.header("x-ms-previous-snapshot-url", x_ms_previous_snapshot_url);
        }
        if let Some(x_ms_range) = x_ms_range {
            req_builder = req_builder.header("x-ms-range", x_ms_range);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_page_ranges_diff::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_page_ranges_diff::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: PageList = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_page_ranges_diff::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_page_ranges_diff::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_page_ranges_diff::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_page_ranges_diff {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn resize(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_blob_content_length: i64,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), resize::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?comp=properties&Resize",
            operation_config.base_path(),
            container_name,
            blob
        );
        let mut url = url::Url::parse(url_str).map_err(resize::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(resize::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-blob-content-length", x_ms_blob_content_length);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(resize::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(resize::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| resize::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(resize::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod resize {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update_sequence_number(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_sequence_number_action: &str,
        x_ms_blob_sequence_number: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), update_sequence_number::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?comp=properties&UpdateSequenceNumber",
            operation_config.base_path(),
            container_name,
            blob
        );
        let mut url = url::Url::parse(url_str).map_err(update_sequence_number::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update_sequence_number::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-sequence-number-action", x_ms_sequence_number_action);
        if let Some(x_ms_blob_sequence_number) = x_ms_blob_sequence_number {
            req_builder = req_builder.header("x-ms-blob-sequence-number", x_ms_blob_sequence_number);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(update_sequence_number::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(update_sequence_number::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| update_sequence_number::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update_sequence_number::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update_sequence_number {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn copy_incremental(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_copy_source: &str,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), copy_incremental::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=incrementalcopy", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(copy_incremental::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(copy_incremental::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(copy_incremental::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(copy_incremental::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| copy_incremental::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(copy_incremental::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod copy_incremental {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod append_blob {
    use super::{models, models::*, API_VERSION};
    pub async fn create(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        x_ms_blob_type: &str,
        timeout: Option<i64>,
        content_length: i64,
        x_ms_blob_content_type: Option<&str>,
        x_ms_blob_content_encoding: Option<&str>,
        x_ms_blob_content_language: Option<&str>,
        x_ms_blob_content_md5: Option<&str>,
        x_ms_blob_cache_control: Option<&str>,
        x_ms_meta: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_blob_content_disposition: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_tags: Option<&str>,
        x_ms_immutability_policy_until_date: Option<&str>,
        x_ms_immutability_policy_mode: Option<&str>,
        x_ms_legal_hold: Option<bool>,
    ) -> std::result::Result<(), create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?AppendBlob", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        req_builder = req_builder.header("x-ms-blob-type", x_ms_blob_type);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(x_ms_blob_content_type) = x_ms_blob_content_type {
            req_builder = req_builder.header("x-ms-blob-content-type", x_ms_blob_content_type);
        }
        if let Some(x_ms_blob_content_encoding) = x_ms_blob_content_encoding {
            req_builder = req_builder.header("x-ms-blob-content-encoding", x_ms_blob_content_encoding);
        }
        if let Some(x_ms_blob_content_language) = x_ms_blob_content_language {
            req_builder = req_builder.header("x-ms-blob-content-language", x_ms_blob_content_language);
        }
        if let Some(x_ms_blob_content_md5) = x_ms_blob_content_md5 {
            req_builder = req_builder.header("x-ms-blob-content-md5", x_ms_blob_content_md5);
        }
        if let Some(x_ms_blob_cache_control) = x_ms_blob_cache_control {
            req_builder = req_builder.header("x-ms-blob-cache-control", x_ms_blob_cache_control);
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_blob_content_disposition) = x_ms_blob_content_disposition {
            req_builder = req_builder.header("x-ms-blob-content-disposition", x_ms_blob_content_disposition);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_tags) = x_ms_tags {
            req_builder = req_builder.header("x-ms-tags", x_ms_tags);
        }
        if let Some(x_ms_immutability_policy_until_date) = x_ms_immutability_policy_until_date {
            req_builder = req_builder.header("x-ms-immutability-policy-until-date", x_ms_immutability_policy_until_date);
        }
        if let Some(x_ms_immutability_policy_mode) = x_ms_immutability_policy_mode {
            req_builder = req_builder.header("x-ms-immutability-policy-mode", x_ms_immutability_policy_mode);
        }
        if let Some(x_ms_legal_hold) = x_ms_legal_hold {
            req_builder = req_builder.header("x-ms-legal-hold", x_ms_legal_hold.to_string());
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn append_block(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        body: &serde_json::Value,
        timeout: Option<i64>,
        content_length: i64,
        content_md5: Option<&str>,
        x_ms_content_crc64: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_blob_condition_maxsize: Option<i64>,
        x_ms_blob_condition_appendpos: Option<i64>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), append_block::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=appendblock", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(append_block::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(append_block::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(body).map_err(append_block::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        if let Some(x_ms_content_crc64) = x_ms_content_crc64 {
            req_builder = req_builder.header("x-ms-content-crc64", x_ms_content_crc64);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_blob_condition_maxsize) = x_ms_blob_condition_maxsize {
            req_builder = req_builder.header("x-ms-blob-condition-maxsize", x_ms_blob_condition_maxsize);
        }
        if let Some(x_ms_blob_condition_appendpos) = x_ms_blob_condition_appendpos {
            req_builder = req_builder.header("x-ms-blob-condition-appendpos", x_ms_blob_condition_appendpos);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(append_block::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(append_block::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| append_block::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(append_block::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod append_block {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn append_block_from_url(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        x_ms_copy_source: &str,
        x_ms_source_range: Option<&str>,
        x_ms_source_content_md5: Option<&str>,
        x_ms_source_content_crc64: Option<&str>,
        timeout: Option<i64>,
        content_length: i64,
        content_md5: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_blob_condition_maxsize: Option<i64>,
        x_ms_blob_condition_appendpos: Option<i64>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_source_if_modified_since: Option<&str>,
        x_ms_source_if_unmodified_since: Option<&str>,
        x_ms_source_if_match: Option<&str>,
        x_ms_source_if_none_match: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_copy_source_authorization: Option<&str>,
    ) -> std::result::Result<(), append_block_from_url::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?comp=appendblock&fromUrl",
            operation_config.base_path(),
            container_name,
            blob
        );
        let mut url = url::Url::parse(url_str).map_err(append_block_from_url::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(append_block_from_url::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        if let Some(x_ms_source_range) = x_ms_source_range {
            req_builder = req_builder.header("x-ms-source-range", x_ms_source_range);
        }
        if let Some(x_ms_source_content_md5) = x_ms_source_content_md5 {
            req_builder = req_builder.header("x-ms-source-content-md5", x_ms_source_content_md5);
        }
        if let Some(x_ms_source_content_crc64) = x_ms_source_content_crc64 {
            req_builder = req_builder.header("x-ms-source-content-crc64", x_ms_source_content_crc64);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_blob_condition_maxsize) = x_ms_blob_condition_maxsize {
            req_builder = req_builder.header("x-ms-blob-condition-maxsize", x_ms_blob_condition_maxsize);
        }
        if let Some(x_ms_blob_condition_appendpos) = x_ms_blob_condition_appendpos {
            req_builder = req_builder.header("x-ms-blob-condition-appendpos", x_ms_blob_condition_appendpos);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        if let Some(x_ms_source_if_modified_since) = x_ms_source_if_modified_since {
            req_builder = req_builder.header("x-ms-source-if-modified-since", x_ms_source_if_modified_since);
        }
        if let Some(x_ms_source_if_unmodified_since) = x_ms_source_if_unmodified_since {
            req_builder = req_builder.header("x-ms-source-if-unmodified-since", x_ms_source_if_unmodified_since);
        }
        if let Some(x_ms_source_if_match) = x_ms_source_if_match {
            req_builder = req_builder.header("x-ms-source-if-match", x_ms_source_if_match);
        }
        if let Some(x_ms_source_if_none_match) = x_ms_source_if_none_match {
            req_builder = req_builder.header("x-ms-source-if-none-match", x_ms_source_if_none_match);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_copy_source_authorization) = x_ms_copy_source_authorization {
            req_builder = req_builder.header("x-ms-copy-source-authorization", x_ms_copy_source_authorization);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(append_block_from_url::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(append_block_from_url::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| append_block_from_url::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(append_block_from_url::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod append_block_from_url {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn seal(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_lease_id: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_blob_condition_appendpos: Option<i64>,
    ) -> std::result::Result<(), seal::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=seal", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(seal::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(seal::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_blob_condition_appendpos) = x_ms_blob_condition_appendpos {
            req_builder = req_builder.header("x-ms-blob-condition-appendpos", x_ms_blob_condition_appendpos);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(seal::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(seal::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| seal::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(seal::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod seal {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod block_blob {
    use super::{models, models::*, API_VERSION};
    pub async fn upload(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        x_ms_blob_type: &str,
        body: &serde_json::Value,
        timeout: Option<i64>,
        content_md5: Option<&str>,
        content_length: i64,
        x_ms_blob_content_type: Option<&str>,
        x_ms_blob_content_encoding: Option<&str>,
        x_ms_blob_content_language: Option<&str>,
        x_ms_blob_content_md5: Option<&str>,
        x_ms_blob_cache_control: Option<&str>,
        x_ms_meta: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_blob_content_disposition: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_access_tier: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_tags: Option<&str>,
        x_ms_immutability_policy_until_date: Option<&str>,
        x_ms_immutability_policy_mode: Option<&str>,
        x_ms_legal_hold: Option<bool>,
    ) -> std::result::Result<(), upload::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?BlockBlob", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(upload::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upload::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        req_builder = req_builder.header("x-ms-blob-type", x_ms_blob_type);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(body).map_err(upload::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(x_ms_blob_content_type) = x_ms_blob_content_type {
            req_builder = req_builder.header("x-ms-blob-content-type", x_ms_blob_content_type);
        }
        if let Some(x_ms_blob_content_encoding) = x_ms_blob_content_encoding {
            req_builder = req_builder.header("x-ms-blob-content-encoding", x_ms_blob_content_encoding);
        }
        if let Some(x_ms_blob_content_language) = x_ms_blob_content_language {
            req_builder = req_builder.header("x-ms-blob-content-language", x_ms_blob_content_language);
        }
        if let Some(x_ms_blob_content_md5) = x_ms_blob_content_md5 {
            req_builder = req_builder.header("x-ms-blob-content-md5", x_ms_blob_content_md5);
        }
        if let Some(x_ms_blob_cache_control) = x_ms_blob_cache_control {
            req_builder = req_builder.header("x-ms-blob-cache-control", x_ms_blob_cache_control);
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_blob_content_disposition) = x_ms_blob_content_disposition {
            req_builder = req_builder.header("x-ms-blob-content-disposition", x_ms_blob_content_disposition);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(x_ms_access_tier) = x_ms_access_tier {
            req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_tags) = x_ms_tags {
            req_builder = req_builder.header("x-ms-tags", x_ms_tags);
        }
        if let Some(x_ms_immutability_policy_until_date) = x_ms_immutability_policy_until_date {
            req_builder = req_builder.header("x-ms-immutability-policy-until-date", x_ms_immutability_policy_until_date);
        }
        if let Some(x_ms_immutability_policy_mode) = x_ms_immutability_policy_mode {
            req_builder = req_builder.header("x-ms-immutability-policy-mode", x_ms_immutability_policy_mode);
        }
        if let Some(x_ms_legal_hold) = x_ms_legal_hold {
            req_builder = req_builder.header("x-ms-legal-hold", x_ms_legal_hold.to_string());
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(upload::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(upload::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| upload::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upload::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upload {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn put_blob_from_url(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        x_ms_blob_type: &str,
        timeout: Option<i64>,
        content_md5: Option<&str>,
        content_length: i64,
        x_ms_blob_content_type: Option<&str>,
        x_ms_blob_content_encoding: Option<&str>,
        x_ms_blob_content_language: Option<&str>,
        x_ms_blob_content_md5: Option<&str>,
        x_ms_blob_cache_control: Option<&str>,
        x_ms_meta: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_blob_content_disposition: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_access_tier: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_source_if_modified_since: Option<&str>,
        x_ms_source_if_unmodified_since: Option<&str>,
        x_ms_source_if_match: Option<&str>,
        x_ms_source_if_none_match: Option<&str>,
        x_ms_source_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_source_content_md5: Option<&str>,
        x_ms_tags: Option<&str>,
        x_ms_copy_source: &str,
        x_ms_copy_source_blob_properties: Option<bool>,
        x_ms_copy_source_authorization: Option<&str>,
    ) -> std::result::Result<(), put_blob_from_url::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?BlockBlob&fromUrl", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(put_blob_from_url::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(put_blob_from_url::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        req_builder = req_builder.header("x-ms-blob-type", x_ms_blob_type);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(x_ms_blob_content_type) = x_ms_blob_content_type {
            req_builder = req_builder.header("x-ms-blob-content-type", x_ms_blob_content_type);
        }
        if let Some(x_ms_blob_content_encoding) = x_ms_blob_content_encoding {
            req_builder = req_builder.header("x-ms-blob-content-encoding", x_ms_blob_content_encoding);
        }
        if let Some(x_ms_blob_content_language) = x_ms_blob_content_language {
            req_builder = req_builder.header("x-ms-blob-content-language", x_ms_blob_content_language);
        }
        if let Some(x_ms_blob_content_md5) = x_ms_blob_content_md5 {
            req_builder = req_builder.header("x-ms-blob-content-md5", x_ms_blob_content_md5);
        }
        if let Some(x_ms_blob_cache_control) = x_ms_blob_cache_control {
            req_builder = req_builder.header("x-ms-blob-cache-control", x_ms_blob_cache_control);
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_blob_content_disposition) = x_ms_blob_content_disposition {
            req_builder = req_builder.header("x-ms-blob-content-disposition", x_ms_blob_content_disposition);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(x_ms_access_tier) = x_ms_access_tier {
            req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        if let Some(x_ms_source_if_modified_since) = x_ms_source_if_modified_since {
            req_builder = req_builder.header("x-ms-source-if-modified-since", x_ms_source_if_modified_since);
        }
        if let Some(x_ms_source_if_unmodified_since) = x_ms_source_if_unmodified_since {
            req_builder = req_builder.header("x-ms-source-if-unmodified-since", x_ms_source_if_unmodified_since);
        }
        if let Some(x_ms_source_if_match) = x_ms_source_if_match {
            req_builder = req_builder.header("x-ms-source-if-match", x_ms_source_if_match);
        }
        if let Some(x_ms_source_if_none_match) = x_ms_source_if_none_match {
            req_builder = req_builder.header("x-ms-source-if-none-match", x_ms_source_if_none_match);
        }
        if let Some(x_ms_source_if_tags) = x_ms_source_if_tags {
            req_builder = req_builder.header("x-ms-source-if-tags", x_ms_source_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_source_content_md5) = x_ms_source_content_md5 {
            req_builder = req_builder.header("x-ms-source-content-md5", x_ms_source_content_md5);
        }
        if let Some(x_ms_tags) = x_ms_tags {
            req_builder = req_builder.header("x-ms-tags", x_ms_tags);
        }
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        if let Some(x_ms_copy_source_blob_properties) = x_ms_copy_source_blob_properties {
            req_builder = req_builder.header("x-ms-copy-source-blob-properties", x_ms_copy_source_blob_properties.to_string());
        }
        if let Some(x_ms_copy_source_authorization) = x_ms_copy_source_authorization {
            req_builder = req_builder.header("x-ms-copy-source-authorization", x_ms_copy_source_authorization);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(put_blob_from_url::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(put_blob_from_url::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| put_blob_from_url::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(put_blob_from_url::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod put_blob_from_url {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn stage_block(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        blockid: &str,
        content_length: i64,
        content_md5: Option<&str>,
        x_ms_content_crc64: Option<&str>,
        body: &serde_json::Value,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), stage_block::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=block", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(stage_block::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(stage_block::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        url.query_pairs_mut().append_pair("blockid", blockid);
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        if let Some(x_ms_content_crc64) = x_ms_content_crc64 {
            req_builder = req_builder.header("x-ms-content-crc64", x_ms_content_crc64);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(body).map_err(stage_block::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(stage_block::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(stage_block::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| stage_block::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(stage_block::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod stage_block {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn stage_block_from_url(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        blockid: &str,
        content_length: i64,
        x_ms_copy_source: &str,
        x_ms_source_range: Option<&str>,
        x_ms_source_content_md5: Option<&str>,
        x_ms_source_content_crc64: Option<&str>,
        timeout: Option<i64>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_source_if_modified_since: Option<&str>,
        x_ms_source_if_unmodified_since: Option<&str>,
        x_ms_source_if_match: Option<&str>,
        x_ms_source_if_none_match: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_copy_source_authorization: Option<&str>,
    ) -> std::result::Result<(), stage_block_from_url::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=block&fromURL", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(stage_block_from_url::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(stage_block_from_url::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        url.query_pairs_mut().append_pair("blockid", blockid);
        req_builder = req_builder.header("Content-Length", content_length);
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        if let Some(x_ms_source_range) = x_ms_source_range {
            req_builder = req_builder.header("x-ms-source-range", x_ms_source_range);
        }
        if let Some(x_ms_source_content_md5) = x_ms_source_content_md5 {
            req_builder = req_builder.header("x-ms-source-content-md5", x_ms_source_content_md5);
        }
        if let Some(x_ms_source_content_crc64) = x_ms_source_content_crc64 {
            req_builder = req_builder.header("x-ms-source-content-crc64", x_ms_source_content_crc64);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_source_if_modified_since) = x_ms_source_if_modified_since {
            req_builder = req_builder.header("x-ms-source-if-modified-since", x_ms_source_if_modified_since);
        }
        if let Some(x_ms_source_if_unmodified_since) = x_ms_source_if_unmodified_since {
            req_builder = req_builder.header("x-ms-source-if-unmodified-since", x_ms_source_if_unmodified_since);
        }
        if let Some(x_ms_source_if_match) = x_ms_source_if_match {
            req_builder = req_builder.header("x-ms-source-if-match", x_ms_source_if_match);
        }
        if let Some(x_ms_source_if_none_match) = x_ms_source_if_none_match {
            req_builder = req_builder.header("x-ms-source-if-none-match", x_ms_source_if_none_match);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_copy_source_authorization) = x_ms_copy_source_authorization {
            req_builder = req_builder.header("x-ms-copy-source-authorization", x_ms_copy_source_authorization);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(stage_block_from_url::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(stage_block_from_url::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| stage_block_from_url::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(stage_block_from_url::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod stage_block_from_url {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_block_list(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        snapshot: Option<&str>,
        blocklisttype: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_if_tags: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<BlockList, get_block_list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=blocklist", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(get_block_list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_block_list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(snapshot) = snapshot {
            url.query_pairs_mut().append_pair("snapshot", snapshot);
        }
        url.query_pairs_mut().append_pair("blocklisttype", blocklisttype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_block_list::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_block_list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: BlockList =
                    serde_json::from_slice(rsp_body).map_err(|source| get_block_list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_block_list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_block_list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_block_list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn commit_block_list(
        operation_config: &crate::OperationConfig,
        container_name: &str,
        blob: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_blob_cache_control: Option<&str>,
        x_ms_blob_content_type: Option<&str>,
        x_ms_blob_content_encoding: Option<&str>,
        x_ms_blob_content_language: Option<&str>,
        x_ms_blob_content_md5: Option<&str>,
        content_md5: Option<&str>,
        x_ms_content_crc64: Option<&str>,
        x_ms_meta: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_blob_content_disposition: Option<&str>,
        x_ms_encryption_key: Option<&str>,
        x_ms_encryption_key_sha256: Option<&str>,
        x_ms_encryption_algorithm: Option<&str>,
        x_ms_encryption_scope: Option<&str>,
        x_ms_access_tier: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        x_ms_if_tags: Option<&str>,
        blocks: &BlockLookupList,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_tags: Option<&str>,
        x_ms_immutability_policy_until_date: Option<&str>,
        x_ms_immutability_policy_mode: Option<&str>,
        x_ms_legal_hold: Option<bool>,
    ) -> std::result::Result<(), commit_block_list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=blocklist", operation_config.base_path(), container_name, blob);
        let mut url = url::Url::parse(url_str).map_err(commit_block_list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(commit_block_list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_blob_cache_control) = x_ms_blob_cache_control {
            req_builder = req_builder.header("x-ms-blob-cache-control", x_ms_blob_cache_control);
        }
        if let Some(x_ms_blob_content_type) = x_ms_blob_content_type {
            req_builder = req_builder.header("x-ms-blob-content-type", x_ms_blob_content_type);
        }
        if let Some(x_ms_blob_content_encoding) = x_ms_blob_content_encoding {
            req_builder = req_builder.header("x-ms-blob-content-encoding", x_ms_blob_content_encoding);
        }
        if let Some(x_ms_blob_content_language) = x_ms_blob_content_language {
            req_builder = req_builder.header("x-ms-blob-content-language", x_ms_blob_content_language);
        }
        if let Some(x_ms_blob_content_md5) = x_ms_blob_content_md5 {
            req_builder = req_builder.header("x-ms-blob-content-md5", x_ms_blob_content_md5);
        }
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        if let Some(x_ms_content_crc64) = x_ms_content_crc64 {
            req_builder = req_builder.header("x-ms-content-crc64", x_ms_content_crc64);
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_blob_content_disposition) = x_ms_blob_content_disposition {
            req_builder = req_builder.header("x-ms-blob-content-disposition", x_ms_blob_content_disposition);
        }
        if let Some(x_ms_encryption_key) = x_ms_encryption_key {
            req_builder = req_builder.header("x-ms-encryption-key", x_ms_encryption_key);
        }
        if let Some(x_ms_encryption_key_sha256) = x_ms_encryption_key_sha256 {
            req_builder = req_builder.header("x-ms-encryption-key-sha256", x_ms_encryption_key_sha256);
        }
        if let Some(x_ms_encryption_algorithm) = x_ms_encryption_algorithm {
            req_builder = req_builder.header("x-ms-encryption-algorithm", x_ms_encryption_algorithm);
        }
        if let Some(x_ms_encryption_scope) = x_ms_encryption_scope {
            req_builder = req_builder.header("x-ms-encryption-scope", x_ms_encryption_scope);
        }
        if let Some(x_ms_access_tier) = x_ms_access_tier {
            req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(x_ms_if_tags) = x_ms_if_tags {
            req_builder = req_builder.header("x-ms-if-tags", x_ms_if_tags);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(blocks).map_err(commit_block_list::Error::SerializeError)?;
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_tags) = x_ms_tags {
            req_builder = req_builder.header("x-ms-tags", x_ms_tags);
        }
        if let Some(x_ms_immutability_policy_until_date) = x_ms_immutability_policy_until_date {
            req_builder = req_builder.header("x-ms-immutability-policy-until-date", x_ms_immutability_policy_until_date);
        }
        if let Some(x_ms_immutability_policy_mode) = x_ms_immutability_policy_mode {
            req_builder = req_builder.header("x-ms-immutability-policy-mode", x_ms_immutability_policy_mode);
        }
        if let Some(x_ms_legal_hold) = x_ms_legal_hold {
            req_builder = req_builder.header("x-ms-legal-hold", x_ms_legal_hold.to_string());
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(commit_block_list::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(commit_block_list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| commit_block_list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(commit_block_list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod commit_block_list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
