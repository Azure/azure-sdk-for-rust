#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, API_VERSION};
#[non_exhaustive]
#[derive(Debug, thiserror :: Error)]
#[allow(non_camel_case_types)]
pub enum Error {
    #[error(transparent)]
    Application_List(#[from] application::list::Error),
    #[error(transparent)]
    Application_Get(#[from] application::get::Error),
    #[error(transparent)]
    Pool_ListUsageMetrics(#[from] pool::list_usage_metrics::Error),
    #[error(transparent)]
    Account_ListNodeAgentSkus(#[from] account::list_node_agent_skus::Error),
    #[error(transparent)]
    Account_ListPoolNodeCounts(#[from] account::list_pool_node_counts::Error),
    #[error(transparent)]
    Pool_GetAllLifetimeStatistics(#[from] pool::get_all_lifetime_statistics::Error),
    #[error(transparent)]
    Job_GetAllLifetimeStatistics(#[from] job::get_all_lifetime_statistics::Error),
    #[error(transparent)]
    Certificate_List(#[from] certificate::list::Error),
    #[error(transparent)]
    Certificate_Add(#[from] certificate::add::Error),
    #[error(transparent)]
    Certificate_CancelDeletion(#[from] certificate::cancel_deletion::Error),
    #[error(transparent)]
    Certificate_Get(#[from] certificate::get::Error),
    #[error(transparent)]
    Certificate_Delete(#[from] certificate::delete::Error),
    #[error(transparent)]
    File_GetFromTask(#[from] file::get_from_task::Error),
    #[error(transparent)]
    File_DeleteFromTask(#[from] file::delete_from_task::Error),
    #[error(transparent)]
    File_GetPropertiesFromTask(#[from] file::get_properties_from_task::Error),
    #[error(transparent)]
    File_GetFromComputeNode(#[from] file::get_from_compute_node::Error),
    #[error(transparent)]
    File_DeleteFromComputeNode(#[from] file::delete_from_compute_node::Error),
    #[error(transparent)]
    File_GetPropertiesFromComputeNode(#[from] file::get_properties_from_compute_node::Error),
    #[error(transparent)]
    File_ListFromTask(#[from] file::list_from_task::Error),
    #[error(transparent)]
    File_ListFromComputeNode(#[from] file::list_from_compute_node::Error),
    #[error(transparent)]
    JobSchedule_Get(#[from] job_schedule::get::Error),
    #[error(transparent)]
    JobSchedule_Update(#[from] job_schedule::update::Error),
    #[error(transparent)]
    JobSchedule_Patch(#[from] job_schedule::patch::Error),
    #[error(transparent)]
    JobSchedule_Delete(#[from] job_schedule::delete::Error),
    #[error(transparent)]
    JobSchedule_Exists(#[from] job_schedule::exists::Error),
    #[error(transparent)]
    JobSchedule_Disable(#[from] job_schedule::disable::Error),
    #[error(transparent)]
    JobSchedule_Enable(#[from] job_schedule::enable::Error),
    #[error(transparent)]
    JobSchedule_Terminate(#[from] job_schedule::terminate::Error),
    #[error(transparent)]
    JobSchedule_List(#[from] job_schedule::list::Error),
    #[error(transparent)]
    JobSchedule_Add(#[from] job_schedule::add::Error),
    #[error(transparent)]
    Job_Get(#[from] job::get::Error),
    #[error(transparent)]
    Job_Update(#[from] job::update::Error),
    #[error(transparent)]
    Job_Patch(#[from] job::patch::Error),
    #[error(transparent)]
    Job_Delete(#[from] job::delete::Error),
    #[error(transparent)]
    Job_Disable(#[from] job::disable::Error),
    #[error(transparent)]
    Job_Enable(#[from] job::enable::Error),
    #[error(transparent)]
    Job_Terminate(#[from] job::terminate::Error),
    #[error(transparent)]
    Job_List(#[from] job::list::Error),
    #[error(transparent)]
    Job_Add(#[from] job::add::Error),
    #[error(transparent)]
    Job_ListFromJobSchedule(#[from] job::list_from_job_schedule::Error),
    #[error(transparent)]
    Job_ListPreparationAndReleaseTaskStatus(#[from] job::list_preparation_and_release_task_status::Error),
    #[error(transparent)]
    Job_GetTaskCounts(#[from] job::get_task_counts::Error),
    #[error(transparent)]
    Pool_List(#[from] pool::list::Error),
    #[error(transparent)]
    Pool_Add(#[from] pool::add::Error),
    #[error(transparent)]
    Pool_Get(#[from] pool::get::Error),
    #[error(transparent)]
    Pool_Patch(#[from] pool::patch::Error),
    #[error(transparent)]
    Pool_Delete(#[from] pool::delete::Error),
    #[error(transparent)]
    Pool_Exists(#[from] pool::exists::Error),
    #[error(transparent)]
    Pool_DisableAutoScale(#[from] pool::disable_auto_scale::Error),
    #[error(transparent)]
    Pool_EnableAutoScale(#[from] pool::enable_auto_scale::Error),
    #[error(transparent)]
    Pool_EvaluateAutoScale(#[from] pool::evaluate_auto_scale::Error),
    #[error(transparent)]
    Pool_Resize(#[from] pool::resize::Error),
    #[error(transparent)]
    Pool_StopResize(#[from] pool::stop_resize::Error),
    #[error(transparent)]
    Pool_UpdateProperties(#[from] pool::update_properties::Error),
    #[error(transparent)]
    Pool_UpgradeOs(#[from] pool::upgrade_os::Error),
    #[error(transparent)]
    Pool_RemoveNodes(#[from] pool::remove_nodes::Error),
    #[error(transparent)]
    Task_List(#[from] task::list::Error),
    #[error(transparent)]
    Task_Add(#[from] task::add::Error),
    #[error(transparent)]
    Task_AddCollection(#[from] task::add_collection::Error),
    #[error(transparent)]
    Task_Get(#[from] task::get::Error),
    #[error(transparent)]
    Task_Update(#[from] task::update::Error),
    #[error(transparent)]
    Task_Delete(#[from] task::delete::Error),
    #[error(transparent)]
    Task_ListSubtasks(#[from] task::list_subtasks::Error),
    #[error(transparent)]
    Task_Terminate(#[from] task::terminate::Error),
    #[error(transparent)]
    Task_Reactivate(#[from] task::reactivate::Error),
    #[error(transparent)]
    ComputeNode_AddUser(#[from] compute_node::add_user::Error),
    #[error(transparent)]
    ComputeNode_UpdateUser(#[from] compute_node::update_user::Error),
    #[error(transparent)]
    ComputeNode_DeleteUser(#[from] compute_node::delete_user::Error),
    #[error(transparent)]
    ComputeNode_Get(#[from] compute_node::get::Error),
    #[error(transparent)]
    ComputeNode_Reboot(#[from] compute_node::reboot::Error),
    #[error(transparent)]
    ComputeNode_Reimage(#[from] compute_node::reimage::Error),
    #[error(transparent)]
    ComputeNode_DisableScheduling(#[from] compute_node::disable_scheduling::Error),
    #[error(transparent)]
    ComputeNode_EnableScheduling(#[from] compute_node::enable_scheduling::Error),
    #[error(transparent)]
    ComputeNode_GetRemoteLoginSettings(#[from] compute_node::get_remote_login_settings::Error),
    #[error(transparent)]
    ComputeNode_GetRemoteDesktop(#[from] compute_node::get_remote_desktop::Error),
    #[error(transparent)]
    ComputeNode_UploadBatchServiceLogs(#[from] compute_node::upload_batch_service_logs::Error),
    #[error(transparent)]
    ComputeNode_List(#[from] compute_node::list::Error),
}
pub mod application {
    use super::{models, API_VERSION};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::ApplicationListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/applications", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ApplicationListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        application_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::ApplicationSummary, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/applications/{}", operation_config.base_path(), application_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ApplicationSummary =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod pool {
    use super::{models, API_VERSION};
    pub async fn list_usage_metrics(
        operation_config: &crate::OperationConfig,
        starttime: Option<&str>,
        endtime: Option<&str>,
        filter: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::PoolListUsageMetricsResult, list_usage_metrics::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/poolusagemetrics", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list_usage_metrics::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_usage_metrics::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(starttime) = starttime {
            url.query_pairs_mut().append_pair("starttime", starttime);
        }
        if let Some(endtime) = endtime {
            url.query_pairs_mut().append_pair("endtime", endtime);
        }
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_usage_metrics::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_usage_metrics::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PoolListUsageMetricsResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_usage_metrics::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_usage_metrics::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_usage_metrics::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_usage_metrics {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_all_lifetime_statistics(
        operation_config: &crate::OperationConfig,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::PoolStatistics, get_all_lifetime_statistics::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/lifetimepoolstats", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_all_lifetime_statistics::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_all_lifetime_statistics::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_all_lifetime_statistics::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_all_lifetime_statistics::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PoolStatistics = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_all_lifetime_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_all_lifetime_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_all_lifetime_statistics::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_all_lifetime_statistics {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::CloudPoolListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudPoolListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        pool: &models::PoolAddParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool).map_err(add::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        select: Option<&str>,
        expand: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<models::CloudPool, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudPool =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn patch(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_patch_parameter: &models::PoolPatchParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), patch::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(patch::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(patch::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_patch_parameter).map_err(patch::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(patch::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(patch::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| patch::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(patch::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod patch {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn exists(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), exists::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(exists::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(exists::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(exists::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(exists::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            http::StatusCode::NOT_FOUND => Err(exists::Error::NotFound404 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| exists::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(exists::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod exists {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotFound404 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn disable_auto_scale(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), disable_auto_scale::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/disableautoscale", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(disable_auto_scale::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(disable_auto_scale::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(disable_auto_scale::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(disable_auto_scale::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| disable_auto_scale::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(disable_auto_scale::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod disable_auto_scale {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn enable_auto_scale(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_enable_auto_scale_parameter: &models::PoolEnableAutoScaleParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), enable_auto_scale::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/enableautoscale", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(enable_auto_scale::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(enable_auto_scale::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_enable_auto_scale_parameter).map_err(enable_auto_scale::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(enable_auto_scale::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(enable_auto_scale::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| enable_auto_scale::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(enable_auto_scale::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod enable_auto_scale {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn evaluate_auto_scale(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_evaluate_auto_scale_parameter: &models::PoolEvaluateAutoScaleParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::AutoScaleRun, evaluate_auto_scale::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/evaluateautoscale", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(evaluate_auto_scale::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(evaluate_auto_scale::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_evaluate_auto_scale_parameter).map_err(evaluate_auto_scale::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(evaluate_auto_scale::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(evaluate_auto_scale::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::AutoScaleRun = serde_json::from_slice(rsp_body)
                    .map_err(|source| evaluate_auto_scale::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| evaluate_auto_scale::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(evaluate_auto_scale::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod evaluate_auto_scale {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn resize(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_resize_parameter: &models::PoolResizeParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), resize::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/resize", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(resize::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(resize::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_resize_parameter).map_err(resize::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(resize::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(resize::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| resize::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(resize::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod resize {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn stop_resize(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), stop_resize::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/stopresize", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(stop_resize::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(stop_resize::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(stop_resize::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(stop_resize::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| stop_resize::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(stop_resize::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod stop_resize {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update_properties(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_update_properties_parameter: &models::PoolUpdatePropertiesParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), update_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/updateproperties", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(update_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_update_properties_parameter).map_err(update_properties::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(update_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| update_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update_properties {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upgrade_os(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_upgrade_os_parameter: &models::PoolUpgradeOsParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), upgrade_os::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/upgradeos", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(upgrade_os::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upgrade_os::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_upgrade_os_parameter).map_err(upgrade_os::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(upgrade_os::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(upgrade_os::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| upgrade_os::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upgrade_os::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upgrade_os {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn remove_nodes(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_remove_parameter: &models::NodeRemoveParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), remove_nodes::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/removenodes", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(remove_nodes::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(remove_nodes::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(node_remove_parameter).map_err(remove_nodes::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(remove_nodes::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(remove_nodes::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| remove_nodes::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(remove_nodes::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod remove_nodes {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod account {
    use super::{models, API_VERSION};
    pub async fn list_node_agent_skus(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::AccountListNodeAgentSkusResult, list_node_agent_skus::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/nodeagentskus", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list_node_agent_skus::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_node_agent_skus::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_node_agent_skus::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_node_agent_skus::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::AccountListNodeAgentSkusResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_node_agent_skus::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_node_agent_skus::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_node_agent_skus::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_node_agent_skus {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_pool_node_counts(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::PoolNodeCountsListResult, list_pool_node_counts::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/nodecounts", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list_pool_node_counts::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_pool_node_counts::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_pool_node_counts::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_pool_node_counts::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PoolNodeCountsListResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_pool_node_counts::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_pool_node_counts::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_pool_node_counts::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_pool_node_counts {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod job {
    use super::{models, API_VERSION};
    pub async fn get_all_lifetime_statistics(
        operation_config: &crate::OperationConfig,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::JobStatistics, get_all_lifetime_statistics::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/lifetimejobstats", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_all_lifetime_statistics::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_all_lifetime_statistics::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_all_lifetime_statistics::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_all_lifetime_statistics::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::JobStatistics = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_all_lifetime_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_all_lifetime_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_all_lifetime_statistics::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_all_lifetime_statistics {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        select: Option<&str>,
        expand: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<models::CloudJob, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudJob =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        job_update_parameter: &models::JobUpdateParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_update_parameter).map_err(update::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn patch(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        job_patch_parameter: &models::JobPatchParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), patch::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(patch::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(patch::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_patch_parameter).map_err(patch::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(patch::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(patch::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| patch::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(patch::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod patch {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn disable(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        job_disable_parameter: &models::JobDisableParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), disable::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/disable", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(disable::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(disable::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_disable_parameter).map_err(disable::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(disable::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(disable::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| disable::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(disable::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod disable {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn enable(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), enable::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/enable", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(enable::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(enable::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(enable::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(enable::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| enable::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(enable::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod enable {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn terminate(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        job_terminate_parameter: Option<&models::JobTerminateParameter>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), terminate::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/terminate", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(terminate::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(terminate::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = if let Some(job_terminate_parameter) = job_terminate_parameter {
            req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
            azure_core::to_json(job_terminate_parameter).map_err(terminate::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(terminate::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(terminate::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| terminate::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(terminate::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod terminate {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::CloudJobListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudJobListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        job: &models::JobAddParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job).map_err(add::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_from_job_schedule(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::CloudJobListResult, list_from_job_schedule::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}/jobs", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(list_from_job_schedule::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_from_job_schedule::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_from_job_schedule::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_from_job_schedule::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudJobListResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_from_job_schedule::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_from_job_schedule::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_from_job_schedule::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_from_job_schedule {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_preparation_and_release_task_status(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        filter: Option<&str>,
        select: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::CloudJobListPreparationAndReleaseTaskStatusResult, list_preparation_and_release_task_status::Error>
    {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/jobs/{}/jobpreparationandreleasetaskstatus",
            operation_config.base_path(),
            job_id
        );
        let mut url = url::Url::parse(url_str).map_err(list_preparation_and_release_task_status::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_preparation_and_release_task_status::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_preparation_and_release_task_status::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_preparation_and_release_task_status::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudJobListPreparationAndReleaseTaskStatusResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_preparation_and_release_task_status::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_preparation_and_release_task_status::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_preparation_and_release_task_status::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_preparation_and_release_task_status {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_task_counts(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::TaskCounts, get_task_counts::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/taskcounts", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(get_task_counts::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_task_counts::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_task_counts::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_task_counts::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TaskCounts = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_task_counts::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_task_counts::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_task_counts::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_task_counts {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod certificate {
    use super::{models, API_VERSION};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        select: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::CertificateListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/certificates", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CertificateListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        certificate: &models::CertificateAddParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/certificates", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(certificate).map_err(add::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn cancel_deletion(
        operation_config: &crate::OperationConfig,
        thumbprint_algorithm: &str,
        thumbprint: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), cancel_deletion::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/certificates(thumbprintAlgorithm={},thumbprint={})/canceldelete",
            operation_config.base_path(),
            thumbprint_algorithm,
            thumbprint
        );
        let mut url = url::Url::parse(url_str).map_err(cancel_deletion::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(cancel_deletion::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(cancel_deletion::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(cancel_deletion::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| cancel_deletion::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(cancel_deletion::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod cancel_deletion {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        thumbprint_algorithm: &str,
        thumbprint: &str,
        select: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::Certificate, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/certificates(thumbprintAlgorithm={},thumbprint={})",
            operation_config.base_path(),
            thumbprint_algorithm,
            thumbprint
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::Certificate =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        thumbprint_algorithm: &str,
        thumbprint: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/certificates(thumbprintAlgorithm={},thumbprint={})",
            operation_config.base_path(),
            thumbprint_algorithm,
            thumbprint
        );
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod file {
    use super::{models, API_VERSION};
    pub async fn get_from_task(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        file_path: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        ocp_range: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<bytes::Bytes, get_from_task::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/jobs/{}/tasks/{}/files/{}",
            operation_config.base_path(),
            job_id,
            task_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(get_from_task::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_from_task::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(ocp_range) = ocp_range {
            req_builder = req_builder.header("ocp-range", ocp_range);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_from_task::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_from_task::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value = rsp_body.clone();
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_from_task::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_from_task {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_from_task(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        file_path: &str,
        recursive: Option<bool>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), delete_from_task::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/jobs/{}/tasks/{}/files/{}",
            operation_config.base_path(),
            job_id,
            task_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(delete_from_task::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_from_task::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_from_task::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_from_task::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_from_task::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_from_task {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_properties_from_task(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        file_path: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), get_properties_from_task::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/jobs/{}/tasks/{}/files/{}",
            operation_config.base_path(),
            job_id,
            task_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(get_properties_from_task::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties_from_task::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_properties_from_task::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties_from_task::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_properties_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties_from_task::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties_from_task {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_from_compute_node(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        file_path: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        ocp_range: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<bytes::Bytes, get_from_compute_node::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/files/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(get_from_compute_node::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_from_compute_node::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(ocp_range) = ocp_range {
            req_builder = req_builder.header("ocp-range", ocp_range);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_from_compute_node::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_from_compute_node::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value = rsp_body.clone();
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_from_compute_node::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_from_compute_node {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_from_compute_node(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        file_path: &str,
        recursive: Option<bool>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), delete_from_compute_node::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/files/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(delete_from_compute_node::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_from_compute_node::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(delete_from_compute_node::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_from_compute_node::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_from_compute_node::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_from_compute_node {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_properties_from_compute_node(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        file_path: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), get_properties_from_compute_node::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/files/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(get_properties_from_compute_node::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties_from_compute_node::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_properties_from_compute_node::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties_from_compute_node::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_properties_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties_from_compute_node::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties_from_compute_node {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_from_task(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        filter: Option<&str>,
        recursive: Option<bool>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::NodeFileListResult, list_from_task::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}/files", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(list_from_task::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_from_task::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_from_task::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_from_task::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::NodeFileListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_from_task::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_from_task {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_from_compute_node(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        filter: Option<&str>,
        recursive: Option<bool>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::NodeFileListResult, list_from_compute_node::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/files", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(list_from_compute_node::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_from_compute_node::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_from_compute_node::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_from_compute_node::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::NodeFileListResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_from_compute_node::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_from_compute_node {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod job_schedule {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        select: Option<&str>,
        expand: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<models::CloudJobSchedule, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudJobSchedule =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        job_schedule_update_parameter: &models::JobScheduleUpdateParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_schedule_update_parameter).map_err(update::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn patch(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        job_schedule_patch_parameter: &models::JobSchedulePatchParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), patch::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(patch::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(patch::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_schedule_patch_parameter).map_err(patch::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(patch::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(patch::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| patch::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(patch::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod patch {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn exists(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), exists::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(exists::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(exists::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(exists::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(exists::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            http::StatusCode::NOT_FOUND => Err(exists::Error::NotFound404 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| exists::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(exists::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod exists {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotFound404 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn disable(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), disable::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}/disable", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(disable::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(disable::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(disable::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(disable::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| disable::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(disable::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod disable {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn enable(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), enable::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}/enable", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(enable::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(enable::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(enable::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(enable::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| enable::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(enable::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod enable {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn terminate(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), terminate::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}/terminate", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(terminate::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(terminate::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(terminate::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(terminate::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| terminate::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(terminate::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod terminate {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::CloudJobScheduleListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudJobScheduleListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        timeout: Option<i32>,
        cloud_job_schedule: &models::JobScheduleAddParameter,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(cloud_job_schedule).map_err(add::Error::SerializeError)?;
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod task {
    use super::{models, API_VERSION};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::CloudTaskListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudTaskListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task: &models::TaskAddParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(task).map_err(add::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add_collection(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_collection: &models::TaskAddCollectionParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::TaskAddCollectionResult, add_collection::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/addtaskcollection", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(add_collection::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add_collection::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(task_collection).map_err(add_collection::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add_collection::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(add_collection::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TaskAddCollectionResult =
                    serde_json::from_slice(rsp_body).map_err(|source| add_collection::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add_collection::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add_collection::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add_collection {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        select: Option<&str>,
        expand: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<models::CloudTask, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudTask =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        task_update_parameter: &models::TaskUpdateParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(task_update_parameter).map_err(update::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_subtasks(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        select: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::CloudTaskListSubtasksResult, list_subtasks::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}/subtasksinfo", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(list_subtasks::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_subtasks::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_subtasks::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_subtasks::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudTaskListSubtasksResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list_subtasks::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list_subtasks::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_subtasks::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_subtasks {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn terminate(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), terminate::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}/terminate", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(terminate::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(terminate::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(terminate::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(terminate::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| terminate::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(terminate::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod terminate {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn reactivate(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), reactivate::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}/reactivate", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(reactivate::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(reactivate::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(reactivate::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(reactivate::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| reactivate::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(reactivate::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod reactivate {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod compute_node {
    use super::{models, API_VERSION};
    pub async fn add_user(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        user: &models::ComputeNodeUser,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add_user::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/users", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(add_user::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add_user::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(user).map_err(add_user::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add_user::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(add_user::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add_user::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add_user::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add_user {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update_user(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        user_name: &str,
        node_update_user_parameter: &models::NodeUpdateUserParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), update_user::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/users/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            user_name
        );
        let mut url = url::Url::parse(url_str).map_err(update_user::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update_user::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(node_update_user_parameter).map_err(update_user::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update_user::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(update_user::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| update_user::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update_user::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update_user {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_user(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        user_name: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), delete_user::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/users/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            user_name
        );
        let mut url = url::Url::parse(url_str).map_err(delete_user::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_user::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_user::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_user::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete_user::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_user::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_user {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        select: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::ComputeNode, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ComputeNode =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn reboot(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        node_reboot_parameter: Option<&models::NodeRebootParameter>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), reboot::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/reboot", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(reboot::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(reboot::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = if let Some(node_reboot_parameter) = node_reboot_parameter {
            req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
            azure_core::to_json(node_reboot_parameter).map_err(reboot::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(reboot::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(reboot::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| reboot::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(reboot::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod reboot {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn reimage(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        node_reimage_parameter: Option<&models::NodeReimageParameter>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), reimage::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/reimage", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(reimage::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(reimage::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = if let Some(node_reimage_parameter) = node_reimage_parameter {
            req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
            azure_core::to_json(node_reimage_parameter).map_err(reimage::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(reimage::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(reimage::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| reimage::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(reimage::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod reimage {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn disable_scheduling(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        node_disable_scheduling_parameter: Option<&models::NodeDisableSchedulingParameter>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), disable_scheduling::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/disablescheduling",
            operation_config.base_path(),
            pool_id,
            node_id
        );
        let mut url = url::Url::parse(url_str).map_err(disable_scheduling::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(disable_scheduling::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = if let Some(node_disable_scheduling_parameter) = node_disable_scheduling_parameter {
            req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
            azure_core::to_json(node_disable_scheduling_parameter).map_err(disable_scheduling::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(disable_scheduling::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(disable_scheduling::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| disable_scheduling::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(disable_scheduling::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod disable_scheduling {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn enable_scheduling(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), enable_scheduling::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/enablescheduling",
            operation_config.base_path(),
            pool_id,
            node_id
        );
        let mut url = url::Url::parse(url_str).map_err(enable_scheduling::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(enable_scheduling::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(enable_scheduling::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(enable_scheduling::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| enable_scheduling::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(enable_scheduling::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod enable_scheduling {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_remote_login_settings(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::ComputeNodeGetRemoteLoginSettingsResult, get_remote_login_settings::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/remoteloginsettings",
            operation_config.base_path(),
            pool_id,
            node_id
        );
        let mut url = url::Url::parse(url_str).map_err(get_remote_login_settings::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_remote_login_settings::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_remote_login_settings::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_remote_login_settings::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ComputeNodeGetRemoteLoginSettingsResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_remote_login_settings::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_remote_login_settings::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_remote_login_settings::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_remote_login_settings {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_remote_desktop(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<bytes::Bytes, get_remote_desktop::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/rdp", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(get_remote_desktop::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_remote_desktop::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_remote_desktop::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_remote_desktop::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value = rsp_body.clone();
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_remote_desktop::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_remote_desktop::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_remote_desktop {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upload_batch_service_logs(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        upload_batch_service_logs_configuration: &models::UploadBatchServiceLogsConfiguration,
    ) -> std::result::Result<models::UploadBatchServiceLogsResult, upload_batch_service_logs::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/uploadbatchservicelogs",
            operation_config.base_path(),
            pool_id,
            node_id
        );
        let mut url = url::Url::parse(url_str).map_err(upload_batch_service_logs::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upload_batch_service_logs::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body =
            azure_core::to_json(upload_batch_service_logs_configuration).map_err(upload_batch_service_logs::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(upload_batch_service_logs::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(upload_batch_service_logs::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::UploadBatchServiceLogsResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| upload_batch_service_logs::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| upload_batch_service_logs::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upload_batch_service_logs::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upload_batch_service_logs {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        filter: Option<&str>,
        select: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<models::ComputeNodeListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ComputeNodeListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
