#![doc = "generated by AutoRust"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::redundant_clone)]
use super::models;
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
}
pub const DEFAULT_ENDPOINT: &str = azure_core::resource_manager_endpoint::AZURE_PUBLIC_CLOUD;
impl ClientBuilder {
    pub fn new(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
        }
    }
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self.scopes.unwrap_or_else(|| vec![format!("{}/", endpoint)]);
        Client::new(endpoint, self.credential, scopes)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn token_credential(&self) -> &dyn azure_core::auth::TokenCredential {
        self.credential.as_ref()
    }
    pub(crate) fn scopes(&self) -> Vec<&str> {
        self.scopes.iter().map(String::as_str).collect()
    }
    pub(crate) async fn send(&self, request: &mut azure_core::Request) -> azure_core::Result<azure_core::Response> {
        let mut context = azure_core::Context::default();
        self.pipeline.send(&mut context, request).await
    }
    pub fn new(
        endpoint: impl Into<String>,
        credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
        scopes: Vec<String>,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            azure_core::ClientOptions::default(),
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn account(&self) -> account::Client {
        account::Client(self.clone())
    }
    pub fn application(&self) -> application::Client {
        application::Client(self.clone())
    }
    pub fn certificate(&self) -> certificate::Client {
        certificate::Client(self.clone())
    }
    pub fn compute_node(&self) -> compute_node::Client {
        compute_node::Client(self.clone())
    }
    pub fn file(&self) -> file::Client {
        file::Client(self.clone())
    }
    pub fn job(&self) -> job::Client {
        job::Client(self.clone())
    }
    pub fn job_schedule(&self) -> job_schedule::Client {
        job_schedule::Client(self.clone())
    }
    pub fn pool(&self) -> pool::Client {
        pool::Client(self.clone())
    }
    pub fn task(&self) -> task::Client {
        task::Client(self.clone())
    }
}
pub mod application {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Lists all of the applications available in the specified Account."]
        pub fn list(&self) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Gets information about the specified Application."]
        pub fn get(&self, application_id: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                application_id: application_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::ApplicationListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/applications", this.client.endpoint(),))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ApplicationListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::ApplicationSummary;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/applications/{}", this.client.endpoint(), &this.application_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ApplicationSummary = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod pool {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified Account."]
        pub fn list_usage_metrics(&self) -> list_usage_metrics::Builder {
            list_usage_metrics::Builder {
                client: self.0.clone(),
                starttime: None,
                endtime: None,
                filter: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Gets lifetime summary statistics for all of the Pools in the specified Account."]
        pub fn get_all_lifetime_statistics(&self) -> get_all_lifetime_statistics::Builder {
            get_all_lifetime_statistics::Builder {
                client: self.0.clone(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Lists all of the Pools in the specified Account."]
        pub fn list(&self) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                filter: None,
                select: None,
                expand: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Adds a Pool to the specified Account."]
        pub fn add(&self, pool: impl Into<models::PoolAddParameter>) -> add::Builder {
            add::Builder {
                client: self.0.clone(),
                pool: pool.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        pub fn get(&self, pool_id: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                select: None,
                expand: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Updates the properties of the specified Pool."]
        pub fn patch(&self, pool_id: impl Into<String>, pool_patch_parameter: impl Into<models::PoolPatchParameter>) -> patch::Builder {
            patch::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                pool_patch_parameter: pool_patch_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Deletes a Pool from the specified Account."]
        pub fn delete(&self, pool_id: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        pub fn exists(&self, pool_id: impl Into<String>) -> exists::Builder {
            exists::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Disables automatic scaling for a Pool."]
        pub fn disable_auto_scale(&self, pool_id: impl Into<String>) -> disable_auto_scale::Builder {
            disable_auto_scale::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Enables automatic scaling for a Pool."]
        pub fn enable_auto_scale(
            &self,
            pool_id: impl Into<String>,
            pool_enable_auto_scale_parameter: impl Into<models::PoolEnableAutoScaleParameter>,
        ) -> enable_auto_scale::Builder {
            enable_auto_scale::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                pool_enable_auto_scale_parameter: pool_enable_auto_scale_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Gets the result of evaluating an automatic scaling formula on the Pool."]
        pub fn evaluate_auto_scale(
            &self,
            pool_id: impl Into<String>,
            pool_evaluate_auto_scale_parameter: impl Into<models::PoolEvaluateAutoScaleParameter>,
        ) -> evaluate_auto_scale::Builder {
            evaluate_auto_scale::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                pool_evaluate_auto_scale_parameter: pool_evaluate_auto_scale_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Changes the number of Compute Nodes that are assigned to a Pool."]
        pub fn resize(&self, pool_id: impl Into<String>, pool_resize_parameter: impl Into<models::PoolResizeParameter>) -> resize::Builder {
            resize::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                pool_resize_parameter: pool_resize_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Stops an ongoing resize operation on the Pool."]
        pub fn stop_resize(&self, pool_id: impl Into<String>) -> stop_resize::Builder {
            stop_resize::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Updates the properties of the specified Pool."]
        pub fn update_properties(
            &self,
            pool_id: impl Into<String>,
            pool_update_properties_parameter: impl Into<models::PoolUpdatePropertiesParameter>,
        ) -> update_properties::Builder {
            update_properties::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                pool_update_properties_parameter: pool_update_properties_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Removes Compute Nodes from the specified Pool."]
        pub fn remove_nodes(
            &self,
            pool_id: impl Into<String>,
            node_remove_parameter: impl Into<models::NodeRemoveParameter>,
        ) -> remove_nodes::Builder {
            remove_nodes::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_remove_parameter: node_remove_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
    }
    pub mod list_usage_metrics {
        use super::models;
        type Response = models::PoolListUsageMetricsResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) starttime: Option<String>,
            pub(crate) endtime: Option<String>,
            pub(crate) filter: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn starttime(mut self, starttime: impl Into<String>) -> Self {
                self.starttime = Some(starttime.into());
                self
            }
            pub fn endtime(mut self, endtime: impl Into<String>) -> Self {
                self.endtime = Some(endtime.into());
                self
            }
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/poolusagemetrics", this.client.endpoint(),))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(starttime) = &this.starttime {
                                    req.url_mut().query_pairs_mut().append_pair("starttime", starttime);
                                }
                                if let Some(endtime) = &this.endtime {
                                    req.url_mut().query_pairs_mut().append_pair("endtime", endtime);
                                }
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::PoolListUsageMetricsResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod get_all_lifetime_statistics {
        use super::models;
        type Response = models::PoolStatistics;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/lifetimepoolstats", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::PoolStatistics = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::CloudPoolListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) filter: Option<String>,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/pools", this.client.endpoint(),))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(select) = &this.select {
                                    req.url_mut().query_pairs_mut().append_pair("$select", select);
                                }
                                if let Some(expand) = &this.expand {
                                    req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudPoolListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod add {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool: models::PoolAddParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.pool)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::CREATED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::CloudPool;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(select) = &this.select {
                            req.url_mut().query_pairs_mut().append_pair("$select", select);
                        }
                        if let Some(expand) = &this.expand {
                            req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudPool = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod patch {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) pool_patch_parameter: models::PoolPatchParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::PATCH);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.pool_patch_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::DELETE);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod exists {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::HEAD);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod disable_auto_scale {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}/disableautoscale", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod enable_auto_scale {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) pool_enable_auto_scale_parameter: models::PoolEnableAutoScaleParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}/enableautoscale", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.pool_enable_auto_scale_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod evaluate_auto_scale {
        use super::models;
        type Response = models::AutoScaleRun;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) pool_evaluate_auto_scale_parameter: models::PoolEvaluateAutoScaleParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}/evaluateautoscale", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.pool_evaluate_auto_scale_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AutoScaleRun = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod resize {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) pool_resize_parameter: models::PoolResizeParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}/resize", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.pool_resize_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod stop_resize {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}/stopresize", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update_properties {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) pool_update_properties_parameter: models::PoolUpdatePropertiesParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}/updateproperties", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.pool_update_properties_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::NO_CONTENT => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod remove_nodes {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_remove_parameter: models::NodeRemoveParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/pools/{}/removenodes", this.client.endpoint(), &this.pool_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.node_remove_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod account {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Lists all Virtual Machine Images supported by the Azure Batch service."]
        pub fn list_supported_images(&self) -> list_supported_images::Builder {
            list_supported_images::Builder {
                client: self.0.clone(),
                filter: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        pub fn list_pool_node_counts(&self) -> list_pool_node_counts::Builder {
            list_pool_node_counts::Builder {
                client: self.0.clone(),
                filter: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
    }
    pub mod list_supported_images {
        use super::models;
        type Response = models::AccountListSupportedImagesResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) filter: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/supportedimages", this.client.endpoint(),))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AccountListSupportedImagesResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod list_pool_node_counts {
        use super::models;
        type Response = models::PoolNodeCountsListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) filter: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/nodecounts", this.client.endpoint(),))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::PoolNodeCountsListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
}
pub mod job {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets lifetime summary statistics for all of the Jobs in the specified Account."]
        pub fn get_all_lifetime_statistics(&self) -> get_all_lifetime_statistics::Builder {
            get_all_lifetime_statistics::Builder {
                client: self.0.clone(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Gets information about the specified Job."]
        pub fn get(&self, job_id: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                select: None,
                expand: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Updates the properties of the specified Job."]
        pub fn update(&self, job_id: impl Into<String>, job_update_parameter: impl Into<models::JobUpdateParameter>) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job_update_parameter: job_update_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Updates the properties of the specified Job."]
        pub fn patch(&self, job_id: impl Into<String>, job_patch_parameter: impl Into<models::JobPatchParameter>) -> patch::Builder {
            patch::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job_patch_parameter: job_patch_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Deletes a Job."]
        pub fn delete(&self, job_id: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Disables the specified Job, preventing new Tasks from running."]
        pub fn disable(
            &self,
            job_id: impl Into<String>,
            job_disable_parameter: impl Into<models::JobDisableParameter>,
        ) -> disable::Builder {
            disable::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job_disable_parameter: job_disable_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Enables the specified Job, allowing new Tasks to run."]
        pub fn enable(&self, job_id: impl Into<String>) -> enable::Builder {
            enable::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Terminates the specified Job, marking it as completed."]
        pub fn terminate(&self, job_id: impl Into<String>) -> terminate::Builder {
            terminate::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job_terminate_parameter: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Lists all of the Jobs in the specified Account."]
        pub fn list(&self) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                filter: None,
                select: None,
                expand: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Adds a Job to the specified Account."]
        pub fn add(&self, job: impl Into<models::JobAddParameter>) -> add::Builder {
            add::Builder {
                client: self.0.clone(),
                job: job.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Lists the Jobs that have been created under the specified Job Schedule."]
        pub fn list_from_job_schedule(&self, job_schedule_id: impl Into<String>) -> list_from_job_schedule::Builder {
            list_from_job_schedule::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                filter: None,
                select: None,
                expand: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute Nodes where the Job has run."]
        pub fn list_preparation_and_release_task_status(
            &self,
            job_id: impl Into<String>,
        ) -> list_preparation_and_release_task_status::Builder {
            list_preparation_and_release_task_status::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                filter: None,
                select: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Gets the Task counts for the specified Job."]
        pub fn get_task_counts(&self, job_id: impl Into<String>) -> get_task_counts::Builder {
            get_task_counts::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
    }
    pub mod get_all_lifetime_statistics {
        use super::models;
        type Response = models::JobStatistics;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/lifetimejobstats", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::JobStatistics = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::CloudJob;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(select) = &this.select {
                            req.url_mut().query_pairs_mut().append_pair("$select", select);
                        }
                        if let Some(expand) = &this.expand {
                            req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudJob = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job_update_parameter: models::JobUpdateParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::PUT);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.job_update_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod patch {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job_patch_parameter: models::JobPatchParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::PATCH);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.job_patch_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::DELETE);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod disable {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job_disable_parameter: models::JobDisableParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}/disable", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.job_disable_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod enable {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}/enable", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod terminate {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job_terminate_parameter: Option<models::JobTerminateParameter>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn job_terminate_parameter(mut self, job_terminate_parameter: impl Into<models::JobTerminateParameter>) -> Self {
                self.job_terminate_parameter = Some(job_terminate_parameter.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}/terminate", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        let req_body = if let Some(job_terminate_parameter) = &this.job_terminate_parameter {
                            req.insert_header("content-type", "application/json; odata=minimalmetadata");
                            azure_core::to_json(job_terminate_parameter)?
                        } else {
                            azure_core::EMPTY_BODY
                        };
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::CloudJobListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) filter: Option<String>,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/jobs", this.client.endpoint(),))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(select) = &this.select {
                                    req.url_mut().query_pairs_mut().append_pair("$select", select);
                                }
                                if let Some(expand) = &this.expand {
                                    req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudJobListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod add {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job: models::JobAddParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.job)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::CREATED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_from_job_schedule {
        use super::models;
        type Response = models::CloudJobListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) filter: Option<String>,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url =
                            azure_core::Url::parse(&format!("{}/jobschedules/{}/jobs", this.client.endpoint(), &this.job_schedule_id))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(select) = &this.select {
                                    req.url_mut().query_pairs_mut().append_pair("$select", select);
                                }
                                if let Some(expand) = &this.expand {
                                    req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudJobListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod list_preparation_and_release_task_status {
        use super::models;
        type Response = models::CloudJobListPreparationAndReleaseTaskStatusResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) filter: Option<String>,
            pub(crate) select: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!(
                            "{}/jobs/{}/jobpreparationandreleasetaskstatus",
                            this.client.endpoint(),
                            &this.job_id
                        ))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(select) = &this.select {
                                    req.url_mut().query_pairs_mut().append_pair("$select", select);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudJobListPreparationAndReleaseTaskStatusResult =
                                    serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod get_task_counts {
        use super::models;
        type Response = models::TaskCountsResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}/taskcounts", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::TaskCountsResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod certificate {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Lists all of the Certificates that have been added to the specified Account."]
        pub fn list(&self) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                filter: None,
                select: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Adds a Certificate to the specified Account."]
        pub fn add(&self, certificate: impl Into<models::CertificateAddParameter>) -> add::Builder {
            add::Builder {
                client: self.0.clone(),
                certificate: certificate.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Cancels a failed deletion of a Certificate from the specified Account."]
        pub fn cancel_deletion(&self, thumbprint_algorithm: impl Into<String>, thumbprint: impl Into<String>) -> cancel_deletion::Builder {
            cancel_deletion::Builder {
                client: self.0.clone(),
                thumbprint_algorithm: thumbprint_algorithm.into(),
                thumbprint: thumbprint.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        pub fn get(&self, thumbprint_algorithm: impl Into<String>, thumbprint: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                thumbprint_algorithm: thumbprint_algorithm.into(),
                thumbprint: thumbprint.into(),
                select: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Deletes a Certificate from the specified Account."]
        pub fn delete(&self, thumbprint_algorithm: impl Into<String>, thumbprint: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                thumbprint_algorithm: thumbprint_algorithm.into(),
                thumbprint: thumbprint.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::CertificateListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) filter: Option<String>,
            pub(crate) select: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/certificates", this.client.endpoint(),))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(select) = &this.select {
                                    req.url_mut().query_pairs_mut().append_pair("$select", select);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CertificateListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod add {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) certificate: models::CertificateAddParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/certificates", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.certificate)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::CREATED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod cancel_deletion {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) thumbprint_algorithm: String,
            pub(crate) thumbprint: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/certificates(thumbprintAlgorithm={},thumbprint={})/canceldelete",
                            this.client.endpoint(),
                            &this.thumbprint_algorithm,
                            &this.thumbprint
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::NO_CONTENT => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::Certificate;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) thumbprint_algorithm: String,
            pub(crate) thumbprint: String,
            pub(crate) select: Option<String>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/certificates(thumbprintAlgorithm={},thumbprint={})",
                            this.client.endpoint(),
                            &this.thumbprint_algorithm,
                            &this.thumbprint
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(select) = &this.select {
                            req.url_mut().query_pairs_mut().append_pair("$select", select);
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::Certificate = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) thumbprint_algorithm: String,
            pub(crate) thumbprint: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/certificates(thumbprintAlgorithm={},thumbprint={})",
                            this.client.endpoint(),
                            &this.thumbprint_algorithm,
                            &this.thumbprint
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::DELETE);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod file {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_from_task(
            &self,
            job_id: impl Into<String>,
            task_id: impl Into<String>,
            file_path: impl Into<String>,
        ) -> get_from_task::Builder {
            get_from_task::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                file_path: file_path.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                ocp_range: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Deletes the specified Task file from the Compute Node where the Task ran."]
        pub fn delete_from_task(
            &self,
            job_id: impl Into<String>,
            task_id: impl Into<String>,
            file_path: impl Into<String>,
        ) -> delete_from_task::Builder {
            delete_from_task::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                file_path: file_path.into(),
                recursive: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        pub fn get_properties_from_task(
            &self,
            job_id: impl Into<String>,
            task_id: impl Into<String>,
            file_path: impl Into<String>,
        ) -> get_properties_from_task::Builder {
            get_properties_from_task::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                file_path: file_path.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        pub fn get_from_compute_node(
            &self,
            pool_id: impl Into<String>,
            node_id: impl Into<String>,
            file_path: impl Into<String>,
        ) -> get_from_compute_node::Builder {
            get_from_compute_node::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                file_path: file_path.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                ocp_range: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Deletes the specified file from the Compute Node."]
        pub fn delete_from_compute_node(
            &self,
            pool_id: impl Into<String>,
            node_id: impl Into<String>,
            file_path: impl Into<String>,
        ) -> delete_from_compute_node::Builder {
            delete_from_compute_node::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                file_path: file_path.into(),
                recursive: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        pub fn get_properties_from_compute_node(
            &self,
            pool_id: impl Into<String>,
            node_id: impl Into<String>,
            file_path: impl Into<String>,
        ) -> get_properties_from_compute_node::Builder {
            get_properties_from_compute_node::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                file_path: file_path.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Lists the files in a Task's directory on its Compute Node."]
        pub fn list_from_task(&self, job_id: impl Into<String>, task_id: impl Into<String>) -> list_from_task::Builder {
            list_from_task::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                filter: None,
                recursive: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Lists all of the files in Task directories on the specified Compute Node."]
        pub fn list_from_compute_node(&self, pool_id: impl Into<String>, node_id: impl Into<String>) -> list_from_compute_node::Builder {
            list_from_compute_node::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                filter: None,
                recursive: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
    }
    pub mod get_from_task {
        use super::models;
        type Response = serde_json::Value;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) file_path: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) ocp_range: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn ocp_range(mut self, ocp_range: impl Into<String>) -> Self {
                self.ocp_range = Some(ocp_range.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/jobs/{}/tasks/{}/files/{}",
                            this.client.endpoint(),
                            &this.job_id,
                            &this.task_id,
                            &this.file_path
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(ocp_range) = &this.ocp_range {
                            req.insert_header("ocp-range", ocp_range);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: serde_json::Value = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_from_task {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) file_path: String,
            pub(crate) recursive: Option<bool>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn recursive(mut self, recursive: bool) -> Self {
                self.recursive = Some(recursive);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/jobs/{}/tasks/{}/files/{}",
                            this.client.endpoint(),
                            &this.job_id,
                            &this.task_id,
                            &this.file_path
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::DELETE);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(recursive) = &this.recursive {
                            req.url_mut().query_pairs_mut().append_pair("recursive", &recursive.to_string());
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_properties_from_task {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) file_path: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/jobs/{}/tasks/{}/files/{}",
                            this.client.endpoint(),
                            &this.job_id,
                            &this.task_id,
                            &this.file_path
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::HEAD);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_from_compute_node {
        use super::models;
        type Response = serde_json::Value;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) file_path: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) ocp_range: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn ocp_range(mut self, ocp_range: impl Into<String>) -> Self {
                self.ocp_range = Some(ocp_range.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/files/{}",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id,
                            &this.file_path
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(ocp_range) = &this.ocp_range {
                            req.insert_header("ocp-range", ocp_range);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: serde_json::Value = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_from_compute_node {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) file_path: String,
            pub(crate) recursive: Option<bool>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn recursive(mut self, recursive: bool) -> Self {
                self.recursive = Some(recursive);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/files/{}",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id,
                            &this.file_path
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::DELETE);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(recursive) = &this.recursive {
                            req.url_mut().query_pairs_mut().append_pair("recursive", &recursive.to_string());
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_properties_from_compute_node {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) file_path: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/files/{}",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id,
                            &this.file_path
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::HEAD);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_from_task {
        use super::models;
        type Response = models::NodeFileListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) filter: Option<String>,
            pub(crate) recursive: Option<bool>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn recursive(mut self, recursive: bool) -> Self {
                self.recursive = Some(recursive);
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!(
                            "{}/jobs/{}/tasks/{}/files",
                            this.client.endpoint(),
                            &this.job_id,
                            &this.task_id
                        ))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(recursive) = &this.recursive {
                                    req.url_mut().query_pairs_mut().append_pair("recursive", &recursive.to_string());
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::NodeFileListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod list_from_compute_node {
        use super::models;
        type Response = models::NodeFileListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) filter: Option<String>,
            pub(crate) recursive: Option<bool>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn recursive(mut self, recursive: bool) -> Self {
                self.recursive = Some(recursive);
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/files",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(recursive) = &this.recursive {
                                    req.url_mut().query_pairs_mut().append_pair("recursive", &recursive.to_string());
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::NodeFileListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
}
pub mod job_schedule {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get(&self, job_schedule_id: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                select: None,
                expand: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Updates the properties of the specified Job Schedule."]
        pub fn update(
            &self,
            job_schedule_id: impl Into<String>,
            job_schedule_update_parameter: impl Into<models::JobScheduleUpdateParameter>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                job_schedule_update_parameter: job_schedule_update_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Updates the properties of the specified Job Schedule."]
        pub fn patch(
            &self,
            job_schedule_id: impl Into<String>,
            job_schedule_patch_parameter: impl Into<models::JobSchedulePatchParameter>,
        ) -> patch::Builder {
            patch::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                job_schedule_patch_parameter: job_schedule_patch_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Deletes a Job Schedule from the specified Account."]
        pub fn delete(&self, job_schedule_id: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Checks the specified Job Schedule exists."]
        pub fn exists(&self, job_schedule_id: impl Into<String>) -> exists::Builder {
            exists::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Disables a Job Schedule."]
        pub fn disable(&self, job_schedule_id: impl Into<String>) -> disable::Builder {
            disable::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Enables a Job Schedule."]
        pub fn enable(&self, job_schedule_id: impl Into<String>) -> enable::Builder {
            enable::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Terminates a Job Schedule."]
        pub fn terminate(&self, job_schedule_id: impl Into<String>) -> terminate::Builder {
            terminate::Builder {
                client: self.0.clone(),
                job_schedule_id: job_schedule_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Lists all of the Job Schedules in the specified Account."]
        pub fn list(&self) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                filter: None,
                select: None,
                expand: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Adds a Job Schedule to the specified Account."]
        pub fn add(&self, cloud_job_schedule: impl Into<models::JobScheduleAddParameter>) -> add::Builder {
            add::Builder {
                client: self.0.clone(),
                cloud_job_schedule: cloud_job_schedule.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::CloudJobSchedule;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobschedules/{}", this.client.endpoint(), &this.job_schedule_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(select) = &this.select {
                            req.url_mut().query_pairs_mut().append_pair("$select", select);
                        }
                        if let Some(expand) = &this.expand {
                            req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudJobSchedule = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) job_schedule_update_parameter: models::JobScheduleUpdateParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobschedules/{}", this.client.endpoint(), &this.job_schedule_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::PUT);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.job_schedule_update_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod patch {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) job_schedule_patch_parameter: models::JobSchedulePatchParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobschedules/{}", this.client.endpoint(), &this.job_schedule_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::PATCH);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.job_schedule_patch_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobschedules/{}", this.client.endpoint(), &this.job_schedule_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::DELETE);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod exists {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobschedules/{}", this.client.endpoint(), &this.job_schedule_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::HEAD);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod disable {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/jobschedules/{}/disable",
                            this.client.endpoint(),
                            &this.job_schedule_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::NO_CONTENT => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod enable {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/jobschedules/{}/enable", this.client.endpoint(), &this.job_schedule_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::NO_CONTENT => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod terminate {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_schedule_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/jobschedules/{}/terminate",
                            this.client.endpoint(),
                            &this.job_schedule_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::CloudJobScheduleListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) filter: Option<String>,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/jobschedules", this.client.endpoint(),))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(select) = &this.select {
                                    req.url_mut().query_pairs_mut().append_pair("$select", select);
                                }
                                if let Some(expand) = &this.expand {
                                    req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudJobScheduleListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod add {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) cloud_job_schedule: models::JobScheduleAddParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobschedules", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.cloud_job_schedule)?;
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::CREATED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod task {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Lists all of the Tasks that are associated with the specified Job."]
        pub fn list(&self, job_id: impl Into<String>) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                filter: None,
                select: None,
                expand: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Adds a Task to the specified Job."]
        pub fn add(&self, job_id: impl Into<String>, task: impl Into<models::TaskAddParameter>) -> add::Builder {
            add::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task: task.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Adds a collection of Tasks to the specified Job."]
        pub fn add_collection(
            &self,
            job_id: impl Into<String>,
            task_collection: impl Into<models::TaskAddCollectionParameter>,
        ) -> add_collection::Builder {
            add_collection::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_collection: task_collection.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Gets information about the specified Task."]
        pub fn get(&self, job_id: impl Into<String>, task_id: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                select: None,
                expand: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        pub fn update(
            &self,
            job_id: impl Into<String>,
            task_id: impl Into<String>,
            task_update_parameter: impl Into<models::TaskUpdateParameter>,
        ) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                task_update_parameter: task_update_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Deletes a Task from the specified Job."]
        pub fn delete(&self, job_id: impl Into<String>, task_id: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Lists all of the subtasks that are associated with the specified multi-instance Task."]
        pub fn list_subtasks(&self, job_id: impl Into<String>, task_id: impl Into<String>) -> list_subtasks::Builder {
            list_subtasks::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                select: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Terminates the specified Task."]
        pub fn terminate(&self, job_id: impl Into<String>, task_id: impl Into<String>) -> terminate::Builder {
            terminate::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
        #[doc = "Reactivates a Task, allowing it to run again even if its retry count has been exhausted."]
        pub fn reactivate(&self, job_id: impl Into<String>, task_id: impl Into<String>) -> reactivate::Builder {
            reactivate::Builder {
                client: self.0.clone(),
                job_id: job_id.into(),
                task_id: task_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
                if_match: None,
                if_none_match: None,
                if_modified_since: None,
                if_unmodified_since: None,
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::CloudTaskListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) filter: Option<String>,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/jobs/{}/tasks", this.client.endpoint(), &this.job_id))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(select) = &this.select {
                                    req.url_mut().query_pairs_mut().append_pair("$select", select);
                                }
                                if let Some(expand) = &this.expand {
                                    req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudTaskListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
    pub mod add {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task: models::TaskAddParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}/tasks", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.task)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::CREATED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod add_collection {
        use super::models;
        type Response = models::TaskAddCollectionResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_collection: models::TaskAddCollectionParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/jobs/{}/addtaskcollection", this.client.endpoint(), &this.job_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.task_collection)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::TaskAddCollectionResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::CloudTask;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) select: Option<String>,
            pub(crate) expand: Option<String>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn expand(mut self, expand: impl Into<String>) -> Self {
                self.expand = Some(expand.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/jobs/{}/tasks/{}", this.client.endpoint(), &this.job_id, &this.task_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(select) = &this.select {
                            req.url_mut().query_pairs_mut().append_pair("$select", select);
                        }
                        if let Some(expand) = &this.expand {
                            req.url_mut().query_pairs_mut().append_pair("$expand", expand);
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudTask = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) task_update_parameter: models::TaskUpdateParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/jobs/{}/tasks/{}", this.client.endpoint(), &this.job_id, &this.task_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::PUT);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.task_update_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/jobs/{}/tasks/{}", this.client.endpoint(), &this.job_id, &this.task_id))?;
                        let mut req = azure_core::Request::new(url, http::Method::DELETE);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_subtasks {
        use super::models;
        type Response = models::CloudTaskListSubtasksResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) select: Option<String>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/jobs/{}/tasks/{}/subtasksinfo",
                            this.client.endpoint(),
                            &this.job_id,
                            &this.task_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(select) = &this.select {
                            req.url_mut().query_pairs_mut().append_pair("$select", select);
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::CloudTaskListSubtasksResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod terminate {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/jobs/{}/tasks/{}/terminate",
                            this.client.endpoint(),
                            &this.job_id,
                            &this.task_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::NO_CONTENT => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod reactivate {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) task_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
            pub(crate) if_match: Option<String>,
            pub(crate) if_none_match: Option<String>,
            pub(crate) if_modified_since: Option<String>,
            pub(crate) if_unmodified_since: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn if_match(mut self, if_match: impl Into<String>) -> Self {
                self.if_match = Some(if_match.into());
                self
            }
            pub fn if_none_match(mut self, if_none_match: impl Into<String>) -> Self {
                self.if_none_match = Some(if_none_match.into());
                self
            }
            pub fn if_modified_since(mut self, if_modified_since: impl Into<String>) -> Self {
                self.if_modified_since = Some(if_modified_since.into());
                self
            }
            pub fn if_unmodified_since(mut self, if_unmodified_since: impl Into<String>) -> Self {
                self.if_unmodified_since = Some(if_unmodified_since.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/jobs/{}/tasks/{}/reactivate",
                            this.client.endpoint(),
                            &this.job_id,
                            &this.task_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        if let Some(if_match) = &this.if_match {
                            req.insert_header("If-Match", if_match);
                        }
                        if let Some(if_none_match) = &this.if_none_match {
                            req.insert_header("If-None-Match", if_none_match);
                        }
                        if let Some(if_modified_since) = &this.if_modified_since {
                            req.insert_header("If-Modified-Since", if_modified_since);
                        }
                        if let Some(if_unmodified_since) = &this.if_unmodified_since {
                            req.insert_header("If-Unmodified-Since", if_unmodified_since);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::NO_CONTENT => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod compute_node {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Adds a user Account to the specified Compute Node."]
        pub fn add_user(
            &self,
            pool_id: impl Into<String>,
            node_id: impl Into<String>,
            user: impl Into<models::ComputeNodeUser>,
        ) -> add_user::Builder {
            add_user::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                user: user.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Updates the password and expiration time of a user Account on the specified Compute Node."]
        pub fn update_user(
            &self,
            pool_id: impl Into<String>,
            node_id: impl Into<String>,
            user_name: impl Into<String>,
            node_update_user_parameter: impl Into<models::NodeUpdateUserParameter>,
        ) -> update_user::Builder {
            update_user::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                user_name: user_name.into(),
                node_update_user_parameter: node_update_user_parameter.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Deletes a user Account from the specified Compute Node."]
        pub fn delete_user(
            &self,
            pool_id: impl Into<String>,
            node_id: impl Into<String>,
            user_name: impl Into<String>,
        ) -> delete_user::Builder {
            delete_user::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                user_name: user_name.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Gets information about the specified Compute Node."]
        pub fn get(&self, pool_id: impl Into<String>, node_id: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                select: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Restarts the specified Compute Node."]
        pub fn reboot(&self, pool_id: impl Into<String>, node_id: impl Into<String>) -> reboot::Builder {
            reboot::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                node_reboot_parameter: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Reinstalls the operating system on the specified Compute Node."]
        pub fn reimage(&self, pool_id: impl Into<String>, node_id: impl Into<String>) -> reimage::Builder {
            reimage::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                node_reimage_parameter: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Disables Task scheduling on the specified Compute Node."]
        pub fn disable_scheduling(&self, pool_id: impl Into<String>, node_id: impl Into<String>) -> disable_scheduling::Builder {
            disable_scheduling::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                node_disable_scheduling_parameter: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Enables Task scheduling on the specified Compute Node."]
        pub fn enable_scheduling(&self, pool_id: impl Into<String>, node_id: impl Into<String>) -> enable_scheduling::Builder {
            enable_scheduling::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Gets the settings required for remote login to a Compute Node."]
        pub fn get_remote_login_settings(
            &self,
            pool_id: impl Into<String>,
            node_id: impl Into<String>,
        ) -> get_remote_login_settings::Builder {
            get_remote_login_settings::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Gets the Remote Desktop Protocol file for the specified Compute Node."]
        pub fn get_remote_desktop(&self, pool_id: impl Into<String>, node_id: impl Into<String>) -> get_remote_desktop::Builder {
            get_remote_desktop::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Upload Azure Batch service log files from the specified Compute Node to Azure Blob Storage."]
        pub fn upload_batch_service_logs(
            &self,
            pool_id: impl Into<String>,
            node_id: impl Into<String>,
            upload_batch_service_logs_configuration: impl Into<models::UploadBatchServiceLogsConfiguration>,
        ) -> upload_batch_service_logs::Builder {
            upload_batch_service_logs::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                node_id: node_id.into(),
                upload_batch_service_logs_configuration: upload_batch_service_logs_configuration.into(),
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
        #[doc = "Lists the Compute Nodes in the specified Pool."]
        pub fn list(&self, pool_id: impl Into<String>) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                pool_id: pool_id.into(),
                filter: None,
                select: None,
                maxresults: None,
                timeout: None,
                client_request_id: None,
                return_client_request_id: None,
                ocp_date: None,
            }
        }
    }
    pub mod add_user {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) user: models::ComputeNodeUser,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/users",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.user)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::CREATED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update_user {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) user_name: String,
            pub(crate) node_update_user_parameter: models::NodeUpdateUserParameter,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/users/{}",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id,
                            &this.user_name
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::PUT);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.node_update_user_parameter)?;
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_user {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) user_name: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/users/{}",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id,
                            &this.user_name
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::DELETE);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::ComputeNode;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) select: Option<String>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(select) = &this.select {
                            req.url_mut().query_pairs_mut().append_pair("$select", select);
                        }
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ComputeNode = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod reboot {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) node_reboot_parameter: Option<models::NodeRebootParameter>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn node_reboot_parameter(mut self, node_reboot_parameter: impl Into<models::NodeRebootParameter>) -> Self {
                self.node_reboot_parameter = Some(node_reboot_parameter.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/reboot",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        let req_body = if let Some(node_reboot_parameter) = &this.node_reboot_parameter {
                            req.insert_header("content-type", "application/json; odata=minimalmetadata");
                            azure_core::to_json(node_reboot_parameter)?
                        } else {
                            azure_core::EMPTY_BODY
                        };
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod reimage {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) node_reimage_parameter: Option<models::NodeReimageParameter>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn node_reimage_parameter(mut self, node_reimage_parameter: impl Into<models::NodeReimageParameter>) -> Self {
                self.node_reimage_parameter = Some(node_reimage_parameter.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/reimage",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        let req_body = if let Some(node_reimage_parameter) = &this.node_reimage_parameter {
                            req.insert_header("content-type", "application/json; odata=minimalmetadata");
                            azure_core::to_json(node_reimage_parameter)?
                        } else {
                            azure_core::EMPTY_BODY
                        };
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::ACCEPTED => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod disable_scheduling {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) node_disable_scheduling_parameter: Option<models::NodeDisableSchedulingParameter>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn node_disable_scheduling_parameter(
                mut self,
                node_disable_scheduling_parameter: impl Into<models::NodeDisableSchedulingParameter>,
            ) -> Self {
                self.node_disable_scheduling_parameter = Some(node_disable_scheduling_parameter.into());
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/disablescheduling",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        let req_body = if let Some(node_disable_scheduling_parameter) = &this.node_disable_scheduling_parameter {
                            req.insert_header("content-type", "application/json; odata=minimalmetadata");
                            azure_core::to_json(node_disable_scheduling_parameter)?
                        } else {
                            azure_core::EMPTY_BODY
                        };
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod enable_scheduling {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/enablescheduling",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_remote_login_settings {
        use super::models;
        type Response = models::ComputeNodeGetRemoteLoginSettingsResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/remoteloginsettings",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ComputeNodeGetRemoteLoginSettingsResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_remote_desktop {
        use super::models;
        type Response = serde_json::Value;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/rdp",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::GET);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: serde_json::Value = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod upload_batch_service_logs {
        use super::models;
        type Response = models::UploadBatchServiceLogsResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) node_id: String,
            pub(crate) upload_batch_service_logs_configuration: models::UploadBatchServiceLogsConfiguration,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/pools/{}/nodes/{}/uploadbatchservicelogs",
                            this.client.endpoint(),
                            &this.pool_id,
                            &this.node_id
                        ))?;
                        let mut req = azure_core::Request::new(url, http::Method::POST);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                        if let Some(timeout) = &this.timeout {
                            req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                        }
                        if let Some(client_request_id) = &this.client_request_id {
                            req.insert_header("client-request-id", client_request_id);
                        }
                        if let Some(return_client_request_id) = &this.return_client_request_id {
                            req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                        }
                        if let Some(ocp_date) = &this.ocp_date {
                            req.insert_header("ocp-date", ocp_date);
                        }
                        req.insert_header("content-type", "application/json; odata=minimalmetadata");
                        let req_body = azure_core::to_json(&this.upload_batch_service_logs_configuration)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::UploadBatchServiceLogsResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::ComputeNodeListResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) pool_id: String,
            pub(crate) filter: Option<String>,
            pub(crate) select: Option<String>,
            pub(crate) maxresults: Option<i32>,
            pub(crate) timeout: Option<i32>,
            pub(crate) client_request_id: Option<String>,
            pub(crate) return_client_request_id: Option<bool>,
            pub(crate) ocp_date: Option<String>,
        }
        impl Builder {
            pub fn filter(mut self, filter: impl Into<String>) -> Self {
                self.filter = Some(filter.into());
                self
            }
            pub fn select(mut self, select: impl Into<String>) -> Self {
                self.select = Some(select.into());
                self
            }
            pub fn maxresults(mut self, maxresults: i32) -> Self {
                self.maxresults = Some(maxresults);
                self
            }
            pub fn timeout(mut self, timeout: i32) -> Self {
                self.timeout = Some(timeout);
                self
            }
            pub fn client_request_id(mut self, client_request_id: impl Into<String>) -> Self {
                self.client_request_id = Some(client_request_id.into());
                self
            }
            pub fn return_client_request_id(mut self, return_client_request_id: bool) -> Self {
                self.return_client_request_id = Some(return_client_request_id);
                self
            }
            pub fn ocp_date(mut self, ocp_date: impl Into<String>) -> Self {
                self.ocp_date = Some(ocp_date.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<Response, azure_core::error::Error> {
                let make_request = move |continuation: Option<azure_core::prelude::Continuation>| {
                    let this = self.clone();
                    async move {
                        let mut url = azure_core::Url::parse(&format!("{}/pools/{}/nodes", this.client.endpoint(), &this.pool_id))?;
                        let rsp = match continuation {
                            Some(azure_core::prelude::Continuation::String(value)) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            Some(azure_core::prelude::Continuation::Range(_)) => {
                                panic!("unexpected continuation type");
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, http::Method::GET);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2020-09-01.12.0");
                                if let Some(filter) = &this.filter {
                                    req.url_mut().query_pairs_mut().append_pair("$filter", filter);
                                }
                                if let Some(select) = &this.select {
                                    req.url_mut().query_pairs_mut().append_pair("$select", select);
                                }
                                if let Some(maxresults) = &this.maxresults {
                                    req.url_mut().query_pairs_mut().append_pair("maxresults", &maxresults.to_string());
                                }
                                if let Some(timeout) = &this.timeout {
                                    req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                                }
                                if let Some(client_request_id) = &this.client_request_id {
                                    req.insert_header("client-request-id", client_request_id);
                                }
                                if let Some(return_client_request_id) = &this.return_client_request_id {
                                    req.insert_header("return-client-request-id", &return_client_request_id.to_string());
                                }
                                if let Some(ocp_date) = &this.ocp_date {
                                    req.insert_header("ocp-date", ocp_date);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            http::StatusCode::OK => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ComputeNodeListResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code.as_u16(),
                                error_code: None,
                            })),
                        }
                    }
                };
                azure_core::Pageable::new(make_request)
            }
        }
    }
}
