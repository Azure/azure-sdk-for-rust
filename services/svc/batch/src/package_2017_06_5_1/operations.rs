#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, models::*, API_VERSION};
pub mod application {
    use super::{models, models::*, API_VERSION};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<ApplicationListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/applications", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ApplicationListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        application_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<ApplicationSummary, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/applications/{}", operation_config.base_path(), application_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ApplicationSummary =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod pool {
    use super::{models, models::*, API_VERSION};
    pub async fn list_usage_metrics(
        operation_config: &crate::OperationConfig,
        starttime: Option<&str>,
        endtime: Option<&str>,
        filter: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<PoolListUsageMetricsResult, list_usage_metrics::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/poolusagemetrics", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list_usage_metrics::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_usage_metrics::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(starttime) = starttime {
            url.query_pairs_mut().append_pair("starttime", starttime);
        }
        if let Some(endtime) = endtime {
            url.query_pairs_mut().append_pair("endtime", endtime);
        }
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_usage_metrics::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_usage_metrics::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: PoolListUsageMetricsResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_usage_metrics::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_usage_metrics::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_usage_metrics::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_usage_metrics {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_all_lifetime_statistics(
        operation_config: &crate::OperationConfig,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<PoolStatistics, get_all_lifetime_statistics::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/lifetimepoolstats", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_all_lifetime_statistics::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_all_lifetime_statistics::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_all_lifetime_statistics::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_all_lifetime_statistics::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: PoolStatistics = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_all_lifetime_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_all_lifetime_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_all_lifetime_statistics::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_all_lifetime_statistics {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<CloudPoolListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudPoolListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        pool: &PoolAddParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool).map_err(add::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        select: Option<&str>,
        expand: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<CloudPool, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudPool =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn patch(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_patch_parameter: &PoolPatchParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), patch::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(patch::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(patch::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_patch_parameter).map_err(patch::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(patch::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(patch::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| patch::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(patch::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod patch {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn exists(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), exists::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(exists::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(exists::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(exists::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(exists::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            http::StatusCode::NOT_FOUND => Err(exists::Error::NotFound404 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| exists::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(exists::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod exists {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotFound404 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn disable_auto_scale(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), disable_auto_scale::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/disableautoscale", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(disable_auto_scale::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(disable_auto_scale::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(disable_auto_scale::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(disable_auto_scale::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| disable_auto_scale::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(disable_auto_scale::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod disable_auto_scale {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn enable_auto_scale(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_enable_auto_scale_parameter: &PoolEnableAutoScaleParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), enable_auto_scale::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/enableautoscale", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(enable_auto_scale::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(enable_auto_scale::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_enable_auto_scale_parameter).map_err(enable_auto_scale::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(enable_auto_scale::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(enable_auto_scale::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| enable_auto_scale::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(enable_auto_scale::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod enable_auto_scale {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn evaluate_auto_scale(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_evaluate_auto_scale_parameter: &PoolEvaluateAutoScaleParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<AutoScaleRun, evaluate_auto_scale::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/evaluateautoscale", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(evaluate_auto_scale::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(evaluate_auto_scale::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_evaluate_auto_scale_parameter).map_err(evaluate_auto_scale::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(evaluate_auto_scale::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(evaluate_auto_scale::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: AutoScaleRun = serde_json::from_slice(rsp_body)
                    .map_err(|source| evaluate_auto_scale::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| evaluate_auto_scale::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(evaluate_auto_scale::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod evaluate_auto_scale {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn resize(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_resize_parameter: &PoolResizeParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), resize::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/resize", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(resize::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(resize::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_resize_parameter).map_err(resize::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(resize::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(resize::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| resize::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(resize::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod resize {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn stop_resize(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), stop_resize::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/stopresize", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(stop_resize::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(stop_resize::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(stop_resize::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(stop_resize::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| stop_resize::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(stop_resize::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod stop_resize {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update_properties(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_update_properties_parameter: &PoolUpdatePropertiesParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), update_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/updateproperties", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(update_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_update_properties_parameter).map_err(update_properties::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(update_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| update_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update_properties {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upgrade_os(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        pool_upgrade_os_parameter: &PoolUpgradeOsParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), upgrade_os::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/upgradeos", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(upgrade_os::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upgrade_os::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(pool_upgrade_os_parameter).map_err(upgrade_os::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(upgrade_os::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(upgrade_os::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| upgrade_os::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upgrade_os::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upgrade_os {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn remove_nodes(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_remove_parameter: &NodeRemoveParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), remove_nodes::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/removenodes", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(remove_nodes::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(remove_nodes::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(node_remove_parameter).map_err(remove_nodes::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(remove_nodes::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(remove_nodes::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| remove_nodes::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(remove_nodes::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod remove_nodes {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod account {
    use super::{models, models::*, API_VERSION};
    pub async fn list_node_agent_skus(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<AccountListNodeAgentSkusResult, list_node_agent_skus::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/nodeagentskus", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list_node_agent_skus::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_node_agent_skus::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_node_agent_skus::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_node_agent_skus::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: AccountListNodeAgentSkusResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_node_agent_skus::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_node_agent_skus::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_node_agent_skus::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_node_agent_skus {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod job {
    use super::{models, models::*, API_VERSION};
    pub async fn get_all_lifetime_statistics(
        operation_config: &crate::OperationConfig,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<JobStatistics, get_all_lifetime_statistics::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/lifetimejobstats", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_all_lifetime_statistics::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_all_lifetime_statistics::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_all_lifetime_statistics::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_all_lifetime_statistics::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: JobStatistics = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_all_lifetime_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_all_lifetime_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_all_lifetime_statistics::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_all_lifetime_statistics {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        select: Option<&str>,
        expand: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<CloudJob, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudJob =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        job_update_parameter: &JobUpdateParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_update_parameter).map_err(update::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn patch(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        job_patch_parameter: &JobPatchParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), patch::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(patch::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(patch::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_patch_parameter).map_err(patch::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(patch::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(patch::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| patch::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(patch::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod patch {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn disable(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        job_disable_parameter: &JobDisableParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), disable::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/disable", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(disable::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(disable::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_disable_parameter).map_err(disable::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(disable::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(disable::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| disable::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(disable::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod disable {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn enable(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), enable::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/enable", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(enable::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(enable::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(enable::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(enable::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| enable::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(enable::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod enable {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn terminate(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        job_terminate_parameter: Option<&JobTerminateParameter>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), terminate::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/terminate", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(terminate::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(terminate::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = if let Some(job_terminate_parameter) = job_terminate_parameter {
            req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
            azure_core::to_json(job_terminate_parameter).map_err(terminate::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(terminate::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(terminate::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| terminate::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(terminate::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod terminate {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<CloudJobListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudJobListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        job: &JobAddParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job).map_err(add::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_from_job_schedule(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<CloudJobListResult, list_from_job_schedule::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}/jobs", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(list_from_job_schedule::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_from_job_schedule::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_from_job_schedule::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_from_job_schedule::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudJobListResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_from_job_schedule::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_from_job_schedule::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_from_job_schedule::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_from_job_schedule {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_preparation_and_release_task_status(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        filter: Option<&str>,
        select: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<CloudJobListPreparationAndReleaseTaskStatusResult, list_preparation_and_release_task_status::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/jobs/{}/jobpreparationandreleasetaskstatus",
            operation_config.base_path(),
            job_id
        );
        let mut url = url::Url::parse(url_str).map_err(list_preparation_and_release_task_status::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_preparation_and_release_task_status::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_preparation_and_release_task_status::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_preparation_and_release_task_status::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudJobListPreparationAndReleaseTaskStatusResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_preparation_and_release_task_status::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_preparation_and_release_task_status::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_preparation_and_release_task_status::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_preparation_and_release_task_status {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_task_counts(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<TaskCounts, get_task_counts::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/taskcounts", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(get_task_counts::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_task_counts::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_task_counts::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_task_counts::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: TaskCounts = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_task_counts::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_task_counts::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_task_counts::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_task_counts {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod certificate {
    use super::{models, models::*, API_VERSION};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        select: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<CertificateListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/certificates", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CertificateListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        certificate: &CertificateAddParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/certificates", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(certificate).map_err(add::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn cancel_deletion(
        operation_config: &crate::OperationConfig,
        thumbprint_algorithm: &str,
        thumbprint: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), cancel_deletion::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/certificates(thumbprintAlgorithm={},thumbprint={})/canceldelete",
            operation_config.base_path(),
            thumbprint_algorithm,
            thumbprint
        );
        let mut url = url::Url::parse(url_str).map_err(cancel_deletion::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(cancel_deletion::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(cancel_deletion::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(cancel_deletion::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| cancel_deletion::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(cancel_deletion::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod cancel_deletion {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        thumbprint_algorithm: &str,
        thumbprint: &str,
        select: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<Certificate, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/certificates(thumbprintAlgorithm={},thumbprint={})",
            operation_config.base_path(),
            thumbprint_algorithm,
            thumbprint
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: Certificate =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        thumbprint_algorithm: &str,
        thumbprint: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/certificates(thumbprintAlgorithm={},thumbprint={})",
            operation_config.base_path(),
            thumbprint_algorithm,
            thumbprint
        );
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod file {
    use super::{models, models::*, API_VERSION};
    pub async fn get_from_task(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        file_path: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        ocp_range: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<bytes::Bytes, get_from_task::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/jobs/{}/tasks/{}/files/{}",
            operation_config.base_path(),
            job_id,
            task_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(get_from_task::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_from_task::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(ocp_range) = ocp_range {
            req_builder = req_builder.header("ocp-range", ocp_range);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_from_task::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_from_task::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value = rsp_body.clone();
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_from_task::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_from_task {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_from_task(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        file_path: &str,
        recursive: Option<bool>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), delete_from_task::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/jobs/{}/tasks/{}/files/{}",
            operation_config.base_path(),
            job_id,
            task_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(delete_from_task::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_from_task::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_from_task::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_from_task::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_from_task::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_from_task {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_properties_from_task(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        file_path: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), get_properties_from_task::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/jobs/{}/tasks/{}/files/{}",
            operation_config.base_path(),
            job_id,
            task_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(get_properties_from_task::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties_from_task::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_properties_from_task::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties_from_task::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_properties_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties_from_task::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties_from_task {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_from_compute_node(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        file_path: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        ocp_range: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<bytes::Bytes, get_from_compute_node::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/files/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(get_from_compute_node::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_from_compute_node::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(ocp_range) = ocp_range {
            req_builder = req_builder.header("ocp-range", ocp_range);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_from_compute_node::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_from_compute_node::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value = rsp_body.clone();
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_from_compute_node::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_from_compute_node {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_from_compute_node(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        file_path: &str,
        recursive: Option<bool>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), delete_from_compute_node::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/files/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(delete_from_compute_node::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_from_compute_node::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(delete_from_compute_node::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_from_compute_node::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_from_compute_node::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_from_compute_node {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_properties_from_compute_node(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        file_path: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), get_properties_from_compute_node::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/files/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            file_path
        );
        let mut url = url::Url::parse(url_str).map_err(get_properties_from_compute_node::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties_from_compute_node::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_properties_from_compute_node::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties_from_compute_node::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_properties_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties_from_compute_node::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties_from_compute_node {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_from_task(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        filter: Option<&str>,
        recursive: Option<bool>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<NodeFileListResult, list_from_task::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}/files", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(list_from_task::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_from_task::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_from_task::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_from_task::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: NodeFileListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list_from_task::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_from_task::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_from_task {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_from_compute_node(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        filter: Option<&str>,
        recursive: Option<bool>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<NodeFileListResult, list_from_compute_node::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/files", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(list_from_compute_node::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_from_compute_node::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_from_compute_node::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_from_compute_node::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: NodeFileListResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_from_compute_node::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_from_compute_node::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_from_compute_node {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod job_schedule {
    use super::{models, models::*, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        select: Option<&str>,
        expand: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<CloudJobSchedule, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudJobSchedule =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        job_schedule_update_parameter: &JobScheduleUpdateParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_schedule_update_parameter).map_err(update::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn patch(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        job_schedule_patch_parameter: &JobSchedulePatchParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), patch::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(patch::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(patch::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(job_schedule_patch_parameter).map_err(patch::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(patch::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(patch::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| patch::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(patch::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod patch {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn exists(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), exists::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(exists::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(exists::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(exists::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(exists::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            http::StatusCode::NOT_FOUND => Err(exists::Error::NotFound404 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| exists::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(exists::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod exists {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotFound404 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn disable(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), disable::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}/disable", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(disable::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(disable::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(disable::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(disable::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| disable::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(disable::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod disable {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn enable(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), enable::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}/enable", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(enable::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(enable::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(enable::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(enable::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| enable::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(enable::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod enable {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn terminate(
        operation_config: &crate::OperationConfig,
        job_schedule_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), terminate::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules/{}/terminate", operation_config.base_path(), job_schedule_id);
        let mut url = url::Url::parse(url_str).map_err(terminate::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(terminate::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(terminate::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(terminate::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| terminate::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(terminate::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod terminate {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<CloudJobScheduleListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudJobScheduleListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        timeout: Option<i32>,
        cloud_job_schedule: &JobScheduleAddParameter,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobschedules", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(cloud_job_schedule).map_err(add::Error::SerializeError)?;
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod task {
    use super::{models, models::*, API_VERSION};
    pub async fn list(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        filter: Option<&str>,
        select: Option<&str>,
        expand: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<CloudTaskListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudTaskListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task: &TaskAddParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(add::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(task).map_err(add::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(add::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add_collection(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_collection: &TaskAddCollectionParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<TaskAddCollectionResult, add_collection::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/addtaskcollection", operation_config.base_path(), job_id);
        let mut url = url::Url::parse(url_str).map_err(add_collection::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add_collection::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(task_collection).map_err(add_collection::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add_collection::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(add_collection::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: TaskAddCollectionResult =
                    serde_json::from_slice(rsp_body).map_err(|source| add_collection::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add_collection::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add_collection::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add_collection {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        select: Option<&str>,
        expand: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<CloudTask, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(expand) = expand {
            url.query_pairs_mut().append_pair("$expand", expand);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudTask =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        task_update_parameter: &TaskUpdateParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(task_update_parameter).map_err(update::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_subtasks(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        select: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<CloudTaskListSubtasksResult, list_subtasks::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}/subtasksinfo", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(list_subtasks::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_subtasks::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_subtasks::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_subtasks::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: CloudTaskListSubtasksResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list_subtasks::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list_subtasks::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_subtasks::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_subtasks {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn terminate(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), terminate::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}/terminate", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(terminate::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(terminate::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(terminate::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(terminate::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| terminate::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(terminate::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod terminate {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn reactivate(
        operation_config: &crate::OperationConfig,
        job_id: &str,
        task_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), reactivate::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/jobs/{}/tasks/{}/reactivate", operation_config.base_path(), job_id, task_id);
        let mut url = url::Url::parse(url_str).map_err(reactivate::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(reactivate::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(reactivate::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(reactivate::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| reactivate::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(reactivate::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod reactivate {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod compute_node {
    use super::{models, models::*, API_VERSION};
    pub async fn add_user(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        user: &ComputeNodeUser,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), add_user::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/users", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(add_user::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add_user::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(user).map_err(add_user::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add_user::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(add_user::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| add_user::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add_user::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add_user {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update_user(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        user_name: &str,
        node_update_user_parameter: &NodeUpdateUserParameter,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), update_user::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/users/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            user_name
        );
        let mut url = url::Url::parse(url_str).map_err(update_user::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update_user::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
        let req_body = azure_core::to_json(node_update_user_parameter).map_err(update_user::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update_user::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(update_user::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| update_user::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update_user::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update_user {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_user(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        user_name: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), delete_user::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/users/{}",
            operation_config.base_path(),
            pool_id,
            node_id,
            user_name
        );
        let mut url = url::Url::parse(url_str).map_err(delete_user::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_user::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_user::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_user::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete_user::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_user::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_user {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        select: Option<&str>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<ComputeNode, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ComputeNode =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn reboot(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        node_reboot_parameter: Option<&NodeRebootParameter>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), reboot::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/reboot", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(reboot::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(reboot::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = if let Some(node_reboot_parameter) = node_reboot_parameter {
            req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
            azure_core::to_json(node_reboot_parameter).map_err(reboot::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(reboot::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(reboot::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| reboot::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(reboot::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod reboot {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn reimage(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        node_reimage_parameter: Option<&NodeReimageParameter>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), reimage::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/reimage", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(reimage::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(reimage::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = if let Some(node_reimage_parameter) = node_reimage_parameter {
            req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
            azure_core::to_json(node_reimage_parameter).map_err(reimage::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(reimage::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(reimage::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| reimage::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(reimage::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod reimage {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn disable_scheduling(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        node_disable_scheduling_parameter: Option<&NodeDisableSchedulingParameter>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), disable_scheduling::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/disablescheduling",
            operation_config.base_path(),
            pool_id,
            node_id
        );
        let mut url = url::Url::parse(url_str).map_err(disable_scheduling::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(disable_scheduling::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = if let Some(node_disable_scheduling_parameter) = node_disable_scheduling_parameter {
            req_builder = req_builder.header("content-type", "application/json; odata=minimalmetadata");
            azure_core::to_json(node_disable_scheduling_parameter).map_err(disable_scheduling::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(disable_scheduling::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(disable_scheduling::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| disable_scheduling::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(disable_scheduling::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod disable_scheduling {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn enable_scheduling(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<(), enable_scheduling::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/enablescheduling",
            operation_config.base_path(),
            pool_id,
            node_id
        );
        let mut url = url::Url::parse(url_str).map_err(enable_scheduling::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(enable_scheduling::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(enable_scheduling::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(enable_scheduling::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| enable_scheduling::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(enable_scheduling::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod enable_scheduling {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_remote_login_settings(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<ComputeNodeGetRemoteLoginSettingsResult, get_remote_login_settings::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pools/{}/nodes/{}/remoteloginsettings",
            operation_config.base_path(),
            pool_id,
            node_id
        );
        let mut url = url::Url::parse(url_str).map_err(get_remote_login_settings::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_remote_login_settings::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_remote_login_settings::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_remote_login_settings::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ComputeNodeGetRemoteLoginSettingsResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_remote_login_settings::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_remote_login_settings::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_remote_login_settings::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_remote_login_settings {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_remote_desktop(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        node_id: &str,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<bytes::Bytes, get_remote_desktop::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes/{}/rdp", operation_config.base_path(), pool_id, node_id);
        let mut url = url::Url::parse(url_str).map_err(get_remote_desktop::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_remote_desktop::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_remote_desktop::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_remote_desktop::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value = rsp_body.clone();
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_remote_desktop::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_remote_desktop::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_remote_desktop {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        pool_id: &str,
        filter: Option<&str>,
        select: Option<&str>,
        maxresults: Option<i32>,
        timeout: Option<i32>,
        client_request_id: Option<&str>,
        return_client_request_id: Option<bool>,
        ocp_date: Option<&str>,
    ) -> std::result::Result<ComputeNodeListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pools/{}/nodes", operation_config.base_path(), pool_id);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(client_request_id) = client_request_id {
            req_builder = req_builder.header("client-request-id", client_request_id);
        }
        if let Some(return_client_request_id) = return_client_request_id {
            req_builder = req_builder.header("return-client-request-id", return_client_request_id.to_string());
        }
        if let Some(ocp_date) = ocp_date {
            req_builder = req_builder.header("ocp-date", ocp_date);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ComputeNodeListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: BatchError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::BatchError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
