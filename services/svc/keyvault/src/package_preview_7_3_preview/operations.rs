#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, API_VERSION};
#[non_exhaustive]
#[derive(Debug, thiserror :: Error)]
#[allow(non_camel_case_types)]
pub enum Error {
    #[error(transparent)]
    FullBackup(#[from] full_backup::Error),
    #[error(transparent)]
    FullBackupStatus(#[from] full_backup_status::Error),
    #[error(transparent)]
    FullRestoreOperation(#[from] full_restore_operation::Error),
    #[error(transparent)]
    RestoreStatus(#[from] restore_status::Error),
    #[error(transparent)]
    SelectiveKeyRestoreOperation(#[from] selective_key_restore_operation::Error),
    #[error(transparent)]
    GetCertificates(#[from] get_certificates::Error),
    #[error(transparent)]
    DeleteCertificate(#[from] delete_certificate::Error),
    #[error(transparent)]
    GetCertificateContacts(#[from] get_certificate_contacts::Error),
    #[error(transparent)]
    SetCertificateContacts(#[from] set_certificate_contacts::Error),
    #[error(transparent)]
    DeleteCertificateContacts(#[from] delete_certificate_contacts::Error),
    #[error(transparent)]
    GetCertificateIssuers(#[from] get_certificate_issuers::Error),
    #[error(transparent)]
    GetCertificateIssuer(#[from] get_certificate_issuer::Error),
    #[error(transparent)]
    SetCertificateIssuer(#[from] set_certificate_issuer::Error),
    #[error(transparent)]
    UpdateCertificateIssuer(#[from] update_certificate_issuer::Error),
    #[error(transparent)]
    DeleteCertificateIssuer(#[from] delete_certificate_issuer::Error),
    #[error(transparent)]
    CreateCertificate(#[from] create_certificate::Error),
    #[error(transparent)]
    ImportCertificate(#[from] import_certificate::Error),
    #[error(transparent)]
    GetCertificateVersions(#[from] get_certificate_versions::Error),
    #[error(transparent)]
    GetCertificatePolicy(#[from] get_certificate_policy::Error),
    #[error(transparent)]
    UpdateCertificatePolicy(#[from] update_certificate_policy::Error),
    #[error(transparent)]
    GetCertificate(#[from] get_certificate::Error),
    #[error(transparent)]
    UpdateCertificate(#[from] update_certificate::Error),
    #[error(transparent)]
    GetCertificateOperation(#[from] get_certificate_operation::Error),
    #[error(transparent)]
    UpdateCertificateOperation(#[from] update_certificate_operation::Error),
    #[error(transparent)]
    DeleteCertificateOperation(#[from] delete_certificate_operation::Error),
    #[error(transparent)]
    MergeCertificate(#[from] merge_certificate::Error),
    #[error(transparent)]
    BackupCertificate(#[from] backup_certificate::Error),
    #[error(transparent)]
    RestoreCertificate(#[from] restore_certificate::Error),
    #[error(transparent)]
    GetDeletedCertificates(#[from] get_deleted_certificates::Error),
    #[error(transparent)]
    GetDeletedCertificate(#[from] get_deleted_certificate::Error),
    #[error(transparent)]
    PurgeDeletedCertificate(#[from] purge_deleted_certificate::Error),
    #[error(transparent)]
    RecoverDeletedCertificate(#[from] recover_deleted_certificate::Error),
    #[error(transparent)]
    CreateKey(#[from] create_key::Error),
    #[error(transparent)]
    RotateKey(#[from] rotate_key::Error),
    #[error(transparent)]
    ImportKey(#[from] import_key::Error),
    #[error(transparent)]
    DeleteKey(#[from] delete_key::Error),
    #[error(transparent)]
    GetKey(#[from] get_key::Error),
    #[error(transparent)]
    UpdateKey(#[from] update_key::Error),
    #[error(transparent)]
    GetKeyVersions(#[from] get_key_versions::Error),
    #[error(transparent)]
    GetKeys(#[from] get_keys::Error),
    #[error(transparent)]
    BackupKey(#[from] backup_key::Error),
    #[error(transparent)]
    RestoreKey(#[from] restore_key::Error),
    #[error(transparent)]
    Encrypt(#[from] encrypt::Error),
    #[error(transparent)]
    Decrypt(#[from] decrypt::Error),
    #[error(transparent)]
    Sign(#[from] sign::Error),
    #[error(transparent)]
    Verify(#[from] verify::Error),
    #[error(transparent)]
    WrapKey(#[from] wrap_key::Error),
    #[error(transparent)]
    UnwrapKey(#[from] unwrap_key::Error),
    #[error(transparent)]
    Export(#[from] export::Error),
    #[error(transparent)]
    Release(#[from] release::Error),
    #[error(transparent)]
    GetDeletedKeys(#[from] get_deleted_keys::Error),
    #[error(transparent)]
    GetDeletedKey(#[from] get_deleted_key::Error),
    #[error(transparent)]
    PurgeDeletedKey(#[from] purge_deleted_key::Error),
    #[error(transparent)]
    RecoverDeletedKey(#[from] recover_deleted_key::Error),
    #[error(transparent)]
    GetKeyRotationPolicy(#[from] get_key_rotation_policy::Error),
    #[error(transparent)]
    UpdateKeyRotationPolicy(#[from] update_key_rotation_policy::Error),
    #[error(transparent)]
    GetRandomBytes(#[from] get_random_bytes::Error),
    #[error(transparent)]
    SetSecret(#[from] set_secret::Error),
    #[error(transparent)]
    DeleteSecret(#[from] delete_secret::Error),
    #[error(transparent)]
    GetSecret(#[from] get_secret::Error),
    #[error(transparent)]
    UpdateSecret(#[from] update_secret::Error),
    #[error(transparent)]
    GetSecrets(#[from] get_secrets::Error),
    #[error(transparent)]
    GetSecretVersions(#[from] get_secret_versions::Error),
    #[error(transparent)]
    GetDeletedSecrets(#[from] get_deleted_secrets::Error),
    #[error(transparent)]
    GetDeletedSecret(#[from] get_deleted_secret::Error),
    #[error(transparent)]
    PurgeDeletedSecret(#[from] purge_deleted_secret::Error),
    #[error(transparent)]
    RecoverDeletedSecret(#[from] recover_deleted_secret::Error),
    #[error(transparent)]
    BackupSecret(#[from] backup_secret::Error),
    #[error(transparent)]
    RestoreSecret(#[from] restore_secret::Error),
    #[error(transparent)]
    RoleDefinitions_Get(#[from] role_definitions::get::Error),
    #[error(transparent)]
    RoleDefinitions_CreateOrUpdate(#[from] role_definitions::create_or_update::Error),
    #[error(transparent)]
    RoleDefinitions_Delete(#[from] role_definitions::delete::Error),
    #[error(transparent)]
    RoleDefinitions_List(#[from] role_definitions::list::Error),
    #[error(transparent)]
    RoleAssignments_Get(#[from] role_assignments::get::Error),
    #[error(transparent)]
    RoleAssignments_Create(#[from] role_assignments::create::Error),
    #[error(transparent)]
    RoleAssignments_Delete(#[from] role_assignments::delete::Error),
    #[error(transparent)]
    RoleAssignments_ListForScope(#[from] role_assignments::list_for_scope::Error),
    #[error(transparent)]
    HsmSecurityDomain_DownloadPending(#[from] hsm_security_domain::download_pending::Error),
    #[error(transparent)]
    HsmSecurityDomain_Download(#[from] hsm_security_domain::download::Error),
    #[error(transparent)]
    HsmSecurityDomain_TransferKey(#[from] hsm_security_domain::transfer_key::Error),
    #[error(transparent)]
    HsmSecurityDomain_Upload(#[from] hsm_security_domain::upload::Error),
    #[error(transparent)]
    HsmSecurityDomain_UploadPending(#[from] hsm_security_domain::upload_pending::Error),
    #[error(transparent)]
    GetStorageAccounts(#[from] get_storage_accounts::Error),
    #[error(transparent)]
    GetDeletedStorageAccounts(#[from] get_deleted_storage_accounts::Error),
    #[error(transparent)]
    GetDeletedStorageAccount(#[from] get_deleted_storage_account::Error),
    #[error(transparent)]
    PurgeDeletedStorageAccount(#[from] purge_deleted_storage_account::Error),
    #[error(transparent)]
    RecoverDeletedStorageAccount(#[from] recover_deleted_storage_account::Error),
    #[error(transparent)]
    BackupStorageAccount(#[from] backup_storage_account::Error),
    #[error(transparent)]
    RestoreStorageAccount(#[from] restore_storage_account::Error),
    #[error(transparent)]
    GetStorageAccount(#[from] get_storage_account::Error),
    #[error(transparent)]
    SetStorageAccount(#[from] set_storage_account::Error),
    #[error(transparent)]
    UpdateStorageAccount(#[from] update_storage_account::Error),
    #[error(transparent)]
    DeleteStorageAccount(#[from] delete_storage_account::Error),
    #[error(transparent)]
    RegenerateStorageAccountKey(#[from] regenerate_storage_account_key::Error),
    #[error(transparent)]
    GetSasDefinitions(#[from] get_sas_definitions::Error),
    #[error(transparent)]
    GetDeletedSasDefinitions(#[from] get_deleted_sas_definitions::Error),
    #[error(transparent)]
    GetDeletedSasDefinition(#[from] get_deleted_sas_definition::Error),
    #[error(transparent)]
    RecoverDeletedSasDefinition(#[from] recover_deleted_sas_definition::Error),
    #[error(transparent)]
    GetSasDefinition(#[from] get_sas_definition::Error),
    #[error(transparent)]
    SetSasDefinition(#[from] set_sas_definition::Error),
    #[error(transparent)]
    UpdateSasDefinition(#[from] update_sas_definition::Error),
    #[error(transparent)]
    DeleteSasDefinition(#[from] delete_sas_definition::Error),
}
pub async fn full_backup(
    operation_config: &crate::OperationConfig,
    azure_storage_blob_container_uri: Option<&models::SasTokenParameter>,
) -> std::result::Result<models::FullBackupOperation, full_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/backup", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(full_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(full_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = if let Some(azure_storage_blob_container_uri) = azure_storage_blob_container_uri {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(azure_storage_blob_container_uri).map_err(full_backup::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(full_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(full_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => {
            let rsp_body = rsp.body();
            let rsp_value: models::FullBackupOperation =
                serde_json::from_slice(rsp_body).map_err(|source| full_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| full_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(full_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod full_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn full_backup_status(
    operation_config: &crate::OperationConfig,
    job_id: &str,
) -> std::result::Result<models::FullBackupOperation, full_backup_status::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/backup/{}/pending", operation_config.base_path(), job_id);
    let mut url = url::Url::parse(url_str).map_err(full_backup_status::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(full_backup_status::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(full_backup_status::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(full_backup_status::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::FullBackupOperation =
                serde_json::from_slice(rsp_body).map_err(|source| full_backup_status::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| full_backup_status::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(full_backup_status::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod full_backup_status {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn full_restore_operation(
    operation_config: &crate::OperationConfig,
    restore_blob_details: Option<&models::RestoreOperationParameters>,
) -> std::result::Result<models::RestoreOperation, full_restore_operation::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/restore", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(full_restore_operation::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(full_restore_operation::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = if let Some(restore_blob_details) = restore_blob_details {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(restore_blob_details).map_err(full_restore_operation::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(full_restore_operation::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(full_restore_operation::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => {
            let rsp_body = rsp.body();
            let rsp_value: models::RestoreOperation = serde_json::from_slice(rsp_body)
                .map_err(|source| full_restore_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| full_restore_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(full_restore_operation::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod full_restore_operation {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restore_status(
    operation_config: &crate::OperationConfig,
    job_id: &str,
) -> std::result::Result<models::RestoreOperation, restore_status::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/restore/{}/pending", operation_config.base_path(), job_id);
    let mut url = url::Url::parse(url_str).map_err(restore_status::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restore_status::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(restore_status::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restore_status::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RestoreOperation =
                serde_json::from_slice(rsp_body).map_err(|source| restore_status::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| restore_status::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restore_status::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restore_status {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn selective_key_restore_operation(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    restore_blob_details: Option<&models::SelectiveKeyRestoreOperationParameters>,
) -> std::result::Result<models::SelectiveKeyRestoreOperation, selective_key_restore_operation::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/restore", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(selective_key_restore_operation::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(selective_key_restore_operation::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = if let Some(restore_blob_details) = restore_blob_details {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(restore_blob_details).map_err(selective_key_restore_operation::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(selective_key_restore_operation::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(selective_key_restore_operation::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => {
            let rsp_body = rsp.body();
            let rsp_value: models::SelectiveKeyRestoreOperation = serde_json::from_slice(rsp_body)
                .map_err(|source| selective_key_restore_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| selective_key_restore_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(selective_key_restore_operation::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod selective_key_restore_operation {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_certificates(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
    include_pending: Option<bool>,
) -> std::result::Result<models::CertificateListResult, get_certificates::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_certificates::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_certificates::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    if let Some(include_pending) = include_pending {
        url.query_pairs_mut()
            .append_pair("includePending", include_pending.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_certificates::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_certificates::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_certificates::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_certificates::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_certificates::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_certificates {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
) -> std::result::Result<models::DeletedCertificateBundle, delete_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(delete_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedCertificateBundle =
                serde_json::from_slice(rsp_body).map_err(|source| delete_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| delete_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_certificate_contacts(
    operation_config: &crate::OperationConfig,
) -> std::result::Result<models::Contacts, get_certificate_contacts::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/contacts", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_certificate_contacts::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_certificate_contacts::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_certificate_contacts::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_certificate_contacts::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::Contacts = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_contacts::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_contacts::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_certificate_contacts::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_certificate_contacts {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn set_certificate_contacts(
    operation_config: &crate::OperationConfig,
    contacts: &models::Contacts,
) -> std::result::Result<models::Contacts, set_certificate_contacts::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/contacts", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(set_certificate_contacts::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(set_certificate_contacts::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(contacts).map_err(set_certificate_contacts::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(set_certificate_contacts::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(set_certificate_contacts::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::Contacts = serde_json::from_slice(rsp_body)
                .map_err(|source| set_certificate_contacts::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| set_certificate_contacts::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(set_certificate_contacts::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod set_certificate_contacts {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_certificate_contacts(
    operation_config: &crate::OperationConfig,
) -> std::result::Result<models::Contacts, delete_certificate_contacts::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/contacts", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(delete_certificate_contacts::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_certificate_contacts::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(delete_certificate_contacts::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_certificate_contacts::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::Contacts = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_certificate_contacts::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_certificate_contacts::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_certificate_contacts::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_certificate_contacts {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_certificate_issuers(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
) -> std::result::Result<models::CertificateIssuerListResult, get_certificate_issuers::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/issuers", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_certificate_issuers::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_certificate_issuers::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_certificate_issuers::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_certificate_issuers::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateIssuerListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_issuers::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_issuers::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_certificate_issuers::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_certificate_issuers {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_certificate_issuer(
    operation_config: &crate::OperationConfig,
    issuer_name: &str,
) -> std::result::Result<models::IssuerBundle, get_certificate_issuer::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/issuers/{}", operation_config.base_path(), issuer_name);
    let mut url = url::Url::parse(url_str).map_err(get_certificate_issuer::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_certificate_issuer::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_certificate_issuer::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_certificate_issuer::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::IssuerBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_issuer::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_issuer::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_certificate_issuer::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_certificate_issuer {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn set_certificate_issuer(
    operation_config: &crate::OperationConfig,
    issuer_name: &str,
    parameter: &models::CertificateIssuerSetParameters,
) -> std::result::Result<models::IssuerBundle, set_certificate_issuer::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/issuers/{}", operation_config.base_path(), issuer_name);
    let mut url = url::Url::parse(url_str).map_err(set_certificate_issuer::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(set_certificate_issuer::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameter).map_err(set_certificate_issuer::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(set_certificate_issuer::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(set_certificate_issuer::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::IssuerBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| set_certificate_issuer::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| set_certificate_issuer::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(set_certificate_issuer::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod set_certificate_issuer {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_certificate_issuer(
    operation_config: &crate::OperationConfig,
    issuer_name: &str,
    parameter: &models::CertificateIssuerUpdateParameters,
) -> std::result::Result<models::IssuerBundle, update_certificate_issuer::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/issuers/{}", operation_config.base_path(), issuer_name);
    let mut url = url::Url::parse(url_str).map_err(update_certificate_issuer::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PATCH);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_certificate_issuer::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameter).map_err(update_certificate_issuer::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_certificate_issuer::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_certificate_issuer::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::IssuerBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| update_certificate_issuer::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_certificate_issuer::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_certificate_issuer::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_certificate_issuer {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_certificate_issuer(
    operation_config: &crate::OperationConfig,
    issuer_name: &str,
) -> std::result::Result<models::IssuerBundle, delete_certificate_issuer::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/issuers/{}", operation_config.base_path(), issuer_name);
    let mut url = url::Url::parse(url_str).map_err(delete_certificate_issuer::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_certificate_issuer::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(delete_certificate_issuer::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_certificate_issuer::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::IssuerBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_certificate_issuer::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_certificate_issuer::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_certificate_issuer::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_certificate_issuer {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
    parameters: &models::CertificateCreateParameters,
) -> std::result::Result<models::CertificateOperation, create_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/create", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(create_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(create_certificate::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(create_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateOperation =
                serde_json::from_slice(rsp_body).map_err(|source| create_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| create_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn import_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
    parameters: &models::CertificateImportParameters,
) -> std::result::Result<models::CertificateBundle, import_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/import", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(import_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(import_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(import_certificate::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(import_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(import_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateBundle =
                serde_json::from_slice(rsp_body).map_err(|source| import_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| import_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(import_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod import_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_certificate_versions(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
    maxresults: Option<i32>,
) -> std::result::Result<models::CertificateListResult, get_certificate_versions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/versions", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(get_certificate_versions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_certificate_versions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_certificate_versions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_certificate_versions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_versions::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_versions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_certificate_versions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_certificate_versions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_certificate_policy(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
) -> std::result::Result<models::CertificatePolicy, get_certificate_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/policy", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(get_certificate_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_certificate_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_certificate_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_certificate_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificatePolicy = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_certificate_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_certificate_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_certificate_policy(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
    certificate_policy: &models::CertificatePolicy,
) -> std::result::Result<models::CertificatePolicy, update_certificate_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/policy", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(update_certificate_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PATCH);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_certificate_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(certificate_policy).map_err(update_certificate_policy::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_certificate_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_certificate_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificatePolicy = serde_json::from_slice(rsp_body)
                .map_err(|source| update_certificate_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_certificate_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_certificate_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_certificate_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
    certificate_version: &str,
) -> std::result::Result<models::CertificateBundle, get_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/certificates/{}/{}",
        operation_config.base_path(),
        certificate_name,
        certificate_version
    );
    let mut url = url::Url::parse(url_str).map_err(get_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateBundle =
                serde_json::from_slice(rsp_body).map_err(|source| get_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
    certificate_version: &str,
    parameters: &models::CertificateUpdateParameters,
) -> std::result::Result<models::CertificateBundle, update_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/certificates/{}/{}",
        operation_config.base_path(),
        certificate_name,
        certificate_version
    );
    let mut url = url::Url::parse(url_str).map_err(update_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PATCH);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(update_certificate::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(update_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateBundle =
                serde_json::from_slice(rsp_body).map_err(|source| update_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| update_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_certificate_operation(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
) -> std::result::Result<models::CertificateOperation, get_certificate_operation::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/pending", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(get_certificate_operation::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_certificate_operation::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_certificate_operation::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_certificate_operation::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateOperation = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_certificate_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_certificate_operation::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_certificate_operation {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_certificate_operation(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
    certificate_operation: &models::CertificateOperationUpdateParameter,
) -> std::result::Result<models::CertificateOperation, update_certificate_operation::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/pending", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(update_certificate_operation::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PATCH);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_certificate_operation::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(certificate_operation).map_err(update_certificate_operation::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_certificate_operation::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_certificate_operation::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateOperation = serde_json::from_slice(rsp_body)
                .map_err(|source| update_certificate_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_certificate_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_certificate_operation::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_certificate_operation {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_certificate_operation(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
) -> std::result::Result<models::CertificateOperation, delete_certificate_operation::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/pending", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(delete_certificate_operation::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_certificate_operation::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(delete_certificate_operation::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_certificate_operation::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateOperation = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_certificate_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_certificate_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_certificate_operation::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_certificate_operation {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn merge_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
    parameters: &models::CertificateMergeParameters,
) -> std::result::Result<models::CertificateBundle, merge_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/pending/merge", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(merge_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(merge_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(merge_certificate::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(merge_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(merge_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::CREATED => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateBundle =
                serde_json::from_slice(rsp_body).map_err(|source| merge_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| merge_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(merge_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod merge_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn backup_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
) -> std::result::Result<models::BackupCertificateResult, backup_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/{}/backup", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(backup_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(backup_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(backup_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(backup_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::BackupCertificateResult =
                serde_json::from_slice(rsp_body).map_err(|source| backup_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| backup_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(backup_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod backup_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restore_certificate(
    operation_config: &crate::OperationConfig,
    parameters: &models::CertificateRestoreParameters,
) -> std::result::Result<models::CertificateBundle, restore_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/certificates/restore", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(restore_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restore_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(restore_certificate::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(restore_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restore_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| restore_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| restore_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restore_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restore_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_certificates(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
    include_pending: Option<bool>,
) -> std::result::Result<models::DeletedCertificateListResult, get_deleted_certificates::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedcertificates", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_certificates::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_certificates::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    if let Some(include_pending) = include_pending {
        url.query_pairs_mut()
            .append_pair("includePending", include_pending.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deleted_certificates::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_certificates::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedCertificateListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_certificates::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_certificates::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_certificates::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_certificates {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
) -> std::result::Result<models::DeletedCertificateBundle, get_deleted_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedcertificates/{}", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deleted_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedCertificateBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn purge_deleted_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
) -> std::result::Result<(), purge_deleted_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedcertificates/{}", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(purge_deleted_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(purge_deleted_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(purge_deleted_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(purge_deleted_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::NO_CONTENT => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| purge_deleted_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(purge_deleted_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod purge_deleted_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_deleted_certificate(
    operation_config: &crate::OperationConfig,
    certificate_name: &str,
) -> std::result::Result<models::CertificateBundle, recover_deleted_certificate::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedcertificates/{}/recover", operation_config.base_path(), certificate_name);
    let mut url = url::Url::parse(url_str).map_err(recover_deleted_certificate::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_deleted_certificate::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(recover_deleted_certificate::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_deleted_certificate::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::CertificateBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_certificate::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_deleted_certificate::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_deleted_certificate {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    parameters: &models::KeyCreateParameters,
) -> std::result::Result<models::KeyBundle, create_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/create", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(create_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(create_key::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(create_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| create_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| create_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn rotate_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
) -> std::result::Result<models::KeyBundle, rotate_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/rotate", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(rotate_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(rotate_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(rotate_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(rotate_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| rotate_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| rotate_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(rotate_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod rotate_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn import_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    parameters: &models::KeyImportParameters,
) -> std::result::Result<models::KeyBundle, import_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(import_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(import_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(import_key::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(import_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(import_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| import_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| import_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(import_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod import_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
) -> std::result::Result<models::DeletedKeyBundle, delete_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(delete_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedKeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| delete_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| delete_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
) -> std::result::Result<models::KeyBundle, get_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(get_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| get_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeyUpdateParameters,
) -> std::result::Result<models::KeyBundle, update_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(update_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PATCH);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(update_key::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(update_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| update_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| update_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_key_versions(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    maxresults: Option<i32>,
) -> std::result::Result<models::KeyListResult, get_key_versions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/versions", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(get_key_versions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_key_versions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_key_versions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_key_versions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_key_versions::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_key_versions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_key_versions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_key_versions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_keys(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
) -> std::result::Result<models::KeyListResult, get_keys::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_keys::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_keys::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_keys::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_keys::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_keys::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_keys::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_keys::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_keys {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn backup_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
) -> std::result::Result<models::BackupKeyResult, backup_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/backup", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(backup_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(backup_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(backup_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(backup_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::BackupKeyResult =
                serde_json::from_slice(rsp_body).map_err(|source| backup_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| backup_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(backup_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod backup_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restore_key(
    operation_config: &crate::OperationConfig,
    parameters: &models::KeyRestoreParameters,
) -> std::result::Result<models::KeyBundle, restore_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/restore", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(restore_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restore_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(restore_key::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(restore_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restore_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| restore_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| restore_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restore_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restore_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn encrypt(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeyOperationsParameters,
) -> std::result::Result<models::KeyOperationResult, encrypt::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}/encrypt", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(encrypt::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(encrypt::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(encrypt::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(encrypt::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(encrypt::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyOperationResult =
                serde_json::from_slice(rsp_body).map_err(|source| encrypt::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| encrypt::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(encrypt::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod encrypt {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn decrypt(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeyOperationsParameters,
) -> std::result::Result<models::KeyOperationResult, decrypt::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}/decrypt", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(decrypt::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(decrypt::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(decrypt::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(decrypt::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(decrypt::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyOperationResult =
                serde_json::from_slice(rsp_body).map_err(|source| decrypt::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| decrypt::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(decrypt::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod decrypt {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn sign(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeySignParameters,
) -> std::result::Result<models::KeyOperationResult, sign::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}/sign", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(sign::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(sign::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(sign::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(sign::Error::BuildRequestError)?;
    let rsp = http_client.execute_request(req).await.map_err(sign::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyOperationResult =
                serde_json::from_slice(rsp_body).map_err(|source| sign::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| sign::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(sign::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod sign {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn verify(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeyVerifyParameters,
) -> std::result::Result<models::KeyVerifyResult, verify::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}/verify", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(verify::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(verify::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(verify::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(verify::Error::BuildRequestError)?;
    let rsp = http_client.execute_request(req).await.map_err(verify::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVerifyResult =
                serde_json::from_slice(rsp_body).map_err(|source| verify::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| verify::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(verify::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod verify {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn wrap_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeyOperationsParameters,
) -> std::result::Result<models::KeyOperationResult, wrap_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}/wrapkey", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(wrap_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(wrap_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(wrap_key::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(wrap_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(wrap_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyOperationResult =
                serde_json::from_slice(rsp_body).map_err(|source| wrap_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| wrap_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(wrap_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod wrap_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn unwrap_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeyOperationsParameters,
) -> std::result::Result<models::KeyOperationResult, unwrap_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}/unwrapkey", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(unwrap_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(unwrap_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(unwrap_key::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(unwrap_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(unwrap_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyOperationResult =
                serde_json::from_slice(rsp_body).map_err(|source| unwrap_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| unwrap_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(unwrap_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod unwrap_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn export(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeyExportParameters,
) -> std::result::Result<models::KeyBundle, export::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}/export", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(export::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(export::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(export::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(export::Error::BuildRequestError)?;
    let rsp = http_client.execute_request(req).await.map_err(export::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| export::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| export::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(export::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod export {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn release(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_version: &str,
    parameters: &models::KeyReleaseParameters,
) -> std::result::Result<models::KeyReleaseResult, release::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/{}/release", operation_config.base_path(), key_name, key_version);
    let mut url = url::Url::parse(url_str).map_err(release::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(release::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(release::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(release::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(release::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyReleaseResult =
                serde_json::from_slice(rsp_body).map_err(|source| release::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| release::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(release::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod release {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_keys(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
) -> std::result::Result<models::DeletedKeyListResult, get_deleted_keys::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedkeys", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_keys::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_keys::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_deleted_keys::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_keys::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedKeyListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_deleted_keys::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_deleted_keys::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_keys::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_keys {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
) -> std::result::Result<models::DeletedKeyBundle, get_deleted_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedkeys/{}", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_deleted_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedKeyBundle =
                serde_json::from_slice(rsp_body).map_err(|source| get_deleted_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_deleted_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn purge_deleted_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
) -> std::result::Result<(), purge_deleted_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedkeys/{}", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(purge_deleted_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(purge_deleted_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(purge_deleted_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(purge_deleted_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::NO_CONTENT => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| purge_deleted_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(purge_deleted_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod purge_deleted_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_deleted_key(
    operation_config: &crate::OperationConfig,
    key_name: &str,
) -> std::result::Result<models::KeyBundle, recover_deleted_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedkeys/{}/recover", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(recover_deleted_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_deleted_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(recover_deleted_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_deleted_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_deleted_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_deleted_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_key_rotation_policy(
    operation_config: &crate::OperationConfig,
    key_name: &str,
) -> std::result::Result<models::KeyRotationPolicy, get_key_rotation_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/rotationpolicy", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(get_key_rotation_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_key_rotation_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_key_rotation_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_key_rotation_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyRotationPolicy = serde_json::from_slice(rsp_body)
                .map_err(|source| get_key_rotation_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_key_rotation_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_key_rotation_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_key_rotation_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_key_rotation_policy(
    operation_config: &crate::OperationConfig,
    key_name: &str,
    key_rotation_policy: &models::KeyRotationPolicy,
) -> std::result::Result<models::KeyRotationPolicy, update_key_rotation_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys/{}/rotationpolicy", operation_config.base_path(), key_name);
    let mut url = url::Url::parse(url_str).map_err(update_key_rotation_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_key_rotation_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(key_rotation_policy).map_err(update_key_rotation_policy::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_key_rotation_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_key_rotation_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyRotationPolicy = serde_json::from_slice(rsp_body)
                .map_err(|source| update_key_rotation_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_key_rotation_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_key_rotation_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_key_rotation_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_random_bytes(
    operation_config: &crate::OperationConfig,
    parameters: &models::GetRandomBytesRequest,
) -> std::result::Result<models::RandomBytes, get_random_bytes::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/rng", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_random_bytes::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_random_bytes::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(get_random_bytes::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_random_bytes::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_random_bytes::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RandomBytes =
                serde_json::from_slice(rsp_body).map_err(|source| get_random_bytes::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_random_bytes::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_random_bytes::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_random_bytes {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn set_secret(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
    parameters: &models::SecretSetParameters,
) -> std::result::Result<models::SecretBundle, set_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/secrets/{}", operation_config.base_path(), secret_name);
    let mut url = url::Url::parse(url_str).map_err(set_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(set_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(set_secret::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(set_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(set_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SecretBundle =
                serde_json::from_slice(rsp_body).map_err(|source| set_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| set_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(set_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod set_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_secret(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
) -> std::result::Result<models::DeletedSecretBundle, delete_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/secrets/{}", operation_config.base_path(), secret_name);
    let mut url = url::Url::parse(url_str).map_err(delete_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedSecretBundle =
                serde_json::from_slice(rsp_body).map_err(|source| delete_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| delete_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_secret(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
    secret_version: &str,
) -> std::result::Result<models::SecretBundle, get_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/secrets/{}/{}", operation_config.base_path(), secret_name, secret_version);
    let mut url = url::Url::parse(url_str).map_err(get_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SecretBundle =
                serde_json::from_slice(rsp_body).map_err(|source| get_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_secret(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
    secret_version: &str,
    parameters: &models::SecretUpdateParameters,
) -> std::result::Result<models::SecretBundle, update_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/secrets/{}/{}", operation_config.base_path(), secret_name, secret_version);
    let mut url = url::Url::parse(url_str).map_err(update_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PATCH);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(update_secret::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(update_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SecretBundle =
                serde_json::from_slice(rsp_body).map_err(|source| update_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| update_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_secrets(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
) -> std::result::Result<models::SecretListResult, get_secrets::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/secrets", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_secrets::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_secrets::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_secrets::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_secrets::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SecretListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_secrets::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_secrets::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_secrets::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_secrets {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_secret_versions(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
    maxresults: Option<i32>,
) -> std::result::Result<models::SecretListResult, get_secret_versions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/secrets/{}/versions", operation_config.base_path(), secret_name);
    let mut url = url::Url::parse(url_str).map_err(get_secret_versions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_secret_versions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_secret_versions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_secret_versions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SecretListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_secret_versions::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_secret_versions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_secret_versions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_secret_versions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_secrets(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
) -> std::result::Result<models::DeletedSecretListResult, get_deleted_secrets::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedsecrets", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_secrets::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_secrets::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_deleted_secrets::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_secrets::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedSecretListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_secrets::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_secrets::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_secrets::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_secrets {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_secret(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
) -> std::result::Result<models::DeletedSecretBundle, get_deleted_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedsecrets/{}", operation_config.base_path(), secret_name);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_deleted_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedSecretBundle =
                serde_json::from_slice(rsp_body).map_err(|source| get_deleted_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_deleted_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn purge_deleted_secret(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
) -> std::result::Result<(), purge_deleted_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedsecrets/{}", operation_config.base_path(), secret_name);
    let mut url = url::Url::parse(url_str).map_err(purge_deleted_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(purge_deleted_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(purge_deleted_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(purge_deleted_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::NO_CONTENT => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| purge_deleted_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(purge_deleted_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod purge_deleted_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_deleted_secret(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
) -> std::result::Result<models::SecretBundle, recover_deleted_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedsecrets/{}/recover", operation_config.base_path(), secret_name);
    let mut url = url::Url::parse(url_str).map_err(recover_deleted_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_deleted_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(recover_deleted_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_deleted_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SecretBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_deleted_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_deleted_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn backup_secret(
    operation_config: &crate::OperationConfig,
    secret_name: &str,
) -> std::result::Result<models::BackupSecretResult, backup_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/secrets/{}/backup", operation_config.base_path(), secret_name);
    let mut url = url::Url::parse(url_str).map_err(backup_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(backup_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(backup_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(backup_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::BackupSecretResult =
                serde_json::from_slice(rsp_body).map_err(|source| backup_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| backup_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(backup_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod backup_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restore_secret(
    operation_config: &crate::OperationConfig,
    parameters: &models::SecretRestoreParameters,
) -> std::result::Result<models::SecretBundle, restore_secret::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/secrets/restore", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(restore_secret::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restore_secret::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(restore_secret::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(restore_secret::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restore_secret::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SecretBundle =
                serde_json::from_slice(rsp_body).map_err(|source| restore_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| restore_secret::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restore_secret::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restore_secret {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_storage_accounts(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
) -> std::result::Result<models::StorageListResult, get_storage_accounts::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_storage_accounts::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_storage_accounts::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_storage_accounts::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_storage_accounts::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::StorageListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_storage_accounts::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_storage_accounts::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_storage_accounts::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_storage_accounts {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_storage_accounts(
    operation_config: &crate::OperationConfig,
    maxresults: Option<i32>,
) -> std::result::Result<models::DeletedStorageListResult, get_deleted_storage_accounts::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedstorage", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_storage_accounts::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_storage_accounts::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deleted_storage_accounts::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_storage_accounts::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedStorageListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_storage_accounts::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_storage_accounts::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_storage_accounts::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_storage_accounts {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_storage_account(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
) -> std::result::Result<models::DeletedStorageBundle, get_deleted_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedstorage/{}", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deleted_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedStorageBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn purge_deleted_storage_account(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
) -> std::result::Result<(), purge_deleted_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedstorage/{}", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(purge_deleted_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(purge_deleted_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(purge_deleted_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(purge_deleted_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::NO_CONTENT => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| purge_deleted_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(purge_deleted_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod purge_deleted_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_deleted_storage_account(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
) -> std::result::Result<models::StorageBundle, recover_deleted_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedstorage/{}/recover", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(recover_deleted_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_deleted_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(recover_deleted_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_deleted_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::StorageBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_deleted_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_deleted_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn backup_storage_account(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
) -> std::result::Result<models::BackupStorageResult, backup_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage/{}/backup", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(backup_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(backup_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(backup_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(backup_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::BackupStorageResult = serde_json::from_slice(rsp_body)
                .map_err(|source| backup_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| backup_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(backup_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod backup_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restore_storage_account(
    operation_config: &crate::OperationConfig,
    parameters: &models::StorageRestoreParameters,
) -> std::result::Result<models::StorageBundle, restore_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage/restore", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(restore_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restore_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(restore_storage_account::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(restore_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restore_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::StorageBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| restore_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| restore_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restore_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restore_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_storage_account(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
) -> std::result::Result<models::StorageBundle, get_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage/{}", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(get_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::StorageBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| get_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn set_storage_account(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    parameters: &models::StorageAccountCreateParameters,
) -> std::result::Result<models::StorageBundle, set_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage/{}", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(set_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(set_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(set_storage_account::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(set_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(set_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::StorageBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| set_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| set_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(set_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod set_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_storage_account(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    parameters: &models::StorageAccountUpdateParameters,
) -> std::result::Result<models::StorageBundle, update_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage/{}", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(update_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PATCH);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(update_storage_account::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::StorageBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| update_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_storage_account(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
) -> std::result::Result<models::DeletedStorageBundle, delete_storage_account::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage/{}", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(delete_storage_account::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_storage_account::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(delete_storage_account::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_storage_account::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedStorageBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_storage_account::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_storage_account::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_storage_account {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn regenerate_storage_account_key(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    parameters: &models::StorageAccountRegenerteKeyParameters,
) -> std::result::Result<models::StorageBundle, regenerate_storage_account_key::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage/{}/regeneratekey", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(regenerate_storage_account_key::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(regenerate_storage_account_key::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(regenerate_storage_account_key::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(regenerate_storage_account_key::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(regenerate_storage_account_key::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::StorageBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| regenerate_storage_account_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| regenerate_storage_account_key::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(regenerate_storage_account_key::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod regenerate_storage_account_key {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_sas_definitions(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    maxresults: Option<i32>,
) -> std::result::Result<models::SasDefinitionListResult, get_sas_definitions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/storage/{}/sas", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(get_sas_definitions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_sas_definitions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_sas_definitions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_sas_definitions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SasDefinitionListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_sas_definitions::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_sas_definitions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_sas_definitions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_sas_definitions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_sas_definitions(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    maxresults: Option<i32>,
) -> std::result::Result<models::DeletedSasDefinitionListResult, get_deleted_sas_definitions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/deletedstorage/{}/sas", operation_config.base_path(), storage_account_name);
    let mut url = url::Url::parse(url_str).map_err(get_deleted_sas_definitions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_sas_definitions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(maxresults) = maxresults {
        url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deleted_sas_definitions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_sas_definitions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedSasDefinitionListResult = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_sas_definitions::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_sas_definitions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_sas_definitions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_sas_definitions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deleted_sas_definition(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    sas_definition_name: &str,
) -> std::result::Result<models::DeletedSasDefinitionBundle, get_deleted_sas_definition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/deletedstorage/{}/sas/{}",
        operation_config.base_path(),
        storage_account_name,
        sas_definition_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_deleted_sas_definition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deleted_sas_definition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deleted_sas_definition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deleted_sas_definition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedSasDefinitionBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deleted_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deleted_sas_definition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deleted_sas_definition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_deleted_sas_definition(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    sas_definition_name: &str,
) -> std::result::Result<models::SasDefinitionBundle, recover_deleted_sas_definition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/deletedstorage/{}/sas/{}/recover",
        operation_config.base_path(),
        storage_account_name,
        sas_definition_name
    );
    let mut url = url::Url::parse(url_str).map_err(recover_deleted_sas_definition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_deleted_sas_definition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(recover_deleted_sas_definition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_deleted_sas_definition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SasDefinitionBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_deleted_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_deleted_sas_definition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_deleted_sas_definition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_sas_definition(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    sas_definition_name: &str,
) -> std::result::Result<models::SasDefinitionBundle, get_sas_definition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/storage/{}/sas/{}",
        operation_config.base_path(),
        storage_account_name,
        sas_definition_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_sas_definition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_sas_definition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_sas_definition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_sas_definition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SasDefinitionBundle =
                serde_json::from_slice(rsp_body).map_err(|source| get_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| get_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_sas_definition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_sas_definition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn set_sas_definition(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    sas_definition_name: &str,
    parameters: &models::SasDefinitionCreateParameters,
) -> std::result::Result<models::SasDefinitionBundle, set_sas_definition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/storage/{}/sas/{}",
        operation_config.base_path(),
        storage_account_name,
        sas_definition_name
    );
    let mut url = url::Url::parse(url_str).map_err(set_sas_definition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(set_sas_definition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(set_sas_definition::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(set_sas_definition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(set_sas_definition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SasDefinitionBundle =
                serde_json::from_slice(rsp_body).map_err(|source| set_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError =
                serde_json::from_slice(rsp_body).map_err(|source| set_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(set_sas_definition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod set_sas_definition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_sas_definition(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    sas_definition_name: &str,
    parameters: &models::SasDefinitionUpdateParameters,
) -> std::result::Result<models::SasDefinitionBundle, update_sas_definition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/storage/{}/sas/{}",
        operation_config.base_path(),
        storage_account_name,
        sas_definition_name
    );
    let mut url = url::Url::parse(url_str).map_err(update_sas_definition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PATCH);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_sas_definition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(parameters).map_err(update_sas_definition::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_sas_definition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_sas_definition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SasDefinitionBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| update_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_sas_definition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_sas_definition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_sas_definition(
    operation_config: &crate::OperationConfig,
    storage_account_name: &str,
    sas_definition_name: &str,
) -> std::result::Result<models::DeletedSasDefinitionBundle, delete_sas_definition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/storage/{}/sas/{}",
        operation_config.base_path(),
        storage_account_name,
        sas_definition_name
    );
    let mut url = url::Url::parse(url_str).map_err(delete_sas_definition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_sas_definition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(delete_sas_definition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_sas_definition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeletedSasDefinitionBundle = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_sas_definition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_sas_definition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_sas_definition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::KeyVaultError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub mod role_definitions {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        scope: &str,
        role_definition_name: &str,
    ) -> std::result::Result<models::RoleDefinition, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/providers/Microsoft.Authorization/roleDefinitions/{}",
            operation_config.base_path(),
            scope,
            role_definition_name
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::RoleDefinition =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        scope: &str,
        role_definition_name: &str,
        parameters: &models::RoleDefinitionCreateParameters,
    ) -> std::result::Result<models::RoleDefinition, create_or_update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/providers/Microsoft.Authorization/roleDefinitions/{}",
            operation_config.base_path(),
            scope,
            role_definition_name
        );
        let mut url = url::Url::parse(url_str).map_err(create_or_update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(parameters).map_err(create_or_update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_or_update::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::RoleDefinition = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        scope: &str,
        role_definition_name: &str,
    ) -> std::result::Result<models::RoleDefinition, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/providers/Microsoft.Authorization/roleDefinitions/{}",
            operation_config.base_path(),
            scope,
            role_definition_name
        );
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::RoleDefinition =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        scope: &str,
        filter: Option<&str>,
    ) -> std::result::Result<models::RoleDefinitionListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/providers/Microsoft.Authorization/roleDefinitions",
            operation_config.base_path(),
            scope
        );
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::RoleDefinitionListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod role_assignments {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        scope: &str,
        role_assignment_name: &str,
    ) -> std::result::Result<models::RoleAssignment, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/providers/Microsoft.Authorization/roleAssignments/{}",
            operation_config.base_path(),
            scope,
            role_assignment_name
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::RoleAssignment =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create(
        operation_config: &crate::OperationConfig,
        scope: &str,
        role_assignment_name: &str,
        parameters: &models::RoleAssignmentCreateParameters,
    ) -> std::result::Result<models::RoleAssignment, create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/providers/Microsoft.Authorization/roleAssignments/{}",
            operation_config.base_path(),
            scope,
            role_assignment_name
        );
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(parameters).map_err(create::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::RoleAssignment =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        scope: &str,
        role_assignment_name: &str,
    ) -> std::result::Result<models::RoleAssignment, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/providers/Microsoft.Authorization/roleAssignments/{}",
            operation_config.base_path(),
            scope,
            role_assignment_name
        );
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::RoleAssignment =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_for_scope(
        operation_config: &crate::OperationConfig,
        scope: &str,
        filter: Option<&str>,
    ) -> std::result::Result<models::RoleAssignmentListResult, list_for_scope::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/providers/Microsoft.Authorization/roleAssignments",
            operation_config.base_path(),
            scope
        );
        let mut url = url::Url::parse(url_str).map_err(list_for_scope::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_for_scope::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(filter) = filter {
            url.query_pairs_mut().append_pair("$filter", filter);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_for_scope::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_for_scope::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::RoleAssignmentListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list_for_scope::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| list_for_scope::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_for_scope::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_for_scope {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod hsm_security_domain {
    use super::{models, API_VERSION};
    pub async fn download_pending(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::SecurityDomainOperationStatus, download_pending::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/securitydomain/download/pending", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(download_pending::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(download_pending::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(download_pending::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(download_pending::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecurityDomainOperationStatus = serde_json::from_slice(rsp_body)
                    .map_err(|source| download_pending::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError = serde_json::from_slice(rsp_body)
                    .map_err(|source| download_pending::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(download_pending::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod download_pending {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn download(
        operation_config: &crate::OperationConfig,
        certificate_info_object: &models::CertificateInfoObject,
    ) -> std::result::Result<models::SecurityDomainObject, download::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/securitydomain/download", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(download::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(download::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(certificate_info_object).map_err(download::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(download::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(download::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecurityDomainObject =
                    serde_json::from_slice(rsp_body).map_err(|source| download::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| download::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(download::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod download {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn transfer_key(operation_config: &crate::OperationConfig) -> std::result::Result<models::TransferKey, transfer_key::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/securitydomain/upload", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(transfer_key::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(transfer_key::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(transfer_key::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(transfer_key::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TransferKey =
                    serde_json::from_slice(rsp_body).map_err(|source| transfer_key::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| transfer_key::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(transfer_key::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod transfer_key {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upload(
        operation_config: &crate::OperationConfig,
        security_domain: &models::SecurityDomainObject,
    ) -> std::result::Result<upload::Response, upload::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/securitydomain/upload", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(upload::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upload::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(security_domain).map_err(upload::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(upload::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(upload::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecurityDomainOperationStatus =
                    serde_json::from_slice(rsp_body).map_err(|source| upload::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(upload::Response::Accepted202(rsp_value))
            }
            http::StatusCode::NO_CONTENT => Ok(upload::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| upload::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upload::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upload {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Accepted202(models::SecurityDomainOperationStatus),
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upload_pending(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::SecurityDomainOperationStatus, upload_pending::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/securitydomain/upload/pending", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(upload_pending::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upload_pending::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(upload_pending::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(upload_pending::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecurityDomainOperationStatus =
                    serde_json::from_slice(rsp_body).map_err(|source| upload_pending::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::KeyVaultError =
                    serde_json::from_slice(rsp_body).map_err(|source| upload_pending::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upload_pending::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upload_pending {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::KeyVaultError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
