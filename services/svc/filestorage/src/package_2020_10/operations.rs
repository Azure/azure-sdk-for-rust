#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use crate::models::*;
pub mod service {
    use crate::models::*;
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
    ) -> std::result::Result<StorageServiceProperties, get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?restype=service&comp=properties", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: StorageServiceProperties =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_properties(
        operation_config: &crate::OperationConfig,
        restype: &str,
        comp: &str,
        storage_service_properties: &StorageServiceProperties,
        timeout: Option<i64>,
        x_ms_version: &str,
    ) -> std::result::Result<(), set_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?restype=service&comp=properties", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(set_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(storage_service_properties).map_err(set_properties::Error::SerializeError)?;
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_properties {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_shares_segment(
        operation_config: &crate::OperationConfig,
        comp: &str,
        prefix: Option<&str>,
        marker: Option<&str>,
        maxresults: Option<i64>,
        include: &Vec<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
    ) -> std::result::Result<ListSharesResponse, list_shares_segment::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/?comp=list", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list_shares_segment::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_shares_segment::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(prefix) = prefix {
            url.query_pairs_mut().append_pair("prefix", prefix);
        }
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_shares_segment::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_shares_segment::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ListSharesResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_shares_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_shares_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_shares_segment::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_shares_segment {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod share {
    use crate::models::*;
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        sharesnapshot: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_share_quota: Option<i64>,
        x_ms_access_tier: Option<&str>,
        x_ms_version: &str,
        x_ms_enabled_protocols: Option<&str>,
        x_ms_root_squash: Option<&str>,
    ) -> std::result::Result<(), create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_share_quota) = x_ms_share_quota {
            req_builder = req_builder.header("x-ms-share-quota", x_ms_share_quota);
        }
        if let Some(x_ms_access_tier) = x_ms_access_tier {
            req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_enabled_protocols) = x_ms_enabled_protocols {
            req_builder = req_builder.header("x-ms-enabled-protocols", x_ms_enabled_protocols);
        }
        if let Some(x_ms_root_squash) = x_ms_root_squash {
            req_builder = req_builder.header("x-ms-root-squash", x_ms_root_squash);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        sharesnapshot: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_delete_snapshots: Option<&str>,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_delete_snapshots) = x_ms_delete_snapshots {
            req_builder = req_builder.header("x-ms-delete-snapshots", x_ms_delete_snapshots);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn acquire_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_lease_duration: Option<i64>,
        x_ms_proposed_lease_id: Option<&str>,
        x_ms_version: &str,
        sharesnapshot: Option<&str>,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), acquire_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=lease&acquire", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(acquire_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(acquire_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_duration) = x_ms_lease_duration {
            req_builder = req_builder.header("x-ms-lease-duration", x_ms_lease_duration);
        }
        if let Some(x_ms_proposed_lease_id) = x_ms_proposed_lease_id {
            req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(acquire_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(acquire_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| acquire_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(acquire_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod acquire_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn release_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        x_ms_version: &str,
        sharesnapshot: Option<&str>,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), release_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=lease&release", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(release_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(release_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(release_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(release_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| release_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(release_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod release_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn change_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        x_ms_proposed_lease_id: Option<&str>,
        x_ms_version: &str,
        sharesnapshot: Option<&str>,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), change_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=lease&change", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(change_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(change_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        if let Some(x_ms_proposed_lease_id) = x_ms_proposed_lease_id {
            req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(change_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(change_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| change_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(change_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod change_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn renew_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        x_ms_version: &str,
        sharesnapshot: Option<&str>,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), renew_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=lease&renew", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(renew_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(renew_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(renew_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(renew_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| renew_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(renew_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod renew_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn break_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_lease_break_period: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        sharesnapshot: Option<&str>,
    ) -> std::result::Result<(), break_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=lease&break", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(break_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(break_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_break_period) = x_ms_lease_break_period {
            req_builder = req_builder.header("x-ms-lease-break-period", x_ms_lease_break_period);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(break_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(break_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| break_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(break_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod break_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_snapshot(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_version: &str,
    ) -> std::result::Result<(), create_snapshot::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=snapshot", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(create_snapshot::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_snapshot::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_snapshot::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_snapshot::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_snapshot::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_snapshot::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_snapshot {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_permission(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        x_ms_file_permission_key: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
    ) -> std::result::Result<SharePermission, get_permission::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=filepermission", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(get_permission::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_permission::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-file-permission-key", x_ms_file_permission_key);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_permission::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_permission::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: SharePermission =
                    serde_json::from_slice(rsp_body).map_err(|source| get_permission::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_permission::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_permission::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_permission {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_permission(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        share_permission: &SharePermission,
    ) -> std::result::Result<(), create_permission::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=filepermission", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(create_permission::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_permission::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(share_permission).map_err(create_permission::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_permission::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_permission::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_permission::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_permission::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_permission {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_properties(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_share_quota: Option<i64>,
        x_ms_access_tier: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_root_squash: Option<&str>,
    ) -> std::result::Result<(), set_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=properties", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(set_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_share_quota) = x_ms_share_quota {
            req_builder = req_builder.header("x-ms-share-quota", x_ms_share_quota);
        }
        if let Some(x_ms_access_tier) = x_ms_access_tier {
            req_builder = req_builder.header("x-ms-access-tier", x_ms_access_tier);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_root_squash) = x_ms_root_squash {
            req_builder = req_builder.header("x-ms-root-squash", x_ms_root_squash);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_properties {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_metadata(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), set_metadata::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=metadata", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(set_metadata::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_metadata::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_metadata::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_metadata::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_metadata::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_metadata::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_metadata {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_access_policy(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<SignedIdentifiers, get_access_policy::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=acl", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(get_access_policy::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_access_policy::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_access_policy::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_access_policy::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: SignedIdentifiers = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_access_policy::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_access_policy::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_access_policy::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_access_policy {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_access_policy(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        share_acl: Option<&SignedIdentifiers>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), set_access_policy::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=acl", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(set_access_policy::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_access_policy::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        let req_body = if let Some(share_acl) = share_acl {
            req_builder = req_builder.header("content-type", "application/json");
            azure_core::to_json(share_acl).map_err(set_access_policy::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_access_policy::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_access_policy::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| set_access_policy::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_access_policy::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_access_policy {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_statistics(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<ShareStats, get_statistics::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=stats", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(get_statistics::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_statistics::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_statistics::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_statistics::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ShareStats =
                    serde_json::from_slice(rsp_body).map_err(|source| get_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_statistics::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_statistics::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_statistics {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn restore(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_deleted_share_name: Option<&str>,
        x_ms_deleted_share_version: Option<&str>,
    ) -> std::result::Result<(), restore::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?restype=share&comp=undelete", operation_config.base_path(), share_name);
        let mut url = url::Url::parse(url_str).map_err(restore::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(restore::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(x_ms_deleted_share_name) = x_ms_deleted_share_name {
            req_builder = req_builder.header("x-ms-deleted-share-name", x_ms_deleted_share_name);
        }
        if let Some(x_ms_deleted_share_version) = x_ms_deleted_share_version {
            req_builder = req_builder.header("x-ms-deleted-share-version", x_ms_deleted_share_version);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(restore::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(restore::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| restore::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(restore::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod restore {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod directory {
    use crate::models::*;
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        restype: &str,
        sharesnapshot: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
    ) -> std::result::Result<(), get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?restype=directory", operation_config.base_path(), share_name, directory);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_version: &str,
        x_ms_file_permission: Option<&str>,
        x_ms_file_permission_key: Option<&str>,
        x_ms_file_attributes: &str,
        x_ms_file_creation_time: &str,
        x_ms_file_last_write_time: &str,
    ) -> std::result::Result<(), create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?restype=directory", operation_config.base_path(), share_name, directory);
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_file_permission) = x_ms_file_permission {
            req_builder = req_builder.header("x-ms-file-permission", x_ms_file_permission);
        }
        if let Some(x_ms_file_permission_key) = x_ms_file_permission_key {
            req_builder = req_builder.header("x-ms-file-permission-key", x_ms_file_permission_key);
        }
        req_builder = req_builder.header("x-ms-file-attributes", x_ms_file_attributes);
        req_builder = req_builder.header("x-ms-file-creation-time", x_ms_file_creation_time);
        req_builder = req_builder.header("x-ms-file-last-write-time", x_ms_file_last_write_time);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        restype: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?restype=directory", operation_config.base_path(), share_name, directory);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_properties(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_file_permission: Option<&str>,
        x_ms_file_permission_key: Option<&str>,
        x_ms_file_attributes: &str,
        x_ms_file_creation_time: &str,
        x_ms_file_last_write_time: &str,
    ) -> std::result::Result<(), set_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?restype=directory&comp=properties",
            operation_config.base_path(),
            share_name,
            directory
        );
        let mut url = url::Url::parse(url_str).map_err(set_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_file_permission) = x_ms_file_permission {
            req_builder = req_builder.header("x-ms-file-permission", x_ms_file_permission);
        }
        if let Some(x_ms_file_permission_key) = x_ms_file_permission_key {
            req_builder = req_builder.header("x-ms-file-permission-key", x_ms_file_permission_key);
        }
        req_builder = req_builder.header("x-ms-file-attributes", x_ms_file_attributes);
        req_builder = req_builder.header("x-ms-file-creation-time", x_ms_file_creation_time);
        req_builder = req_builder.header("x-ms-file-last-write-time", x_ms_file_last_write_time);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_properties {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_metadata(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        restype: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_version: &str,
    ) -> std::result::Result<(), set_metadata::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?restype=directory&comp=metadata",
            operation_config.base_path(),
            share_name,
            directory
        );
        let mut url = url::Url::parse(url_str).map_err(set_metadata::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_metadata::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_metadata::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_metadata::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_metadata::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_metadata::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_metadata {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_files_and_directories_segment(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        restype: &str,
        comp: &str,
        prefix: Option<&str>,
        sharesnapshot: Option<&str>,
        marker: Option<&str>,
        maxresults: Option<i64>,
        timeout: Option<i64>,
        x_ms_version: &str,
        include: &Vec<&str>,
        x_ms_file_extended_info: Option<bool>,
    ) -> std::result::Result<ListFilesAndDirectoriesSegmentResponse, list_files_and_directories_segment::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?restype=directory&comp=list",
            operation_config.base_path(),
            share_name,
            directory
        );
        let mut url = url::Url::parse(url_str).map_err(list_files_and_directories_segment::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_files_and_directories_segment::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(prefix) = prefix {
            url.query_pairs_mut().append_pair("prefix", prefix);
        }
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_file_extended_info) = x_ms_file_extended_info {
            req_builder = req_builder.header("x-ms-file-extended-info", x_ms_file_extended_info.to_string());
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_files_and_directories_segment::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_files_and_directories_segment::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ListFilesAndDirectoriesSegmentResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_files_and_directories_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_files_and_directories_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_files_and_directories_segment::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_files_and_directories_segment {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_handles(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        comp: &str,
        marker: Option<&str>,
        maxresults: Option<i64>,
        timeout: Option<i64>,
        sharesnapshot: Option<&str>,
        x_ms_recursive: Option<bool>,
        x_ms_version: &str,
    ) -> std::result::Result<ListHandlesResponse, list_handles::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=listhandles", operation_config.base_path(), share_name, directory);
        let mut url = url::Url::parse(url_str).map_err(list_handles::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_handles::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(x_ms_recursive) = x_ms_recursive {
            req_builder = req_builder.header("x-ms-recursive", x_ms_recursive.to_string());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_handles::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_handles::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ListHandlesResponse =
                    serde_json::from_slice(rsp_body).map_err(|source| list_handles::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| list_handles::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_handles::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_handles {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn force_close_handles(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        comp: &str,
        timeout: Option<i64>,
        marker: Option<&str>,
        sharesnapshot: Option<&str>,
        x_ms_handle_id: &str,
        x_ms_recursive: Option<bool>,
        x_ms_version: &str,
    ) -> std::result::Result<(), force_close_handles::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?comp=forceclosehandles",
            operation_config.base_path(),
            share_name,
            directory
        );
        let mut url = url::Url::parse(url_str).map_err(force_close_handles::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(force_close_handles::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        req_builder = req_builder.header("x-ms-handle-id", x_ms_handle_id);
        if let Some(x_ms_recursive) = x_ms_recursive {
            req_builder = req_builder.header("x-ms-recursive", x_ms_recursive.to_string());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(force_close_handles::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(force_close_handles::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| force_close_handles::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(force_close_handles::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod force_close_handles {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod file {
    use crate::models::*;
    pub async fn download(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_range: Option<&str>,
        x_ms_range_get_content_md5: Option<bool>,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<download::Response, download::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}/{}", operation_config.base_path(), share_name, directory, file_name);
        let mut url = url::Url::parse(url_str).map_err(download::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(download::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_range) = x_ms_range {
            req_builder = req_builder.header("x-ms-range", x_ms_range);
        }
        if let Some(x_ms_range_get_content_md5) = x_ms_range_get_content_md5 {
            req_builder = req_builder.header("x-ms-range-get-content-md5", x_ms_range_get_content_md5.to_string());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(download::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(download::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| download::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(download::Response::Ok200(rsp_value))
            }
            http::StatusCode::PARTIAL_CONTENT => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| download::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(download::Response::PartialContent206(rsp_value))
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| download::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(download::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod download {
        use crate::{models, models::*};
        #[derive(Debug)]
        pub enum Response {
            Ok200(serde_json::Value),
            PartialContent206(serde_json::Value),
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_content_length: i64,
        x_ms_type: &str,
        x_ms_content_type: Option<&str>,
        x_ms_content_encoding: Option<&str>,
        x_ms_content_language: Option<&str>,
        x_ms_cache_control: Option<&str>,
        x_ms_content_md5: Option<&str>,
        x_ms_content_disposition: Option<&str>,
        x_ms_meta: Option<&str>,
        x_ms_file_permission: Option<&str>,
        x_ms_file_permission_key: Option<&str>,
        x_ms_file_attributes: &str,
        x_ms_file_creation_time: &str,
        x_ms_file_last_write_time: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}/{}", operation_config.base_path(), share_name, directory, file_name);
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        req_builder = req_builder.header("x-ms-content-length", x_ms_content_length);
        req_builder = req_builder.header("x-ms-type", x_ms_type);
        if let Some(x_ms_content_type) = x_ms_content_type {
            req_builder = req_builder.header("x-ms-content-type", x_ms_content_type);
        }
        if let Some(x_ms_content_encoding) = x_ms_content_encoding {
            req_builder = req_builder.header("x-ms-content-encoding", x_ms_content_encoding);
        }
        if let Some(x_ms_content_language) = x_ms_content_language {
            req_builder = req_builder.header("x-ms-content-language", x_ms_content_language);
        }
        if let Some(x_ms_cache_control) = x_ms_cache_control {
            req_builder = req_builder.header("x-ms-cache-control", x_ms_cache_control);
        }
        if let Some(x_ms_content_md5) = x_ms_content_md5 {
            req_builder = req_builder.header("x-ms-content-md5", x_ms_content_md5);
        }
        if let Some(x_ms_content_disposition) = x_ms_content_disposition {
            req_builder = req_builder.header("x-ms-content-disposition", x_ms_content_disposition);
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        if let Some(x_ms_file_permission) = x_ms_file_permission {
            req_builder = req_builder.header("x-ms-file-permission", x_ms_file_permission);
        }
        if let Some(x_ms_file_permission_key) = x_ms_file_permission_key {
            req_builder = req_builder.header("x-ms-file-permission-key", x_ms_file_permission_key);
        }
        req_builder = req_builder.header("x-ms-file-attributes", x_ms_file_attributes);
        req_builder = req_builder.header("x-ms-file-creation-time", x_ms_file_creation_time);
        req_builder = req_builder.header("x-ms-file-last-write-time", x_ms_file_last_write_time);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}/{}", operation_config.base_path(), share_name, directory, file_name);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        sharesnapshot: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}/{}", operation_config.base_path(), share_name, directory, file_name);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_http_headers(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_content_length: Option<i64>,
        x_ms_content_type: Option<&str>,
        x_ms_content_encoding: Option<&str>,
        x_ms_content_language: Option<&str>,
        x_ms_cache_control: Option<&str>,
        x_ms_content_md5: Option<&str>,
        x_ms_content_disposition: Option<&str>,
        x_ms_file_permission: Option<&str>,
        x_ms_file_permission_key: Option<&str>,
        x_ms_file_attributes: &str,
        x_ms_file_creation_time: &str,
        x_ms_file_last_write_time: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), set_http_headers::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=properties",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(set_http_headers::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_http_headers::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_content_length) = x_ms_content_length {
            req_builder = req_builder.header("x-ms-content-length", x_ms_content_length);
        }
        if let Some(x_ms_content_type) = x_ms_content_type {
            req_builder = req_builder.header("x-ms-content-type", x_ms_content_type);
        }
        if let Some(x_ms_content_encoding) = x_ms_content_encoding {
            req_builder = req_builder.header("x-ms-content-encoding", x_ms_content_encoding);
        }
        if let Some(x_ms_content_language) = x_ms_content_language {
            req_builder = req_builder.header("x-ms-content-language", x_ms_content_language);
        }
        if let Some(x_ms_cache_control) = x_ms_cache_control {
            req_builder = req_builder.header("x-ms-cache-control", x_ms_cache_control);
        }
        if let Some(x_ms_content_md5) = x_ms_content_md5 {
            req_builder = req_builder.header("x-ms-content-md5", x_ms_content_md5);
        }
        if let Some(x_ms_content_disposition) = x_ms_content_disposition {
            req_builder = req_builder.header("x-ms-content-disposition", x_ms_content_disposition);
        }
        if let Some(x_ms_file_permission) = x_ms_file_permission {
            req_builder = req_builder.header("x-ms-file-permission", x_ms_file_permission);
        }
        if let Some(x_ms_file_permission_key) = x_ms_file_permission_key {
            req_builder = req_builder.header("x-ms-file-permission-key", x_ms_file_permission_key);
        }
        req_builder = req_builder.header("x-ms-file-attributes", x_ms_file_attributes);
        req_builder = req_builder.header("x-ms-file-creation-time", x_ms_file_creation_time);
        req_builder = req_builder.header("x-ms-file-last-write-time", x_ms_file_last_write_time);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_http_headers::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_http_headers::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| set_http_headers::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_http_headers::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_http_headers {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_metadata(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_meta: Option<&str>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), set_metadata::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=metadata",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(set_metadata::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_metadata::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_metadata::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_metadata::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_metadata::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_metadata::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_metadata {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn acquire_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_duration: Option<i64>,
        x_ms_proposed_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), acquire_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=lease&acquire",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(acquire_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(acquire_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_duration) = x_ms_lease_duration {
            req_builder = req_builder.header("x-ms-lease-duration", x_ms_lease_duration);
        }
        if let Some(x_ms_proposed_lease_id) = x_ms_proposed_lease_id {
            req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(acquire_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(acquire_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| acquire_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(acquire_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod acquire_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn release_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), release_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=lease&release",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(release_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(release_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(release_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(release_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| release_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(release_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod release_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn change_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: &str,
        x_ms_proposed_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), change_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=lease&change",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(change_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(change_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        if let Some(x_ms_proposed_lease_id) = x_ms_proposed_lease_id {
            req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(change_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(change_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| change_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(change_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod change_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn break_lease(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        x_ms_lease_action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), break_lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=lease&break",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(break_lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(break_lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(break_lease::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(break_lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| break_lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(break_lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod break_lease {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upload_range(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        optionalbody: Option<&serde_json::Value>,
        timeout: Option<i64>,
        x_ms_range: &str,
        x_ms_write: &str,
        content_length: i64,
        content_md5: Option<&str>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), upload_range::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=range",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(upload_range::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upload_range::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        let req_body = if let Some(optionalbody) = optionalbody {
            req_builder = req_builder.header("content-type", "application/json");
            azure_core::to_json(optionalbody).map_err(upload_range::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-range", x_ms_range);
        req_builder = req_builder.header("x-ms-write", x_ms_write);
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(upload_range::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(upload_range::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| upload_range::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upload_range::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upload_range {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn upload_range_from_url(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_range: &str,
        x_ms_copy_source: &str,
        x_ms_source_range: Option<&str>,
        x_ms_write: &str,
        content_length: i64,
        x_ms_source_content_crc64: Option<&str>,
        x_ms_source_if_match_crc64: Option<&str>,
        x_ms_source_if_none_match_crc64: Option<&str>,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
        x_ms_copy_source_authorization: Option<&str>,
    ) -> std::result::Result<(), upload_range_from_url::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=range&fromURL",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(upload_range_from_url::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(upload_range_from_url::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-range", x_ms_range);
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        if let Some(x_ms_source_range) = x_ms_source_range {
            req_builder = req_builder.header("x-ms-source-range", x_ms_source_range);
        }
        req_builder = req_builder.header("x-ms-write", x_ms_write);
        req_builder = req_builder.header("Content-Length", content_length);
        if let Some(x_ms_source_content_crc64) = x_ms_source_content_crc64 {
            req_builder = req_builder.header("x-ms-source-content-crc64", x_ms_source_content_crc64);
        }
        if let Some(x_ms_source_if_match_crc64) = x_ms_source_if_match_crc64 {
            req_builder = req_builder.header("x-ms-source-if-match-crc64", x_ms_source_if_match_crc64);
        }
        if let Some(x_ms_source_if_none_match_crc64) = x_ms_source_if_none_match_crc64 {
            req_builder = req_builder.header("x-ms-source-if-none-match-crc64", x_ms_source_if_none_match_crc64);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_copy_source_authorization) = x_ms_copy_source_authorization {
            req_builder = req_builder.header("x-ms-copy-source-authorization", x_ms_copy_source_authorization);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(upload_range_from_url::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(upload_range_from_url::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| upload_range_from_url::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(upload_range_from_url::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod upload_range_from_url {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_range_list(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        sharesnapshot: Option<&str>,
        prevsharesnapshot: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_range: Option<&str>,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<ShareFileRangeList, get_range_list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=rangelist",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(get_range_list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_range_list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        if let Some(prevsharesnapshot) = prevsharesnapshot {
            url.query_pairs_mut().append_pair("prevsharesnapshot", prevsharesnapshot);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_range) = x_ms_range {
            req_builder = req_builder.header("x-ms-range", x_ms_range);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_range_list::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_range_list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ShareFileRangeList =
                    serde_json::from_slice(rsp_body).map_err(|source| get_range_list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_range_list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_range_list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_range_list {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn start_copy(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_meta: Option<&str>,
        x_ms_copy_source: &str,
        x_ms_file_permission: Option<&str>,
        x_ms_file_permission_key: Option<&str>,
        x_ms_file_permission_copy_mode: Option<&str>,
        x_ms_file_copy_ignore_read_only: Option<bool>,
        x_ms_file_attributes: Option<&str>,
        x_ms_file_creation_time: Option<&str>,
        x_ms_file_last_write_time: Option<&str>,
        x_ms_file_copy_set_archive: Option<bool>,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), start_copy::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=copy",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(start_copy::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(start_copy::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_meta) = x_ms_meta {
            req_builder = req_builder.header("x-ms-meta", x_ms_meta);
        }
        req_builder = req_builder.header("x-ms-copy-source", x_ms_copy_source);
        if let Some(x_ms_file_permission) = x_ms_file_permission {
            req_builder = req_builder.header("x-ms-file-permission", x_ms_file_permission);
        }
        if let Some(x_ms_file_permission_key) = x_ms_file_permission_key {
            req_builder = req_builder.header("x-ms-file-permission-key", x_ms_file_permission_key);
        }
        if let Some(x_ms_file_permission_copy_mode) = x_ms_file_permission_copy_mode {
            req_builder = req_builder.header("x-ms-file-permission-copy-mode", x_ms_file_permission_copy_mode);
        }
        if let Some(x_ms_file_copy_ignore_read_only) = x_ms_file_copy_ignore_read_only {
            req_builder = req_builder.header("x-ms-file-copy-ignore-read-only", x_ms_file_copy_ignore_read_only.to_string());
        }
        if let Some(x_ms_file_attributes) = x_ms_file_attributes {
            req_builder = req_builder.header("x-ms-file-attributes", x_ms_file_attributes);
        }
        if let Some(x_ms_file_creation_time) = x_ms_file_creation_time {
            req_builder = req_builder.header("x-ms-file-creation-time", x_ms_file_creation_time);
        }
        if let Some(x_ms_file_last_write_time) = x_ms_file_last_write_time {
            req_builder = req_builder.header("x-ms-file-last-write-time", x_ms_file_last_write_time);
        }
        if let Some(x_ms_file_copy_set_archive) = x_ms_file_copy_set_archive {
            req_builder = req_builder.header("x-ms-file-copy-set-archive", x_ms_file_copy_set_archive.to_string());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(start_copy::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(start_copy::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| start_copy::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(start_copy::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod start_copy {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn abort_copy(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        copyid: &str,
        timeout: Option<i64>,
        x_ms_copy_action: &str,
        x_ms_version: &str,
        x_ms_lease_id: Option<&str>,
    ) -> std::result::Result<(), abort_copy::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=copy&copyid",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(abort_copy::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(abort_copy::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        url.query_pairs_mut().append_pair("copyid", copyid);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-copy-action", x_ms_copy_action);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(abort_copy::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(abort_copy::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| abort_copy::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(abort_copy::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod abort_copy {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_handles(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        marker: Option<&str>,
        maxresults: Option<i64>,
        timeout: Option<i64>,
        sharesnapshot: Option<&str>,
        x_ms_version: &str,
    ) -> std::result::Result<ListHandlesResponse, list_handles::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=listhandles",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(list_handles::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_handles::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(maxresults) = maxresults {
            url.query_pairs_mut().append_pair("maxresults", maxresults.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_handles::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_handles::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ListHandlesResponse =
                    serde_json::from_slice(rsp_body).map_err(|source| list_handles::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| list_handles::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_handles::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_handles {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn force_close_handles(
        operation_config: &crate::OperationConfig,
        share_name: &str,
        directory: &str,
        file_name: &str,
        comp: &str,
        timeout: Option<i64>,
        marker: Option<&str>,
        sharesnapshot: Option<&str>,
        x_ms_handle_id: &str,
        x_ms_version: &str,
    ) -> std::result::Result<(), force_close_handles::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}/{}?comp=forceclosehandles",
            operation_config.base_path(),
            share_name,
            directory,
            file_name
        );
        let mut url = url::Url::parse(url_str).map_err(force_close_handles::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(force_close_handles::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(sharesnapshot) = sharesnapshot {
            url.query_pairs_mut().append_pair("sharesnapshot", sharesnapshot);
        }
        req_builder = req_builder.header("x-ms-handle-id", x_ms_handle_id);
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(force_close_handles::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(force_close_handles::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| force_close_handles::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(force_close_handles::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod force_close_handles {
        use crate::{models, models::*};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
