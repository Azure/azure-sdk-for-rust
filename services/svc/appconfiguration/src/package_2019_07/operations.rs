#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, API_VERSION};
#[non_exhaustive]
#[derive(Debug, thiserror :: Error)]
#[allow(non_camel_case_types)]
pub enum Error {
    #[error(transparent)]
    GetKeys(#[from] get_keys::Error),
    #[error(transparent)]
    CheckKeys(#[from] check_keys::Error),
    #[error(transparent)]
    GetKeyValues(#[from] get_key_values::Error),
    #[error(transparent)]
    CheckKeyValues(#[from] check_key_values::Error),
    #[error(transparent)]
    GetKeyValue(#[from] get_key_value::Error),
    #[error(transparent)]
    PutKeyValue(#[from] put_key_value::Error),
    #[error(transparent)]
    DeleteKeyValue(#[from] delete_key_value::Error),
    #[error(transparent)]
    CheckKeyValue(#[from] check_key_value::Error),
    #[error(transparent)]
    GetLabels(#[from] get_labels::Error),
    #[error(transparent)]
    CheckLabels(#[from] check_labels::Error),
    #[error(transparent)]
    PutLock(#[from] put_lock::Error),
    #[error(transparent)]
    DeleteLock(#[from] delete_lock::Error),
    #[error(transparent)]
    GetRevisions(#[from] get_revisions::Error),
    #[error(transparent)]
    CheckRevisions(#[from] check_revisions::Error),
}
pub async fn get_keys(
    operation_config: &crate::OperationConfig,
    name: Option<&str>,
    sync_token: Option<&str>,
    after: Option<&str>,
    accept_datetime: Option<&str>,
) -> std::result::Result<models::KeyListResult, get_keys::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_keys::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_keys::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(name) = name {
        url.query_pairs_mut().append_pair("name", name);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(after) = after {
        url.query_pairs_mut().append_pair("After", after);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_keys::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_keys::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_keys::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| get_keys::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_keys::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_keys {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn check_keys(
    operation_config: &crate::OperationConfig,
    name: Option<&str>,
    sync_token: Option<&str>,
    after: Option<&str>,
    accept_datetime: Option<&str>,
) -> std::result::Result<(), check_keys::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/keys", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(check_keys::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::HEAD);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(check_keys::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(name) = name {
        url.query_pairs_mut().append_pair("name", name);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(after) = after {
        url.query_pairs_mut().append_pair("After", after);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(check_keys::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(check_keys::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => Err(check_keys::Error::DefaultResponse { status_code }),
    }
}
pub mod check_keys {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse { status_code: http::StatusCode },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_key_values(
    operation_config: &crate::OperationConfig,
    key: Option<&str>,
    label: Option<&str>,
    sync_token: Option<&str>,
    after: Option<&str>,
    accept_datetime: Option<&str>,
    select: &[&str],
) -> std::result::Result<models::KeyValueListResult, get_key_values::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/kv", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_key_values::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_key_values::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(key) = key {
        url.query_pairs_mut().append_pair("key", key);
    }
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(after) = after {
        url.query_pairs_mut().append_pair("After", after);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_key_values::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_key_values::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyValueListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_key_values::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| get_key_values::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_key_values::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_key_values {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn check_key_values(
    operation_config: &crate::OperationConfig,
    key: Option<&str>,
    label: Option<&str>,
    sync_token: Option<&str>,
    after: Option<&str>,
    accept_datetime: Option<&str>,
    select: &[&str],
) -> std::result::Result<(), check_key_values::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/kv", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(check_key_values::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::HEAD);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(check_key_values::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(key) = key {
        url.query_pairs_mut().append_pair("key", key);
    }
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(after) = after {
        url.query_pairs_mut().append_pair("After", after);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(check_key_values::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(check_key_values::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => Err(check_key_values::Error::DefaultResponse { status_code }),
    }
}
pub mod check_key_values {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse { status_code: http::StatusCode },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_key_value(
    operation_config: &crate::OperationConfig,
    key: &str,
    label: Option<&str>,
    sync_token: Option<&str>,
    accept_datetime: Option<&str>,
    if_match: Option<&str>,
    if_none_match: Option<&str>,
    select: &[&str],
) -> std::result::Result<models::KeyValue, get_key_value::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/kv/{}", operation_config.base_path(), key);
    let mut url = url::Url::parse(url_str).map_err(get_key_value::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_key_value::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    if let Some(if_match) = if_match {
        req_builder = req_builder.header("If-Match", if_match);
    }
    if let Some(if_none_match) = if_none_match {
        req_builder = req_builder.header("If-None-Match", if_none_match);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_key_value::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_key_value::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyValue =
                serde_json::from_slice(rsp_body).map_err(|source| get_key_value::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| get_key_value::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_key_value::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_key_value {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn put_key_value(
    operation_config: &crate::OperationConfig,
    key: &str,
    label: Option<&str>,
    entity: Option<&models::KeyValue>,
    sync_token: Option<&str>,
    if_match: Option<&str>,
    if_none_match: Option<&str>,
) -> std::result::Result<models::KeyValue, put_key_value::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/kv/{}", operation_config.base_path(), key);
    let mut url = url::Url::parse(url_str).map_err(put_key_value::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(put_key_value::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    let req_body = if let Some(entity) = entity {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(entity).map_err(put_key_value::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(if_match) = if_match {
        req_builder = req_builder.header("If-Match", if_match);
    }
    if let Some(if_none_match) = if_none_match {
        req_builder = req_builder.header("If-None-Match", if_none_match);
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(put_key_value::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(put_key_value::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyValue =
                serde_json::from_slice(rsp_body).map_err(|source| put_key_value::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| put_key_value::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(put_key_value::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod put_key_value {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_key_value(
    operation_config: &crate::OperationConfig,
    key: &str,
    label: Option<&str>,
    sync_token: Option<&str>,
    if_match: Option<&str>,
) -> std::result::Result<delete_key_value::Response, delete_key_value::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/kv/{}", operation_config.base_path(), key);
    let mut url = url::Url::parse(url_str).map_err(delete_key_value::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_key_value::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(if_match) = if_match {
        req_builder = req_builder.header("If-Match", if_match);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_key_value::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_key_value::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyValue =
                serde_json::from_slice(rsp_body).map_err(|source| delete_key_value::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(delete_key_value::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(delete_key_value::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| delete_key_value::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_key_value::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_key_value {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::KeyValue),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn check_key_value(
    operation_config: &crate::OperationConfig,
    key: &str,
    label: Option<&str>,
    sync_token: Option<&str>,
    accept_datetime: Option<&str>,
    if_match: Option<&str>,
    if_none_match: Option<&str>,
    select: &[&str],
) -> std::result::Result<(), check_key_value::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/kv/{}", operation_config.base_path(), key);
    let mut url = url::Url::parse(url_str).map_err(check_key_value::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::HEAD);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(check_key_value::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    if let Some(if_match) = if_match {
        req_builder = req_builder.header("If-Match", if_match);
    }
    if let Some(if_none_match) = if_none_match {
        req_builder = req_builder.header("If-None-Match", if_none_match);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(check_key_value::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(check_key_value::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => Err(check_key_value::Error::DefaultResponse { status_code }),
    }
}
pub mod check_key_value {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse { status_code: http::StatusCode },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_labels(
    operation_config: &crate::OperationConfig,
    name: Option<&str>,
    sync_token: Option<&str>,
    after: Option<&str>,
    accept_datetime: Option<&str>,
    select: &[&str],
) -> std::result::Result<models::LabelListResult, get_labels::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/labels", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_labels::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_labels::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(name) = name {
        url.query_pairs_mut().append_pair("name", name);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(after) = after {
        url.query_pairs_mut().append_pair("After", after);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_labels::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_labels::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::LabelListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_labels::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| get_labels::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_labels::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_labels {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn check_labels(
    operation_config: &crate::OperationConfig,
    name: Option<&str>,
    sync_token: Option<&str>,
    after: Option<&str>,
    accept_datetime: Option<&str>,
    select: &[&str],
) -> std::result::Result<(), check_labels::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/labels", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(check_labels::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::HEAD);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(check_labels::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(name) = name {
        url.query_pairs_mut().append_pair("name", name);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(after) = after {
        url.query_pairs_mut().append_pair("After", after);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(check_labels::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(check_labels::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => Err(check_labels::Error::DefaultResponse { status_code }),
    }
}
pub mod check_labels {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse { status_code: http::StatusCode },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn put_lock(
    operation_config: &crate::OperationConfig,
    key: &str,
    label: Option<&str>,
    sync_token: Option<&str>,
    if_match: Option<&str>,
    if_none_match: Option<&str>,
) -> std::result::Result<models::KeyValue, put_lock::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/locks/{}", operation_config.base_path(), key);
    let mut url = url::Url::parse(url_str).map_err(put_lock::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(put_lock::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(if_match) = if_match {
        req_builder = req_builder.header("If-Match", if_match);
    }
    if let Some(if_none_match) = if_none_match {
        req_builder = req_builder.header("If-None-Match", if_none_match);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(put_lock::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(put_lock::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyValue =
                serde_json::from_slice(rsp_body).map_err(|source| put_lock::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| put_lock::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(put_lock::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod put_lock {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_lock(
    operation_config: &crate::OperationConfig,
    key: &str,
    label: Option<&str>,
    sync_token: Option<&str>,
    if_match: Option<&str>,
    if_none_match: Option<&str>,
) -> std::result::Result<models::KeyValue, delete_lock::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/locks/{}", operation_config.base_path(), key);
    let mut url = url::Url::parse(url_str).map_err(delete_lock::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_lock::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(if_match) = if_match {
        req_builder = req_builder.header("If-Match", if_match);
    }
    if let Some(if_none_match) = if_none_match {
        req_builder = req_builder.header("If-None-Match", if_none_match);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_lock::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_lock::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyValue =
                serde_json::from_slice(rsp_body).map_err(|source| delete_lock::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| delete_lock::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_lock::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_lock {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_revisions(
    operation_config: &crate::OperationConfig,
    key: Option<&str>,
    label: Option<&str>,
    sync_token: Option<&str>,
    after: Option<&str>,
    accept_datetime: Option<&str>,
    select: &[&str],
) -> std::result::Result<models::KeyValueListResult, get_revisions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/revisions", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_revisions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_revisions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(key) = key {
        url.query_pairs_mut().append_pair("key", key);
    }
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(after) = after {
        url.query_pairs_mut().append_pair("After", after);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_revisions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_revisions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::KeyValueListResult =
                serde_json::from_slice(rsp_body).map_err(|source| get_revisions::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::Error =
                serde_json::from_slice(rsp_body).map_err(|source| get_revisions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_revisions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_revisions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::Error,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn check_revisions(
    operation_config: &crate::OperationConfig,
    key: Option<&str>,
    label: Option<&str>,
    sync_token: Option<&str>,
    after: Option<&str>,
    accept_datetime: Option<&str>,
    select: &[&str],
) -> std::result::Result<(), check_revisions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/revisions", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(check_revisions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::HEAD);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(check_revisions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(key) = key {
        url.query_pairs_mut().append_pair("key", key);
    }
    if let Some(label) = label {
        url.query_pairs_mut().append_pair("label", label);
    }
    if let Some(sync_token) = sync_token {
        req_builder = req_builder.header("Sync-Token", sync_token);
    }
    if let Some(after) = after {
        url.query_pairs_mut().append_pair("After", after);
    }
    if let Some(accept_datetime) = accept_datetime {
        req_builder = req_builder.header("Accept-Datetime", accept_datetime);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(check_revisions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(check_revisions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => Err(check_revisions::Error::DefaultResponse { status_code }),
    }
}
pub mod check_revisions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse { status_code: http::StatusCode },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
