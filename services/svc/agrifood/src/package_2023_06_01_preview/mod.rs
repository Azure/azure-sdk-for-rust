#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::redundant_clone)]
pub mod models;
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
    options: azure_core::ClientOptions,
}
pub const DEFAULT_ENDPOINT: &str = azure_core::resource_manager_endpoint::AZURE_PUBLIC_CLOUD;
impl ClientBuilder {
    #[doc = "Create a new instance of `ClientBuilder`."]
    #[must_use]
    pub fn new(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
            options: azure_core::ClientOptions::default(),
        }
    }
    #[doc = "Set the endpoint."]
    #[must_use]
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    #[doc = "Set the scopes."]
    #[must_use]
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    #[doc = "Set the retry options."]
    #[must_use]
    pub fn retry(mut self, retry: impl Into<azure_core::RetryOptions>) -> Self {
        self.options = self.options.retry(retry);
        self
    }
    #[doc = "Set the transport options."]
    #[must_use]
    pub fn transport(mut self, transport: impl Into<azure_core::TransportOptions>) -> Self {
        self.options = self.options.transport(transport);
        self
    }
    #[doc = "Convert the builder into a `Client` instance."]
    #[must_use]
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self.scopes.unwrap_or_else(|| vec![format!("{endpoint}/")]);
        Client::new(endpoint, self.credential, scopes, self.options)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn token_credential(&self) -> &dyn azure_core::auth::TokenCredential {
        self.credential.as_ref()
    }
    pub(crate) fn scopes(&self) -> Vec<&str> {
        self.scopes.iter().map(String::as_str).collect()
    }
    pub(crate) async fn send(&self, request: &mut azure_core::Request) -> azure_core::Result<azure_core::Response> {
        let context = azure_core::Context::default();
        self.pipeline.send(&context, request).await
    }
    #[doc = "Create a new `ClientBuilder`."]
    #[must_use]
    pub fn builder(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> ClientBuilder {
        ClientBuilder::new(credential)
    }
    #[doc = "Create a new `Client`."]
    #[must_use]
    pub fn new(
        endpoint: impl Into<String>,
        credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
        scopes: Vec<String>,
        options: azure_core::ClientOptions,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            options,
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn application_data_client(&self) -> application_data::Client {
        application_data::Client(self.clone())
    }
    pub fn attachments_client(&self) -> attachments::Client {
        attachments::Client(self.clone())
    }
    pub fn boundaries_client(&self) -> boundaries::Client {
        boundaries::Client(self.clone())
    }
    pub fn crop_products_client(&self) -> crop_products::Client {
        crop_products::Client(self.clone())
    }
    pub fn crops_client(&self) -> crops::Client {
        crops::Client(self.clone())
    }
    pub fn device_data_models_client(&self) -> device_data_models::Client {
        device_data_models::Client(self.clone())
    }
    pub fn devices_client(&self) -> devices::Client {
        devices::Client(self.clone())
    }
    pub fn farm_operations_client(&self) -> farm_operations::Client {
        farm_operations::Client(self.clone())
    }
    pub fn farms_client(&self) -> farms::Client {
        farms::Client(self.clone())
    }
    pub fn fields_client(&self) -> fields::Client {
        fields::Client(self.clone())
    }
    pub fn harvest_data_client(&self) -> harvest_data::Client {
        harvest_data::Client(self.clone())
    }
    pub fn image_processing_client(&self) -> image_processing::Client {
        image_processing::Client(self.clone())
    }
    pub fn insight_attachments_client(&self) -> insight_attachments::Client {
        insight_attachments::Client(self.clone())
    }
    pub fn insights_client(&self) -> insights::Client {
        insights::Client(self.clone())
    }
    pub fn management_zones_client(&self) -> management_zones::Client {
        management_zones::Client(self.clone())
    }
    pub fn model_inference_client(&self) -> model_inference::Client {
        model_inference::Client(self.clone())
    }
    pub fn nutrient_analyses_client(&self) -> nutrient_analyses::Client {
        nutrient_analyses::Client(self.clone())
    }
    pub fn o_auth_providers_client(&self) -> o_auth_providers::Client {
        o_auth_providers::Client(self.clone())
    }
    pub fn o_auth_tokens_client(&self) -> o_auth_tokens::Client {
        o_auth_tokens::Client(self.clone())
    }
    pub fn parties_client(&self) -> parties::Client {
        parties::Client(self.clone())
    }
    pub fn plant_tissue_analyses_client(&self) -> plant_tissue_analyses::Client {
        plant_tissue_analyses::Client(self.clone())
    }
    pub fn planting_data_client(&self) -> planting_data::Client {
        planting_data::Client(self.clone())
    }
    pub fn prescription_maps_client(&self) -> prescription_maps::Client {
        prescription_maps::Client(self.clone())
    }
    pub fn prescriptions_client(&self) -> prescriptions::Client {
        prescriptions::Client(self.clone())
    }
    pub fn scenes_client(&self) -> scenes::Client {
        scenes::Client(self.clone())
    }
    pub fn seasonal_fields_client(&self) -> seasonal_fields::Client {
        seasonal_fields::Client(self.clone())
    }
    pub fn seasons_client(&self) -> seasons::Client {
        seasons::Client(self.clone())
    }
    pub fn sensor_data_models_client(&self) -> sensor_data_models::Client {
        sensor_data_models::Client(self.clone())
    }
    pub fn sensor_events_client(&self) -> sensor_events::Client {
        sensor_events::Client(self.clone())
    }
    pub fn sensor_mappings_client(&self) -> sensor_mappings::Client {
        sensor_mappings::Client(self.clone())
    }
    pub fn sensor_partner_integrations_client(&self) -> sensor_partner_integrations::Client {
        sensor_partner_integrations::Client(self.clone())
    }
    pub fn sensors_client(&self) -> sensors::Client {
        sensors::Client(self.clone())
    }
    pub fn solution_inference_client(&self) -> solution_inference::Client {
        solution_inference::Client(self.clone())
    }
    pub fn tillage_data_client(&self) -> tillage_data::Client {
        tillage_data::Client(self.clone())
    }
    pub fn weather_client(&self) -> weather::Client {
        weather::Client(self.clone())
    }
    pub fn weather_data_client(&self) -> weather_data::Client {
        weather_data::Client(self.clone())
    }
    pub fn zones_client(&self) -> zones::Client {
        zones::Client(self.clone())
    }
}
pub mod application_data {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of application data resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                min_avg_material: None,
                max_avg_material: None,
                min_total_material: None,
                max_total_material: None,
                sources: Vec::new(),
                associated_boundary_ids: Vec::new(),
                min_operation_start_date_time: None,
                max_operation_start_date_time: None,
                min_operation_end_date_time: None,
                max_operation_end_date_time: None,
                min_operation_modified_date_time: None,
                max_operation_modified_date_time: None,
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get cascade delete job for application data resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create cascade delete job for application data resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job Id supplied by end user."]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `application_data_id`: Id of the application data."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            application_data_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                application_data_id: application_data_id.into(),
            }
        }
        #[doc = "Returns a paginated list of application data resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                min_avg_material: None,
                max_avg_material: None,
                min_total_material: None,
                max_total_material: None,
                sources: Vec::new(),
                associated_boundary_ids: Vec::new(),
                min_operation_start_date_time: None,
                max_operation_start_date_time: None,
                min_operation_end_date_time: None,
                max_operation_end_date_time: None,
                min_operation_modified_date_time: None,
                max_operation_modified_date_time: None,
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a specified application data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `application_data_id`: ID of the application data resource."]
        pub fn get(&self, party_id: impl Into<String>, application_data_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                application_data_id: application_data_id.into(),
            }
        }
        #[doc = "Creates or updates an application data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `application_data_id`: ID of the application data resource."]
        #[doc = "* `application_data`: Application data resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            application_data_id: impl Into<String>,
            application_data: impl Into<models::ApplicationData>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                application_data_id: application_data_id.into(),
                application_data: application_data.into(),
            }
        }
        #[doc = "Deletes a specified application data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `application_data_id`: ID of the application data."]
        pub fn delete(&self, party_id: impl Into<String>, application_data_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                application_data_id: application_data_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ApplicationDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ApplicationDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) min_avg_material: Option<f64>,
            pub(crate) max_avg_material: Option<f64>,
            pub(crate) min_total_material: Option<f64>,
            pub(crate) max_total_material: Option<f64>,
            pub(crate) sources: Vec<String>,
            pub(crate) associated_boundary_ids: Vec<String>,
            pub(crate) min_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum average amount of material applied during the application (inclusive)."]
            pub fn min_avg_material(mut self, min_avg_material: f64) -> Self {
                self.min_avg_material = Some(min_avg_material);
                self
            }
            #[doc = "Maximum average amount of material applied during the application (inclusive)."]
            pub fn max_avg_material(mut self, max_avg_material: f64) -> Self {
                self.max_avg_material = Some(max_avg_material);
                self
            }
            #[doc = "Minimum total amount of material applied during the application (inclusive)."]
            pub fn min_total_material(mut self, min_total_material: f64) -> Self {
                self.min_total_material = Some(min_total_material);
                self
            }
            #[doc = "Maximum total amount of material applied during the application (inclusive)."]
            pub fn max_total_material(mut self, max_total_material: f64) -> Self {
                self.max_total_material = Some(max_total_material);
                self
            }
            #[doc = "Sources of the operation data."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Boundary IDs associated with operation data."]
            pub fn associated_boundary_ids(mut self, associated_boundary_ids: Vec<String>) -> Self {
                self.associated_boundary_ids = associated_boundary_ids;
                self
            }
            #[doc = "Minimum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_start_date_time(mut self, min_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_start_date_time = Some(min_operation_start_date_time.into());
                self
            }
            #[doc = "Maximum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_start_date_time(mut self, max_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_start_date_time = Some(max_operation_start_date_time.into());
                self
            }
            #[doc = "Minimum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_end_date_time(mut self, min_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_end_date_time = Some(min_operation_end_date_time.into());
                self
            }
            #[doc = "Maximum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_end_date_time(mut self, max_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_end_date_time = Some(max_operation_end_date_time.into());
                self
            }
            #[doc = "Minimum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_modified_date_time(mut self, min_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_modified_date_time = Some(min_operation_modified_date_time.into());
                self
            }
            #[doc = "Maximum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_modified_date_time(mut self, max_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_modified_date_time = Some(max_operation_modified_date_time.into());
                self
            }
            #[doc = "Minimum area for which operation was applied (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum area for which operation was applied (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::ApplicationDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_avg_material) = &this.min_avg_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgMaterial", &min_avg_material.to_string());
                                }
                                if let Some(max_avg_material) = &this.max_avg_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgMaterial", &max_avg_material.to_string());
                                }
                                if let Some(min_total_material) = &this.min_total_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTotalMaterial", &min_total_material.to_string());
                                }
                                if let Some(max_total_material) = &this.max_total_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTotalMaterial", &max_total_material.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let associated_boundary_ids = &this.associated_boundary_ids;
                                for value in &this.associated_boundary_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("associatedBoundaryIds", &value.to_string());
                                }
                                if let Some(min_operation_start_date_time) = &this.min_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationStartDateTime", &min_operation_start_date_time.to_string());
                                }
                                if let Some(max_operation_start_date_time) = &this.max_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationStartDateTime", &max_operation_start_date_time.to_string());
                                }
                                if let Some(min_operation_end_date_time) = &this.min_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationEndDateTime", &min_operation_end_date_time.to_string());
                                }
                                if let Some(max_operation_end_date_time) = &this.max_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationEndDateTime", &max_operation_end_date_time.to_string());
                                }
                                if let Some(min_operation_modified_date_time) = &this.min_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationModifiedDateTime", &min_operation_modified_date_time.to_string());
                                }
                                if let Some(max_operation_modified_date_time) = &this.max_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationModifiedDateTime", &max_operation_modified_date_time.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/application-data", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/application-data/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) application_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let application_data_id = &this.application_data_id;
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("applicationDataId", application_data_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/application-data/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ApplicationDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ApplicationDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) min_avg_material: Option<f64>,
            pub(crate) max_avg_material: Option<f64>,
            pub(crate) min_total_material: Option<f64>,
            pub(crate) max_total_material: Option<f64>,
            pub(crate) sources: Vec<String>,
            pub(crate) associated_boundary_ids: Vec<String>,
            pub(crate) min_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum average amount of material applied during the application (inclusive)."]
            pub fn min_avg_material(mut self, min_avg_material: f64) -> Self {
                self.min_avg_material = Some(min_avg_material);
                self
            }
            #[doc = "Maximum average amount of material applied during the application (inclusive)."]
            pub fn max_avg_material(mut self, max_avg_material: f64) -> Self {
                self.max_avg_material = Some(max_avg_material);
                self
            }
            #[doc = "Minimum total amount of material applied during the application (inclusive)."]
            pub fn min_total_material(mut self, min_total_material: f64) -> Self {
                self.min_total_material = Some(min_total_material);
                self
            }
            #[doc = "Maximum total amount of material applied during the application (inclusive)."]
            pub fn max_total_material(mut self, max_total_material: f64) -> Self {
                self.max_total_material = Some(max_total_material);
                self
            }
            #[doc = "Sources of the operation data."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Boundary IDs associated with operation data."]
            pub fn associated_boundary_ids(mut self, associated_boundary_ids: Vec<String>) -> Self {
                self.associated_boundary_ids = associated_boundary_ids;
                self
            }
            #[doc = "Minimum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_start_date_time(mut self, min_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_start_date_time = Some(min_operation_start_date_time.into());
                self
            }
            #[doc = "Maximum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_start_date_time(mut self, max_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_start_date_time = Some(max_operation_start_date_time.into());
                self
            }
            #[doc = "Minimum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_end_date_time(mut self, min_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_end_date_time = Some(min_operation_end_date_time.into());
                self
            }
            #[doc = "Maximum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_end_date_time(mut self, max_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_end_date_time = Some(max_operation_end_date_time.into());
                self
            }
            #[doc = "Minimum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_modified_date_time(mut self, min_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_modified_date_time = Some(min_operation_modified_date_time.into());
                self
            }
            #[doc = "Maximum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_modified_date_time(mut self, max_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_modified_date_time = Some(max_operation_modified_date_time.into());
                self
            }
            #[doc = "Minimum area for which operation was applied (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum area for which operation was applied (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::ApplicationDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_avg_material) = &this.min_avg_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgMaterial", &min_avg_material.to_string());
                                }
                                if let Some(max_avg_material) = &this.max_avg_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgMaterial", &max_avg_material.to_string());
                                }
                                if let Some(min_total_material) = &this.min_total_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTotalMaterial", &min_total_material.to_string());
                                }
                                if let Some(max_total_material) = &this.max_total_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTotalMaterial", &max_total_material.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let associated_boundary_ids = &this.associated_boundary_ids;
                                for value in &this.associated_boundary_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("associatedBoundaryIds", &value.to_string());
                                }
                                if let Some(min_operation_start_date_time) = &this.min_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationStartDateTime", &min_operation_start_date_time.to_string());
                                }
                                if let Some(max_operation_start_date_time) = &this.max_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationStartDateTime", &max_operation_start_date_time.to_string());
                                }
                                if let Some(min_operation_end_date_time) = &this.min_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationEndDateTime", &min_operation_end_date_time.to_string());
                                }
                                if let Some(max_operation_end_date_time) = &this.max_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationEndDateTime", &max_operation_end_date_time.to_string());
                                }
                                if let Some(min_operation_modified_date_time) = &this.min_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationModifiedDateTime", &min_operation_modified_date_time.to_string());
                                }
                                if let Some(max_operation_modified_date_time) = &this.max_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationModifiedDateTime", &max_operation_modified_date_time.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/application-data", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ApplicationData> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ApplicationData = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) application_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/application-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.application_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::ApplicationData>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::ApplicationData>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ApplicationData> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ApplicationData = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) application_data_id: String,
            pub(crate) application_data: models::ApplicationData,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.application_data)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/application-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.application_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::ApplicationData>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::ApplicationData>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) application_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/application-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.application_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod attachments {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of attachment resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                resource_ids: Vec::new(),
                resource_types: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified attachment resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `attachment_id`: Id of the attachment."]
        pub fn get(&self, party_id: impl Into<String>, attachment_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                attachment_id: attachment_id.into(),
            }
        }
        #[doc = "Creates or updates an attachment resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party resource."]
        #[doc = "* `attachment_id`: Id of the attachment resource."]
        pub fn create_or_update(&self, party_id: impl Into<String>, attachment_id: impl Into<String>) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                attachment_id: attachment_id.into(),
                file: None,
                resource_id: None,
                resource_type: None,
                original_file_name: None,
                id: None,
                status: None,
                created_date_time: None,
                modified_date_time: None,
                source: None,
                name: None,
                description: None,
                created_by: None,
                modified_by: None,
                e_tag: None,
            }
        }
        #[doc = "Deletes a specified attachment resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `attachment_id`: Id of the attachment."]
        pub fn delete(&self, party_id: impl Into<String>, attachment_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                attachment_id: attachment_id.into(),
            }
        }
        #[doc = "Downloads and returns attachment as response for the given input filePath."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `attachment_id`: Id of attachment to be downloaded."]
        pub fn download(&self, party_id: impl Into<String>, attachment_id: impl Into<String>) -> download::RequestBuilder {
            download::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                attachment_id: attachment_id.into(),
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::AttachmentListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::AttachmentListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) resource_ids: Vec<String>,
            pub(crate) resource_types: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Resource Ids of the resource."]
            pub fn resource_ids(mut self, resource_ids: Vec<String>) -> Self {
                self.resource_ids = resource_ids;
                self
            }
            #[doc = "Resource Types of the resource.\r\ni.e. Party, Farm, Field, SeasonalField, Boundary, ApplicationData, HarvestData, TillageData, PlantingData, PlantTissueAnalysis."]
            pub fn resource_types(mut self, resource_types: Vec<String>) -> Self {
                self.resource_types = resource_types;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::AttachmentListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let resource_ids = &this.resource_ids;
                                for value in &this.resource_ids {
                                    req.url_mut().query_pairs_mut().append_pair("resourceIds", &value.to_string());
                                }
                                let resource_types = &this.resource_types;
                                for value in &this.resource_types {
                                    req.url_mut().query_pairs_mut().append_pair("resourceTypes", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/attachments", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Attachment> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Attachment = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) attachment_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/attachments/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.attachment_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Attachment>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Attachment>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Attachment> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Attachment = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) attachment_id: String,
            pub(crate) file: Option<bytes::Bytes>,
            pub(crate) resource_id: Option<String>,
            pub(crate) resource_type: Option<String>,
            pub(crate) original_file_name: Option<String>,
            pub(crate) id: Option<String>,
            pub(crate) status: Option<String>,
            pub(crate) created_date_time: Option<time::OffsetDateTime>,
            pub(crate) modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) source: Option<String>,
            pub(crate) name: Option<String>,
            pub(crate) description: Option<String>,
            pub(crate) created_by: Option<String>,
            pub(crate) modified_by: Option<String>,
            pub(crate) e_tag: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "File to be uploaded."]
            pub fn file(mut self, file: impl Into<bytes::Bytes>) -> Self {
                self.file = Some(file.into());
                self
            }
            #[doc = "Associated Resource id for this attachment."]
            pub fn resource_id(mut self, resource_id: impl Into<String>) -> Self {
                self.resource_id = Some(resource_id.into());
                self
            }
            #[doc = "Associated Resource type for this attachment."]
            pub fn resource_type(mut self, resource_type: impl Into<String>) -> Self {
                self.resource_type = Some(resource_type.into());
                self
            }
            #[doc = "Original File Name for this attachment."]
            pub fn original_file_name(mut self, original_file_name: impl Into<String>) -> Self {
                self.original_file_name = Some(original_file_name.into());
                self
            }
            #[doc = "Unique id."]
            pub fn id(mut self, id: impl Into<String>) -> Self {
                self.id = Some(id.into());
                self
            }
            #[doc = "Status of the resource."]
            pub fn status(mut self, status: impl Into<String>) -> Self {
                self.status = Some(status.into());
                self
            }
            #[doc = "Date when resource was created."]
            pub fn created_date_time(mut self, created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.created_date_time = Some(created_date_time.into());
                self
            }
            #[doc = "Date when resource was last modified."]
            pub fn modified_date_time(mut self, modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.modified_date_time = Some(modified_date_time.into());
                self
            }
            #[doc = "Source of the resource."]
            pub fn source(mut self, source: impl Into<String>) -> Self {
                self.source = Some(source.into());
                self
            }
            #[doc = "Name to identify resource."]
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            #[doc = "Textual description of resource."]
            pub fn description(mut self, description: impl Into<String>) -> Self {
                self.description = Some(description.into());
                self
            }
            #[doc = "Created by user/tenant id."]
            pub fn created_by(mut self, created_by: impl Into<String>) -> Self {
                self.created_by = Some(created_by.into());
                self
            }
            #[doc = "Modified by user/tenant id."]
            pub fn modified_by(mut self, modified_by: impl Into<String>) -> Self {
                self.modified_by = Some(modified_by.into());
                self
            }
            #[doc = "The ETag value to implement optimistic concurrency."]
            pub fn e_tag(mut self, e_tag: impl Into<String>) -> Self {
                self.e_tag = Some(e_tag.into());
                self
            }
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/attachments/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.attachment_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Attachment>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Attachment>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) attachment_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/attachments/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.attachment_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod download {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<bytes::Bytes> {
                let bytes = self.0.into_body().collect().await?;
                let body = bytes;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) attachment_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/attachments/{}/file",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.attachment_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<bytes::Bytes>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<bytes::Bytes>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod boundaries {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of boundary resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                parent_type: None,
                type_: None,
                parent_ids: Vec::new(),
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Search for boundaries across all parties by fields and intersecting geometry."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `search_boundary_query`: Query filters."]
        pub fn search(&self, search_boundary_query: impl Into<models::SearchBoundaryQuery>) -> search::RequestBuilder {
            search::RequestBuilder {
                client: self.0.clone(),
                search_boundary_query: search_boundary_query.into(),
            }
        }
        #[doc = "Get cascade delete job for specified boundary."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified boundary."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `boundary_id`: ID of the boundary to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            boundary_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                boundary_id: boundary_id.into(),
            }
        }
        #[doc = "Returns a paginated list of boundary resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                parent_type: None,
                type_: None,
                parent_ids: Vec::new(),
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Search for boundaries by fields and intersecting geometry."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `search_boundary_query`: Query filters."]
        pub fn search_by_party_id(
            &self,
            party_id: impl Into<String>,
            search_boundary_query: impl Into<models::SearchBoundaryQuery>,
        ) -> search_by_party_id::RequestBuilder {
            search_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                search_boundary_query: search_boundary_query.into(),
            }
        }
        #[doc = "Gets a specified boundary resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `boundary_id`: Id of the boundary."]
        pub fn get(&self, party_id: impl Into<String>, boundary_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                boundary_id: boundary_id.into(),
            }
        }
        #[doc = "Creates or updates a boundary resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party resource."]
        #[doc = "* `boundary_id`: Id of the boundary resource."]
        #[doc = "* `boundary`: Boundary resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            boundary_id: impl Into<String>,
            boundary: impl Into<models::Boundary>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                boundary_id: boundary_id.into(),
                boundary: boundary.into(),
            }
        }
        #[doc = "Deletes a specified boundary resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `boundary_id`: Id of the boundary."]
        pub fn delete(&self, party_id: impl Into<String>, boundary_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                boundary_id: boundary_id.into(),
            }
        }
        #[doc = "Returns overlapping area between two boundary Ids."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `boundary_id`: Id of the boundary."]
        #[doc = "* `other_party_id`: PartyId of the other field."]
        #[doc = "* `other_boundary_id`: Id of the other boundary."]
        pub fn get_overlap(
            &self,
            party_id: impl Into<String>,
            boundary_id: impl Into<String>,
            other_party_id: impl Into<String>,
            other_boundary_id: impl Into<String>,
        ) -> get_overlap::RequestBuilder {
            get_overlap::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                boundary_id: boundary_id.into(),
                other_party_id: other_party_id.into(),
                other_boundary_id: other_boundary_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::BoundaryMetadataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::BoundaryMetadataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) parent_type: Option<String>,
            pub(crate) type_: Option<String>,
            pub(crate) parent_ids: Vec<String>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Type of the parent it belongs to."]
            pub fn parent_type(mut self, parent_type: impl Into<String>) -> Self {
                self.parent_type = Some(parent_type.into());
                self
            }
            #[doc = "Type it belongs to."]
            pub fn type_(mut self, type_: impl Into<String>) -> Self {
                self.type_ = Some(type_.into());
                self
            }
            #[doc = "Parent Ids of the resource."]
            pub fn parent_ids(mut self, parent_ids: Vec<String>) -> Self {
                self.parent_ids = parent_ids;
                self
            }
            #[doc = "Minimum area of the boundary (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum acreage of the boundary (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::BoundaryMetadataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(parent_type) = &this.parent_type {
                                    req.url_mut().query_pairs_mut().append_pair("parentType", parent_type);
                                }
                                if let Some(type_) = &this.type_ {
                                    req.url_mut().query_pairs_mut().append_pair("type", type_);
                                }
                                let parent_ids = &this.parent_ids;
                                for value in &this.parent_ids {
                                    req.url_mut().query_pairs_mut().append_pair("parentIds", &value.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/boundaries", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod search {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::BoundaryMetadataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::BoundaryMetadataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) search_boundary_query: models::SearchBoundaryQuery,
        }
        impl RequestBuilder {
            pub fn into_stream(self) -> azure_core::Pageable<models::BoundaryMetadataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.insert_header("content-type", "application/json");
                                let req_body = azure_core::to_json(&this.search_boundary_query)?;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/boundaries", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/boundaries/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) boundary_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let boundary_id = &this.boundary_id;
                        req.url_mut().query_pairs_mut().append_pair("boundaryId", boundary_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/boundaries/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::BoundaryMetadataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::BoundaryMetadataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) parent_type: Option<String>,
            pub(crate) type_: Option<String>,
            pub(crate) parent_ids: Vec<String>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Type of the parent it belongs to."]
            pub fn parent_type(mut self, parent_type: impl Into<String>) -> Self {
                self.parent_type = Some(parent_type.into());
                self
            }
            #[doc = "Type it belongs to."]
            pub fn type_(mut self, type_: impl Into<String>) -> Self {
                self.type_ = Some(type_.into());
                self
            }
            #[doc = "Parent Ids of the resource."]
            pub fn parent_ids(mut self, parent_ids: Vec<String>) -> Self {
                self.parent_ids = parent_ids;
                self
            }
            #[doc = "Minimum area of the boundary (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum acreage of the boundary (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::BoundaryMetadataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(parent_type) = &this.parent_type {
                                    req.url_mut().query_pairs_mut().append_pair("parentType", parent_type);
                                }
                                if let Some(type_) = &this.type_ {
                                    req.url_mut().query_pairs_mut().append_pair("type", type_);
                                }
                                let parent_ids = &this.parent_ids;
                                for value in &this.parent_ids {
                                    req.url_mut().query_pairs_mut().append_pair("parentIds", &value.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/boundaries", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod search_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::BoundaryMetadataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::BoundaryMetadataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) search_boundary_query: models::SearchBoundaryQuery,
        }
        impl RequestBuilder {
            pub fn into_stream(self) -> azure_core::Pageable<models::BoundaryMetadataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                req.insert_header("content-type", "application/json");
                                let req_body = azure_core::to_json(&this.search_boundary_query)?;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/boundaries", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Boundary> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Boundary = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) boundary_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/boundaries/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.boundary_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Boundary>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Boundary>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Boundary> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Boundary = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) boundary_id: String,
            pub(crate) boundary: models::Boundary,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.boundary)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/boundaries/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.boundary_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Boundary>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Boundary>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) boundary_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/boundaries/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.boundary_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_overlap {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::BoundaryOverlapResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::BoundaryOverlapResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) boundary_id: String,
            pub(crate) other_party_id: String,
            pub(crate) other_boundary_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let other_party_id = &this.other_party_id;
                        req.url_mut().query_pairs_mut().append_pair("otherPartyId", other_party_id);
                        let other_boundary_id = &this.other_boundary_id;
                        req.url_mut().query_pairs_mut().append_pair("otherBoundaryId", other_boundary_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/boundaries/{}/overlap",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.boundary_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::BoundaryOverlapResponse>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::BoundaryOverlapResponse>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod crop_products {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of crop product resources."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                crop_ids: Vec::new(),
                brands: Vec::new(),
                products: Vec::new(),
                traits: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified crop Product resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `crop_product_id`: Id of the crop Product."]
        pub fn get(&self, crop_product_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                crop_product_id: crop_product_id.into(),
            }
        }
        #[doc = "Creates or updates a crop Product resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `crop_product_id`: Id of the crop Product resource."]
        #[doc = "* `crop_product`: Crop Product resource payload to create or update."]
        pub fn create_or_update(
            &self,
            crop_product_id: impl Into<String>,
            crop_product: impl Into<models::CropProduct>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                crop_product_id: crop_product_id.into(),
                crop_product: crop_product.into(),
            }
        }
        #[doc = "Deletes a specified crop Product resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `crop_product_id`: Id of the crop Product."]
        pub fn delete(&self, crop_product_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                crop_product_id: crop_product_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CropProductListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CropProductListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) brands: Vec<String>,
            pub(crate) products: Vec<String>,
            pub(crate) traits: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "CropIds of the resource."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "Brands of the resource."]
            pub fn brands(mut self, brands: Vec<String>) -> Self {
                self.brands = brands;
                self
            }
            #[doc = "Products of the resource."]
            pub fn products(mut self, products: Vec<String>) -> Self {
                self.products = products;
                self
            }
            #[doc = "Traits of the resource."]
            pub fn traits(mut self, traits: Vec<String>) -> Self {
                self.traits = traits;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::CropProductListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let brands = &this.brands;
                                for value in &this.brands {
                                    req.url_mut().query_pairs_mut().append_pair("brands", &value.to_string());
                                }
                                let products = &this.products;
                                for value in &this.products {
                                    req.url_mut().query_pairs_mut().append_pair("products", &value.to_string());
                                }
                                let traits = &this.traits;
                                for value in &this.traits {
                                    req.url_mut().query_pairs_mut().append_pair("traits", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/crop-products", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CropProduct> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CropProduct = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) crop_product_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/crop-products/{}", self.client.endpoint(), &self.crop_product_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CropProduct>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CropProduct>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CropProduct> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CropProduct = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) crop_product_id: String,
            pub(crate) crop_product: models::CropProduct,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.crop_product)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/crop-products/{}", self.client.endpoint(), &self.crop_product_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CropProduct>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CropProduct>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) crop_product_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/crop-products/{}", self.client.endpoint(), &self.crop_product_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod crops {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of crop resources."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                phenotypes: Vec::new(),
                breeding_methods: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified crop resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `crop_id`: Id of the crop."]
        pub fn get(&self, crop_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                crop_id: crop_id.into(),
            }
        }
        #[doc = "Creates or updates a crop resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `crop_id`: Id of the crop resource."]
        #[doc = "* `crop`: Crop resource payload to create or update."]
        pub fn create_or_update(&self, crop_id: impl Into<String>, crop: impl Into<models::Crop>) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                crop_id: crop_id.into(),
                crop: crop.into(),
            }
        }
        #[doc = "Deletes Crop for given crop id."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `crop_id`: Id of crop to be deleted."]
        pub fn delete(&self, crop_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                crop_id: crop_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CropListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CropListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) phenotypes: Vec<String>,
            pub(crate) breeding_methods: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Crop phenotypes of the resource."]
            pub fn phenotypes(mut self, phenotypes: Vec<String>) -> Self {
                self.phenotypes = phenotypes;
                self
            }
            #[doc = "Breeding method of the resource."]
            pub fn breeding_methods(mut self, breeding_methods: Vec<String>) -> Self {
                self.breeding_methods = breeding_methods;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::CropListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let phenotypes = &this.phenotypes;
                                for value in &this.phenotypes {
                                    req.url_mut().query_pairs_mut().append_pair("phenotypes", &value.to_string());
                                }
                                let breeding_methods = &this.breeding_methods;
                                for value in &this.breeding_methods {
                                    req.url_mut().query_pairs_mut().append_pair("breedingMethods", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/crops", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Crop> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Crop = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) crop_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/crops/{}", self.client.endpoint(), &self.crop_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Crop>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Crop>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Crop> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Crop = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) crop_id: String,
            pub(crate) crop: models::Crop,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.crop)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/crops/{}", self.client.endpoint(), &self.crop_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Crop>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Crop>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) crop_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/crops/{}", self.client.endpoint(), &self.crop_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod device_data_models {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of device data model resources."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the associated sensor partner."]
        pub fn list(&self, sensor_partner_id: impl Into<String>) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a device data model entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `device_data_model_id`: Id of the device data model resource."]
        pub fn get(&self, sensor_partner_id: impl Into<String>, device_data_model_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                device_data_model_id: device_data_model_id.into(),
            }
        }
        #[doc = "Create a device data model entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `device_data_model_id`: Id of the device data model."]
        #[doc = "* `device_data_model_object`: Device data model object details."]
        pub fn create_or_update(
            &self,
            sensor_partner_id: impl Into<String>,
            device_data_model_id: impl Into<String>,
            device_data_model_object: impl Into<models::DeviceDataModel>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                device_data_model_id: device_data_model_id.into(),
                device_data_model_object: device_data_model_object.into(),
            }
        }
        #[doc = "Deletes a device data model entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `device_data_model_id`: Id of the device data model resource."]
        pub fn delete(&self, sensor_partner_id: impl Into<String>, device_data_model_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                device_data_model_id: device_data_model_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::DeviceDataModelListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::DeviceDataModelListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::DeviceDataModelListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/device-data-models",
                    self.client.endpoint(),
                    &self.sensor_partner_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::DeviceDataModel> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::DeviceDataModel = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) device_data_model_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/device-data-models/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.device_data_model_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::DeviceDataModel>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::DeviceDataModel>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::DeviceDataModel> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::DeviceDataModel = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) device_data_model_id: String,
            pub(crate) device_data_model_object: models::DeviceDataModel,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.device_data_model_object)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/device-data-models/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.device_data_model_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::DeviceDataModel>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::DeviceDataModel>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) device_data_model_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/device-data-models/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.device_data_model_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod devices {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of device resources."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the associated sensor partner."]
        pub fn list(&self, sensor_partner_id: impl Into<String>) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                parent_device_ids: Vec::new(),
                device_data_model_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a device entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `device_id`: Id of the device resource."]
        pub fn get(&self, sensor_partner_id: impl Into<String>, device_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                device_id: device_id.into(),
            }
        }
        #[doc = "Create a device entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `device_id`: Id of the device resource."]
        #[doc = "* `device_details`: Device object details."]
        pub fn create_or_update(
            &self,
            sensor_partner_id: impl Into<String>,
            device_id: impl Into<String>,
            device_details: impl Into<models::Device>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                device_id: device_id.into(),
                device_details: device_details.into(),
            }
        }
        #[doc = "Deletes a device entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `device_id`: Id of the device resource."]
        pub fn delete(&self, sensor_partner_id: impl Into<String>, device_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                device_id: device_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::DeviceListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::DeviceListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) parent_device_ids: Vec<String>,
            pub(crate) device_data_model_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Id's of the parent devices."]
            pub fn parent_device_ids(mut self, parent_device_ids: Vec<String>) -> Self {
                self.parent_device_ids = parent_device_ids;
                self
            }
            #[doc = "Id's of the device data models."]
            pub fn device_data_model_ids(mut self, device_data_model_ids: Vec<String>) -> Self {
                self.device_data_model_ids = device_data_model_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::DeviceListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let parent_device_ids = &this.parent_device_ids;
                                for value in &this.parent_device_ids {
                                    req.url_mut().query_pairs_mut().append_pair("parentDeviceIds", &value.to_string());
                                }
                                let device_data_model_ids = &this.device_data_model_ids;
                                for value in &this.device_data_model_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("deviceDataModelIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/devices",
                    self.client.endpoint(),
                    &self.sensor_partner_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Device> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Device = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) device_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/devices/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.device_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Device>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Device>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Device> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Device = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) device_id: String,
            pub(crate) device_details: models::Device,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.device_details)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/devices/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.device_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Device>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Device>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) device_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/devices/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.device_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod farm_operations {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Get a farm operation data ingestion job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_data_ingestion_job_details(&self, job_id: impl Into<String>) -> get_data_ingestion_job_details::RequestBuilder {
            get_data_ingestion_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a farm operation data ingestion job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job Id supplied by user."]
        #[doc = "* `job`: Job parameters supplied by user."]
        pub fn create_data_ingestion_job(
            &self,
            job_id: impl Into<String>,
            job: impl Into<models::FarmOperationDataIngestionJob>,
        ) -> create_data_ingestion_job::RequestBuilder {
            create_data_ingestion_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job: job.into(),
            }
        }
    }
    pub mod get_data_ingestion_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::FarmOperationDataIngestionJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::FarmOperationDataIngestionJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/farm-operations/ingest-data/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::FarmOperationDataIngestionJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::FarmOperationDataIngestionJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_data_ingestion_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::FarmOperationDataIngestionJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::FarmOperationDataIngestionJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job: models::FarmOperationDataIngestionJob,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.job)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/farm-operations/ingest-data/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::FarmOperationDataIngestionJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::FarmOperationDataIngestionJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod farms {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of farm resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a cascade delete job for specified farm."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified farm."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `farm_id`: ID of the farm to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            farm_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                farm_id: farm_id.into(),
            }
        }
        #[doc = "Returns a paginated list of farm resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified farm resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `farm_id`: ID of the farm resource."]
        pub fn get(&self, party_id: impl Into<String>, farm_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                farm_id: farm_id.into(),
            }
        }
        #[doc = "Creates or updates a farm resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party resource."]
        #[doc = "* `farm_id`: Id of the farm resource."]
        #[doc = "* `farm`: Farm resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            farm_id: impl Into<String>,
            farm: impl Into<models::Farm>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                farm_id: farm_id.into(),
                farm: farm.into(),
            }
        }
        #[doc = "Deletes a specified farm resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `farm_id`: Id of the farm."]
        pub fn delete(&self, party_id: impl Into<String>, farm_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                farm_id: farm_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::FarmListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::FarmListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::FarmListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/farms", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/farms/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) farm_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let farm_id = &this.farm_id;
                        req.url_mut().query_pairs_mut().append_pair("farmId", farm_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/farms/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::FarmListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::FarmListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::FarmListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/farms", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Farm> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Farm = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) farm_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/farms/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.farm_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Farm>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Farm>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Farm> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Farm = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) farm_id: String,
            pub(crate) farm: models::Farm,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.farm)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/farms/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.farm_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Farm>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Farm>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) farm_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/farms/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.farm_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod fields {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of field resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                farm_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a cascade delete job for specified field."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified field."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `field_id`: ID of the field to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            field_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                field_id: field_id.into(),
            }
        }
        #[doc = "Returns a paginated list of field resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                farm_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified field resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `field_id`: Id of the field."]
        pub fn get(&self, party_id: impl Into<String>, field_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                field_id: field_id.into(),
            }
        }
        #[doc = "Creates or Updates a field resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party resource."]
        #[doc = "* `field_id`: Id of the field resource."]
        #[doc = "* `field`: Field resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            field_id: impl Into<String>,
            field: impl Into<models::Field>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                field_id: field_id.into(),
                field: field.into(),
            }
        }
        #[doc = "Deletes a specified field resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `field_id`: Id of the field."]
        pub fn delete(&self, party_id: impl Into<String>, field_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                field_id: field_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::FieldListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::FieldListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) farm_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Farm Ids of the resource."]
            pub fn farm_ids(mut self, farm_ids: Vec<String>) -> Self {
                self.farm_ids = farm_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::FieldListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let farm_ids = &this.farm_ids;
                                for value in &this.farm_ids {
                                    req.url_mut().query_pairs_mut().append_pair("farmIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/fields", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/fields/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) field_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let field_id = &this.field_id;
                        req.url_mut().query_pairs_mut().append_pair("fieldId", field_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/fields/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::FieldListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::FieldListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) farm_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Farm Ids of the resource."]
            pub fn farm_ids(mut self, farm_ids: Vec<String>) -> Self {
                self.farm_ids = farm_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::FieldListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let farm_ids = &this.farm_ids;
                                for value in &this.farm_ids {
                                    req.url_mut().query_pairs_mut().append_pair("farmIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/fields", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Field> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Field = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) field_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/fields/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.field_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Field>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Field>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Field> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Field = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) field_id: String,
            pub(crate) field: models::Field,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.field)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/fields/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.field_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Field>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Field>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) field_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/fields/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.field_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod harvest_data {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of harvest data resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                min_total_yield: None,
                max_total_yield: None,
                min_avg_yield: None,
                max_avg_yield: None,
                min_total_wet_mass: None,
                max_total_wet_mass: None,
                min_avg_wet_mass: None,
                max_avg_wet_mass: None,
                min_avg_moisture: None,
                max_avg_moisture: None,
                min_avg_speed: None,
                max_avg_speed: None,
                sources: Vec::new(),
                associated_boundary_ids: Vec::new(),
                min_operation_start_date_time: None,
                max_operation_start_date_time: None,
                min_operation_end_date_time: None,
                max_operation_end_date_time: None,
                min_operation_modified_date_time: None,
                max_operation_modified_date_time: None,
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get cascade delete job for harvest data resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create cascade delete job for harvest data resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job Id supplied by end user."]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `harvest_data_id`: Id of the harvest data."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            harvest_data_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                harvest_data_id: harvest_data_id.into(),
            }
        }
        #[doc = "Returns a paginated list of harvest data resources under a particular farm."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                min_total_yield: None,
                max_total_yield: None,
                min_avg_yield: None,
                max_avg_yield: None,
                min_total_wet_mass: None,
                max_total_wet_mass: None,
                min_avg_wet_mass: None,
                max_avg_wet_mass: None,
                min_avg_moisture: None,
                max_avg_moisture: None,
                min_avg_speed: None,
                max_avg_speed: None,
                sources: Vec::new(),
                associated_boundary_ids: Vec::new(),
                min_operation_start_date_time: None,
                max_operation_start_date_time: None,
                min_operation_end_date_time: None,
                max_operation_end_date_time: None,
                min_operation_modified_date_time: None,
                max_operation_modified_date_time: None,
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a specified harvest data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `harvest_data_id`: ID of the harvest data resource."]
        pub fn get(&self, party_id: impl Into<String>, harvest_data_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                harvest_data_id: harvest_data_id.into(),
            }
        }
        #[doc = "Creates or updates harvest data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the party."]
        #[doc = "* `harvest_data_id`: ID of the harvest data resource."]
        #[doc = "* `harvest_data`: Harvest data resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            harvest_data_id: impl Into<String>,
            harvest_data: impl Into<models::HarvestData>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                harvest_data_id: harvest_data_id.into(),
                harvest_data: harvest_data.into(),
            }
        }
        #[doc = "Deletes a specified harvest data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `harvest_data_id`: ID of the harvest data."]
        pub fn delete(&self, party_id: impl Into<String>, harvest_data_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                harvest_data_id: harvest_data_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::HarvestDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::HarvestDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) min_total_yield: Option<f64>,
            pub(crate) max_total_yield: Option<f64>,
            pub(crate) min_avg_yield: Option<f64>,
            pub(crate) max_avg_yield: Option<f64>,
            pub(crate) min_total_wet_mass: Option<f64>,
            pub(crate) max_total_wet_mass: Option<f64>,
            pub(crate) min_avg_wet_mass: Option<f64>,
            pub(crate) max_avg_wet_mass: Option<f64>,
            pub(crate) min_avg_moisture: Option<f64>,
            pub(crate) max_avg_moisture: Option<f64>,
            pub(crate) min_avg_speed: Option<f64>,
            pub(crate) max_avg_speed: Option<f64>,
            pub(crate) sources: Vec<String>,
            pub(crate) associated_boundary_ids: Vec<String>,
            pub(crate) min_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum Yield value(inclusive)."]
            pub fn min_total_yield(mut self, min_total_yield: f64) -> Self {
                self.min_total_yield = Some(min_total_yield);
                self
            }
            #[doc = "Maximum Yield value (inclusive)."]
            pub fn max_total_yield(mut self, max_total_yield: f64) -> Self {
                self.max_total_yield = Some(max_total_yield);
                self
            }
            #[doc = "Minimum AvgYield value(inclusive)."]
            pub fn min_avg_yield(mut self, min_avg_yield: f64) -> Self {
                self.min_avg_yield = Some(min_avg_yield);
                self
            }
            #[doc = "Maximum AvgYield value (inclusive)."]
            pub fn max_avg_yield(mut self, max_avg_yield: f64) -> Self {
                self.max_avg_yield = Some(max_avg_yield);
                self
            }
            #[doc = "Minimum Total WetMass value(inclusive)."]
            pub fn min_total_wet_mass(mut self, min_total_wet_mass: f64) -> Self {
                self.min_total_wet_mass = Some(min_total_wet_mass);
                self
            }
            #[doc = "Maximum Total WetMass value (inclusive)."]
            pub fn max_total_wet_mass(mut self, max_total_wet_mass: f64) -> Self {
                self.max_total_wet_mass = Some(max_total_wet_mass);
                self
            }
            #[doc = "Minimum AvgWetMass value(inclusive)."]
            pub fn min_avg_wet_mass(mut self, min_avg_wet_mass: f64) -> Self {
                self.min_avg_wet_mass = Some(min_avg_wet_mass);
                self
            }
            #[doc = "Maximum AvgWetMass value (inclusive)."]
            pub fn max_avg_wet_mass(mut self, max_avg_wet_mass: f64) -> Self {
                self.max_avg_wet_mass = Some(max_avg_wet_mass);
                self
            }
            #[doc = "Minimum AvgMoisture value(inclusive)."]
            pub fn min_avg_moisture(mut self, min_avg_moisture: f64) -> Self {
                self.min_avg_moisture = Some(min_avg_moisture);
                self
            }
            #[doc = "Maximum AvgMoisture value (inclusive)."]
            pub fn max_avg_moisture(mut self, max_avg_moisture: f64) -> Self {
                self.max_avg_moisture = Some(max_avg_moisture);
                self
            }
            #[doc = "Minimum AvgSpeed value(inclusive)."]
            pub fn min_avg_speed(mut self, min_avg_speed: f64) -> Self {
                self.min_avg_speed = Some(min_avg_speed);
                self
            }
            #[doc = "Maximum AvgSpeed value (inclusive)."]
            pub fn max_avg_speed(mut self, max_avg_speed: f64) -> Self {
                self.max_avg_speed = Some(max_avg_speed);
                self
            }
            #[doc = "Sources of the operation data."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Boundary IDs associated with operation data."]
            pub fn associated_boundary_ids(mut self, associated_boundary_ids: Vec<String>) -> Self {
                self.associated_boundary_ids = associated_boundary_ids;
                self
            }
            #[doc = "Minimum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_start_date_time(mut self, min_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_start_date_time = Some(min_operation_start_date_time.into());
                self
            }
            #[doc = "Maximum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_start_date_time(mut self, max_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_start_date_time = Some(max_operation_start_date_time.into());
                self
            }
            #[doc = "Minimum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_end_date_time(mut self, min_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_end_date_time = Some(min_operation_end_date_time.into());
                self
            }
            #[doc = "Maximum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_end_date_time(mut self, max_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_end_date_time = Some(max_operation_end_date_time.into());
                self
            }
            #[doc = "Minimum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_modified_date_time(mut self, min_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_modified_date_time = Some(min_operation_modified_date_time.into());
                self
            }
            #[doc = "Maximum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_modified_date_time(mut self, max_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_modified_date_time = Some(max_operation_modified_date_time.into());
                self
            }
            #[doc = "Minimum area for which operation was applied (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum area for which operation was applied (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::HarvestDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_total_yield) = &this.min_total_yield {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTotalYield", &min_total_yield.to_string());
                                }
                                if let Some(max_total_yield) = &this.max_total_yield {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTotalYield", &max_total_yield.to_string());
                                }
                                if let Some(min_avg_yield) = &this.min_avg_yield {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgYield", &min_avg_yield.to_string());
                                }
                                if let Some(max_avg_yield) = &this.max_avg_yield {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgYield", &max_avg_yield.to_string());
                                }
                                if let Some(min_total_wet_mass) = &this.min_total_wet_mass {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTotalWetMass", &min_total_wet_mass.to_string());
                                }
                                if let Some(max_total_wet_mass) = &this.max_total_wet_mass {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTotalWetMass", &max_total_wet_mass.to_string());
                                }
                                if let Some(min_avg_wet_mass) = &this.min_avg_wet_mass {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgWetMass", &min_avg_wet_mass.to_string());
                                }
                                if let Some(max_avg_wet_mass) = &this.max_avg_wet_mass {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgWetMass", &max_avg_wet_mass.to_string());
                                }
                                if let Some(min_avg_moisture) = &this.min_avg_moisture {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgMoisture", &min_avg_moisture.to_string());
                                }
                                if let Some(max_avg_moisture) = &this.max_avg_moisture {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgMoisture", &max_avg_moisture.to_string());
                                }
                                if let Some(min_avg_speed) = &this.min_avg_speed {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgSpeed", &min_avg_speed.to_string());
                                }
                                if let Some(max_avg_speed) = &this.max_avg_speed {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgSpeed", &max_avg_speed.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let associated_boundary_ids = &this.associated_boundary_ids;
                                for value in &this.associated_boundary_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("associatedBoundaryIds", &value.to_string());
                                }
                                if let Some(min_operation_start_date_time) = &this.min_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationStartDateTime", &min_operation_start_date_time.to_string());
                                }
                                if let Some(max_operation_start_date_time) = &this.max_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationStartDateTime", &max_operation_start_date_time.to_string());
                                }
                                if let Some(min_operation_end_date_time) = &this.min_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationEndDateTime", &min_operation_end_date_time.to_string());
                                }
                                if let Some(max_operation_end_date_time) = &this.max_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationEndDateTime", &max_operation_end_date_time.to_string());
                                }
                                if let Some(min_operation_modified_date_time) = &this.min_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationModifiedDateTime", &min_operation_modified_date_time.to_string());
                                }
                                if let Some(max_operation_modified_date_time) = &this.max_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationModifiedDateTime", &max_operation_modified_date_time.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/harvest-data", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/harvest-data/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) harvest_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let harvest_data_id = &this.harvest_data_id;
                        req.url_mut().query_pairs_mut().append_pair("harvestDataId", harvest_data_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/harvest-data/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::HarvestDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::HarvestDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) min_total_yield: Option<f64>,
            pub(crate) max_total_yield: Option<f64>,
            pub(crate) min_avg_yield: Option<f64>,
            pub(crate) max_avg_yield: Option<f64>,
            pub(crate) min_total_wet_mass: Option<f64>,
            pub(crate) max_total_wet_mass: Option<f64>,
            pub(crate) min_avg_wet_mass: Option<f64>,
            pub(crate) max_avg_wet_mass: Option<f64>,
            pub(crate) min_avg_moisture: Option<f64>,
            pub(crate) max_avg_moisture: Option<f64>,
            pub(crate) min_avg_speed: Option<f64>,
            pub(crate) max_avg_speed: Option<f64>,
            pub(crate) sources: Vec<String>,
            pub(crate) associated_boundary_ids: Vec<String>,
            pub(crate) min_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum Yield value(inclusive)."]
            pub fn min_total_yield(mut self, min_total_yield: f64) -> Self {
                self.min_total_yield = Some(min_total_yield);
                self
            }
            #[doc = "Maximum Yield value (inclusive)."]
            pub fn max_total_yield(mut self, max_total_yield: f64) -> Self {
                self.max_total_yield = Some(max_total_yield);
                self
            }
            #[doc = "Minimum AvgYield value(inclusive)."]
            pub fn min_avg_yield(mut self, min_avg_yield: f64) -> Self {
                self.min_avg_yield = Some(min_avg_yield);
                self
            }
            #[doc = "Maximum AvgYield value (inclusive)."]
            pub fn max_avg_yield(mut self, max_avg_yield: f64) -> Self {
                self.max_avg_yield = Some(max_avg_yield);
                self
            }
            #[doc = "Minimum Total WetMass value(inclusive)."]
            pub fn min_total_wet_mass(mut self, min_total_wet_mass: f64) -> Self {
                self.min_total_wet_mass = Some(min_total_wet_mass);
                self
            }
            #[doc = "Maximum Total WetMass value (inclusive)."]
            pub fn max_total_wet_mass(mut self, max_total_wet_mass: f64) -> Self {
                self.max_total_wet_mass = Some(max_total_wet_mass);
                self
            }
            #[doc = "Minimum AvgWetMass value(inclusive)."]
            pub fn min_avg_wet_mass(mut self, min_avg_wet_mass: f64) -> Self {
                self.min_avg_wet_mass = Some(min_avg_wet_mass);
                self
            }
            #[doc = "Maximum AvgWetMass value (inclusive)."]
            pub fn max_avg_wet_mass(mut self, max_avg_wet_mass: f64) -> Self {
                self.max_avg_wet_mass = Some(max_avg_wet_mass);
                self
            }
            #[doc = "Minimum AvgMoisture value(inclusive)."]
            pub fn min_avg_moisture(mut self, min_avg_moisture: f64) -> Self {
                self.min_avg_moisture = Some(min_avg_moisture);
                self
            }
            #[doc = "Maximum AvgMoisture value (inclusive)."]
            pub fn max_avg_moisture(mut self, max_avg_moisture: f64) -> Self {
                self.max_avg_moisture = Some(max_avg_moisture);
                self
            }
            #[doc = "Minimum AvgSpeed value(inclusive)."]
            pub fn min_avg_speed(mut self, min_avg_speed: f64) -> Self {
                self.min_avg_speed = Some(min_avg_speed);
                self
            }
            #[doc = "Maximum AvgSpeed value (inclusive)."]
            pub fn max_avg_speed(mut self, max_avg_speed: f64) -> Self {
                self.max_avg_speed = Some(max_avg_speed);
                self
            }
            #[doc = "Sources of the operation data."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Boundary IDs associated with operation data."]
            pub fn associated_boundary_ids(mut self, associated_boundary_ids: Vec<String>) -> Self {
                self.associated_boundary_ids = associated_boundary_ids;
                self
            }
            #[doc = "Minimum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_start_date_time(mut self, min_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_start_date_time = Some(min_operation_start_date_time.into());
                self
            }
            #[doc = "Maximum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_start_date_time(mut self, max_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_start_date_time = Some(max_operation_start_date_time.into());
                self
            }
            #[doc = "Minimum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_end_date_time(mut self, min_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_end_date_time = Some(min_operation_end_date_time.into());
                self
            }
            #[doc = "Maximum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_end_date_time(mut self, max_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_end_date_time = Some(max_operation_end_date_time.into());
                self
            }
            #[doc = "Minimum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_modified_date_time(mut self, min_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_modified_date_time = Some(min_operation_modified_date_time.into());
                self
            }
            #[doc = "Maximum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_modified_date_time(mut self, max_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_modified_date_time = Some(max_operation_modified_date_time.into());
                self
            }
            #[doc = "Minimum area for which operation was applied (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum area for which operation was applied (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::HarvestDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_total_yield) = &this.min_total_yield {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTotalYield", &min_total_yield.to_string());
                                }
                                if let Some(max_total_yield) = &this.max_total_yield {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTotalYield", &max_total_yield.to_string());
                                }
                                if let Some(min_avg_yield) = &this.min_avg_yield {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgYield", &min_avg_yield.to_string());
                                }
                                if let Some(max_avg_yield) = &this.max_avg_yield {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgYield", &max_avg_yield.to_string());
                                }
                                if let Some(min_total_wet_mass) = &this.min_total_wet_mass {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTotalWetMass", &min_total_wet_mass.to_string());
                                }
                                if let Some(max_total_wet_mass) = &this.max_total_wet_mass {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTotalWetMass", &max_total_wet_mass.to_string());
                                }
                                if let Some(min_avg_wet_mass) = &this.min_avg_wet_mass {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgWetMass", &min_avg_wet_mass.to_string());
                                }
                                if let Some(max_avg_wet_mass) = &this.max_avg_wet_mass {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgWetMass", &max_avg_wet_mass.to_string());
                                }
                                if let Some(min_avg_moisture) = &this.min_avg_moisture {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgMoisture", &min_avg_moisture.to_string());
                                }
                                if let Some(max_avg_moisture) = &this.max_avg_moisture {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgMoisture", &max_avg_moisture.to_string());
                                }
                                if let Some(min_avg_speed) = &this.min_avg_speed {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgSpeed", &min_avg_speed.to_string());
                                }
                                if let Some(max_avg_speed) = &this.max_avg_speed {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgSpeed", &max_avg_speed.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let associated_boundary_ids = &this.associated_boundary_ids;
                                for value in &this.associated_boundary_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("associatedBoundaryIds", &value.to_string());
                                }
                                if let Some(min_operation_start_date_time) = &this.min_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationStartDateTime", &min_operation_start_date_time.to_string());
                                }
                                if let Some(max_operation_start_date_time) = &this.max_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationStartDateTime", &max_operation_start_date_time.to_string());
                                }
                                if let Some(min_operation_end_date_time) = &this.min_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationEndDateTime", &min_operation_end_date_time.to_string());
                                }
                                if let Some(max_operation_end_date_time) = &this.max_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationEndDateTime", &max_operation_end_date_time.to_string());
                                }
                                if let Some(min_operation_modified_date_time) = &this.min_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationModifiedDateTime", &min_operation_modified_date_time.to_string());
                                }
                                if let Some(max_operation_modified_date_time) = &this.max_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationModifiedDateTime", &max_operation_modified_date_time.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/harvest-data", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::HarvestData> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::HarvestData = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) harvest_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/harvest-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.harvest_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::HarvestData>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::HarvestData>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::HarvestData> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::HarvestData = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) harvest_data_id: String,
            pub(crate) harvest_data: models::HarvestData,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.harvest_data)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/harvest-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.harvest_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::HarvestData>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::HarvestData>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) harvest_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/harvest-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.harvest_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod image_processing {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Get ImageProcessing Rasterize job's details."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_rasterize_job(&self, job_id: impl Into<String>) -> get_rasterize_job::RequestBuilder {
            get_rasterize_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a ImageProcessing Rasterize job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: JobId provided by user."]
        #[doc = "* `job`: Job parameters supplied by user."]
        pub fn create_rasterize_job(
            &self,
            job_id: impl Into<String>,
            job: impl Into<models::ImageProcessingRasterizeJob>,
        ) -> create_rasterize_job::RequestBuilder {
            create_rasterize_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job: job.into(),
            }
        }
    }
    pub mod get_rasterize_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ImageProcessingRasterizeJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ImageProcessingRasterizeJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/image-processing/rasterize/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::ImageProcessingRasterizeJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::ImageProcessingRasterizeJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_rasterize_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ImageProcessingRasterizeJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ImageProcessingRasterizeJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job: models::ImageProcessingRasterizeJob,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.job)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/image-processing/rasterize/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::ImageProcessingRasterizeJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::ImageProcessingRasterizeJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod insight_attachments {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of insight resources."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        pub fn list_by_party_id_model_id_and_resource(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
        ) -> list_by_party_id_model_id_and_resource::RequestBuilder {
            list_by_party_id_model_id_and_resource::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified insight resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model.\r\nIt can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any solution id."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        #[doc = "* `insight_attachment_id`: Id of the insight attachment resource."]
        pub fn get(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
            insight_attachment_id: impl Into<String>,
        ) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_attachment_id: insight_attachment_id.into(),
            }
        }
        #[doc = "Creates or updates insight entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model.\r\nIt can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any solution id."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        #[doc = "* `insight_attachment_id`: Id of the insight resource."]
        #[doc = "* `insight_id`: InsightID for this InsightAttachment."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
            insight_attachment_id: impl Into<String>,
            insight_id: impl Into<String>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_attachment_id: insight_attachment_id.into(),
                insight_id: insight_id.into(),
                file: None,
                original_file_name: None,
                id: None,
                status: None,
                created_date_time: None,
                modified_date_time: None,
                source: None,
                name: None,
                description: None,
                created_by: None,
                modified_by: None,
                e_tag: None,
            }
        }
        #[doc = "Deletes a specified insight resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model.\r\nIt can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any solution id."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        #[doc = "* `insight_attachment_id`: Id of the insight attachment resource."]
        pub fn delete(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
            insight_attachment_id: impl Into<String>,
        ) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_attachment_id: insight_attachment_id.into(),
            }
        }
        #[doc = "Downloads and returns insight-attachment as response for the given input filePath."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model.\r\nIt can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any solution id."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        #[doc = "* `insight_attachment_id`: Id of the insight attachment resource."]
        pub fn download(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
            insight_attachment_id: impl Into<String>,
        ) -> download::RequestBuilder {
            download::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_attachment_id: insight_attachment_id.into(),
            }
        }
    }
    pub mod list_by_party_id_model_id_and_resource {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::InsightAttachmentListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::InsightAttachmentListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "List of insight IDs."]
            pub fn insight_ids(mut self, insight_ids: Vec<String>) -> Self {
                self.insight_ids = insight_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::InsightAttachmentListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let insight_ids = &this.insight_ids;
                                for value in &this.insight_ids {
                                    req.url_mut().query_pairs_mut().append_pair("insightIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insight-attachments",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::InsightAttachment> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::InsightAttachment = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_attachment_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insight-attachments/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id,
                    &self.insight_attachment_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::InsightAttachment>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::InsightAttachment>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::InsightAttachment> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::InsightAttachment = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_attachment_id: String,
            pub(crate) insight_id: String,
            pub(crate) file: Option<bytes::Bytes>,
            pub(crate) original_file_name: Option<String>,
            pub(crate) id: Option<String>,
            pub(crate) status: Option<String>,
            pub(crate) created_date_time: Option<time::OffsetDateTime>,
            pub(crate) modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) source: Option<String>,
            pub(crate) name: Option<String>,
            pub(crate) description: Option<String>,
            pub(crate) created_by: Option<String>,
            pub(crate) modified_by: Option<String>,
            pub(crate) e_tag: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "File to be uploaded."]
            pub fn file(mut self, file: impl Into<bytes::Bytes>) -> Self {
                self.file = Some(file.into());
                self
            }
            #[doc = "Original File Name for this attachment."]
            pub fn original_file_name(mut self, original_file_name: impl Into<String>) -> Self {
                self.original_file_name = Some(original_file_name.into());
                self
            }
            #[doc = "Unique id."]
            pub fn id(mut self, id: impl Into<String>) -> Self {
                self.id = Some(id.into());
                self
            }
            #[doc = "Status of the resource."]
            pub fn status(mut self, status: impl Into<String>) -> Self {
                self.status = Some(status.into());
                self
            }
            #[doc = "Date when resource was created."]
            pub fn created_date_time(mut self, created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.created_date_time = Some(created_date_time.into());
                self
            }
            #[doc = "Date when resource was last modified."]
            pub fn modified_date_time(mut self, modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.modified_date_time = Some(modified_date_time.into());
                self
            }
            #[doc = "Source of the resource."]
            pub fn source(mut self, source: impl Into<String>) -> Self {
                self.source = Some(source.into());
                self
            }
            #[doc = "Name to identify resource."]
            pub fn name(mut self, name: impl Into<String>) -> Self {
                self.name = Some(name.into());
                self
            }
            #[doc = "Textual description of resource."]
            pub fn description(mut self, description: impl Into<String>) -> Self {
                self.description = Some(description.into());
                self
            }
            #[doc = "Created by user/tenant id."]
            pub fn created_by(mut self, created_by: impl Into<String>) -> Self {
                self.created_by = Some(created_by.into());
                self
            }
            #[doc = "Modified by user/tenant id."]
            pub fn modified_by(mut self, modified_by: impl Into<String>) -> Self {
                self.modified_by = Some(modified_by.into());
                self
            }
            #[doc = "The ETag value to implement optimistic concurrency."]
            pub fn e_tag(mut self, e_tag: impl Into<String>) -> Self {
                self.e_tag = Some(e_tag.into());
                self
            }
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        unimplemented!("form data not yet supported");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insight-attachments/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id,
                    &self.insight_attachment_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::InsightAttachment>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::InsightAttachment>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_attachment_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insight-attachments/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id,
                    &self.insight_attachment_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod download {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<bytes::Bytes> {
                let bytes = self.0.into_body().collect().await?;
                let body = bytes;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_attachment_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insight-attachments/{}/file",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id,
                    &self.insight_attachment_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<bytes::Bytes>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<bytes::Bytes>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod insights {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Get a cascade delete job for specified insight."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for insights specified partyId/modelId/resourceType/resourceId."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `model_id`: Id of the associated model."]
        #[doc = "* `resource_type`: Resource Type."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        #[doc = "* `insight_id`: Insight id."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
            insight_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_id: insight_id.into(),
            }
        }
        #[doc = "Returns a paginated list of insight resources."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        pub fn list_by_party_id_model_id_and_resource(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
        ) -> list_by_party_id_model_id_and_resource::RequestBuilder {
            list_by_party_id_model_id_and_resource::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                min_insight_start_date_time: None,
                max_insight_start_date_time: None,
                min_insight_end_date_time: None,
                max_insight_end_date_time: None,
                measurement_filters: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified insight resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model.\r\nIt can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any solution id."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        #[doc = "* `insight_id`: Id of the insight resource."]
        pub fn get(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
            insight_id: impl Into<String>,
        ) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_id: insight_id.into(),
            }
        }
        #[doc = "Creates or updates insight entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model.\r\nIt can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any solution id."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        #[doc = "* `insight_id`: Id of the insight resource."]
        #[doc = "* `insight_data`: Insight data."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
            insight_id: impl Into<String>,
            insight_data: impl Into<models::Insight>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_id: insight_id.into(),
                insight_data: insight_data.into(),
            }
        }
        #[doc = "Deletes a specified insight resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `model_id`: Id of the associated model.\r\nIt can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any solution id."]
        #[doc = "* `resource_type`: Resource type associated with the record."]
        #[doc = "* `resource_id`: Id of the associated resource."]
        #[doc = "* `insight_id`: Id of the insight resource."]
        pub fn delete(
            &self,
            party_id: impl Into<String>,
            model_id: impl Into<String>,
            resource_type: impl Into<String>,
            resource_id: impl Into<String>,
            insight_id: impl Into<String>,
        ) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                model_id: model_id.into(),
                resource_type: resource_type.into(),
                resource_id: resource_id.into(),
                insight_id: insight_id.into(),
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/insights/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let model_id = &this.model_id;
                        req.url_mut().query_pairs_mut().append_pair("modelId", model_id);
                        let resource_type = &this.resource_type;
                        req.url_mut().query_pairs_mut().append_pair("resourceType", resource_type);
                        let resource_id = &this.resource_id;
                        req.url_mut().query_pairs_mut().append_pair("resourceId", resource_id);
                        let insight_id = &this.insight_id;
                        req.url_mut().query_pairs_mut().append_pair("insightId", insight_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/insights/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod list_by_party_id_model_id_and_resource {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::InsightListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::InsightListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) min_insight_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_insight_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_insight_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_insight_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) measurement_filters: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum insightStartDateTime time of insight resources (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn min_insight_start_date_time(mut self, min_insight_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_insight_start_date_time = Some(min_insight_start_date_time.into());
                self
            }
            #[doc = "Maximum insightStartDateTime time of insight resources (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn max_insight_start_date_time(mut self, max_insight_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_insight_start_date_time = Some(max_insight_start_date_time.into());
                self
            }
            #[doc = "Minimum insightEndDateTime time of insight resources (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn min_insight_end_date_time(mut self, min_insight_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_insight_end_date_time = Some(min_insight_end_date_time.into());
                self
            }
            #[doc = "Maximum insightEndDateTime time of insight resources (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn max_insight_end_date_time(mut self, max_insight_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_insight_end_date_time = Some(max_insight_end_date_time.into());
                self
            }
            #[doc = "Filters on measureKey.unit/unitValue or measureKey.value/value pairs within the Measures object.\r\neg. \"measureKey.unit eq {testValue}\" where testValue is string.\r\neg. \"measureKey.value eq {testValue}\" where testValue = double."]
            pub fn measurement_filters(mut self, measurement_filters: Vec<String>) -> Self {
                self.measurement_filters = measurement_filters;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::InsightListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_insight_start_date_time) = &this.min_insight_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minInsightStartDateTime", &min_insight_start_date_time.to_string());
                                }
                                if let Some(max_insight_start_date_time) = &this.max_insight_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxInsightStartDateTime", &max_insight_start_date_time.to_string());
                                }
                                if let Some(min_insight_end_date_time) = &this.min_insight_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minInsightEndDateTime", &min_insight_end_date_time.to_string());
                                }
                                if let Some(max_insight_end_date_time) = &this.max_insight_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxInsightEndDateTime", &max_insight_end_date_time.to_string());
                                }
                                let measurement_filters = &this.measurement_filters;
                                for value in &this.measurement_filters {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("measurementFilters", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insights",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Insight> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Insight = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insights/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id,
                    &self.insight_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Insight>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Insight>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Insight> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Insight = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_id: String,
            pub(crate) insight_data: models::Insight,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.insight_data)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insights/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id,
                    &self.insight_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Insight>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Insight>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) model_id: String,
            pub(crate) resource_type: String,
            pub(crate) resource_id: String,
            pub(crate) insight_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/models/{}/resource-types/{}/resources/{}/insights/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.model_id,
                    &self.resource_type,
                    &self.resource_id,
                    &self.insight_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod management_zones {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of management zone resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                types: Vec::new(),
                crop_ids: Vec::new(),
                season_ids: Vec::new(),
                field_ids: Vec::new(),
                sources: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a cascade delete job for specified job id."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified management zone."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `management_zone_id`: ID of the management zone to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            management_zone_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                management_zone_id: management_zone_id.into(),
            }
        }
        #[doc = "Returns a paginated list of management zone resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                types: Vec::new(),
                crop_ids: Vec::new(),
                season_ids: Vec::new(),
                field_ids: Vec::new(),
                sources: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified management zone resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `management_zone_id`: Id of the management zone."]
        pub fn get(&self, party_id: impl Into<String>, management_zone_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                management_zone_id: management_zone_id.into(),
            }
        }
        #[doc = "Creates or updates a management zone resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party resource."]
        #[doc = "* `management_zone_id`: Id of the management zone resource."]
        #[doc = "* `management_zone`: ManagementZone resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            management_zone_id: impl Into<String>,
            management_zone: impl Into<models::ManagementZone>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                management_zone_id: management_zone_id.into(),
                management_zone: management_zone.into(),
            }
        }
        #[doc = "Deletes a specified management zone resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `management_zone_id`: Id of the management zone."]
        pub fn delete(&self, party_id: impl Into<String>, management_zone_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                management_zone_id: management_zone_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ManagementZoneListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ManagementZoneListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) types: Vec<String>,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) season_ids: Vec<String>,
            pub(crate) field_ids: Vec<String>,
            pub(crate) sources: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Types of the ManagementZone."]
            pub fn types(mut self, types: Vec<String>) -> Self {
                self.types = types;
                self
            }
            #[doc = "CropIds of the ManagementZone."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "SeasonIds of the ManagementZone."]
            pub fn season_ids(mut self, season_ids: Vec<String>) -> Self {
                self.season_ids = season_ids;
                self
            }
            #[doc = "FieldIds of the ManagementZone."]
            pub fn field_ids(mut self, field_ids: Vec<String>) -> Self {
                self.field_ids = field_ids;
                self
            }
            #[doc = "Sources of the ManagementZone."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::ManagementZoneListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let types = &this.types;
                                for value in &this.types {
                                    req.url_mut().query_pairs_mut().append_pair("types", &value.to_string());
                                }
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let season_ids = &this.season_ids;
                                for value in &this.season_ids {
                                    req.url_mut().query_pairs_mut().append_pair("seasonIds", &value.to_string());
                                }
                                let field_ids = &this.field_ids;
                                for value in &this.field_ids {
                                    req.url_mut().query_pairs_mut().append_pair("fieldIds", &value.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/management-zones", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/management-zones/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) management_zone_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let management_zone_id = &this.management_zone_id;
                        req.url_mut().query_pairs_mut().append_pair("managementZoneId", management_zone_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/management-zones/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ManagementZoneListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ManagementZoneListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) types: Vec<String>,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) season_ids: Vec<String>,
            pub(crate) field_ids: Vec<String>,
            pub(crate) sources: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Types of the ManagementZone."]
            pub fn types(mut self, types: Vec<String>) -> Self {
                self.types = types;
                self
            }
            #[doc = "CropIds of the ManagementZone."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "SeasonIds of the ManagementZone."]
            pub fn season_ids(mut self, season_ids: Vec<String>) -> Self {
                self.season_ids = season_ids;
                self
            }
            #[doc = "FieldIds of the ManagementZone."]
            pub fn field_ids(mut self, field_ids: Vec<String>) -> Self {
                self.field_ids = field_ids;
                self
            }
            #[doc = "Sources of the ManagementZone."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::ManagementZoneListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let types = &this.types;
                                for value in &this.types {
                                    req.url_mut().query_pairs_mut().append_pair("types", &value.to_string());
                                }
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let season_ids = &this.season_ids;
                                for value in &this.season_ids {
                                    req.url_mut().query_pairs_mut().append_pair("seasonIds", &value.to_string());
                                }
                                let field_ids = &this.field_ids;
                                for value in &this.field_ids {
                                    req.url_mut().query_pairs_mut().append_pair("fieldIds", &value.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/management-zones", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ManagementZone> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ManagementZone = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) management_zone_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/management-zones/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.management_zone_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::ManagementZone>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::ManagementZone>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ManagementZone> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ManagementZone = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) management_zone_id: String,
            pub(crate) management_zone: models::ManagementZone,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.management_zone)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/management-zones/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.management_zone_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::ManagementZone>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::ManagementZone>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) management_zone_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/management-zones/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.management_zone_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod model_inference {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Get Biomass Model job's details."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_biomass_model_job(&self, job_id: impl Into<String>) -> get_biomass_model_job::RequestBuilder {
            get_biomass_model_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a Biomass Model job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: JobId provided by user."]
        #[doc = "* `job`: Job parameters supplied by user."]
        pub fn create_biomass_model_job(
            &self,
            job_id: impl Into<String>,
            job: impl Into<models::BiomassModelJob>,
        ) -> create_biomass_model_job::RequestBuilder {
            create_biomass_model_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job: job.into(),
            }
        }
        #[doc = "Get Sensor Placement Model job's details."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_sensor_placement_model_job(&self, job_id: impl Into<String>) -> get_sensor_placement_model_job::RequestBuilder {
            get_sensor_placement_model_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a Sensor Placement Model job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: JobId provided by user."]
        #[doc = "* `job`: Job parameters supplied by user."]
        pub fn create_sensor_placement_model_job(
            &self,
            job_id: impl Into<String>,
            job: impl Into<models::SensorPlacementModelJob>,
        ) -> create_sensor_placement_model_job::RequestBuilder {
            create_sensor_placement_model_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job: job.into(),
            }
        }
        #[doc = "Get SoilMoisture Model job's details."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_soil_moisture_model_job(&self, job_id: impl Into<String>) -> get_soil_moisture_model_job::RequestBuilder {
            get_soil_moisture_model_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a SoilMoisture Model job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: JobId provided by user."]
        #[doc = "* `job`: Job parameters supplied by user."]
        pub fn create_soil_moisture_model_job(
            &self,
            job_id: impl Into<String>,
            job: impl Into<models::SoilMoistureModelJob>,
        ) -> create_soil_moisture_model_job::RequestBuilder {
            create_soil_moisture_model_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job: job.into(),
            }
        }
    }
    pub mod get_biomass_model_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::BiomassModelJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::BiomassModelJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/model-inference/models/microsoft-biomass/infer-data/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::BiomassModelJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::BiomassModelJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_biomass_model_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::BiomassModelJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::BiomassModelJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job: models::BiomassModelJob,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.job)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/model-inference/models/microsoft-biomass/infer-data/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::BiomassModelJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::BiomassModelJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod get_sensor_placement_model_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorPlacementModelJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorPlacementModelJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/model-inference/models/microsoft-sensor-placement/infer-data/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorPlacementModelJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorPlacementModelJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_sensor_placement_model_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorPlacementModelJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorPlacementModelJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job: models::SensorPlacementModelJob,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.job)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/model-inference/models/microsoft-sensor-placement/infer-data/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorPlacementModelJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorPlacementModelJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod get_soil_moisture_model_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SoilMoistureModelJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SoilMoistureModelJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/model-inference/models/microsoft-soil-moisture/infer-data/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SoilMoistureModelJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SoilMoistureModelJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_soil_moisture_model_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SoilMoistureModelJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SoilMoistureModelJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job: models::SoilMoistureModelJob,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.job)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/model-inference/models/microsoft-soil-moisture/infer-data/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SoilMoistureModelJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SoilMoistureModelJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod nutrient_analyses {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of nutrient analysis resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                parent_type: None,
                parent_ids: Vec::new(),
                classifications: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Returns a paginated list of nutrient analysis resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                parent_type: None,
                parent_ids: Vec::new(),
                classifications: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified nutrient analysis resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `nutrient_analysis_id`: Id of the nutrient analysis."]
        pub fn get(&self, party_id: impl Into<String>, nutrient_analysis_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                nutrient_analysis_id: nutrient_analysis_id.into(),
            }
        }
        #[doc = "Creates or updates a nutrient analysis resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party resource."]
        #[doc = "* `nutrient_analysis_id`: Id of the nutrient analysis resource."]
        #[doc = "* `nutrient_analysis`: NutrientAnalysis resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            nutrient_analysis_id: impl Into<String>,
            nutrient_analysis: impl Into<models::NutrientAnalysis>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                nutrient_analysis_id: nutrient_analysis_id.into(),
                nutrient_analysis: nutrient_analysis.into(),
            }
        }
        #[doc = "Deletes a specified nutrient analysis resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `nutrient_analysis_id`: Id of the nutrient analysis."]
        pub fn delete(&self, party_id: impl Into<String>, nutrient_analysis_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                nutrient_analysis_id: nutrient_analysis_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::NutrientAnalysisListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::NutrientAnalysisListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) parent_type: Option<String>,
            pub(crate) parent_ids: Vec<String>,
            pub(crate) classifications: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Type of the parent it belongs to.\r\ni.e. PlantTissueAnalysis."]
            pub fn parent_type(mut self, parent_type: impl Into<String>) -> Self {
                self.parent_type = Some(parent_type.into());
                self
            }
            #[doc = "Parent ids of the resource."]
            pub fn parent_ids(mut self, parent_ids: Vec<String>) -> Self {
                self.parent_ids = parent_ids;
                self
            }
            #[doc = "Classifications for nutrient analyses."]
            pub fn classifications(mut self, classifications: Vec<String>) -> Self {
                self.classifications = classifications;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::NutrientAnalysisListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(parent_type) = &this.parent_type {
                                    req.url_mut().query_pairs_mut().append_pair("parentType", parent_type);
                                }
                                let parent_ids = &this.parent_ids;
                                for value in &this.parent_ids {
                                    req.url_mut().query_pairs_mut().append_pair("parentIds", &value.to_string());
                                }
                                let classifications = &this.classifications;
                                for value in &this.classifications {
                                    req.url_mut().query_pairs_mut().append_pair("classifications", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/nutrient-analyses", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::NutrientAnalysisListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::NutrientAnalysisListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) parent_type: Option<String>,
            pub(crate) parent_ids: Vec<String>,
            pub(crate) classifications: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Type of the parent it belongs to.\r\ni.e. PlantTissueAnalysis."]
            pub fn parent_type(mut self, parent_type: impl Into<String>) -> Self {
                self.parent_type = Some(parent_type.into());
                self
            }
            #[doc = "Parent ids of the resource."]
            pub fn parent_ids(mut self, parent_ids: Vec<String>) -> Self {
                self.parent_ids = parent_ids;
                self
            }
            #[doc = "Classifications for nutrient analyses."]
            pub fn classifications(mut self, classifications: Vec<String>) -> Self {
                self.classifications = classifications;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::NutrientAnalysisListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(parent_type) = &this.parent_type {
                                    req.url_mut().query_pairs_mut().append_pair("parentType", parent_type);
                                }
                                let parent_ids = &this.parent_ids;
                                for value in &this.parent_ids {
                                    req.url_mut().query_pairs_mut().append_pair("parentIds", &value.to_string());
                                }
                                let classifications = &this.classifications;
                                for value in &this.classifications {
                                    req.url_mut().query_pairs_mut().append_pair("classifications", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/nutrient-analyses", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::NutrientAnalysis> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::NutrientAnalysis = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) nutrient_analysis_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/nutrient-analyses/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.nutrient_analysis_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::NutrientAnalysis>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::NutrientAnalysis>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::NutrientAnalysis> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::NutrientAnalysis = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) nutrient_analysis_id: String,
            pub(crate) nutrient_analysis: models::NutrientAnalysis,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.nutrient_analysis)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/nutrient-analyses/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.nutrient_analysis_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::NutrientAnalysis>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::NutrientAnalysis>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) nutrient_analysis_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/nutrient-analyses/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.nutrient_analysis_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod o_auth_providers {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of oauthProvider resources."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a specified oauthProvider resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `oauth_provider_id`: ID of the oauthProvider resource."]
        pub fn get(&self, oauth_provider_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                oauth_provider_id: oauth_provider_id.into(),
            }
        }
        #[doc = "Creates or updates an oauthProvider resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `oauth_provider_id`: ID of oauthProvider resource."]
        #[doc = "* `oauth_provider`: OauthProvider resource payload to create or update."]
        pub fn create_or_update(
            &self,
            oauth_provider_id: impl Into<String>,
            oauth_provider: impl Into<models::OAuthProvider>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                oauth_provider_id: oauth_provider_id.into(),
                oauth_provider: oauth_provider.into(),
            }
        }
        #[doc = "Deletes an specified oauthProvider resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `oauth_provider_id`: ID of oauthProvider."]
        pub fn delete(&self, oauth_provider_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                oauth_provider_id: oauth_provider_id.into(),
            }
        }
        #[doc = "Get cascade delete job for oauthProvider resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create cascade delete job for oauthProvider resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job Id supplied by end user."]
        #[doc = "* `oauth_provider_id`: Id of the application data."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            oauth_provider_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                oauth_provider_id: oauth_provider_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::OAuthProviderListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::OAuthProviderListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::OAuthProviderListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/oauth/providers", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::OAuthProvider> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::OAuthProvider = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) oauth_provider_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/oauth/providers/{}", self.client.endpoint(), &self.oauth_provider_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::OAuthProvider>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::OAuthProvider>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::OAuthProvider> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::OAuthProvider = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) oauth_provider_id: String,
            pub(crate) oauth_provider: models::OAuthProvider,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.oauth_provider)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/oauth/providers/{}", self.client.endpoint(), &self.oauth_provider_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::OAuthProvider>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::OAuthProvider>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) oauth_provider_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/oauth/providers/{}", self.client.endpoint(), &self.oauth_provider_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::OAuthProviderCascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::OAuthProviderCascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/oauth/providers/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::OAuthProviderCascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::OAuthProviderCascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::OAuthProviderCascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::OAuthProviderCascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) oauth_provider_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let oauth_provider_id = &this.oauth_provider_id;
                        req.url_mut().query_pairs_mut().append_pair("oauthProviderId", oauth_provider_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/oauth/providers/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::OAuthProviderCascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::OAuthProviderCascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod o_auth_tokens {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a list of OAuthToken documents."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                auth_provider_ids: Vec::new(),
                party_ids: Vec::new(),
                is_valid: None,
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Returns Connection link needed in the OAuth flow."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `oauth_connect_request`: OAuth Connect Request."]
        pub fn get_o_auth_connection_link(
            &self,
            oauth_connect_request: impl Into<models::OAuthConnectRequest>,
        ) -> get_o_auth_connection_link::RequestBuilder {
            get_o_auth_connection_link::RequestBuilder {
                client: self.0.clone(),
                oauth_connect_request: oauth_connect_request.into(),
            }
        }
        #[doc = "Get remove job for OAuth token."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create remove job for OAuth token."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job Id supplied by end user."]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `oauth_provider_id`: Id of the OAuthProvider."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            oauth_provider_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                oauth_provider_id: oauth_provider_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::OAuthTokenListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::OAuthTokenListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) auth_provider_ids: Vec<String>,
            pub(crate) party_ids: Vec<String>,
            pub(crate) is_valid: Option<bool>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Name of AuthProvider."]
            pub fn auth_provider_ids(mut self, auth_provider_ids: Vec<String>) -> Self {
                self.auth_provider_ids = auth_provider_ids;
                self
            }
            #[doc = "List of parties."]
            pub fn party_ids(mut self, party_ids: Vec<String>) -> Self {
                self.party_ids = party_ids;
                self
            }
            #[doc = "If the token object is valid."]
            pub fn is_valid(mut self, is_valid: bool) -> Self {
                self.is_valid = Some(is_valid);
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::OAuthTokenListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let auth_provider_ids = &this.auth_provider_ids;
                                for value in &this.auth_provider_ids {
                                    req.url_mut().query_pairs_mut().append_pair("authProviderIds", &value.to_string());
                                }
                                let party_ids = &this.party_ids;
                                for value in &this.party_ids {
                                    req.url_mut().query_pairs_mut().append_pair("partyIds", &value.to_string());
                                }
                                if let Some(is_valid) = &this.is_valid {
                                    req.url_mut().query_pairs_mut().append_pair("isValid", &is_valid.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/oauth/tokens", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_o_auth_connection_link {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<String> {
                let bytes = self.0.into_body().collect().await?;
                let body: String = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) oauth_connect_request: models::OAuthConnectRequest,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.oauth_connect_request)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/oauth/tokens/:connect", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<String>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<String>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/oauth/tokens/remove/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) oauth_provider_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let oauth_provider_id = &this.oauth_provider_id;
                        req.url_mut().query_pairs_mut().append_pair("oauthProviderId", oauth_provider_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/oauth/tokens/remove/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod parties {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of party resources."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified party resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party."]
        pub fn get(&self, party_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
            }
        }
        #[doc = "Creates or updates a party resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party resource."]
        #[doc = "* `party`: Party resource payload to create or update."]
        pub fn create_or_update(&self, party_id: impl Into<String>, party: impl Into<models::Party>) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                party: party.into(),
            }
        }
        #[doc = "Deletes a specified party resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of party to be deleted."]
        pub fn delete(&self, party_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
            }
        }
        #[doc = "Get a cascade delete job for specified party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the party to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PartyListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PartyListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PartyListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Party> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Party = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Party>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Party>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Party> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Party = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) party: models::Party,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.party)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Party>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Party>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod planting_data {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of planting data resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                min_avg_planting_rate: None,
                max_avg_planting_rate: None,
                min_total_material: None,
                max_total_material: None,
                min_avg_material: None,
                max_avg_material: None,
                sources: Vec::new(),
                associated_boundary_ids: Vec::new(),
                min_operation_start_date_time: None,
                max_operation_start_date_time: None,
                min_operation_end_date_time: None,
                max_operation_end_date_time: None,
                min_operation_modified_date_time: None,
                max_operation_modified_date_time: None,
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a specified planting data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `planting_data_id`: ID of the planting data resource."]
        pub fn get(&self, party_id: impl Into<String>, planting_data_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                planting_data_id: planting_data_id.into(),
            }
        }
        #[doc = "Creates or updates an planting data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `planting_data_id`: ID of the planting data resource."]
        #[doc = "* `planting_data`: Planting data resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            planting_data_id: impl Into<String>,
            planting_data: impl Into<models::PlantingData>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                planting_data_id: planting_data_id.into(),
                planting_data: planting_data.into(),
            }
        }
        #[doc = "Deletes a specified planting data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `planting_data_id`: ID of the planting data."]
        pub fn delete(&self, party_id: impl Into<String>, planting_data_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                planting_data_id: planting_data_id.into(),
            }
        }
        #[doc = "Returns a paginated list of planting data resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                min_avg_planting_rate: None,
                max_avg_planting_rate: None,
                min_total_material: None,
                max_total_material: None,
                min_avg_material: None,
                max_avg_material: None,
                sources: Vec::new(),
                associated_boundary_ids: Vec::new(),
                min_operation_start_date_time: None,
                max_operation_start_date_time: None,
                min_operation_end_date_time: None,
                max_operation_end_date_time: None,
                min_operation_modified_date_time: None,
                max_operation_modified_date_time: None,
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get cascade delete job for planting data resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create cascade delete job for planting data resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job Id supplied by end user."]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `planting_data_id`: Id of the planting data."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            planting_data_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                planting_data_id: planting_data_id.into(),
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PlantingDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PlantingDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) min_avg_planting_rate: Option<f64>,
            pub(crate) max_avg_planting_rate: Option<f64>,
            pub(crate) min_total_material: Option<f64>,
            pub(crate) max_total_material: Option<f64>,
            pub(crate) min_avg_material: Option<f64>,
            pub(crate) max_avg_material: Option<f64>,
            pub(crate) sources: Vec<String>,
            pub(crate) associated_boundary_ids: Vec<String>,
            pub(crate) min_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum AvgPlantingRate value(inclusive)."]
            pub fn min_avg_planting_rate(mut self, min_avg_planting_rate: f64) -> Self {
                self.min_avg_planting_rate = Some(min_avg_planting_rate);
                self
            }
            #[doc = "Maximum AvgPlantingRate value (inclusive)."]
            pub fn max_avg_planting_rate(mut self, max_avg_planting_rate: f64) -> Self {
                self.max_avg_planting_rate = Some(max_avg_planting_rate);
                self
            }
            #[doc = "Minimum TotalMaterial value(inclusive)."]
            pub fn min_total_material(mut self, min_total_material: f64) -> Self {
                self.min_total_material = Some(min_total_material);
                self
            }
            #[doc = "Maximum TotalMaterial value (inclusive)."]
            pub fn max_total_material(mut self, max_total_material: f64) -> Self {
                self.max_total_material = Some(max_total_material);
                self
            }
            #[doc = "Minimum AvgMaterial value(inclusive)."]
            pub fn min_avg_material(mut self, min_avg_material: f64) -> Self {
                self.min_avg_material = Some(min_avg_material);
                self
            }
            #[doc = "Maximum AvgMaterial value (inclusive)."]
            pub fn max_avg_material(mut self, max_avg_material: f64) -> Self {
                self.max_avg_material = Some(max_avg_material);
                self
            }
            #[doc = "Sources of the operation data."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Boundary IDs associated with operation data."]
            pub fn associated_boundary_ids(mut self, associated_boundary_ids: Vec<String>) -> Self {
                self.associated_boundary_ids = associated_boundary_ids;
                self
            }
            #[doc = "Minimum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_start_date_time(mut self, min_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_start_date_time = Some(min_operation_start_date_time.into());
                self
            }
            #[doc = "Maximum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_start_date_time(mut self, max_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_start_date_time = Some(max_operation_start_date_time.into());
                self
            }
            #[doc = "Minimum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_end_date_time(mut self, min_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_end_date_time = Some(min_operation_end_date_time.into());
                self
            }
            #[doc = "Maximum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_end_date_time(mut self, max_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_end_date_time = Some(max_operation_end_date_time.into());
                self
            }
            #[doc = "Minimum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_modified_date_time(mut self, min_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_modified_date_time = Some(min_operation_modified_date_time.into());
                self
            }
            #[doc = "Maximum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_modified_date_time(mut self, max_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_modified_date_time = Some(max_operation_modified_date_time.into());
                self
            }
            #[doc = "Minimum area for which operation was applied (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum area for which operation was applied (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PlantingDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_avg_planting_rate) = &this.min_avg_planting_rate {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgPlantingRate", &min_avg_planting_rate.to_string());
                                }
                                if let Some(max_avg_planting_rate) = &this.max_avg_planting_rate {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgPlantingRate", &max_avg_planting_rate.to_string());
                                }
                                if let Some(min_total_material) = &this.min_total_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTotalMaterial", &min_total_material.to_string());
                                }
                                if let Some(max_total_material) = &this.max_total_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTotalMaterial", &max_total_material.to_string());
                                }
                                if let Some(min_avg_material) = &this.min_avg_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgMaterial", &min_avg_material.to_string());
                                }
                                if let Some(max_avg_material) = &this.max_avg_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgMaterial", &max_avg_material.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let associated_boundary_ids = &this.associated_boundary_ids;
                                for value in &this.associated_boundary_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("associatedBoundaryIds", &value.to_string());
                                }
                                if let Some(min_operation_start_date_time) = &this.min_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationStartDateTime", &min_operation_start_date_time.to_string());
                                }
                                if let Some(max_operation_start_date_time) = &this.max_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationStartDateTime", &max_operation_start_date_time.to_string());
                                }
                                if let Some(min_operation_end_date_time) = &this.min_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationEndDateTime", &min_operation_end_date_time.to_string());
                                }
                                if let Some(max_operation_end_date_time) = &this.max_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationEndDateTime", &max_operation_end_date_time.to_string());
                                }
                                if let Some(min_operation_modified_date_time) = &this.min_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationModifiedDateTime", &min_operation_modified_date_time.to_string());
                                }
                                if let Some(max_operation_modified_date_time) = &this.max_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationModifiedDateTime", &max_operation_modified_date_time.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/planting-data", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PlantingData> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PlantingData = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) planting_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/planting-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.planting_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::PlantingData>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::PlantingData>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PlantingData> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PlantingData = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) planting_data_id: String,
            pub(crate) planting_data: models::PlantingData,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.planting_data)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/planting-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.planting_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::PlantingData>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::PlantingData>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) planting_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/planting-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.planting_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PlantingDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PlantingDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) min_avg_planting_rate: Option<f64>,
            pub(crate) max_avg_planting_rate: Option<f64>,
            pub(crate) min_total_material: Option<f64>,
            pub(crate) max_total_material: Option<f64>,
            pub(crate) min_avg_material: Option<f64>,
            pub(crate) max_avg_material: Option<f64>,
            pub(crate) sources: Vec<String>,
            pub(crate) associated_boundary_ids: Vec<String>,
            pub(crate) min_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum AvgPlantingRate value(inclusive)."]
            pub fn min_avg_planting_rate(mut self, min_avg_planting_rate: f64) -> Self {
                self.min_avg_planting_rate = Some(min_avg_planting_rate);
                self
            }
            #[doc = "Maximum AvgPlantingRate value (inclusive)."]
            pub fn max_avg_planting_rate(mut self, max_avg_planting_rate: f64) -> Self {
                self.max_avg_planting_rate = Some(max_avg_planting_rate);
                self
            }
            #[doc = "Minimum TotalMaterial value(inclusive)."]
            pub fn min_total_material(mut self, min_total_material: f64) -> Self {
                self.min_total_material = Some(min_total_material);
                self
            }
            #[doc = "Maximum TotalMaterial value (inclusive)."]
            pub fn max_total_material(mut self, max_total_material: f64) -> Self {
                self.max_total_material = Some(max_total_material);
                self
            }
            #[doc = "Minimum AvgMaterial value(inclusive)."]
            pub fn min_avg_material(mut self, min_avg_material: f64) -> Self {
                self.min_avg_material = Some(min_avg_material);
                self
            }
            #[doc = "Maximum AvgMaterial value (inclusive)."]
            pub fn max_avg_material(mut self, max_avg_material: f64) -> Self {
                self.max_avg_material = Some(max_avg_material);
                self
            }
            #[doc = "Sources of the operation data."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Boundary IDs associated with operation data."]
            pub fn associated_boundary_ids(mut self, associated_boundary_ids: Vec<String>) -> Self {
                self.associated_boundary_ids = associated_boundary_ids;
                self
            }
            #[doc = "Minimum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_start_date_time(mut self, min_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_start_date_time = Some(min_operation_start_date_time.into());
                self
            }
            #[doc = "Maximum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_start_date_time(mut self, max_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_start_date_time = Some(max_operation_start_date_time.into());
                self
            }
            #[doc = "Minimum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_end_date_time(mut self, min_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_end_date_time = Some(min_operation_end_date_time.into());
                self
            }
            #[doc = "Maximum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_end_date_time(mut self, max_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_end_date_time = Some(max_operation_end_date_time.into());
                self
            }
            #[doc = "Minimum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_modified_date_time(mut self, min_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_modified_date_time = Some(min_operation_modified_date_time.into());
                self
            }
            #[doc = "Maximum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_modified_date_time(mut self, max_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_modified_date_time = Some(max_operation_modified_date_time.into());
                self
            }
            #[doc = "Minimum area for which operation was applied (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum area for which operation was applied (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PlantingDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_avg_planting_rate) = &this.min_avg_planting_rate {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgPlantingRate", &min_avg_planting_rate.to_string());
                                }
                                if let Some(max_avg_planting_rate) = &this.max_avg_planting_rate {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgPlantingRate", &max_avg_planting_rate.to_string());
                                }
                                if let Some(min_total_material) = &this.min_total_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTotalMaterial", &min_total_material.to_string());
                                }
                                if let Some(max_total_material) = &this.max_total_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTotalMaterial", &max_total_material.to_string());
                                }
                                if let Some(min_avg_material) = &this.min_avg_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minAvgMaterial", &min_avg_material.to_string());
                                }
                                if let Some(max_avg_material) = &this.max_avg_material {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxAvgMaterial", &max_avg_material.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let associated_boundary_ids = &this.associated_boundary_ids;
                                for value in &this.associated_boundary_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("associatedBoundaryIds", &value.to_string());
                                }
                                if let Some(min_operation_start_date_time) = &this.min_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationStartDateTime", &min_operation_start_date_time.to_string());
                                }
                                if let Some(max_operation_start_date_time) = &this.max_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationStartDateTime", &max_operation_start_date_time.to_string());
                                }
                                if let Some(min_operation_end_date_time) = &this.min_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationEndDateTime", &min_operation_end_date_time.to_string());
                                }
                                if let Some(max_operation_end_date_time) = &this.max_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationEndDateTime", &max_operation_end_date_time.to_string());
                                }
                                if let Some(min_operation_modified_date_time) = &this.min_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationModifiedDateTime", &min_operation_modified_date_time.to_string());
                                }
                                if let Some(max_operation_modified_date_time) = &this.max_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationModifiedDateTime", &max_operation_modified_date_time.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/planting-data", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/planting-data/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) planting_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let planting_data_id = &this.planting_data_id;
                        req.url_mut().query_pairs_mut().append_pair("plantingDataId", planting_data_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/planting-data/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod plant_tissue_analyses {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of plant tissue analysis resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                season_ids: Vec::new(),
                crop_ids: Vec::new(),
                crop_products_ids: Vec::new(),
                field_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified plant tissue analysis resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `plant_tissue_analysis_id`: Id of the plant tissue analysis."]
        pub fn get(&self, party_id: impl Into<String>, plant_tissue_analysis_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                plant_tissue_analysis_id: plant_tissue_analysis_id.into(),
            }
        }
        #[doc = "Creates or updates a plant tissue analysis resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party resource."]
        #[doc = "* `plant_tissue_analysis_id`: Id of the plant tissue analysis resource."]
        #[doc = "* `plant_tissue_analysis`: PlantTissueAnalysis resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            plant_tissue_analysis_id: impl Into<String>,
            plant_tissue_analysis: impl Into<models::PlantTissueAnalysis>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                plant_tissue_analysis_id: plant_tissue_analysis_id.into(),
                plant_tissue_analysis: plant_tissue_analysis.into(),
            }
        }
        #[doc = "Deletes a specified plant tissue analysis resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `plant_tissue_analysis_id`: Id of the plant tissue analysis."]
        pub fn delete(&self, party_id: impl Into<String>, plant_tissue_analysis_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                plant_tissue_analysis_id: plant_tissue_analysis_id.into(),
            }
        }
        #[doc = "Returns a paginated list of plant tissue analysis resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                season_ids: Vec::new(),
                crop_ids: Vec::new(),
                crop_products_ids: Vec::new(),
                field_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a cascade delete job for specified plant tissue analysis."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified plant tissue analysis."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `plant_tissue_analysis_id`: ID of the plant tissue analysis to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            plant_tissue_analysis_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                plant_tissue_analysis_id: plant_tissue_analysis_id.into(),
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PlantTissueAnalysisListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PlantTissueAnalysisListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) season_ids: Vec<String>,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) crop_products_ids: Vec<String>,
            pub(crate) field_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Season ids of the plant tissue analyses."]
            pub fn season_ids(mut self, season_ids: Vec<String>) -> Self {
                self.season_ids = season_ids;
                self
            }
            #[doc = "Crop ids of the plant tissue analyses."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "Crop products ids of the plant tissue analyses."]
            pub fn crop_products_ids(mut self, crop_products_ids: Vec<String>) -> Self {
                self.crop_products_ids = crop_products_ids;
                self
            }
            #[doc = "Field ids of the plant tissue analyses."]
            pub fn field_ids(mut self, field_ids: Vec<String>) -> Self {
                self.field_ids = field_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PlantTissueAnalysisListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let season_ids = &this.season_ids;
                                for value in &this.season_ids {
                                    req.url_mut().query_pairs_mut().append_pair("seasonIds", &value.to_string());
                                }
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let crop_products_ids = &this.crop_products_ids;
                                for value in &this.crop_products_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropProductsIds", &value.to_string());
                                }
                                let field_ids = &this.field_ids;
                                for value in &this.field_ids {
                                    req.url_mut().query_pairs_mut().append_pair("fieldIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/plant-tissue-analyses",
                    self.client.endpoint(),
                    &self.party_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PlantTissueAnalysis> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PlantTissueAnalysis = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) plant_tissue_analysis_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/plant-tissue-analyses/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.plant_tissue_analysis_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::PlantTissueAnalysis>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::PlantTissueAnalysis>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PlantTissueAnalysis> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PlantTissueAnalysis = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) plant_tissue_analysis_id: String,
            pub(crate) plant_tissue_analysis: models::PlantTissueAnalysis,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.plant_tissue_analysis)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/plant-tissue-analyses/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.plant_tissue_analysis_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::PlantTissueAnalysis>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::PlantTissueAnalysis>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) plant_tissue_analysis_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/plant-tissue-analyses/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.plant_tissue_analysis_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PlantTissueAnalysisListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PlantTissueAnalysisListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) season_ids: Vec<String>,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) crop_products_ids: Vec<String>,
            pub(crate) field_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Season ids of the plant tissue analyses."]
            pub fn season_ids(mut self, season_ids: Vec<String>) -> Self {
                self.season_ids = season_ids;
                self
            }
            #[doc = "Crop ids of the plant tissue analyses."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "Crop products ids of the plant tissue analyses."]
            pub fn crop_products_ids(mut self, crop_products_ids: Vec<String>) -> Self {
                self.crop_products_ids = crop_products_ids;
                self
            }
            #[doc = "Field ids of the plant tissue analyses."]
            pub fn field_ids(mut self, field_ids: Vec<String>) -> Self {
                self.field_ids = field_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PlantTissueAnalysisListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let season_ids = &this.season_ids;
                                for value in &this.season_ids {
                                    req.url_mut().query_pairs_mut().append_pair("seasonIds", &value.to_string());
                                }
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let crop_products_ids = &this.crop_products_ids;
                                for value in &this.crop_products_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropProductsIds", &value.to_string());
                                }
                                let field_ids = &this.field_ids;
                                for value in &this.field_ids {
                                    req.url_mut().query_pairs_mut().append_pair("fieldIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/plant-tissue-analyses", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/plant-tissue-analyses/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) plant_tissue_analysis_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let plant_tissue_analysis_id = &this.plant_tissue_analysis_id;
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("plantTissueAnalysisId", plant_tissue_analysis_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/plant-tissue-analyses/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod prescription_maps {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of prescription map resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                types: Vec::new(),
                crop_ids: Vec::new(),
                season_ids: Vec::new(),
                field_ids: Vec::new(),
                sources: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified prescription map resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `prescription_map_id`: Id of the prescription map."]
        pub fn get(&self, party_id: impl Into<String>, prescription_map_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                prescription_map_id: prescription_map_id.into(),
            }
        }
        #[doc = "Creates or Updates a prescription map resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party resource."]
        #[doc = "* `prescription_map_id`: Id of the prescription map resource."]
        #[doc = "* `prescription_map`: PrescriptionMap resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            prescription_map_id: impl Into<String>,
            prescription_map: impl Into<models::PrescriptionMap>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                prescription_map_id: prescription_map_id.into(),
                prescription_map: prescription_map.into(),
            }
        }
        #[doc = "Deletes a specified prescription map resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `prescription_map_id`: Id of the prescriptionMap."]
        pub fn delete(&self, party_id: impl Into<String>, prescription_map_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                prescription_map_id: prescription_map_id.into(),
            }
        }
        #[doc = "Returns a paginated list of prescription map resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                types: Vec::new(),
                crop_ids: Vec::new(),
                season_ids: Vec::new(),
                field_ids: Vec::new(),
                sources: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a cascade delete job for specified prescription map."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified prescription map."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `prescription_map_id`: ID of the prescription map to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            prescription_map_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                prescription_map_id: prescription_map_id.into(),
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PrescriptionMapListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PrescriptionMapListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) types: Vec<String>,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) season_ids: Vec<String>,
            pub(crate) field_ids: Vec<String>,
            pub(crate) sources: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Types of the resource."]
            pub fn types(mut self, types: Vec<String>) -> Self {
                self.types = types;
                self
            }
            #[doc = "Crop Ids of the resource."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "Season Ids of the resource."]
            pub fn season_ids(mut self, season_ids: Vec<String>) -> Self {
                self.season_ids = season_ids;
                self
            }
            #[doc = "Field Ids of the resource."]
            pub fn field_ids(mut self, field_ids: Vec<String>) -> Self {
                self.field_ids = field_ids;
                self
            }
            #[doc = "Sources for the resource."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PrescriptionMapListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let types = &this.types;
                                for value in &this.types {
                                    req.url_mut().query_pairs_mut().append_pair("types", &value.to_string());
                                }
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let season_ids = &this.season_ids;
                                for value in &this.season_ids {
                                    req.url_mut().query_pairs_mut().append_pair("seasonIds", &value.to_string());
                                }
                                let field_ids = &this.field_ids;
                                for value in &this.field_ids {
                                    req.url_mut().query_pairs_mut().append_pair("fieldIds", &value.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/prescription-maps", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PrescriptionMap> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PrescriptionMap = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) prescription_map_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/prescription-maps/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.prescription_map_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::PrescriptionMap>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::PrescriptionMap>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PrescriptionMap> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PrescriptionMap = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) prescription_map_id: String,
            pub(crate) prescription_map: models::PrescriptionMap,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.prescription_map)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/prescription-maps/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.prescription_map_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::PrescriptionMap>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::PrescriptionMap>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) prescription_map_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/prescription-maps/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.prescription_map_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PrescriptionMapListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PrescriptionMapListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) types: Vec<String>,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) season_ids: Vec<String>,
            pub(crate) field_ids: Vec<String>,
            pub(crate) sources: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Types of the resource."]
            pub fn types(mut self, types: Vec<String>) -> Self {
                self.types = types;
                self
            }
            #[doc = "Crop Ids of the resource."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "Season Ids of the resource."]
            pub fn season_ids(mut self, season_ids: Vec<String>) -> Self {
                self.season_ids = season_ids;
                self
            }
            #[doc = "Field Ids of the resource."]
            pub fn field_ids(mut self, field_ids: Vec<String>) -> Self {
                self.field_ids = field_ids;
                self
            }
            #[doc = "Sources for the resource."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PrescriptionMapListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let types = &this.types;
                                for value in &this.types {
                                    req.url_mut().query_pairs_mut().append_pair("types", &value.to_string());
                                }
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let season_ids = &this.season_ids;
                                for value in &this.season_ids {
                                    req.url_mut().query_pairs_mut().append_pair("seasonIds", &value.to_string());
                                }
                                let field_ids = &this.field_ids;
                                for value in &this.field_ids {
                                    req.url_mut().query_pairs_mut().append_pair("fieldIds", &value.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/prescription-maps", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/prescription-maps/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) prescription_map_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let prescription_map_id = &this.prescription_map_id;
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("prescriptionMapId", prescription_map_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/prescription-maps/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod prescriptions {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of prescription resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                prescription_map_ids: Vec::new(),
                types: Vec::new(),
                product_codes: Vec::new(),
                product_names: Vec::new(),
                sources: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified prescription resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `prescription_id`: Id of the prescription."]
        pub fn get(&self, party_id: impl Into<String>, prescription_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                prescription_id: prescription_id.into(),
            }
        }
        #[doc = "Creates or Updates a prescription resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party resource."]
        #[doc = "* `prescription_id`: Id of the prescription resource."]
        #[doc = "* `prescription`: Prescription resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            prescription_id: impl Into<String>,
            prescription: impl Into<models::Prescription>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                prescription_id: prescription_id.into(),
                prescription: prescription.into(),
            }
        }
        #[doc = "Deletes a specified prescription resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `prescription_id`: Id of the prescription."]
        pub fn delete(&self, party_id: impl Into<String>, prescription_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                prescription_id: prescription_id.into(),
            }
        }
        #[doc = "Returns a paginated list of prescription resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                prescription_map_ids: Vec::new(),
                types: Vec::new(),
                product_codes: Vec::new(),
                product_names: Vec::new(),
                sources: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a cascade delete job for specified prescription."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified prescription."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `prescription_id`: ID of the prescription to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            prescription_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                prescription_id: prescription_id.into(),
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PrescriptionListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PrescriptionListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) prescription_map_ids: Vec<String>,
            pub(crate) types: Vec<String>,
            pub(crate) product_codes: Vec<String>,
            pub(crate) product_names: Vec<String>,
            pub(crate) sources: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Prescription Map Ids of the resource."]
            pub fn prescription_map_ids(mut self, prescription_map_ids: Vec<String>) -> Self {
                self.prescription_map_ids = prescription_map_ids;
                self
            }
            #[doc = "Types of the resource."]
            pub fn types(mut self, types: Vec<String>) -> Self {
                self.types = types;
                self
            }
            #[doc = "Product Codes of the resource."]
            pub fn product_codes(mut self, product_codes: Vec<String>) -> Self {
                self.product_codes = product_codes;
                self
            }
            #[doc = "Product Names of the resource."]
            pub fn product_names(mut self, product_names: Vec<String>) -> Self {
                self.product_names = product_names;
                self
            }
            #[doc = "Sources for the resource."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PrescriptionListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let prescription_map_ids = &this.prescription_map_ids;
                                for value in &this.prescription_map_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("prescriptionMapIds", &value.to_string());
                                }
                                let types = &this.types;
                                for value in &this.types {
                                    req.url_mut().query_pairs_mut().append_pair("types", &value.to_string());
                                }
                                let product_codes = &this.product_codes;
                                for value in &this.product_codes {
                                    req.url_mut().query_pairs_mut().append_pair("productCodes", &value.to_string());
                                }
                                let product_names = &this.product_names;
                                for value in &this.product_names {
                                    req.url_mut().query_pairs_mut().append_pair("productNames", &value.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/prescriptions", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Prescription> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Prescription = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) prescription_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/prescriptions/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.prescription_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Prescription>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Prescription>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Prescription> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Prescription = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) prescription_id: String,
            pub(crate) prescription: models::Prescription,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.prescription)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/prescriptions/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.prescription_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Prescription>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Prescription>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) prescription_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/prescriptions/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.prescription_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::PrescriptionListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::PrescriptionListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) prescription_map_ids: Vec<String>,
            pub(crate) types: Vec<String>,
            pub(crate) product_codes: Vec<String>,
            pub(crate) product_names: Vec<String>,
            pub(crate) sources: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Prescription Map Ids of the resource."]
            pub fn prescription_map_ids(mut self, prescription_map_ids: Vec<String>) -> Self {
                self.prescription_map_ids = prescription_map_ids;
                self
            }
            #[doc = "Types of the resource."]
            pub fn types(mut self, types: Vec<String>) -> Self {
                self.types = types;
                self
            }
            #[doc = "Product Codes of the resource."]
            pub fn product_codes(mut self, product_codes: Vec<String>) -> Self {
                self.product_codes = product_codes;
                self
            }
            #[doc = "Product Names of the resource."]
            pub fn product_names(mut self, product_names: Vec<String>) -> Self {
                self.product_names = product_names;
                self
            }
            #[doc = "Sources for the resource."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::PrescriptionListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let prescription_map_ids = &this.prescription_map_ids;
                                for value in &this.prescription_map_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("prescriptionMapIds", &value.to_string());
                                }
                                let types = &this.types;
                                for value in &this.types {
                                    req.url_mut().query_pairs_mut().append_pair("types", &value.to_string());
                                }
                                let product_codes = &this.product_codes;
                                for value in &this.product_codes {
                                    req.url_mut().query_pairs_mut().append_pair("productCodes", &value.to_string());
                                }
                                let product_names = &this.product_names;
                                for value in &this.product_names {
                                    req.url_mut().query_pairs_mut().append_pair("productNames", &value.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/prescriptions", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/prescriptions/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) prescription_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let prescription_id = &this.prescription_id;
                        req.url_mut().query_pairs_mut().append_pair("prescriptionId", prescription_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/prescriptions/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod scenes {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of scene resources."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `provider`: Provider name of scene data. Supported value: SentinelHub."]
        #[doc = "* `party_id`: PartyId."]
        #[doc = "* `boundary_id`: BoundaryId."]
        #[doc = "* `source`: Source name of scene data, Available Values: Sentinel_2_L2A, Sentinel_2_L1C."]
        pub fn list(
            &self,
            provider: impl Into<String>,
            party_id: impl Into<String>,
            boundary_id: impl Into<String>,
            source: impl Into<String>,
        ) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                provider: provider.into(),
                party_id: party_id.into(),
                boundary_id: boundary_id.into(),
                source: source.into(),
                start_date_time: None,
                end_date_time: None,
                max_cloud_coverage_percentage: None,
                max_dark_pixel_coverage_percentage: None,
                image_names: Vec::new(),
                image_resolutions: Vec::new(),
                image_formats: Vec::new(),
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Downloads and returns file Stream as response for the given input filePath."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `file_path`: cloud storage path of scene file."]
        pub fn download(&self, file_path: impl Into<String>) -> download::RequestBuilder {
            download::RequestBuilder {
                client: self.0.clone(),
                file_path: file_path.into(),
            }
        }
        #[doc = "Get a satellite data ingestion job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_satellite_data_ingestion_job_details(
            &self,
            job_id: impl Into<String>,
        ) -> get_satellite_data_ingestion_job_details::RequestBuilder {
            get_satellite_data_ingestion_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a satellite data ingestion job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: JobId provided by user."]
        #[doc = "* `job`: Job parameters supplied by user."]
        pub fn create_satellite_data_ingestion_job(
            &self,
            job_id: impl Into<String>,
            job: impl Into<models::SatelliteDataIngestionJob>,
        ) -> create_satellite_data_ingestion_job::RequestBuilder {
            create_satellite_data_ingestion_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job: job.into(),
            }
        }
        #[doc = "Search for STAC features by collection id, bbox, intersecting geometry, start and end datetime."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `collection_id`: Collection Id to be searched."]
        #[doc = "* `search_features_query`: Query filters."]
        pub fn search_features(
            &self,
            collection_id: impl Into<String>,
            search_features_query: impl Into<models::SearchFeaturesQuery>,
        ) -> search_features::RequestBuilder {
            search_features::RequestBuilder {
                client: self.0.clone(),
                collection_id: collection_id.into(),
                search_features_query: search_features_query.into(),
                maxpagesize: None,
                skip: None,
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SceneListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SceneListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) provider: String,
            pub(crate) party_id: String,
            pub(crate) boundary_id: String,
            pub(crate) source: String,
            pub(crate) start_date_time: Option<time::OffsetDateTime>,
            pub(crate) end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_cloud_coverage_percentage: Option<f64>,
            pub(crate) max_dark_pixel_coverage_percentage: Option<f64>,
            pub(crate) image_names: Vec<String>,
            pub(crate) image_resolutions: Vec<f64>,
            pub(crate) image_formats: Vec<String>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Scene start UTC datetime (inclusive), sample format: yyyy-MM-ddThh:mm:ssZ."]
            pub fn start_date_time(mut self, start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.start_date_time = Some(start_date_time.into());
                self
            }
            #[doc = "Scene end UTC datetime (inclusive), sample format: yyyy-MM-dThh:mm:ssZ."]
            pub fn end_date_time(mut self, end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.end_date_time = Some(end_date_time.into());
                self
            }
            #[doc = "Filter scenes with cloud coverage percentage less than max value. Range [0 to 100.0]."]
            pub fn max_cloud_coverage_percentage(mut self, max_cloud_coverage_percentage: f64) -> Self {
                self.max_cloud_coverage_percentage = Some(max_cloud_coverage_percentage);
                self
            }
            #[doc = "Filter scenes with dark pixel coverage percentage less than max value. Range [0 to 100.0]."]
            pub fn max_dark_pixel_coverage_percentage(mut self, max_dark_pixel_coverage_percentage: f64) -> Self {
                self.max_dark_pixel_coverage_percentage = Some(max_dark_pixel_coverage_percentage);
                self
            }
            #[doc = "List of image names to be filtered."]
            pub fn image_names(mut self, image_names: Vec<String>) -> Self {
                self.image_names = image_names;
                self
            }
            #[doc = "List of image resolutions in meters to be filtered."]
            pub fn image_resolutions(mut self, image_resolutions: Vec<f64>) -> Self {
                self.image_resolutions = image_resolutions;
                self
            }
            #[doc = "List of image formats to be filtered."]
            pub fn image_formats(mut self, image_formats: Vec<String>) -> Self {
                self.image_formats = image_formats;
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::SceneListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let provider = &this.provider;
                                req.url_mut().query_pairs_mut().append_pair("provider", provider);
                                let party_id = &this.party_id;
                                req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                                let boundary_id = &this.boundary_id;
                                req.url_mut().query_pairs_mut().append_pair("boundaryId", boundary_id);
                                let source = &this.source;
                                req.url_mut().query_pairs_mut().append_pair("source", source);
                                if let Some(start_date_time) = &this.start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("startDateTime", &start_date_time.to_string());
                                }
                                if let Some(end_date_time) = &this.end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("endDateTime", &end_date_time.to_string());
                                }
                                if let Some(max_cloud_coverage_percentage) = &this.max_cloud_coverage_percentage {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCloudCoveragePercentage", &max_cloud_coverage_percentage.to_string());
                                }
                                if let Some(max_dark_pixel_coverage_percentage) = &this.max_dark_pixel_coverage_percentage {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxDarkPixelCoveragePercentage", &max_dark_pixel_coverage_percentage.to_string());
                                }
                                let image_names = &this.image_names;
                                for value in &this.image_names {
                                    req.url_mut().query_pairs_mut().append_pair("imageNames", &value.to_string());
                                }
                                let image_resolutions = &this.image_resolutions;
                                for value in &this.image_resolutions {
                                    req.url_mut().query_pairs_mut().append_pair("imageResolutions", &value.to_string());
                                }
                                let image_formats = &this.image_formats;
                                for value in &this.image_formats {
                                    req.url_mut().query_pairs_mut().append_pair("imageFormats", &value.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/scenes", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod download {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<bytes::Bytes> {
                let bytes = self.0.into_body().collect().await?;
                let body = bytes;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) file_path: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let file_path = &this.file_path;
                        req.url_mut().query_pairs_mut().append_pair("filePath", file_path);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/scenes/downloadFiles", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<bytes::Bytes>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<bytes::Bytes>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod get_satellite_data_ingestion_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SatelliteDataIngestionJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SatelliteDataIngestionJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/scenes/satellite/ingest-data/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SatelliteDataIngestionJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SatelliteDataIngestionJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_satellite_data_ingestion_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SatelliteDataIngestionJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SatelliteDataIngestionJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job: models::SatelliteDataIngestionJob,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.job)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/scenes/satellite/ingest-data/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SatelliteDataIngestionJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SatelliteDataIngestionJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod search_features {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SearchFeaturesResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SearchFeaturesResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) collection_id: String,
            pub(crate) search_features_query: models::SearchFeaturesQuery,
            pub(crate) maxpagesize: Option<i32>,
            pub(crate) skip: Option<i32>,
        }
        impl RequestBuilder {
            #[doc = "Maximum number of features needed (inclusive). Minimum = 1, Maximum = 100, Default value = 10."]
            pub fn maxpagesize(mut self, maxpagesize: i32) -> Self {
                self.maxpagesize = Some(maxpagesize);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip(mut self, skip: i32) -> Self {
                self.skip = Some(skip);
                self
            }
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(maxpagesize) = &this.maxpagesize {
                            req.url_mut().query_pairs_mut().append_pair("maxpagesize", &maxpagesize.to_string());
                        }
                        if let Some(skip) = &this.skip {
                            req.url_mut().query_pairs_mut().append_pair("skip", &skip.to_string());
                        }
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.search_features_query)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/scenes/stac-collections/{}:search",
                    self.client.endpoint(),
                    &self.collection_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SearchFeaturesResponse>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SearchFeaturesResponse>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod seasonal_fields {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of seasonal field resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                farm_ids: Vec::new(),
                field_ids: Vec::new(),
                season_ids: Vec::new(),
                crop_product_ids: Vec::new(),
                crop_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified seasonal field resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `seasonal_field_id`: Id of the seasonal field."]
        pub fn get(&self, party_id: impl Into<String>, seasonal_field_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                seasonal_field_id: seasonal_field_id.into(),
            }
        }
        #[doc = "Creates or Updates a seasonal field resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party resource."]
        #[doc = "* `seasonal_field_id`: Id of the seasonal field resource."]
        #[doc = "* `seasonal_field`: Seasonal field resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            seasonal_field_id: impl Into<String>,
            seasonal_field: impl Into<models::SeasonalField>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                seasonal_field_id: seasonal_field_id.into(),
                seasonal_field: seasonal_field.into(),
            }
        }
        #[doc = "Deletes a specified seasonal-field resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `seasonal_field_id`: Id of the seasonal field."]
        pub fn delete(&self, party_id: impl Into<String>, seasonal_field_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                seasonal_field_id: seasonal_field_id.into(),
            }
        }
        #[doc = "Returns a paginated list of seasonal field resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                farm_ids: Vec::new(),
                field_ids: Vec::new(),
                season_ids: Vec::new(),
                crop_product_ids: Vec::new(),
                crop_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get cascade delete job for specified seasonal field."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified seasonal field."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `seasonal_field_id`: ID of the seasonalField to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            seasonal_field_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                seasonal_field_id: seasonal_field_id.into(),
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SeasonalFieldListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SeasonalFieldListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) farm_ids: Vec<String>,
            pub(crate) field_ids: Vec<String>,
            pub(crate) season_ids: Vec<String>,
            pub(crate) crop_product_ids: Vec<String>,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Farm Ids of the resource."]
            pub fn farm_ids(mut self, farm_ids: Vec<String>) -> Self {
                self.farm_ids = farm_ids;
                self
            }
            #[doc = "Field Ids of the resource."]
            pub fn field_ids(mut self, field_ids: Vec<String>) -> Self {
                self.field_ids = field_ids;
                self
            }
            #[doc = "Season Ids of the resource."]
            pub fn season_ids(mut self, season_ids: Vec<String>) -> Self {
                self.season_ids = season_ids;
                self
            }
            #[doc = "CropProductIds of the resource."]
            pub fn crop_product_ids(mut self, crop_product_ids: Vec<String>) -> Self {
                self.crop_product_ids = crop_product_ids;
                self
            }
            #[doc = "Ids of the crop it belongs to."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::SeasonalFieldListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let farm_ids = &this.farm_ids;
                                for value in &this.farm_ids {
                                    req.url_mut().query_pairs_mut().append_pair("farmIds", &value.to_string());
                                }
                                let field_ids = &this.field_ids;
                                for value in &this.field_ids {
                                    req.url_mut().query_pairs_mut().append_pair("fieldIds", &value.to_string());
                                }
                                let season_ids = &this.season_ids;
                                for value in &this.season_ids {
                                    req.url_mut().query_pairs_mut().append_pair("seasonIds", &value.to_string());
                                }
                                let crop_product_ids = &this.crop_product_ids;
                                for value in &this.crop_product_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropProductIds", &value.to_string());
                                }
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/seasonal-fields", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SeasonalField> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SeasonalField = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) seasonal_field_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/seasonal-fields/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.seasonal_field_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SeasonalField>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SeasonalField>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SeasonalField> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SeasonalField = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) seasonal_field_id: String,
            pub(crate) seasonal_field: models::SeasonalField,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.seasonal_field)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/seasonal-fields/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.seasonal_field_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SeasonalField>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SeasonalField>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) seasonal_field_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/seasonal-fields/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.seasonal_field_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SeasonalFieldListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SeasonalFieldListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) farm_ids: Vec<String>,
            pub(crate) field_ids: Vec<String>,
            pub(crate) season_ids: Vec<String>,
            pub(crate) crop_product_ids: Vec<String>,
            pub(crate) crop_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Farm Ids of the resource."]
            pub fn farm_ids(mut self, farm_ids: Vec<String>) -> Self {
                self.farm_ids = farm_ids;
                self
            }
            #[doc = "Field Ids of the resource."]
            pub fn field_ids(mut self, field_ids: Vec<String>) -> Self {
                self.field_ids = field_ids;
                self
            }
            #[doc = "Season Ids of the resource."]
            pub fn season_ids(mut self, season_ids: Vec<String>) -> Self {
                self.season_ids = season_ids;
                self
            }
            #[doc = "CropProductIds of the resource."]
            pub fn crop_product_ids(mut self, crop_product_ids: Vec<String>) -> Self {
                self.crop_product_ids = crop_product_ids;
                self
            }
            #[doc = "Ids of the crop it belongs to."]
            pub fn crop_ids(mut self, crop_ids: Vec<String>) -> Self {
                self.crop_ids = crop_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::SeasonalFieldListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let farm_ids = &this.farm_ids;
                                for value in &this.farm_ids {
                                    req.url_mut().query_pairs_mut().append_pair("farmIds", &value.to_string());
                                }
                                let field_ids = &this.field_ids;
                                for value in &this.field_ids {
                                    req.url_mut().query_pairs_mut().append_pair("fieldIds", &value.to_string());
                                }
                                let season_ids = &this.season_ids;
                                for value in &this.season_ids {
                                    req.url_mut().query_pairs_mut().append_pair("seasonIds", &value.to_string());
                                }
                                let crop_product_ids = &this.crop_product_ids;
                                for value in &this.crop_product_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropProductIds", &value.to_string());
                                }
                                let crop_ids = &this.crop_ids;
                                for value in &this.crop_ids {
                                    req.url_mut().query_pairs_mut().append_pair("cropIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/seasonal-fields", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/seasonal-fields/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) seasonal_field_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let seasonal_field_id = &this.seasonal_field_id;
                        req.url_mut().query_pairs_mut().append_pair("seasonalFieldId", seasonal_field_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/seasonal-fields/cascade-delete/{}",
                    self.client.endpoint(),
                    &self.job_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod seasons {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of season resources."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                min_start_date_time: None,
                max_start_date_time: None,
                min_end_date_time: None,
                max_end_date_time: None,
                years: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified season resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `season_id`: Id of the season."]
        pub fn get(&self, season_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                season_id: season_id.into(),
            }
        }
        #[doc = "Creates or updates a season resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `season_id`: Id of the season resource."]
        #[doc = "* `season`: Season resource payload to create or update."]
        pub fn create_or_update(
            &self,
            season_id: impl Into<String>,
            season: impl Into<models::Season>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                season_id: season_id.into(),
                season: season.into(),
            }
        }
        #[doc = "Deletes a specified season resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `season_id`: Id of the season."]
        pub fn delete(&self, season_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                season_id: season_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SeasonListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SeasonListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) min_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) years: Vec<i32>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum season start datetime, sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn min_start_date_time(mut self, min_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_start_date_time = Some(min_start_date_time.into());
                self
            }
            #[doc = "Maximum season start datetime, sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn max_start_date_time(mut self, max_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_start_date_time = Some(max_start_date_time.into());
                self
            }
            #[doc = "Minimum season end datetime, sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn min_end_date_time(mut self, min_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_end_date_time = Some(min_end_date_time.into());
                self
            }
            #[doc = "Maximum season end datetime, sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn max_end_date_time(mut self, max_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_end_date_time = Some(max_end_date_time.into());
                self
            }
            #[doc = "Years of the resource."]
            pub fn years(mut self, years: Vec<i32>) -> Self {
                self.years = years;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::SeasonListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_start_date_time) = &this.min_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minStartDateTime", &min_start_date_time.to_string());
                                }
                                if let Some(max_start_date_time) = &this.max_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxStartDateTime", &max_start_date_time.to_string());
                                }
                                if let Some(min_end_date_time) = &this.min_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minEndDateTime", &min_end_date_time.to_string());
                                }
                                if let Some(max_end_date_time) = &this.max_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxEndDateTime", &max_end_date_time.to_string());
                                }
                                let years = &this.years;
                                for value in &this.years {
                                    req.url_mut().query_pairs_mut().append_pair("years", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/seasons", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Season> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Season = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) season_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/seasons/{}", self.client.endpoint(), &self.season_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Season>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Season>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Season> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Season = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) season_id: String,
            pub(crate) season: models::Season,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.season)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/seasons/{}", self.client.endpoint(), &self.season_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Season>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Season>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) season_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/seasons/{}", self.client.endpoint(), &self.season_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod sensor_data_models {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of sensor data model resources."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the associated sensor partner."]
        pub fn list(&self, sensor_partner_id: impl Into<String>) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a sensor data model entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `sensor_data_model_id`: Id of the sensor data model resource."]
        pub fn get(&self, sensor_partner_id: impl Into<String>, sensor_data_model_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_data_model_id: sensor_data_model_id.into(),
            }
        }
        #[doc = "Create a sensor data model entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `sensor_data_model_id`: Id of the sensor data model."]
        #[doc = "* `sensor_data_model_object`: Sensor data model object details."]
        pub fn create_or_update(
            &self,
            sensor_partner_id: impl Into<String>,
            sensor_data_model_id: impl Into<String>,
            sensor_data_model_object: impl Into<models::SensorDataModel>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_data_model_id: sensor_data_model_id.into(),
                sensor_data_model_object: sensor_data_model_object.into(),
            }
        }
        #[doc = "Deletes a sensor data model entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `sensor_data_model_id`: Id of the sensor data model resource."]
        pub fn delete(&self, sensor_partner_id: impl Into<String>, sensor_data_model_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_data_model_id: sensor_data_model_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorDataModelListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorDataModelListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::SensorDataModelListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensor-data-models",
                    self.client.endpoint(),
                    &self.sensor_partner_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorDataModel> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorDataModel = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_data_model_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensor-data-models/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.sensor_data_model_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorDataModel>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorDataModel>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorDataModel> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorDataModel = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_data_model_id: String,
            pub(crate) sensor_data_model_object: models::SensorDataModel,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.sensor_data_model_object)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensor-data-models/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.sensor_data_model_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorDataModel>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorDataModel>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_data_model_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensor-data-models/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.sensor_data_model_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod sensor_events {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a list of sensor events data. Time span for query is limited to 90 days at a time.\r\nReturns last 90 days events when startDateTime and endDateTime are not provided."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_id`: Id of the associated sensor."]
        #[doc = "* `sensor_partner_id`: Id of the associated sensor partner."]
        pub fn list(&self, sensor_id: impl Into<String>, sensor_partner_id: impl Into<String>) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                sensor_id: sensor_id.into(),
                sensor_partner_id: sensor_partner_id.into(),
                start_date_time: None,
                end_date_time: None,
                exclude_duplicate_events: None,
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorEventListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorEventListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_id: String,
            pub(crate) sensor_partner_id: String,
            pub(crate) start_date_time: Option<time::OffsetDateTime>,
            pub(crate) end_date_time: Option<time::OffsetDateTime>,
            pub(crate) exclude_duplicate_events: Option<bool>,
        }
        impl RequestBuilder {
            #[doc = "Search span start time of sensor events (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.\r\nIt is truncated upto seconds if fraction is provided."]
            pub fn start_date_time(mut self, start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.start_date_time = Some(start_date_time.into());
                self
            }
            #[doc = "Search span end time of sensor events (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.\r\nIt is truncated upto seconds if fraction is provided."]
            pub fn end_date_time(mut self, end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.end_date_time = Some(end_date_time.into());
                self
            }
            #[doc = "Flag to exclude duplicate events and take the latest ones only (Default: false)."]
            pub fn exclude_duplicate_events(mut self, exclude_duplicate_events: bool) -> Self {
                self.exclude_duplicate_events = Some(exclude_duplicate_events);
                self
            }
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let sensor_id = &this.sensor_id;
                        req.url_mut().query_pairs_mut().append_pair("sensorId", sensor_id);
                        let sensor_partner_id = &this.sensor_partner_id;
                        req.url_mut().query_pairs_mut().append_pair("sensorPartnerId", sensor_partner_id);
                        if let Some(start_date_time) = &this.start_date_time {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("startDateTime", &start_date_time.to_string());
                        }
                        if let Some(end_date_time) = &this.end_date_time {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("endDateTime", &end_date_time.to_string());
                        }
                        if let Some(exclude_duplicate_events) = &this.exclude_duplicate_events {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("excludeDuplicateEvents", &exclude_duplicate_events.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/sensor-events", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorEventListResponse>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorEventListResponse>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod sensor_mappings {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of sensor mapping resources."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                sensor_ids: Vec::new(),
                sensor_partner_ids: Vec::new(),
                party_ids: Vec::new(),
                boundary_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a sensor mapping entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_mapping_id`: Id of the sensor mapping resource."]
        pub fn get(&self, sensor_mapping_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                sensor_mapping_id: sensor_mapping_id.into(),
            }
        }
        #[doc = "Create a sensor mapping entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_mapping_id`: Id of the sensor mapping."]
        #[doc = "* `sensor_mapping_object`: Sensor mapping object details."]
        pub fn create_or_update(
            &self,
            sensor_mapping_id: impl Into<String>,
            sensor_mapping_object: impl Into<models::SensorMapping>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                sensor_mapping_id: sensor_mapping_id.into(),
                sensor_mapping_object: sensor_mapping_object.into(),
            }
        }
        #[doc = "Deletes a sensor mapping entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_mapping_id`: Id of the sensor mapping resource."]
        pub fn delete(&self, sensor_mapping_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                sensor_mapping_id: sensor_mapping_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorMappingListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorMappingListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_ids: Vec<String>,
            pub(crate) sensor_partner_ids: Vec<String>,
            pub(crate) party_ids: Vec<String>,
            pub(crate) boundary_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Id of the sensors."]
            pub fn sensor_ids(mut self, sensor_ids: Vec<String>) -> Self {
                self.sensor_ids = sensor_ids;
                self
            }
            #[doc = "Id of the sensor partners."]
            pub fn sensor_partner_ids(mut self, sensor_partner_ids: Vec<String>) -> Self {
                self.sensor_partner_ids = sensor_partner_ids;
                self
            }
            #[doc = "Id of the parties."]
            pub fn party_ids(mut self, party_ids: Vec<String>) -> Self {
                self.party_ids = party_ids;
                self
            }
            #[doc = "Id of the boundaries."]
            pub fn boundary_ids(mut self, boundary_ids: Vec<String>) -> Self {
                self.boundary_ids = boundary_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::SensorMappingListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let sensor_ids = &this.sensor_ids;
                                for value in &this.sensor_ids {
                                    req.url_mut().query_pairs_mut().append_pair("sensorIds", &value.to_string());
                                }
                                let sensor_partner_ids = &this.sensor_partner_ids;
                                for value in &this.sensor_partner_ids {
                                    req.url_mut().query_pairs_mut().append_pair("sensorPartnerIds", &value.to_string());
                                }
                                let party_ids = &this.party_ids;
                                for value in &this.party_ids {
                                    req.url_mut().query_pairs_mut().append_pair("partyIds", &value.to_string());
                                }
                                let boundary_ids = &this.boundary_ids;
                                for value in &this.boundary_ids {
                                    req.url_mut().query_pairs_mut().append_pair("boundaryIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/sensor-mappings", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorMapping> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorMapping = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_mapping_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/sensor-mappings/{}", self.client.endpoint(), &self.sensor_mapping_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorMapping>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorMapping>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorMapping> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorMapping = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_mapping_id: String,
            pub(crate) sensor_mapping_object: models::SensorMapping,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.sensor_mapping_object)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/sensor-mappings/{}", self.client.endpoint(), &self.sensor_mapping_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorMapping>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorMapping>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_mapping_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/sensor-mappings/{}", self.client.endpoint(), &self.sensor_mapping_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
}
pub mod sensor_partner_integrations {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets partner integration models."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the associated sensor partner."]
        pub fn list(&self, sensor_partner_id: impl Into<String>) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                party_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a partner integration model entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `integration_id`: Id of the integration object."]
        pub fn get(&self, sensor_partner_id: impl Into<String>, integration_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                integration_id: integration_id.into(),
            }
        }
        #[doc = "Create or update an integration with a sensor partner."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `integration_id`: Id of the integration to be created."]
        #[doc = "* `sensor_partner_integration_model`: Partner integration model."]
        pub fn create_or_update(
            &self,
            sensor_partner_id: impl Into<String>,
            integration_id: impl Into<String>,
            sensor_partner_integration_model: impl Into<models::SensorPartnerIntegrationModel>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                integration_id: integration_id.into(),
                sensor_partner_integration_model: sensor_partner_integration_model.into(),
            }
        }
        #[doc = "Deletes a partner integration model entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `integration_id`: Id of the integration to be deleted."]
        pub fn delete(&self, sensor_partner_id: impl Into<String>, integration_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                integration_id: integration_id.into(),
            }
        }
        #[doc = "Checks consent for partner integration."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `integration_id`: Id of the integration object."]
        #[doc = "* `key`: Partner integration key."]
        pub fn check_consent(
            &self,
            sensor_partner_id: impl Into<String>,
            integration_id: impl Into<String>,
            key: impl Into<String>,
        ) -> check_consent::RequestBuilder {
            check_consent::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                integration_id: integration_id.into(),
                key: key.into(),
            }
        }
        #[doc = "Generates partner integration consent link."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `integration_id`: Id of the integration object."]
        pub fn generate_consent_link(
            &self,
            sensor_partner_id: impl Into<String>,
            integration_id: impl Into<String>,
        ) -> generate_consent_link::RequestBuilder {
            generate_consent_link::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                integration_id: integration_id.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorPartnerIntegrationModelListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorPartnerIntegrationModelListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) party_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Ids of the parties."]
            pub fn party_ids(mut self, party_ids: Vec<String>) -> Self {
                self.party_ids = party_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::SensorPartnerIntegrationModelListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let party_ids = &this.party_ids;
                                for value in &this.party_ids {
                                    req.url_mut().query_pairs_mut().append_pair("partyIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/integrations",
                    self.client.endpoint(),
                    &self.sensor_partner_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorPartnerIntegrationModel> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorPartnerIntegrationModel = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) integration_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/integrations/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.integration_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorPartnerIntegrationModel>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorPartnerIntegrationModel>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorPartnerIntegrationModel> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorPartnerIntegrationModel = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) integration_id: String,
            pub(crate) sensor_partner_integration_model: models::SensorPartnerIntegrationModel,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.sensor_partner_integration_model)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/integrations/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.integration_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorPartnerIntegrationModel>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorPartnerIntegrationModel>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) integration_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/integrations/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.integration_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod check_consent {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorPartnerIntegrationCheckConsentResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorPartnerIntegrationCheckConsentResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) integration_id: String,
            pub(crate) key: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let key = &this.key;
                        req.url_mut().query_pairs_mut().append_pair("key", key);
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/integrations/{}/:check-consent",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.integration_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorPartnerIntegrationCheckConsentResponse>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorPartnerIntegrationCheckConsentResponse>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod generate_consent_link {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorPartnerIntegrationGenerateConsentLinkResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorPartnerIntegrationGenerateConsentLinkResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) integration_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/integrations/{}/:generate-consent-link",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.integration_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::SensorPartnerIntegrationGenerateConsentLinkResponse>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::SensorPartnerIntegrationGenerateConsentLinkResponse>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod sensors {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of sensor resources."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the associated sensor partner."]
        pub fn list(&self, sensor_partner_id: impl Into<String>) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_data_model_ids: Vec::new(),
                sensor_mapping_ids: Vec::new(),
                device_ids: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a sensor entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `sensor_id`: Id of the sensor resource."]
        pub fn get(&self, sensor_partner_id: impl Into<String>, sensor_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_id: sensor_id.into(),
            }
        }
        #[doc = "Create a sensor entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `sensor_id`: Id of the sensor resource."]
        #[doc = "* `sensor_details`: Sensor object details."]
        pub fn create_or_update(
            &self,
            sensor_partner_id: impl Into<String>,
            sensor_id: impl Into<String>,
            sensor_details: impl Into<models::Sensor>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_id: sensor_id.into(),
                sensor_details: sensor_details.into(),
            }
        }
        #[doc = "Deletes a sensor entity."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `sensor_id`: Id of the sensor resource."]
        pub fn delete(&self, sensor_partner_id: impl Into<String>, sensor_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_id: sensor_id.into(),
            }
        }
        #[doc = "Gets a sensor connection string."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `sensor_id`: Id of the sensor resource."]
        pub fn get_connection_string(
            &self,
            sensor_partner_id: impl Into<String>,
            sensor_id: impl Into<String>,
        ) -> get_connection_string::RequestBuilder {
            get_connection_string::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_id: sensor_id.into(),
            }
        }
        #[doc = "Renews a sensor connection string."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `sensor_partner_id`: Id of the sensor partner."]
        #[doc = "* `sensor_id`: Id of the sensor resource."]
        #[doc = "* `renew_connection_string_model`: Sensor's connection string model."]
        pub fn renew_connection_string(
            &self,
            sensor_partner_id: impl Into<String>,
            sensor_id: impl Into<String>,
            renew_connection_string_model: impl Into<models::SensorRenewConnectionStringModel>,
        ) -> renew_connection_string::RequestBuilder {
            renew_connection_string::RequestBuilder {
                client: self.0.clone(),
                sensor_partner_id: sensor_partner_id.into(),
                sensor_id: sensor_id.into(),
                renew_connection_string_model: renew_connection_string_model.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::SensorListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::SensorListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_data_model_ids: Vec<String>,
            pub(crate) sensor_mapping_ids: Vec<String>,
            pub(crate) device_ids: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Id's of the sensor data models."]
            pub fn sensor_data_model_ids(mut self, sensor_data_model_ids: Vec<String>) -> Self {
                self.sensor_data_model_ids = sensor_data_model_ids;
                self
            }
            #[doc = "Ids of the sensor mappings."]
            pub fn sensor_mapping_ids(mut self, sensor_mapping_ids: Vec<String>) -> Self {
                self.sensor_mapping_ids = sensor_mapping_ids;
                self
            }
            #[doc = "Id's of the devices."]
            pub fn device_ids(mut self, device_ids: Vec<String>) -> Self {
                self.device_ids = device_ids;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::SensorListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let sensor_data_model_ids = &this.sensor_data_model_ids;
                                for value in &this.sensor_data_model_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("sensorDataModelIds", &value.to_string());
                                }
                                let sensor_mapping_ids = &this.sensor_mapping_ids;
                                for value in &this.sensor_mapping_ids {
                                    req.url_mut().query_pairs_mut().append_pair("sensorMappingIds", &value.to_string());
                                }
                                let device_ids = &this.device_ids;
                                for value in &this.device_ids {
                                    req.url_mut().query_pairs_mut().append_pair("deviceIds", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensors",
                    self.client.endpoint(),
                    &self.sensor_partner_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Sensor> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Sensor = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensors/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.sensor_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Sensor>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Sensor>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Sensor> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Sensor = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_id: String,
            pub(crate) sensor_details: models::Sensor,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.sensor_details)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensors/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.sensor_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Sensor>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Sensor>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensors/{}",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.sensor_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_connection_string {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::IoTHubDeviceAuthentication> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::IoTHubDeviceAuthentication = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensors/{}/connection-strings",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.sensor_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::IoTHubDeviceAuthentication>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::IoTHubDeviceAuthentication>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod renew_connection_string {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::IoTHubDeviceAuthentication> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::IoTHubDeviceAuthentication = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) sensor_partner_id: String,
            pub(crate) sensor_id: String,
            pub(crate) renew_connection_string_model: models::SensorRenewConnectionStringModel,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.renew_connection_string_model)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/sensor-partners/{}/sensors/{}/connection-strings/:renew",
                    self.client.endpoint(),
                    &self.sensor_partner_id,
                    &self.sensor_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::IoTHubDeviceAuthentication>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::IoTHubDeviceAuthentication>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod solution_inference {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Cancels a job for given solution id."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `solution_id`: Id of solution for which job is to be cancelled."]
        #[doc = "* `solution_inference_request`: solutionInferenceRequest containing input needed for job request processing."]
        pub fn cancel(
            &self,
            solution_id: impl Into<String>,
            solution_inference_request: impl Into<models::SolutionInference>,
        ) -> cancel::RequestBuilder {
            cancel::RequestBuilder {
                client: self.0.clone(),
                solution_id: solution_id.into(),
                solution_inference_request: solution_inference_request.into(),
            }
        }
        #[doc = "Creates a job trigger for a solution."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `solution_id`: Id of the solution resource."]
        #[doc = "* `solution_inference_request`: solutionInferenceRequest containing input needed for job request processing."]
        pub fn create_or_update(
            &self,
            solution_id: impl Into<String>,
            solution_inference_request: impl Into<models::SolutionInference>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                solution_id: solution_id.into(),
                solution_inference_request: solution_inference_request.into(),
            }
        }
        #[doc = "Fetches details of triggered job for a solution."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `solution_id`: Id of the solution."]
        #[doc = "* `solution_inference_request`: solutionInferenceRequest containing input needed for job request processing."]
        pub fn fetch(
            &self,
            solution_id: impl Into<String>,
            solution_inference_request: impl Into<models::SolutionInference>,
        ) -> fetch::RequestBuilder {
            fetch::RequestBuilder {
                client: self.0.clone(),
                solution_id: solution_id.into(),
                solution_inference_request: solution_inference_request.into(),
            }
        }
    }
    pub mod cancel {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<serde_json::Value> {
                let bytes = self.0.into_body().collect().await?;
                let body: serde_json::Value = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) solution_id: String,
            pub(crate) solution_inference_request: models::SolutionInference,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.solution_inference_request)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/solutions/{}:cancel", self.client.endpoint(), &self.solution_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<serde_json::Value>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<serde_json::Value>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<serde_json::Value> {
                let bytes = self.0.into_body().collect().await?;
                let body: serde_json::Value = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) solution_id: String,
            pub(crate) solution_inference_request: models::SolutionInference,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.solution_inference_request)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/solutions/{}:create", self.client.endpoint(), &self.solution_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<serde_json::Value>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<serde_json::Value>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod fetch {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<serde_json::Value> {
                let bytes = self.0.into_body().collect().await?;
                let body: serde_json::Value = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) solution_id: String,
            pub(crate) solution_inference_request: models::SolutionInference,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.solution_inference_request)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/solutions/{}:fetch", self.client.endpoint(), &self.solution_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<serde_json::Value>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<serde_json::Value>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod tillage_data {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of tillage data resources under a particular farm."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                min_tillage_depth: None,
                max_tillage_depth: None,
                min_tillage_pressure: None,
                max_tillage_pressure: None,
                sources: Vec::new(),
                associated_boundary_ids: Vec::new(),
                min_operation_start_date_time: None,
                max_operation_start_date_time: None,
                min_operation_end_date_time: None,
                max_operation_end_date_time: None,
                min_operation_modified_date_time: None,
                max_operation_modified_date_time: None,
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a specified tillage data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `tillage_data_id`: ID of the tillage data resource."]
        pub fn get(&self, party_id: impl Into<String>, tillage_data_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                tillage_data_id: tillage_data_id.into(),
            }
        }
        #[doc = "Creates or updates an tillage data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `tillage_data_id`: ID of the tillage data resource."]
        #[doc = "* `tillage_data`: Tillage data resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            tillage_data_id: impl Into<String>,
            tillage_data: impl Into<models::TillageData>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                tillage_data_id: tillage_data_id.into(),
                tillage_data: tillage_data.into(),
            }
        }
        #[doc = "Deletes a specified tillage data resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: ID of the associated party resource."]
        #[doc = "* `tillage_data_id`: ID of the tillage data."]
        pub fn delete(&self, party_id: impl Into<String>, tillage_data_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                tillage_data_id: tillage_data_id.into(),
            }
        }
        #[doc = "Returns a paginated list of tillage data resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                min_tillage_depth: None,
                max_tillage_depth: None,
                min_tillage_pressure: None,
                max_tillage_pressure: None,
                sources: Vec::new(),
                associated_boundary_ids: Vec::new(),
                min_operation_start_date_time: None,
                max_operation_start_date_time: None,
                min_operation_end_date_time: None,
                max_operation_end_date_time: None,
                min_operation_modified_date_time: None,
                max_operation_modified_date_time: None,
                min_area: None,
                max_area: None,
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get cascade delete job for tillage data resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create cascade delete job for tillage data resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job Id supplied by end user."]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `tillage_data_id`: Id of the tillage data."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            tillage_data_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                tillage_data_id: tillage_data_id.into(),
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::TillageDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::TillageDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) min_tillage_depth: Option<f64>,
            pub(crate) max_tillage_depth: Option<f64>,
            pub(crate) min_tillage_pressure: Option<f64>,
            pub(crate) max_tillage_pressure: Option<f64>,
            pub(crate) sources: Vec<String>,
            pub(crate) associated_boundary_ids: Vec<String>,
            pub(crate) min_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum measured tillage depth (inclusive)."]
            pub fn min_tillage_depth(mut self, min_tillage_depth: f64) -> Self {
                self.min_tillage_depth = Some(min_tillage_depth);
                self
            }
            #[doc = "Maximum measured tillage depth (inclusive)."]
            pub fn max_tillage_depth(mut self, max_tillage_depth: f64) -> Self {
                self.max_tillage_depth = Some(max_tillage_depth);
                self
            }
            #[doc = "Minimum pressure applied to a tillage implement (inclusive)."]
            pub fn min_tillage_pressure(mut self, min_tillage_pressure: f64) -> Self {
                self.min_tillage_pressure = Some(min_tillage_pressure);
                self
            }
            #[doc = "Maximum pressure applied to a tillage implement (inclusive)."]
            pub fn max_tillage_pressure(mut self, max_tillage_pressure: f64) -> Self {
                self.max_tillage_pressure = Some(max_tillage_pressure);
                self
            }
            #[doc = "Sources of the operation data."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Boundary IDs associated with operation data."]
            pub fn associated_boundary_ids(mut self, associated_boundary_ids: Vec<String>) -> Self {
                self.associated_boundary_ids = associated_boundary_ids;
                self
            }
            #[doc = "Minimum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_start_date_time(mut self, min_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_start_date_time = Some(min_operation_start_date_time.into());
                self
            }
            #[doc = "Maximum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_start_date_time(mut self, max_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_start_date_time = Some(max_operation_start_date_time.into());
                self
            }
            #[doc = "Minimum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_end_date_time(mut self, min_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_end_date_time = Some(min_operation_end_date_time.into());
                self
            }
            #[doc = "Maximum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_end_date_time(mut self, max_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_end_date_time = Some(max_operation_end_date_time.into());
                self
            }
            #[doc = "Minimum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_modified_date_time(mut self, min_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_modified_date_time = Some(min_operation_modified_date_time.into());
                self
            }
            #[doc = "Maximum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_modified_date_time(mut self, max_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_modified_date_time = Some(max_operation_modified_date_time.into());
                self
            }
            #[doc = "Minimum area for which operation was applied (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum area for which operation was applied (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::TillageDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_tillage_depth) = &this.min_tillage_depth {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTillageDepth", &min_tillage_depth.to_string());
                                }
                                if let Some(max_tillage_depth) = &this.max_tillage_depth {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTillageDepth", &max_tillage_depth.to_string());
                                }
                                if let Some(min_tillage_pressure) = &this.min_tillage_pressure {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTillagePressure", &min_tillage_pressure.to_string());
                                }
                                if let Some(max_tillage_pressure) = &this.max_tillage_pressure {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTillagePressure", &max_tillage_pressure.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let associated_boundary_ids = &this.associated_boundary_ids;
                                for value in &this.associated_boundary_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("associatedBoundaryIds", &value.to_string());
                                }
                                if let Some(min_operation_start_date_time) = &this.min_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationStartDateTime", &min_operation_start_date_time.to_string());
                                }
                                if let Some(max_operation_start_date_time) = &this.max_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationStartDateTime", &max_operation_start_date_time.to_string());
                                }
                                if let Some(min_operation_end_date_time) = &this.min_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationEndDateTime", &min_operation_end_date_time.to_string());
                                }
                                if let Some(max_operation_end_date_time) = &this.max_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationEndDateTime", &max_operation_end_date_time.to_string());
                                }
                                if let Some(min_operation_modified_date_time) = &this.min_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationModifiedDateTime", &min_operation_modified_date_time.to_string());
                                }
                                if let Some(max_operation_modified_date_time) = &this.max_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationModifiedDateTime", &max_operation_modified_date_time.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/tillage-data", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::TillageData> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::TillageData = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) tillage_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/tillage-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.tillage_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::TillageData>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::TillageData>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::TillageData> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::TillageData = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) tillage_data_id: String,
            pub(crate) tillage_data: models::TillageData,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.tillage_data)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/tillage-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.tillage_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::TillageData>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::TillageData>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) tillage_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/tillage-data/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.tillage_data_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::TillageDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::TillageDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) min_tillage_depth: Option<f64>,
            pub(crate) max_tillage_depth: Option<f64>,
            pub(crate) min_tillage_pressure: Option<f64>,
            pub(crate) max_tillage_pressure: Option<f64>,
            pub(crate) sources: Vec<String>,
            pub(crate) associated_boundary_ids: Vec<String>,
            pub(crate) min_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_start_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_end_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_operation_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_area: Option<f64>,
            pub(crate) max_area: Option<f64>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Minimum measured tillage depth (inclusive)."]
            pub fn min_tillage_depth(mut self, min_tillage_depth: f64) -> Self {
                self.min_tillage_depth = Some(min_tillage_depth);
                self
            }
            #[doc = "Maximum measured tillage depth (inclusive)."]
            pub fn max_tillage_depth(mut self, max_tillage_depth: f64) -> Self {
                self.max_tillage_depth = Some(max_tillage_depth);
                self
            }
            #[doc = "Minimum pressure applied to a tillage implement (inclusive)."]
            pub fn min_tillage_pressure(mut self, min_tillage_pressure: f64) -> Self {
                self.min_tillage_pressure = Some(min_tillage_pressure);
                self
            }
            #[doc = "Maximum pressure applied to a tillage implement (inclusive)."]
            pub fn max_tillage_pressure(mut self, max_tillage_pressure: f64) -> Self {
                self.max_tillage_pressure = Some(max_tillage_pressure);
                self
            }
            #[doc = "Sources of the operation data."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Boundary IDs associated with operation data."]
            pub fn associated_boundary_ids(mut self, associated_boundary_ids: Vec<String>) -> Self {
                self.associated_boundary_ids = associated_boundary_ids;
                self
            }
            #[doc = "Minimum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_start_date_time(mut self, min_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_start_date_time = Some(min_operation_start_date_time.into());
                self
            }
            #[doc = "Maximum start date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_start_date_time(mut self, max_operation_start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_start_date_time = Some(max_operation_start_date_time.into());
                self
            }
            #[doc = "Minimum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_end_date_time(mut self, min_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_end_date_time = Some(min_operation_end_date_time.into());
                self
            }
            #[doc = "Maximum end date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_end_date_time(mut self, max_operation_end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_end_date_time = Some(max_operation_end_date_time.into());
                self
            }
            #[doc = "Minimum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn min_operation_modified_date_time(mut self, min_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_operation_modified_date_time = Some(min_operation_modified_date_time.into());
                self
            }
            #[doc = "Maximum modified date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive)."]
            pub fn max_operation_modified_date_time(mut self, max_operation_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_operation_modified_date_time = Some(max_operation_modified_date_time.into());
                self
            }
            #[doc = "Minimum area for which operation was applied (inclusive)."]
            pub fn min_area(mut self, min_area: f64) -> Self {
                self.min_area = Some(min_area);
                self
            }
            #[doc = "Maximum area for which operation was applied (inclusive)."]
            pub fn max_area(mut self, max_area: f64) -> Self {
                self.max_area = Some(max_area);
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::TillageDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                if let Some(min_tillage_depth) = &this.min_tillage_depth {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTillageDepth", &min_tillage_depth.to_string());
                                }
                                if let Some(max_tillage_depth) = &this.max_tillage_depth {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTillageDepth", &max_tillage_depth.to_string());
                                }
                                if let Some(min_tillage_pressure) = &this.min_tillage_pressure {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minTillagePressure", &min_tillage_pressure.to_string());
                                }
                                if let Some(max_tillage_pressure) = &this.max_tillage_pressure {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxTillagePressure", &max_tillage_pressure.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let associated_boundary_ids = &this.associated_boundary_ids;
                                for value in &this.associated_boundary_ids {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("associatedBoundaryIds", &value.to_string());
                                }
                                if let Some(min_operation_start_date_time) = &this.min_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationStartDateTime", &min_operation_start_date_time.to_string());
                                }
                                if let Some(max_operation_start_date_time) = &this.max_operation_start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationStartDateTime", &max_operation_start_date_time.to_string());
                                }
                                if let Some(min_operation_end_date_time) = &this.min_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationEndDateTime", &min_operation_end_date_time.to_string());
                                }
                                if let Some(max_operation_end_date_time) = &this.max_operation_end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationEndDateTime", &max_operation_end_date_time.to_string());
                                }
                                if let Some(min_operation_modified_date_time) = &this.min_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minOperationModifiedDateTime", &min_operation_modified_date_time.to_string());
                                }
                                if let Some(max_operation_modified_date_time) = &this.max_operation_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxOperationModifiedDateTime", &max_operation_modified_date_time.to_string());
                                }
                                if let Some(min_area) = &this.min_area {
                                    req.url_mut().query_pairs_mut().append_pair("minArea", &min_area.to_string());
                                }
                                if let Some(max_area) = &this.max_area {
                                    req.url_mut().query_pairs_mut().append_pair("maxArea", &max_area.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/tillage-data", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/tillage-data/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) tillage_data_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let tillage_data_id = &this.tillage_data_id;
                        req.url_mut().query_pairs_mut().append_pair("tillageDataId", tillage_data_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/tillage-data/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod weather {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of weather data."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Party ID."]
        #[doc = "* `boundary_id`: Boundary ID."]
        #[doc = "* `extension_id`: ID of the weather extension."]
        #[doc = "* `weather_data_type`: Type of weather data (forecast/historical)."]
        #[doc = "* `granularity`: Granularity of weather data (daily/hourly)."]
        pub fn list(
            &self,
            party_id: impl Into<String>,
            boundary_id: impl Into<String>,
            extension_id: impl Into<String>,
            weather_data_type: impl Into<String>,
            granularity: impl Into<String>,
        ) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                boundary_id: boundary_id.into(),
                extension_id: extension_id.into(),
                weather_data_type: weather_data_type.into(),
                granularity: granularity.into(),
                start_date_time: None,
                end_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get weather data delete job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_data_delete_job_details(&self, job_id: impl Into<String>) -> get_data_delete_job_details::RequestBuilder {
            get_data_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a weather data delete job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job Id supplied by end user."]
        #[doc = "* `job`: Job parameters supplied by user."]
        pub fn create_data_delete_job(
            &self,
            job_id: impl Into<String>,
            job: impl Into<models::WeatherDataDeleteJob>,
        ) -> create_data_delete_job::RequestBuilder {
            create_data_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job: job.into(),
            }
        }
        #[doc = "Get weather ingestion job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_data_ingestion_job_details(&self, job_id: impl Into<String>) -> get_data_ingestion_job_details::RequestBuilder {
            get_data_ingestion_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a weather data ingestion job."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job id supplied by user."]
        #[doc = "* `job`: Job parameters supplied by user."]
        pub fn create_data_ingestion_job(
            &self,
            job_id: impl Into<String>,
            job: impl Into<models::WeatherDataIngestionJob>,
        ) -> create_data_ingestion_job::RequestBuilder {
            create_data_ingestion_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                job: job.into(),
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::WeatherDataListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::WeatherDataListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) boundary_id: String,
            pub(crate) extension_id: String,
            pub(crate) weather_data_type: String,
            pub(crate) granularity: String,
            pub(crate) start_date_time: Option<time::OffsetDateTime>,
            pub(crate) end_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Weather data start UTC date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn start_date_time(mut self, start_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.start_date_time = Some(start_date_time.into());
                self
            }
            #[doc = "Weather data end UTC date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ."]
            pub fn end_date_time(mut self, end_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.end_date_time = Some(end_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::WeatherDataListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let party_id = &this.party_id;
                                req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                                let boundary_id = &this.boundary_id;
                                req.url_mut().query_pairs_mut().append_pair("boundaryId", boundary_id);
                                let extension_id = &this.extension_id;
                                req.url_mut().query_pairs_mut().append_pair("extensionId", extension_id);
                                let weather_data_type = &this.weather_data_type;
                                req.url_mut().query_pairs_mut().append_pair("weatherDataType", weather_data_type);
                                let granularity = &this.granularity;
                                req.url_mut().query_pairs_mut().append_pair("granularity", granularity);
                                if let Some(start_date_time) = &this.start_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("startDateTime", &start_date_time.to_string());
                                }
                                if let Some(end_date_time) = &this.end_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("endDateTime", &end_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/weather", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_data_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::WeatherDataDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::WeatherDataDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/weather/delete-data/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::WeatherDataDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::WeatherDataDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_data_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::WeatherDataDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::WeatherDataDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job: models::WeatherDataDeleteJob,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.job)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/weather/delete-data/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::WeatherDataDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::WeatherDataDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
    pub mod get_data_ingestion_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::WeatherDataIngestionJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::WeatherDataIngestionJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/weather/ingest-data/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::WeatherDataIngestionJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::WeatherDataIngestionJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_data_ingestion_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::WeatherDataIngestionJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::WeatherDataIngestionJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) job: models::WeatherDataIngestionJob,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.job)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/weather/ingest-data/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::WeatherDataIngestionJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::WeatherDataIngestionJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
pub mod weather_data {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a list of WeatherData."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `weather_data_provider_request`: Weather data provider request."]
        pub fn get(&self, weather_data_provider_request: impl Into<models::WeatherDataProviderRequest>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                weather_data_provider_request: weather_data_provider_request.into(),
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::WeatherDataProviderResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::WeatherDataProviderResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) weather_data_provider_request: models::WeatherDataProviderRequest,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.weather_data_provider_request)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/weather-data/:fetch", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::WeatherDataProviderResponse>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::WeatherDataProviderResponse>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
}
pub mod zones {
    use super::models;
    #[cfg(not(target_arch = "wasm32"))]
    use futures::future::BoxFuture;
    #[cfg(target_arch = "wasm32")]
    use futures::future::LocalBoxFuture as BoxFuture;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Returns a paginated list of zone resources under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        pub fn list_by_party_id(&self, party_id: impl Into<String>) -> list_by_party_id::RequestBuilder {
            list_by_party_id::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                types: Vec::new(),
                management_zone_ids: Vec::new(),
                sources: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Gets a specified zone resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the associated party."]
        #[doc = "* `zone_id`: Id of the zone."]
        pub fn get(&self, party_id: impl Into<String>, zone_id: impl Into<String>) -> get::RequestBuilder {
            get::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                zone_id: zone_id.into(),
            }
        }
        #[doc = "Creates or updates a Zone resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party resource."]
        #[doc = "* `zone_id`: Id of the zone resource."]
        #[doc = "* `zone`: Zone resource payload to create or update."]
        pub fn create_or_update(
            &self,
            party_id: impl Into<String>,
            zone_id: impl Into<String>,
            zone: impl Into<models::Zone>,
        ) -> create_or_update::RequestBuilder {
            create_or_update::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                zone_id: zone_id.into(),
                zone: zone.into(),
            }
        }
        #[doc = "Deletes a specified zone resource under a particular party."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `party_id`: Id of the party."]
        #[doc = "* `zone_id`: Id of the zone."]
        pub fn delete(&self, party_id: impl Into<String>, zone_id: impl Into<String>) -> delete::RequestBuilder {
            delete::RequestBuilder {
                client: self.0.clone(),
                party_id: party_id.into(),
                zone_id: zone_id.into(),
            }
        }
        #[doc = "Returns a paginated list of zone resources across all parties."]
        pub fn list(&self) -> list::RequestBuilder {
            list::RequestBuilder {
                client: self.0.clone(),
                types: Vec::new(),
                management_zone_ids: Vec::new(),
                sources: Vec::new(),
                ids: Vec::new(),
                names: Vec::new(),
                property_filters: Vec::new(),
                statuses: Vec::new(),
                min_created_date_time: None,
                max_created_date_time: None,
                min_last_modified_date_time: None,
                max_last_modified_date_time: None,
                max_page_size: None,
                skip_token: None,
            }
        }
        #[doc = "Get a cascade delete job for specified job id."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Id of the job."]
        pub fn get_cascade_delete_job_details(&self, job_id: impl Into<String>) -> get_cascade_delete_job_details::RequestBuilder {
            get_cascade_delete_job_details::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
            }
        }
        #[doc = "Create a cascade delete job for specified zone."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `job_id`: Job ID supplied by end user."]
        #[doc = "* `party_id`: ID of the associated party."]
        #[doc = "* `zone_id`: ID of the zone to be deleted."]
        pub fn create_cascade_delete_job(
            &self,
            job_id: impl Into<String>,
            party_id: impl Into<String>,
            zone_id: impl Into<String>,
        ) -> create_cascade_delete_job::RequestBuilder {
            create_cascade_delete_job::RequestBuilder {
                client: self.0.clone(),
                job_id: job_id.into(),
                party_id: party_id.into(),
                zone_id: zone_id.into(),
            }
        }
    }
    pub mod list_by_party_id {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ZoneListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ZoneListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) types: Vec<String>,
            pub(crate) management_zone_ids: Vec<String>,
            pub(crate) sources: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Types of the Zones."]
            pub fn types(mut self, types: Vec<String>) -> Self {
                self.types = types;
                self
            }
            #[doc = "ManagementZoneIds of the Zones."]
            pub fn management_zone_ids(mut self, management_zone_ids: Vec<String>) -> Self {
                self.management_zone_ids = management_zone_ids;
                self
            }
            #[doc = "Sources of the Zones."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::ZoneListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let types = &this.types;
                                for value in &this.types {
                                    req.url_mut().query_pairs_mut().append_pair("types", &value.to_string());
                                }
                                let management_zone_ids = &this.management_zone_ids;
                                for value in &this.management_zone_ids {
                                    req.url_mut().query_pairs_mut().append_pair("managementZoneIds", &value.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/parties/{}/zones", self.client.endpoint(), &self.party_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Zone> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Zone = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) zone_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/zones/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.zone_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Zone>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Zone>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::Zone> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::Zone = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) zone_id: String,
            pub(crate) zone: models::Zone,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Patch);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/merge-patch+json");
                        let req_body = azure_core::to_json(&this.zone)?;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/zones/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.zone_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::Zone>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::Zone>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) party_id: String,
            pub(crate) zone_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!(
                    "{}/parties/{}/zones/{}",
                    self.client.endpoint(),
                    &self.party_id,
                    &self.zone_id
                ))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod list {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::ZoneListResponse> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::ZoneListResponse = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) types: Vec<String>,
            pub(crate) management_zone_ids: Vec<String>,
            pub(crate) sources: Vec<String>,
            pub(crate) ids: Vec<String>,
            pub(crate) names: Vec<String>,
            pub(crate) property_filters: Vec<String>,
            pub(crate) statuses: Vec<String>,
            pub(crate) min_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_created_date_time: Option<time::OffsetDateTime>,
            pub(crate) min_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_last_modified_date_time: Option<time::OffsetDateTime>,
            pub(crate) max_page_size: Option<i32>,
            pub(crate) skip_token: Option<String>,
        }
        impl RequestBuilder {
            #[doc = "Types of the Zones."]
            pub fn types(mut self, types: Vec<String>) -> Self {
                self.types = types;
                self
            }
            #[doc = "ManagementZoneIds of the Zones."]
            pub fn management_zone_ids(mut self, management_zone_ids: Vec<String>) -> Self {
                self.management_zone_ids = management_zone_ids;
                self
            }
            #[doc = "Sources of the Zones."]
            pub fn sources(mut self, sources: Vec<String>) -> Self {
                self.sources = sources;
                self
            }
            #[doc = "Ids of the resource."]
            pub fn ids(mut self, ids: Vec<String>) -> Self {
                self.ids = ids;
                self
            }
            #[doc = "Names of the resource."]
            pub fn names(mut self, names: Vec<String>) -> Self {
                self.names = names;
                self
            }
            #[doc = "Filters on key-value pairs within the Properties object.\r\neg. \"{testKey} eq {testValue}\"."]
            pub fn property_filters(mut self, property_filters: Vec<String>) -> Self {
                self.property_filters = property_filters;
                self
            }
            #[doc = "Statuses of the resource."]
            pub fn statuses(mut self, statuses: Vec<String>) -> Self {
                self.statuses = statuses;
                self
            }
            #[doc = "Minimum creation date of resource (inclusive)."]
            pub fn min_created_date_time(mut self, min_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_created_date_time = Some(min_created_date_time.into());
                self
            }
            #[doc = "Maximum creation date of resource (inclusive)."]
            pub fn max_created_date_time(mut self, max_created_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_created_date_time = Some(max_created_date_time.into());
                self
            }
            #[doc = "Minimum last modified date of resource (inclusive)."]
            pub fn min_last_modified_date_time(mut self, min_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.min_last_modified_date_time = Some(min_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum last modified date of resource (inclusive)."]
            pub fn max_last_modified_date_time(mut self, max_last_modified_date_time: impl Into<time::OffsetDateTime>) -> Self {
                self.max_last_modified_date_time = Some(max_last_modified_date_time.into());
                self
            }
            #[doc = "Maximum number of items needed (inclusive).\r\nMinimum = 10, Maximum = 1000, Default value = 50."]
            pub fn max_page_size(mut self, max_page_size: i32) -> Self {
                self.max_page_size = Some(max_page_size);
                self
            }
            #[doc = "Skip token for getting next set of results."]
            pub fn skip_token(mut self, skip_token: impl Into<String>) -> Self {
                self.skip_token = Some(skip_token.into());
                self
            }
            pub fn into_stream(self) -> azure_core::Pageable<models::ZoneListResponse, azure_core::error::Error> {
                let make_request = move |continuation: Option<String>| {
                    let this = self.clone();
                    async move {
                        let mut url = this.url()?;
                        let rsp = match continuation {
                            Some(value) => {
                                url.set_path("");
                                url = url.join(&value)?;
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let has_api_version_already =
                                    req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                                if !has_api_version_already {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                            None => {
                                let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                                let credential = this.client.token_credential();
                                let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                                req.insert_header(
                                    azure_core::headers::AUTHORIZATION,
                                    format!("Bearer {}", token_response.token.secret()),
                                );
                                let types = &this.types;
                                for value in &this.types {
                                    req.url_mut().query_pairs_mut().append_pair("types", &value.to_string());
                                }
                                let management_zone_ids = &this.management_zone_ids;
                                for value in &this.management_zone_ids {
                                    req.url_mut().query_pairs_mut().append_pair("managementZoneIds", &value.to_string());
                                }
                                let sources = &this.sources;
                                for value in &this.sources {
                                    req.url_mut().query_pairs_mut().append_pair("sources", &value.to_string());
                                }
                                let ids = &this.ids;
                                for value in &this.ids {
                                    req.url_mut().query_pairs_mut().append_pair("ids", &value.to_string());
                                }
                                let names = &this.names;
                                for value in &this.names {
                                    req.url_mut().query_pairs_mut().append_pair("names", &value.to_string());
                                }
                                let property_filters = &this.property_filters;
                                for value in &this.property_filters {
                                    req.url_mut().query_pairs_mut().append_pair("propertyFilters", &value.to_string());
                                }
                                let statuses = &this.statuses;
                                for value in &this.statuses {
                                    req.url_mut().query_pairs_mut().append_pair("statuses", &value.to_string());
                                }
                                if let Some(min_created_date_time) = &this.min_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minCreatedDateTime", &min_created_date_time.to_string());
                                }
                                if let Some(max_created_date_time) = &this.max_created_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxCreatedDateTime", &max_created_date_time.to_string());
                                }
                                if let Some(min_last_modified_date_time) = &this.min_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("minLastModifiedDateTime", &min_last_modified_date_time.to_string());
                                }
                                if let Some(max_last_modified_date_time) = &this.max_last_modified_date_time {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxLastModifiedDateTime", &max_last_modified_date_time.to_string());
                                }
                                if let Some(max_page_size) = &this.max_page_size {
                                    req.url_mut()
                                        .query_pairs_mut()
                                        .append_pair("maxPageSize", &max_page_size.to_string());
                                }
                                if let Some(skip_token) = &this.skip_token {
                                    req.url_mut().query_pairs_mut().append_pair("skipToken", skip_token);
                                }
                                let req_body = azure_core::EMPTY_BODY;
                                req.set_body(req_body);
                                this.client.send(&mut req).await?
                            }
                        };
                        let rsp = match rsp.status() {
                            azure_core::StatusCode::Ok => Ok(Response(rsp)),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        };
                        rsp?.into_body().await
                    }
                };
                azure_core::Pageable::new(make_request)
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/zones", self.client.endpoint(),))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
    }
    pub mod get_cascade_delete_job_details {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the [`RequestBuilder`] into a future"]
        #[doc = r" executes the request and returns a `Result` with the parsed"]
        #[doc = r" response."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use `.send().await` instead."]
        #[doc = r""]
        #[doc = r" If you need lower-level access to the raw response details"]
        #[doc = r" (e.g. to inspect response headers or raw body data) then you"]
        #[doc = r" can finalize the request using the"]
        #[doc = r" [`RequestBuilder::send()`] method which returns a future"]
        #[doc = r" that resolves to a lower-level [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/zones/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that sends the request and returns the parsed response body."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move { self.send().await?.into_body().await })
            }
        }
    }
    pub mod create_cascade_delete_job {
        use super::models;
        #[cfg(not(target_arch = "wasm32"))]
        use futures::future::BoxFuture;
        #[cfg(target_arch = "wasm32")]
        use futures::future::LocalBoxFuture as BoxFuture;
        #[derive(Debug)]
        pub struct Response(azure_core::Response);
        impl Response {
            pub async fn into_body(self) -> azure_core::Result<models::CascadeDeleteJob> {
                let bytes = self.0.into_body().collect().await?;
                let body: models::CascadeDeleteJob = serde_json::from_slice(&bytes)?;
                Ok(body)
            }
            pub fn into_raw_response(self) -> azure_core::Response {
                self.0
            }
            pub fn as_raw_response(&self) -> &azure_core::Response {
                &self.0
            }
        }
        impl From<Response> for azure_core::Response {
            fn from(rsp: Response) -> Self {
                rsp.into_raw_response()
            }
        }
        impl AsRef<azure_core::Response> for Response {
            fn as_ref(&self) -> &azure_core::Response {
                self.as_raw_response()
            }
        }
        #[derive(Clone)]
        #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
        #[doc = r""]
        #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
        #[doc = r" parameters can be chained."]
        #[doc = r""]
        #[doc = r" This `RequestBuilder` implements a Long Running Operation"]
        #[doc = r" (LRO)."]
        #[doc = r""]
        #[doc = r" To finalize and submit the request, invoke `.await`, which"]
        #[doc = r" which will convert the `RequestBuilder` into a future"]
        #[doc = r" executes the request and polls the service until the"]
        #[doc = r" operation completes."]
        #[doc = r""]
        #[doc = r" In order to execute the request without polling the service"]
        #[doc = r" until the operation completes, use"]
        #[doc = r" [`RequestBuilder::send()`], which will return a lower-level"]
        #[doc = r" [`Response`] value."]
        pub struct RequestBuilder {
            pub(crate) client: super::super::Client,
            pub(crate) job_id: String,
            pub(crate) party_id: String,
            pub(crate) zone_id: String,
        }
        impl RequestBuilder {
            #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
            #[doc = ""]
            #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
            #[doc = "However, this function can provide more flexibility when required."]
            pub fn send(self) -> BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = this.url()?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let party_id = &this.party_id;
                        req.url_mut().query_pairs_mut().append_pair("partyId", party_id);
                        let zone_id = &this.zone_id;
                        req.url_mut().query_pairs_mut().append_pair("zoneId", zone_id);
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        Ok(Response(this.client.send(&mut req).await?))
                    }
                })
            }
            fn url(&self) -> azure_core::Result<azure_core::Url> {
                let mut url = azure_core::Url::parse(&format!("{}/zones/cascade-delete/{}", self.client.endpoint(), &self.job_id))?;
                let has_api_version_already = url.query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                if !has_api_version_already {
                    url.query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2023-06-01-preview");
                }
                Ok(url)
            }
        }
        impl std::future::IntoFuture for RequestBuilder {
            type Output = azure_core::Result<models::CascadeDeleteJob>;
            type IntoFuture = BoxFuture<'static, azure_core::Result<models::CascadeDeleteJob>>;
            #[doc = "Returns a future that polls the long running operation, returning once the operation completes."]
            #[doc = ""]
            #[doc = "To only submit the request but not monitor the status of the operation until completion, use `send()` instead."]
            #[doc = ""]
            #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
            #[doc = ""]
            #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
            fn into_future(self) -> Self::IntoFuture {
                Box::pin(async move {
                    use azure_core::{
                        error::{Error, ErrorKind},
                        lro::{
                            get_retry_after,
                            location::{get_location, get_provisioning_state, FinalState},
                            LroStatus,
                        },
                        sleep::sleep,
                    };
                    use std::time::Duration;
                    let this = self.clone();
                    let response = this.send().await?;
                    let headers = response.as_raw_response().headers();
                    let location = get_location(headers, FinalState::Location)?;
                    if let Some(url) = location {
                        loop {
                            let mut req = azure_core::Request::new(url.clone(), azure_core::Method::Get);
                            let credential = self.client.token_credential();
                            let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let response = self.client.send(&mut req).await?;
                            let headers = response.headers();
                            let retry_after = get_retry_after(headers);
                            let bytes = response.into_body().collect().await?;
                            let provisioning_state = get_provisioning_state(&bytes).ok_or_else(|| {
                                Error::message(
                                    ErrorKind::Other,
                                    "Long running operation failed (missing provisioning state)".to_string(),
                                )
                            })?;
                            log::trace!("current provisioning_state: {provisioning_state:?}");
                            match provisioning_state {
                                LroStatus::Succeeded => {
                                    let mut req = azure_core::Request::new(self.url()?, azure_core::Method::Get);
                                    let credential = self.client.token_credential();
                                    let token_response = credential.get_token(&self.client.scopes().join(" ")).await?;
                                    req.insert_header(
                                        azure_core::headers::AUTHORIZATION,
                                        format!("Bearer {}", token_response.token.secret()),
                                    );
                                    let response = self.client.send(&mut req).await?;
                                    return Response(response).into_body().await;
                                }
                                LroStatus::Failed => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation failed".to_string()))
                                }
                                LroStatus::Canceled => {
                                    return Err(Error::message(ErrorKind::Other, "Long running operation canceled".to_string()))
                                }
                                _ => {
                                    sleep(retry_after).await;
                                }
                            }
                        }
                    } else {
                        response.into_body().await
                    }
                })
            }
        }
    }
}
