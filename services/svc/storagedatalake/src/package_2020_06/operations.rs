#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, models::*, API_VERSION};
pub mod service {
    use super::{models, models::*, API_VERSION};
    pub async fn list_file_systems(
        operation_config: &crate::OperationConfig,
        resource: &str,
        prefix: Option<&str>,
        continuation: Option<&str>,
        max_results: Option<i32>,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
    ) -> std::result::Result<FileSystemList, list_file_systems::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list_file_systems::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_file_systems::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("resource", resource);
        if let Some(prefix) = prefix {
            url.query_pairs_mut().append_pair("prefix", prefix);
        }
        if let Some(continuation) = continuation {
            url.query_pairs_mut().append_pair("continuation", continuation);
        }
        if let Some(max_results) = max_results {
            url.query_pairs_mut().append_pair("maxResults", max_results.to_string().as_str());
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_file_systems::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_file_systems::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: FileSystemList = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_file_systems::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_file_systems::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_file_systems::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_file_systems {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod file_system {
    use super::{models, models::*, API_VERSION};
    pub async fn create(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        resource: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_properties: Option<&str>,
    ) -> std::result::Result<(), create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}", operation_config.base_path(), filesystem);
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("resource", resource);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_properties) = x_ms_properties {
            req_builder = req_builder.header("x-ms-properties", x_ms_properties);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_properties(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        resource: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_properties: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), set_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}", operation_config.base_path(), filesystem);
        let mut url = url::Url::parse(url_str).map_err(set_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("resource", resource);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_properties) = x_ms_properties {
            req_builder = req_builder.header("x-ms-properties", x_ms_properties);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_properties {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        resource: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}", operation_config.base_path(), filesystem);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("resource", resource);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        resource: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
    ) -> std::result::Result<(), get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}", operation_config.base_path(), filesystem);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("resource", resource);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_paths(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        resource: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        continuation: Option<&str>,
        directory: Option<&str>,
        recursive: bool,
        max_results: Option<i32>,
        upn: Option<bool>,
    ) -> std::result::Result<PathList, list_paths::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}?resource=filesystem", operation_config.base_path(), filesystem);
        let mut url = url::Url::parse(url_str).map_err(list_paths::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_paths::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("resource", resource);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(continuation) = continuation {
            url.query_pairs_mut().append_pair("continuation", continuation);
        }
        if let Some(directory) = directory {
            url.query_pairs_mut().append_pair("directory", directory);
        }
        url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        if let Some(max_results) = max_results {
            url.query_pairs_mut().append_pair("maxResults", max_results.to_string().as_str());
        }
        if let Some(upn) = upn {
            url.query_pairs_mut().append_pair("upn", upn.to_string().as_str());
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_paths::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_paths::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: PathList =
                    serde_json::from_slice(rsp_body).map_err(|source| list_paths::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| list_paths::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_paths::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_paths {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list_blob_hierarchy_segment(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        restype: &str,
        comp: &str,
        prefix: Option<&str>,
        delimiter: Option<&str>,
        marker: Option<&str>,
        max_results: Option<i32>,
        include: &[&str],
        showonly: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<ListBlobsHierarchySegmentResponse, list_blob_hierarchy_segment::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}?restype=container&comp=list&hierarchy",
            operation_config.base_path(),
            filesystem
        );
        let mut url = url::Url::parse(url_str).map_err(list_blob_hierarchy_segment::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_blob_hierarchy_segment::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("restype", restype);
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(prefix) = prefix {
            url.query_pairs_mut().append_pair("prefix", prefix);
        }
        if let Some(delimiter) = delimiter {
            url.query_pairs_mut().append_pair("delimiter", delimiter);
        }
        if let Some(marker) = marker {
            url.query_pairs_mut().append_pair("marker", marker);
        }
        if let Some(max_results) = max_results {
            url.query_pairs_mut().append_pair("maxResults", max_results.to_string().as_str());
        }
        if let Some(showonly) = showonly {
            url.query_pairs_mut().append_pair("showonly", showonly);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(list_blob_hierarchy_segment::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_blob_hierarchy_segment::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: ListBlobsHierarchySegmentResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_blob_hierarchy_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_blob_hierarchy_segment::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list_blob_hierarchy_segment::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list_blob_hierarchy_segment {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod path {
    use super::{models, models::*, API_VERSION};
    pub async fn read(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        range: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_range_get_content_md5: Option<bool>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<read::Response, read::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(read::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(read::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(range) = range {
            req_builder = req_builder.header("Range", range);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_range_get_content_md5) = x_ms_range_get_content_md5 {
            req_builder = req_builder.header("x-ms-range-get-content-md5", x_ms_range_get_content_md5.to_string());
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(read::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(read::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| read::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(read::Response::Ok200(rsp_value))
            }
            http::StatusCode::PARTIAL_CONTENT => {
                let rsp_body = rsp.body();
                let rsp_value: serde_json::Value =
                    serde_json::from_slice(rsp_body).map_err(|source| read::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(read::Response::PartialContent206(rsp_value))
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| read::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(read::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod read {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(serde_json::Value),
            PartialContent206(serde_json::Value),
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn lease(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_lease_action: &str,
        x_ms_lease_duration: Option<i32>,
        x_ms_lease_break_period: Option<i32>,
        x_ms_lease_id: Option<&str>,
        x_ms_proposed_lease_id: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<lease::Response, lease::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(lease::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(lease::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        req_builder = req_builder.header("x-ms-lease-action", x_ms_lease_action);
        if let Some(x_ms_lease_duration) = x_ms_lease_duration {
            req_builder = req_builder.header("x-ms-lease-duration", x_ms_lease_duration);
        }
        if let Some(x_ms_lease_break_period) = x_ms_lease_break_period {
            req_builder = req_builder.header("x-ms-lease-break-period", x_ms_lease_break_period);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_proposed_lease_id) = x_ms_proposed_lease_id {
            req_builder = req_builder.header("x-ms-proposed-lease-id", x_ms_proposed_lease_id);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(lease::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(lease::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(lease::Response::Ok200),
            http::StatusCode::CREATED => Ok(lease::Response::Created201),
            http::StatusCode::ACCEPTED => Ok(lease::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| lease::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(lease::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod lease {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Created201,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        resource: Option<&str>,
        continuation: Option<&str>,
        mode: Option<&str>,
        x_ms_cache_control: Option<&str>,
        x_ms_content_encoding: Option<&str>,
        x_ms_content_language: Option<&str>,
        x_ms_content_disposition: Option<&str>,
        x_ms_content_type: Option<&str>,
        x_ms_rename_source: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_source_lease_id: Option<&str>,
        x_ms_properties: Option<&str>,
        x_ms_permissions: Option<&str>,
        x_ms_umask: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_source_if_match: Option<&str>,
        x_ms_source_if_none_match: Option<&str>,
        x_ms_source_if_modified_since: Option<&str>,
        x_ms_source_if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), create::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(create::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(resource) = resource {
            url.query_pairs_mut().append_pair("resource", resource);
        }
        if let Some(continuation) = continuation {
            url.query_pairs_mut().append_pair("continuation", continuation);
        }
        if let Some(mode) = mode {
            url.query_pairs_mut().append_pair("mode", mode);
        }
        if let Some(x_ms_cache_control) = x_ms_cache_control {
            req_builder = req_builder.header("x-ms-cache-control", x_ms_cache_control);
        }
        if let Some(x_ms_content_encoding) = x_ms_content_encoding {
            req_builder = req_builder.header("x-ms-content-encoding", x_ms_content_encoding);
        }
        if let Some(x_ms_content_language) = x_ms_content_language {
            req_builder = req_builder.header("x-ms-content-language", x_ms_content_language);
        }
        if let Some(x_ms_content_disposition) = x_ms_content_disposition {
            req_builder = req_builder.header("x-ms-content-disposition", x_ms_content_disposition);
        }
        if let Some(x_ms_content_type) = x_ms_content_type {
            req_builder = req_builder.header("x-ms-content-type", x_ms_content_type);
        }
        if let Some(x_ms_rename_source) = x_ms_rename_source {
            req_builder = req_builder.header("x-ms-rename-source", x_ms_rename_source);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_source_lease_id) = x_ms_source_lease_id {
            req_builder = req_builder.header("x-ms-source-lease-id", x_ms_source_lease_id);
        }
        if let Some(x_ms_properties) = x_ms_properties {
            req_builder = req_builder.header("x-ms-properties", x_ms_properties);
        }
        if let Some(x_ms_permissions) = x_ms_permissions {
            req_builder = req_builder.header("x-ms-permissions", x_ms_permissions);
        }
        if let Some(x_ms_umask) = x_ms_umask {
            req_builder = req_builder.header("x-ms-umask", x_ms_umask);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(x_ms_source_if_match) = x_ms_source_if_match {
            req_builder = req_builder.header("x-ms-source-if-match", x_ms_source_if_match);
        }
        if let Some(x_ms_source_if_none_match) = x_ms_source_if_none_match {
            req_builder = req_builder.header("x-ms-source-if-none-match", x_ms_source_if_none_match);
        }
        if let Some(x_ms_source_if_modified_since) = x_ms_source_if_modified_since {
            req_builder = req_builder.header("x-ms-source-if-modified-since", x_ms_source_if_modified_since);
        }
        if let Some(x_ms_source_if_unmodified_since) = x_ms_source_if_unmodified_since {
            req_builder = req_builder.header("x-ms-source-if-unmodified-since", x_ms_source_if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(create::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| create::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        action: &str,
        max_records: Option<i32>,
        continuation: Option<&str>,
        mode: &str,
        force_flag: Option<bool>,
        position: Option<i64>,
        retain_uncommitted_data: Option<bool>,
        close: Option<bool>,
        content_length: Option<i64>,
        x_ms_content_md5: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_cache_control: Option<&str>,
        x_ms_content_type: Option<&str>,
        x_ms_content_disposition: Option<&str>,
        x_ms_content_encoding: Option<&str>,
        x_ms_content_language: Option<&str>,
        x_ms_properties: Option<&str>,
        x_ms_owner: Option<&str>,
        x_ms_group: Option<&str>,
        x_ms_permissions: Option<&str>,
        x_ms_acl: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        body: &serde_json::Value,
    ) -> std::result::Result<update::Response, update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        url.query_pairs_mut().append_pair("action", action);
        if let Some(max_records) = max_records {
            url.query_pairs_mut().append_pair("maxRecords", max_records.to_string().as_str());
        }
        if let Some(continuation) = continuation {
            url.query_pairs_mut().append_pair("continuation", continuation);
        }
        url.query_pairs_mut().append_pair("mode", mode);
        if let Some(force_flag) = force_flag {
            url.query_pairs_mut().append_pair("forceFlag", force_flag.to_string().as_str());
        }
        if let Some(position) = position {
            url.query_pairs_mut().append_pair("position", position.to_string().as_str());
        }
        if let Some(retain_uncommitted_data) = retain_uncommitted_data {
            url.query_pairs_mut()
                .append_pair("retainUncommittedData", retain_uncommitted_data.to_string().as_str());
        }
        if let Some(close) = close {
            url.query_pairs_mut().append_pair("close", close.to_string().as_str());
        }
        if let Some(content_length) = content_length {
            req_builder = req_builder.header("Content-Length", content_length);
        }
        if let Some(x_ms_content_md5) = x_ms_content_md5 {
            req_builder = req_builder.header("x-ms-content-md5", x_ms_content_md5);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_cache_control) = x_ms_cache_control {
            req_builder = req_builder.header("x-ms-cache-control", x_ms_cache_control);
        }
        if let Some(x_ms_content_type) = x_ms_content_type {
            req_builder = req_builder.header("x-ms-content-type", x_ms_content_type);
        }
        if let Some(x_ms_content_disposition) = x_ms_content_disposition {
            req_builder = req_builder.header("x-ms-content-disposition", x_ms_content_disposition);
        }
        if let Some(x_ms_content_encoding) = x_ms_content_encoding {
            req_builder = req_builder.header("x-ms-content-encoding", x_ms_content_encoding);
        }
        if let Some(x_ms_content_language) = x_ms_content_language {
            req_builder = req_builder.header("x-ms-content-language", x_ms_content_language);
        }
        if let Some(x_ms_properties) = x_ms_properties {
            req_builder = req_builder.header("x-ms-properties", x_ms_properties);
        }
        if let Some(x_ms_owner) = x_ms_owner {
            req_builder = req_builder.header("x-ms-owner", x_ms_owner);
        }
        if let Some(x_ms_group) = x_ms_group {
            req_builder = req_builder.header("x-ms-group", x_ms_group);
        }
        if let Some(x_ms_permissions) = x_ms_permissions {
            req_builder = req_builder.header("x-ms-permissions", x_ms_permissions);
        }
        if let Some(x_ms_acl) = x_ms_acl {
            req_builder = req_builder.header("x-ms-acl", x_ms_acl);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(body).map_err(update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: SetAccessControlRecursiveResponse =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(update::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(update::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(SetAccessControlRecursiveResponse),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        recursive: Option<bool>,
        continuation: Option<&str>,
        x_ms_lease_id: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(recursive) = recursive {
            url.query_pairs_mut().append_pair("recursive", recursive.to_string().as_str());
        }
        if let Some(continuation) = continuation {
            url.query_pairs_mut().append_pair("continuation", continuation);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_properties(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        x_ms_client_request_id: Option<&str>,
        timeout: Option<i64>,
        x_ms_version: &str,
        action: Option<&str>,
        upn: Option<bool>,
        x_ms_lease_id: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
    ) -> std::result::Result<(), get_properties::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(get_properties::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::HEAD);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_properties::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(action) = action {
            url.query_pairs_mut().append_pair("action", action);
        }
        if let Some(upn) = upn {
            url.query_pairs_mut().append_pair("upn", upn.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_properties::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_properties::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_properties::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_properties::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_properties {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_access_control(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        action: &str,
        timeout: Option<i64>,
        x_ms_lease_id: Option<&str>,
        x_ms_owner: Option<&str>,
        x_ms_group: Option<&str>,
        x_ms_permissions: Option<&str>,
        x_ms_acl: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_client_request_id: Option<&str>,
        x_ms_version: &str,
    ) -> std::result::Result<(), set_access_control::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?action=setAccessControl", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(set_access_control::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_access_control::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("action", action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_owner) = x_ms_owner {
            req_builder = req_builder.header("x-ms-owner", x_ms_owner);
        }
        if let Some(x_ms_group) = x_ms_group {
            req_builder = req_builder.header("x-ms-group", x_ms_group);
        }
        if let Some(x_ms_permissions) = x_ms_permissions {
            req_builder = req_builder.header("x-ms-permissions", x_ms_permissions);
        }
        if let Some(x_ms_acl) = x_ms_acl {
            req_builder = req_builder.header("x-ms-acl", x_ms_acl);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_access_control::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_access_control::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| set_access_control::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_access_control::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_access_control {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_access_control_recursive(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        action: &str,
        timeout: Option<i64>,
        continuation: Option<&str>,
        mode: &str,
        force_flag: Option<bool>,
        max_records: Option<i32>,
        x_ms_acl: Option<&str>,
        x_ms_client_request_id: Option<&str>,
        x_ms_version: &str,
    ) -> std::result::Result<SetAccessControlRecursiveResponse, set_access_control_recursive::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/{}/{}?action=setAccessControlRecursive",
            operation_config.base_path(),
            filesystem,
            path
        );
        let mut url = url::Url::parse(url_str).map_err(set_access_control_recursive::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_access_control_recursive::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("action", action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(continuation) = continuation {
            url.query_pairs_mut().append_pair("continuation", continuation);
        }
        url.query_pairs_mut().append_pair("mode", mode);
        if let Some(force_flag) = force_flag {
            url.query_pairs_mut().append_pair("forceFlag", force_flag.to_string().as_str());
        }
        if let Some(max_records) = max_records {
            url.query_pairs_mut().append_pair("maxRecords", max_records.to_string().as_str());
        }
        if let Some(x_ms_acl) = x_ms_acl {
            req_builder = req_builder.header("x-ms-acl", x_ms_acl);
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(set_access_control_recursive::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_access_control_recursive::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: SetAccessControlRecursiveResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| set_access_control_recursive::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError = serde_json::from_slice(rsp_body)
                    .map_err(|source| set_access_control_recursive::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_access_control_recursive::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_access_control_recursive {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn flush_data(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        action: &str,
        timeout: Option<i64>,
        position: Option<i64>,
        retain_uncommitted_data: Option<bool>,
        close: Option<bool>,
        content_length: Option<i64>,
        x_ms_content_md5: Option<&str>,
        x_ms_lease_id: Option<&str>,
        x_ms_cache_control: Option<&str>,
        x_ms_content_type: Option<&str>,
        x_ms_content_disposition: Option<&str>,
        x_ms_content_encoding: Option<&str>,
        x_ms_content_language: Option<&str>,
        if_match: Option<&str>,
        if_none_match: Option<&str>,
        if_modified_since: Option<&str>,
        if_unmodified_since: Option<&str>,
        x_ms_client_request_id: Option<&str>,
        x_ms_version: &str,
    ) -> std::result::Result<(), flush_data::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?action=flush", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(flush_data::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(flush_data::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("action", action);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(position) = position {
            url.query_pairs_mut().append_pair("position", position.to_string().as_str());
        }
        if let Some(retain_uncommitted_data) = retain_uncommitted_data {
            url.query_pairs_mut()
                .append_pair("retainUncommittedData", retain_uncommitted_data.to_string().as_str());
        }
        if let Some(close) = close {
            url.query_pairs_mut().append_pair("close", close.to_string().as_str());
        }
        if let Some(content_length) = content_length {
            req_builder = req_builder.header("Content-Length", content_length);
        }
        if let Some(x_ms_content_md5) = x_ms_content_md5 {
            req_builder = req_builder.header("x-ms-content-md5", x_ms_content_md5);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        if let Some(x_ms_cache_control) = x_ms_cache_control {
            req_builder = req_builder.header("x-ms-cache-control", x_ms_cache_control);
        }
        if let Some(x_ms_content_type) = x_ms_content_type {
            req_builder = req_builder.header("x-ms-content-type", x_ms_content_type);
        }
        if let Some(x_ms_content_disposition) = x_ms_content_disposition {
            req_builder = req_builder.header("x-ms-content-disposition", x_ms_content_disposition);
        }
        if let Some(x_ms_content_encoding) = x_ms_content_encoding {
            req_builder = req_builder.header("x-ms-content-encoding", x_ms_content_encoding);
        }
        if let Some(x_ms_content_language) = x_ms_content_language {
            req_builder = req_builder.header("x-ms-content-language", x_ms_content_language);
        }
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        if let Some(if_modified_since) = if_modified_since {
            req_builder = req_builder.header("If-Modified-Since", if_modified_since);
        }
        if let Some(if_unmodified_since) = if_unmodified_since {
            req_builder = req_builder.header("If-Unmodified-Since", if_unmodified_since);
        }
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(flush_data::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(flush_data::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| flush_data::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(flush_data::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod flush_data {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn append_data(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        action: &str,
        position: Option<i64>,
        timeout: Option<i64>,
        content_length: Option<i64>,
        content_md5: Option<&str>,
        x_ms_content_crc64: Option<&str>,
        x_ms_lease_id: Option<&str>,
        body: &serde_json::Value,
        x_ms_client_request_id: Option<&str>,
        x_ms_version: &str,
    ) -> std::result::Result<(), append_data::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?action=append", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(append_data::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PATCH);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(append_data::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("action", action);
        if let Some(position) = position {
            url.query_pairs_mut().append_pair("position", position.to_string().as_str());
        }
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(content_length) = content_length {
            req_builder = req_builder.header("Content-Length", content_length);
        }
        if let Some(content_md5) = content_md5 {
            req_builder = req_builder.header("Content-MD5", content_md5);
        }
        if let Some(x_ms_content_crc64) = x_ms_content_crc64 {
            req_builder = req_builder.header("x-ms-content-crc64", x_ms_content_crc64);
        }
        if let Some(x_ms_lease_id) = x_ms_lease_id {
            req_builder = req_builder.header("x-ms-lease-id", x_ms_lease_id);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(body).map_err(append_data::Error::SerializeError)?;
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(append_data::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(append_data::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| append_data::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(append_data::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod append_data {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn set_expiry(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
        x_ms_expiry_option: &str,
        x_ms_expiry_time: Option<&str>,
    ) -> std::result::Result<(), set_expiry::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=expiry", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(set_expiry::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(set_expiry::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("x-ms-expiry-option", x_ms_expiry_option);
        if let Some(x_ms_expiry_time) = x_ms_expiry_time {
            req_builder = req_builder.header("x-ms-expiry-time", x_ms_expiry_time);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(set_expiry::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(set_expiry::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| set_expiry::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(set_expiry::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod set_expiry {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn undelete(
        operation_config: &crate::OperationConfig,
        filesystem: &str,
        path: &str,
        comp: &str,
        timeout: Option<i64>,
        x_ms_undelete_source: Option<&str>,
        x_ms_version: &str,
        x_ms_client_request_id: Option<&str>,
    ) -> std::result::Result<(), undelete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/{}/{}?comp=undelete", operation_config.base_path(), filesystem, path);
        let mut url = url::Url::parse(url_str).map_err(undelete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(undelete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("comp", comp);
        if let Some(timeout) = timeout {
            url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
        }
        if let Some(x_ms_undelete_source) = x_ms_undelete_source {
            req_builder = req_builder.header("x-ms-undelete-source", x_ms_undelete_source);
        }
        req_builder = req_builder.header("x-ms-version", x_ms_version);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(undelete::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(undelete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: StorageError =
                    serde_json::from_slice(rsp_body).map_err(|source| undelete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(undelete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod undelete {
        use super::{models, models::*, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::StorageError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
