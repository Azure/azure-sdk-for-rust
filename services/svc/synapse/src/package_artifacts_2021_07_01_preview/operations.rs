#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, API_VERSION};
#[non_exhaustive]
#[derive(Debug, thiserror :: Error)]
#[allow(non_camel_case_types)]
pub enum Error {
    #[error(transparent)]
    Metastore_GetDatabaseOperations(#[from] metastore::get_database_operations::Error),
    #[error(transparent)]
    Metastore_Register(#[from] metastore::register::Error),
    #[error(transparent)]
    Metastore_Update(#[from] metastore::update::Error),
    #[error(transparent)]
    Metastore_Delete(#[from] metastore::delete::Error),
    #[error(transparent)]
    KqlScripts_GetAll(#[from] kql_scripts::get_all::Error),
    #[error(transparent)]
    KqlScript_GetByName(#[from] kql_script::get_by_name::Error),
    #[error(transparent)]
    KqlScript_CreateOrUpdate(#[from] kql_script::create_or_update::Error),
    #[error(transparent)]
    KqlScript_DeleteByName(#[from] kql_script::delete_by_name::Error),
    #[error(transparent)]
    KqlScript_Rename(#[from] kql_script::rename::Error),
    #[error(transparent)]
    SparkConfiguration_GetSparkConfigurationsByWorkspace(#[from] spark_configuration::get_spark_configurations_by_workspace::Error),
    #[error(transparent)]
    SparkConfiguration_GetSparkConfiguration(#[from] spark_configuration::get_spark_configuration::Error),
    #[error(transparent)]
    SparkConfiguration_CreateOrUpdateSparkConfiguration(#[from] spark_configuration::create_or_update_spark_configuration::Error),
    #[error(transparent)]
    SparkConfiguration_DeleteSparkConfiguration(#[from] spark_configuration::delete_spark_configuration::Error),
    #[error(transparent)]
    SparkConfiguration_RenameSparkConfiguration(#[from] spark_configuration::rename_spark_configuration::Error),
    #[error(transparent)]
    BigDataPools_List(#[from] big_data_pools::list::Error),
    #[error(transparent)]
    BigDataPools_Get(#[from] big_data_pools::get::Error),
    #[error(transparent)]
    DataFlow_GetDataFlow(#[from] data_flow::get_data_flow::Error),
    #[error(transparent)]
    DataFlow_CreateOrUpdateDataFlow(#[from] data_flow::create_or_update_data_flow::Error),
    #[error(transparent)]
    DataFlow_DeleteDataFlow(#[from] data_flow::delete_data_flow::Error),
    #[error(transparent)]
    DataFlow_RenameDataFlow(#[from] data_flow::rename_data_flow::Error),
    #[error(transparent)]
    DataFlow_GetDataFlowsByWorkspace(#[from] data_flow::get_data_flows_by_workspace::Error),
    #[error(transparent)]
    DataFlowDebugSession_CreateDataFlowDebugSession(#[from] data_flow_debug_session::create_data_flow_debug_session::Error),
    #[error(transparent)]
    DataFlowDebugSession_QueryDataFlowDebugSessionsByWorkspace(
        #[from] data_flow_debug_session::query_data_flow_debug_sessions_by_workspace::Error,
    ),
    #[error(transparent)]
    DataFlowDebugSession_AddDataFlow(#[from] data_flow_debug_session::add_data_flow::Error),
    #[error(transparent)]
    DataFlowDebugSession_DeleteDataFlowDebugSession(#[from] data_flow_debug_session::delete_data_flow_debug_session::Error),
    #[error(transparent)]
    DataFlowDebugSession_ExecuteCommand(#[from] data_flow_debug_session::execute_command::Error),
    #[error(transparent)]
    Dataset_GetDatasetsByWorkspace(#[from] dataset::get_datasets_by_workspace::Error),
    #[error(transparent)]
    Dataset_GetDataset(#[from] dataset::get_dataset::Error),
    #[error(transparent)]
    Dataset_CreateOrUpdateDataset(#[from] dataset::create_or_update_dataset::Error),
    #[error(transparent)]
    Dataset_DeleteDataset(#[from] dataset::delete_dataset::Error),
    #[error(transparent)]
    Dataset_RenameDataset(#[from] dataset::rename_dataset::Error),
    #[error(transparent)]
    LinkedService_GetLinkedServicesByWorkspace(#[from] linked_service::get_linked_services_by_workspace::Error),
    #[error(transparent)]
    LinkedService_GetLinkedService(#[from] linked_service::get_linked_service::Error),
    #[error(transparent)]
    LinkedService_CreateOrUpdateLinkedService(#[from] linked_service::create_or_update_linked_service::Error),
    #[error(transparent)]
    LinkedService_DeleteLinkedService(#[from] linked_service::delete_linked_service::Error),
    #[error(transparent)]
    LinkedService_RenameLinkedService(#[from] linked_service::rename_linked_service::Error),
    #[error(transparent)]
    WorkspaceGitRepoManagement_GetGitHubAccessToken(#[from] workspace_git_repo_management::get_git_hub_access_token::Error),
    #[error(transparent)]
    IntegrationRuntimes_List(#[from] integration_runtimes::list::Error),
    #[error(transparent)]
    IntegrationRuntimes_Get(#[from] integration_runtimes::get::Error),
    #[error(transparent)]
    Library_Append(#[from] library::append::Error),
    #[error(transparent)]
    Notebook_GetNotebooksByWorkspace(#[from] notebook::get_notebooks_by_workspace::Error),
    #[error(transparent)]
    Notebook_GetNotebookSummaryByWorkSpace(#[from] notebook::get_notebook_summary_by_work_space::Error),
    #[error(transparent)]
    Notebook_GetNotebook(#[from] notebook::get_notebook::Error),
    #[error(transparent)]
    Notebook_CreateOrUpdateNotebook(#[from] notebook::create_or_update_notebook::Error),
    #[error(transparent)]
    Notebook_DeleteNotebook(#[from] notebook::delete_notebook::Error),
    #[error(transparent)]
    Notebook_RenameNotebook(#[from] notebook::rename_notebook::Error),
    #[error(transparent)]
    NotebookOperationResult_Get(#[from] notebook_operation_result::get::Error),
    #[error(transparent)]
    Pipeline_GetPipelinesByWorkspace(#[from] pipeline::get_pipelines_by_workspace::Error),
    #[error(transparent)]
    Pipeline_GetPipeline(#[from] pipeline::get_pipeline::Error),
    #[error(transparent)]
    Pipeline_CreateOrUpdatePipeline(#[from] pipeline::create_or_update_pipeline::Error),
    #[error(transparent)]
    Pipeline_DeletePipeline(#[from] pipeline::delete_pipeline::Error),
    #[error(transparent)]
    Pipeline_RenamePipeline(#[from] pipeline::rename_pipeline::Error),
    #[error(transparent)]
    Pipeline_CreatePipelineRun(#[from] pipeline::create_pipeline_run::Error),
    #[error(transparent)]
    PipelineRun_QueryPipelineRunsByWorkspace(#[from] pipeline_run::query_pipeline_runs_by_workspace::Error),
    #[error(transparent)]
    PipelineRun_GetPipelineRun(#[from] pipeline_run::get_pipeline_run::Error),
    #[error(transparent)]
    PipelineRun_QueryActivityRuns(#[from] pipeline_run::query_activity_runs::Error),
    #[error(transparent)]
    PipelineRun_CancelPipelineRun(#[from] pipeline_run::cancel_pipeline_run::Error),
    #[error(transparent)]
    SparkJobDefinition_GetSparkJobDefinitionsByWorkspace(#[from] spark_job_definition::get_spark_job_definitions_by_workspace::Error),
    #[error(transparent)]
    SparkJobDefinition_GetSparkJobDefinition(#[from] spark_job_definition::get_spark_job_definition::Error),
    #[error(transparent)]
    SparkJobDefinition_CreateOrUpdateSparkJobDefinition(#[from] spark_job_definition::create_or_update_spark_job_definition::Error),
    #[error(transparent)]
    SparkJobDefinition_DeleteSparkJobDefinition(#[from] spark_job_definition::delete_spark_job_definition::Error),
    #[error(transparent)]
    SparkJobDefinition_ExecuteSparkJobDefinition(#[from] spark_job_definition::execute_spark_job_definition::Error),
    #[error(transparent)]
    SparkJobDefinition_RenameSparkJobDefinition(#[from] spark_job_definition::rename_spark_job_definition::Error),
    #[error(transparent)]
    SparkJobDefinition_DebugSparkJobDefinition(#[from] spark_job_definition::debug_spark_job_definition::Error),
    #[error(transparent)]
    SqlPools_List(#[from] sql_pools::list::Error),
    #[error(transparent)]
    SqlPools_Get(#[from] sql_pools::get::Error),
    #[error(transparent)]
    SqlScript_GetSqlScriptsByWorkspace(#[from] sql_script::get_sql_scripts_by_workspace::Error),
    #[error(transparent)]
    SqlScript_GetSqlScript(#[from] sql_script::get_sql_script::Error),
    #[error(transparent)]
    SqlScript_CreateOrUpdateSqlScript(#[from] sql_script::create_or_update_sql_script::Error),
    #[error(transparent)]
    SqlScript_DeleteSqlScript(#[from] sql_script::delete_sql_script::Error),
    #[error(transparent)]
    SqlScript_RenameSqlScript(#[from] sql_script::rename_sql_script::Error),
    #[error(transparent)]
    Trigger_GetTriggersByWorkspace(#[from] trigger::get_triggers_by_workspace::Error),
    #[error(transparent)]
    Trigger_GetTrigger(#[from] trigger::get_trigger::Error),
    #[error(transparent)]
    Trigger_CreateOrUpdateTrigger(#[from] trigger::create_or_update_trigger::Error),
    #[error(transparent)]
    Trigger_DeleteTrigger(#[from] trigger::delete_trigger::Error),
    #[error(transparent)]
    Trigger_SubscribeTriggerToEvents(#[from] trigger::subscribe_trigger_to_events::Error),
    #[error(transparent)]
    Trigger_GetEventSubscriptionStatus(#[from] trigger::get_event_subscription_status::Error),
    #[error(transparent)]
    Trigger_UnsubscribeTriggerFromEvents(#[from] trigger::unsubscribe_trigger_from_events::Error),
    #[error(transparent)]
    Trigger_StartTrigger(#[from] trigger::start_trigger::Error),
    #[error(transparent)]
    Trigger_StopTrigger(#[from] trigger::stop_trigger::Error),
    #[error(transparent)]
    TriggerRun_RerunTriggerInstance(#[from] trigger_run::rerun_trigger_instance::Error),
    #[error(transparent)]
    TriggerRun_CancelTriggerInstance(#[from] trigger_run::cancel_trigger_instance::Error),
    #[error(transparent)]
    TriggerRun_QueryTriggerRunsByWorkspace(#[from] trigger_run::query_trigger_runs_by_workspace::Error),
    #[error(transparent)]
    Workspace_Get(#[from] workspace::get::Error),
}
pub mod metastore {
    use super::{models, API_VERSION};
    pub async fn get_database_operations(
        operation_config: &crate::OperationConfig,
        id: &str,
    ) -> std::result::Result<models::MetastoreRequestSuccessResponse, get_database_operations::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/metastore/create-database-operations/{}", operation_config.base_path(), id);
        let mut url = url::Url::parse(url_str).map_err(get_database_operations::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_database_operations::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_database_operations::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_database_operations::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::MetastoreRequestSuccessResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_database_operations::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_database_operations::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_database_operations::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_database_operations {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn register(
        operation_config: &crate::OperationConfig,
        id: &str,
        register_body: &models::MetastoreRegisterObject,
    ) -> std::result::Result<models::MetastoreRegistrationResponse, register::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/metastore/create-database-operations/{}", operation_config.base_path(), id);
        let mut url = url::Url::parse(url_str).map_err(register::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(register::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(register_body).map_err(register::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(register::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(register::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::MetastoreRegistrationResponse =
                    serde_json::from_slice(rsp_body).map_err(|source| register::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| register::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(register::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod register {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn update(
        operation_config: &crate::OperationConfig,
        id: &str,
        update_body: &models::MetastoreUpdateObject,
    ) -> std::result::Result<models::MetastoreUpdationResponse, update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/metastore/update-database-operations/{}", operation_config.base_path(), id);
        let mut url = url::Url::parse(url_str).map_err(update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(update_body).map_err(update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(update::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::MetastoreUpdationResponse =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod update {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(operation_config: &crate::OperationConfig, id: &str) -> std::result::Result<(), delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/metastore/databases/{}", operation_config.base_path(), id);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::NO_CONTENT => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod kql_scripts {
    use super::{models, API_VERSION};
    pub async fn get_all(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::KqlScriptsResourceCollectionResponse, get_all::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/kqlScripts", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_all::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_all::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_all::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_all::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::KqlScriptsResourceCollectionResponse =
                    serde_json::from_slice(rsp_body).map_err(|source| get_all::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| get_all::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_all::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_all {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod kql_script {
    use super::{models, API_VERSION};
    pub async fn get_by_name(
        operation_config: &crate::OperationConfig,
        kql_script_name: &str,
    ) -> std::result::Result<models::KqlScriptResource, get_by_name::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/kqlScripts/{}", operation_config.base_path(), kql_script_name);
        let mut url = url::Url::parse(url_str).map_err(get_by_name::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_by_name::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_by_name::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_by_name::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::KqlScriptResource =
                    serde_json::from_slice(rsp_body).map_err(|source| get_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| get_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_by_name::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_by_name {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        kql_script_name: &str,
        kql_script: &models::KqlScriptResource,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/kqlScripts/{}", operation_config.base_path(), kql_script_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(kql_script).map_err(create_or_update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_or_update::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::KqlScriptResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::KqlScriptResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_by_name(
        operation_config: &crate::OperationConfig,
        kql_script_name: &str,
    ) -> std::result::Result<delete_by_name::Response, delete_by_name::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/kqlScripts/{}", operation_config.base_path(), kql_script_name);
        let mut url = url::Url::parse(url_str).map_err(delete_by_name::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_by_name::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_by_name::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_by_name::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_by_name::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_by_name::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_by_name::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| delete_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_by_name::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_by_name {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename(
        operation_config: &crate::OperationConfig,
        kql_script_name: &str,
        rename_request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename::Response, rename::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/kqlScripts/{}/rename", operation_config.base_path(), kql_script_name);
        let mut url = url::Url::parse(url_str).map_err(rename::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(rename_request).map_err(rename::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(rename::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(rename::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| rename::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod spark_configuration {
    use super::{models, API_VERSION};
    pub async fn get_spark_configurations_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::SparkConfigurationListResponse, get_spark_configurations_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sparkconfigurations", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_spark_configurations_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_spark_configurations_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_spark_configurations_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_spark_configurations_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkConfigurationListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_spark_configurations_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_spark_configurations_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_spark_configurations_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_spark_configurations_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_spark_configuration(
        operation_config: &crate::OperationConfig,
        spark_configuration_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::SparkConfigurationResource, get_spark_configuration::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sparkconfigurations/{}", operation_config.base_path(), spark_configuration_name);
        let mut url = url::Url::parse(url_str).map_err(get_spark_configuration::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_spark_configuration::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_spark_configuration::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_spark_configuration::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkConfigurationResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_spark_configuration::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            http::StatusCode::NOT_MODIFIED => Err(get_spark_configuration::Error::NotModified304 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_spark_configuration::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_spark_configuration::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_spark_configuration {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotModified304 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_spark_configuration(
        operation_config: &crate::OperationConfig,
        spark_configuration_name: &str,
        if_match: Option<&str>,
        spark_configuration: &models::SparkConfigurationResource,
    ) -> std::result::Result<create_or_update_spark_configuration::Response, create_or_update_spark_configuration::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sparkconfigurations/{}", operation_config.base_path(), spark_configuration_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_spark_configuration::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_spark_configuration::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(spark_configuration).map_err(create_or_update_spark_configuration::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_spark_configuration::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_spark_configuration::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkConfigurationResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_spark_configuration::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_spark_configuration::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_spark_configuration::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_spark_configuration::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_spark_configuration::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_spark_configuration {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::SparkConfigurationResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_spark_configuration(
        operation_config: &crate::OperationConfig,
        spark_configuration_name: &str,
    ) -> std::result::Result<delete_spark_configuration::Response, delete_spark_configuration::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sparkconfigurations/{}", operation_config.base_path(), spark_configuration_name);
        let mut url = url::Url::parse(url_str).map_err(delete_spark_configuration::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_spark_configuration::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(delete_spark_configuration::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_spark_configuration::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_spark_configuration::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_spark_configuration::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_spark_configuration::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_spark_configuration::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_spark_configuration::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_spark_configuration {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename_spark_configuration(
        operation_config: &crate::OperationConfig,
        spark_configuration_name: &str,
        request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename_spark_configuration::Response, rename_spark_configuration::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/sparkconfigurations/{}/rename",
            operation_config.base_path(),
            spark_configuration_name
        );
        let mut url = url::Url::parse(url_str).map_err(rename_spark_configuration::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename_spark_configuration::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(rename_spark_configuration::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(rename_spark_configuration::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rename_spark_configuration::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename_spark_configuration::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename_spark_configuration::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| rename_spark_configuration::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename_spark_configuration::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename_spark_configuration {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod big_data_pools {
    use super::{models, API_VERSION};
    pub async fn list(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::BigDataPoolResourceInfoListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/bigDataPools", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::BigDataPoolResourceInfoListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        big_data_pool_name: &str,
    ) -> std::result::Result<models::BigDataPoolResourceInfo, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/bigDataPools/{}", operation_config.base_path(), big_data_pool_name);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::BigDataPoolResourceInfo =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod data_flow {
    use super::{models, API_VERSION};
    pub async fn get_data_flow(
        operation_config: &crate::OperationConfig,
        data_flow_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::DataFlowResource, get_data_flow::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/dataflows/{}", operation_config.base_path(), data_flow_name);
        let mut url = url::Url::parse(url_str).map_err(get_data_flow::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_data_flow::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_data_flow::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_data_flow::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::DataFlowResource =
                    serde_json::from_slice(rsp_body).map_err(|source| get_data_flow::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_data_flow::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_data_flow::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_data_flow {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_data_flow(
        operation_config: &crate::OperationConfig,
        data_flow_name: &str,
        if_match: Option<&str>,
        data_flow: &models::DataFlowResource,
    ) -> std::result::Result<create_or_update_data_flow::Response, create_or_update_data_flow::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/dataflows/{}", operation_config.base_path(), data_flow_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_data_flow::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_data_flow::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(data_flow).map_err(create_or_update_data_flow::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_data_flow::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_data_flow::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::DataFlowResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_data_flow::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_data_flow::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_data_flow::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_data_flow::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_data_flow::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_data_flow {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::DataFlowResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_data_flow(
        operation_config: &crate::OperationConfig,
        data_flow_name: &str,
    ) -> std::result::Result<delete_data_flow::Response, delete_data_flow::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/dataflows/{}", operation_config.base_path(), data_flow_name);
        let mut url = url::Url::parse(url_str).map_err(delete_data_flow::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_data_flow::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_data_flow::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_data_flow::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_data_flow::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_data_flow::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_data_flow::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_data_flow::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_data_flow::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_data_flow {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename_data_flow(
        operation_config: &crate::OperationConfig,
        data_flow_name: &str,
        request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename_data_flow::Response, rename_data_flow::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/dataflows/{}/rename", operation_config.base_path(), data_flow_name);
        let mut url = url::Url::parse(url_str).map_err(rename_data_flow::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename_data_flow::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(rename_data_flow::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(rename_data_flow::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rename_data_flow::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename_data_flow::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename_data_flow::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| rename_data_flow::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename_data_flow::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename_data_flow {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_data_flows_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::DataFlowListResponse, get_data_flows_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/dataflows", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_data_flows_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_data_flows_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_data_flows_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_data_flows_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::DataFlowListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_data_flows_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_data_flows_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_data_flows_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_data_flows_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod data_flow_debug_session {
    use super::{models, API_VERSION};
    pub async fn create_data_flow_debug_session(
        operation_config: &crate::OperationConfig,
        request: &models::CreateDataFlowDebugSessionRequest,
    ) -> std::result::Result<create_data_flow_debug_session::Response, create_data_flow_debug_session::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/createDataFlowDebugSession", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(create_data_flow_debug_session::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_data_flow_debug_session::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(create_data_flow_debug_session::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_data_flow_debug_session::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_data_flow_debug_session::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(create_data_flow_debug_session::Response::Accepted202),
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CreateDataFlowDebugSessionResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_data_flow_debug_session::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_data_flow_debug_session::Response::Ok200(rsp_value))
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_data_flow_debug_session::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_data_flow_debug_session::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_data_flow_debug_session {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(models::CreateDataFlowDebugSessionResponse),
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn query_data_flow_debug_sessions_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::QueryDataFlowDebugSessionsResponse, query_data_flow_debug_sessions_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/queryDataFlowDebugSessions", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(query_data_flow_debug_sessions_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(query_data_flow_debug_sessions_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(query_data_flow_debug_sessions_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(query_data_flow_debug_sessions_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::QueryDataFlowDebugSessionsResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_data_flow_debug_sessions_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_data_flow_debug_sessions_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(query_data_flow_debug_sessions_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod query_data_flow_debug_sessions_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add_data_flow(
        operation_config: &crate::OperationConfig,
        request: &models::DataFlowDebugPackage,
    ) -> std::result::Result<models::AddDataFlowToDebugSessionResponse, add_data_flow::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/addDataFlowToDebugSession", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(add_data_flow::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add_data_flow::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(add_data_flow::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add_data_flow::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(add_data_flow::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::AddDataFlowToDebugSessionResponse =
                    serde_json::from_slice(rsp_body).map_err(|source| add_data_flow::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| add_data_flow::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add_data_flow::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add_data_flow {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_data_flow_debug_session(
        operation_config: &crate::OperationConfig,
        request: &models::DeleteDataFlowDebugSessionRequest,
    ) -> std::result::Result<(), delete_data_flow_debug_session::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/deleteDataFlowDebugSession", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(delete_data_flow_debug_session::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_data_flow_debug_session::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(delete_data_flow_debug_session::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(delete_data_flow_debug_session::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_data_flow_debug_session::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_data_flow_debug_session::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_data_flow_debug_session::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_data_flow_debug_session {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn execute_command(
        operation_config: &crate::OperationConfig,
        request: &models::DataFlowDebugCommandRequest,
    ) -> std::result::Result<execute_command::Response, execute_command::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/executeDataFlowDebugCommand", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(execute_command::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(execute_command::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(execute_command::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(execute_command::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(execute_command::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => Ok(execute_command::Response::Accepted202),
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::DataFlowDebugCommandResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| execute_command::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(execute_command::Response::Ok200(rsp_value))
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| execute_command::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(execute_command::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod execute_command {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Accepted202,
            Ok200(models::DataFlowDebugCommandResponse),
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod dataset {
    use super::{models, API_VERSION};
    pub async fn get_datasets_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::DatasetListResponse, get_datasets_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/datasets", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_datasets_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_datasets_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_datasets_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_datasets_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::DatasetListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_datasets_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_datasets_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_datasets_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_datasets_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_dataset(
        operation_config: &crate::OperationConfig,
        dataset_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::DatasetResource, get_dataset::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/datasets/{}", operation_config.base_path(), dataset_name);
        let mut url = url::Url::parse(url_str).map_err(get_dataset::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_dataset::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_dataset::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_dataset::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::DatasetResource =
                    serde_json::from_slice(rsp_body).map_err(|source| get_dataset::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            http::StatusCode::NOT_MODIFIED => Err(get_dataset::Error::NotModified304 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_dataset::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_dataset::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_dataset {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotModified304 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_dataset(
        operation_config: &crate::OperationConfig,
        dataset_name: &str,
        if_match: Option<&str>,
        dataset: &models::DatasetResource,
    ) -> std::result::Result<create_or_update_dataset::Response, create_or_update_dataset::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/datasets/{}", operation_config.base_path(), dataset_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_dataset::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_dataset::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(dataset).map_err(create_or_update_dataset::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_dataset::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_dataset::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::DatasetResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_dataset::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_dataset::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_dataset::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_dataset::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_dataset::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_dataset {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::DatasetResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_dataset(
        operation_config: &crate::OperationConfig,
        dataset_name: &str,
    ) -> std::result::Result<delete_dataset::Response, delete_dataset::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/datasets/{}", operation_config.base_path(), dataset_name);
        let mut url = url::Url::parse(url_str).map_err(delete_dataset::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_dataset::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_dataset::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_dataset::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_dataset::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_dataset::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_dataset::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete_dataset::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_dataset::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_dataset {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename_dataset(
        operation_config: &crate::OperationConfig,
        dataset_name: &str,
        request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename_dataset::Response, rename_dataset::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/datasets/{}/rename", operation_config.base_path(), dataset_name);
        let mut url = url::Url::parse(url_str).map_err(rename_dataset::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename_dataset::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(rename_dataset::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(rename_dataset::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rename_dataset::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename_dataset::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename_dataset::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| rename_dataset::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename_dataset::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename_dataset {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod linked_service {
    use super::{models, API_VERSION};
    pub async fn get_linked_services_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::LinkedServiceListResponse, get_linked_services_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/linkedservices", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_linked_services_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_linked_services_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_linked_services_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_linked_services_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::LinkedServiceListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_linked_services_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_linked_services_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_linked_services_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_linked_services_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_linked_service(
        operation_config: &crate::OperationConfig,
        linked_service_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::LinkedServiceResource, get_linked_service::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/linkedservices/{}", operation_config.base_path(), linked_service_name);
        let mut url = url::Url::parse(url_str).map_err(get_linked_service::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_linked_service::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_linked_service::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_linked_service::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::LinkedServiceResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_linked_service::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            http::StatusCode::NOT_MODIFIED => Err(get_linked_service::Error::NotModified304 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_linked_service::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_linked_service::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_linked_service {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotModified304 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_linked_service(
        operation_config: &crate::OperationConfig,
        linked_service_name: &str,
        if_match: Option<&str>,
        linked_service: &models::LinkedServiceResource,
    ) -> std::result::Result<create_or_update_linked_service::Response, create_or_update_linked_service::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/linkedservices/{}", operation_config.base_path(), linked_service_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_linked_service::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_linked_service::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(linked_service).map_err(create_or_update_linked_service::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_linked_service::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_linked_service::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::LinkedServiceResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_linked_service::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_linked_service::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_linked_service::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_linked_service::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_linked_service::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_linked_service {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::LinkedServiceResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_linked_service(
        operation_config: &crate::OperationConfig,
        linked_service_name: &str,
    ) -> std::result::Result<delete_linked_service::Response, delete_linked_service::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/linkedservices/{}", operation_config.base_path(), linked_service_name);
        let mut url = url::Url::parse(url_str).map_err(delete_linked_service::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_linked_service::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(delete_linked_service::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_linked_service::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_linked_service::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_linked_service::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_linked_service::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_linked_service::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_linked_service::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_linked_service {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename_linked_service(
        operation_config: &crate::OperationConfig,
        linked_service_name: &str,
        request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename_linked_service::Response, rename_linked_service::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/linkedservices/{}/rename", operation_config.base_path(), linked_service_name);
        let mut url = url::Url::parse(url_str).map_err(rename_linked_service::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename_linked_service::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(rename_linked_service::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(rename_linked_service::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rename_linked_service::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename_linked_service::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename_linked_service::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| rename_linked_service::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename_linked_service::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename_linked_service {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod workspace_git_repo_management {
    use super::{models, API_VERSION};
    pub async fn get_git_hub_access_token(
        operation_config: &crate::OperationConfig,
        x_ms_client_request_id: Option<&str>,
        git_hub_access_token_request: &models::GitHubAccessTokenRequest,
    ) -> std::result::Result<models::GitHubAccessTokenResponse, get_git_hub_access_token::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/getGitHubAccessToken", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_git_hub_access_token::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_git_hub_access_token::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(x_ms_client_request_id) = x_ms_client_request_id {
            req_builder = req_builder.header("x-ms-client-request-id", x_ms_client_request_id);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(git_hub_access_token_request).map_err(get_git_hub_access_token::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_git_hub_access_token::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_git_hub_access_token::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::GitHubAccessTokenResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_git_hub_access_token::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                Err(get_git_hub_access_token::Error::UnexpectedResponse {
                    status_code,
                    body: rsp_body.clone(),
                })
            }
        }
    }
    pub mod get_git_hub_access_token {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Unexpected HTTP status code {}", status_code)]
            UnexpectedResponse { status_code: http::StatusCode, body: bytes::Bytes },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod integration_runtimes {
    use super::{models, API_VERSION};
    pub async fn list(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::IntegrationRuntimeListResponse, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/integrationRuntimes", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::IntegrationRuntimeListResponse =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(
        operation_config: &crate::OperationConfig,
        integration_runtime_name: &str,
    ) -> std::result::Result<models::IntegrationRuntimeResource, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/integrationRuntimes/{}", operation_config.base_path(), integration_runtime_name);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::IntegrationRuntimeResource =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod library {
    use super::{models, API_VERSION};
    pub async fn append(
        operation_config: &crate::OperationConfig,
        comp: &str,
        library_name: &str,
        content: &str,
        x_ms_blob_condition_appendpos: Option<i64>,
    ) -> std::result::Result<(), append::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/libraries/{}?comp=appendblock", operation_config.base_path(), library_name);
        let mut url = url::Url::parse(url_str).map_err(append::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(append::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        url.query_pairs_mut().append_pair("comp", comp);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(content).map_err(append::Error::SerializeError)?;
        if let Some(x_ms_blob_condition_appendpos) = x_ms_blob_condition_appendpos {
            req_builder = req_builder.header("x-ms-blob-condition-appendpos", x_ms_blob_condition_appendpos);
        }
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(append::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(append::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::CREATED => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| append::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(append::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod append {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod notebook {
    use super::{models, API_VERSION};
    pub async fn get_notebooks_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::NotebookListResponse, get_notebooks_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/notebooks", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_notebooks_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_notebooks_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_notebooks_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_notebooks_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::NotebookListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_notebooks_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_notebooks_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_notebooks_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_notebooks_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_notebook_summary_by_work_space(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::NotebookListResponse, get_notebook_summary_by_work_space::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/notebooksSummary", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_notebook_summary_by_work_space::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_notebook_summary_by_work_space::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_notebook_summary_by_work_space::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_notebook_summary_by_work_space::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::NotebookListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_notebook_summary_by_work_space::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_notebook_summary_by_work_space::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_notebook_summary_by_work_space::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_notebook_summary_by_work_space {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_notebook(
        operation_config: &crate::OperationConfig,
        notebook_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::NotebookResource, get_notebook::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/notebooks/{}", operation_config.base_path(), notebook_name);
        let mut url = url::Url::parse(url_str).map_err(get_notebook::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_notebook::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_notebook::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_notebook::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::NotebookResource =
                    serde_json::from_slice(rsp_body).map_err(|source| get_notebook::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            http::StatusCode::NOT_MODIFIED => Err(get_notebook::Error::NotModified304 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_notebook::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_notebook::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_notebook {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotModified304 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_notebook(
        operation_config: &crate::OperationConfig,
        notebook_name: &str,
        if_match: Option<&str>,
        notebook: &models::NotebookResource,
    ) -> std::result::Result<create_or_update_notebook::Response, create_or_update_notebook::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/notebooks/{}", operation_config.base_path(), notebook_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_notebook::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_notebook::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(notebook).map_err(create_or_update_notebook::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_notebook::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_notebook::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::NotebookResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_notebook::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_notebook::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_notebook::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_notebook::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_notebook::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_notebook {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::NotebookResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_notebook(
        operation_config: &crate::OperationConfig,
        notebook_name: &str,
    ) -> std::result::Result<delete_notebook::Response, delete_notebook::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/notebooks/{}", operation_config.base_path(), notebook_name);
        let mut url = url::Url::parse(url_str).map_err(delete_notebook::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_notebook::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_notebook::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_notebook::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_notebook::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_notebook::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_notebook::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_notebook::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_notebook::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_notebook {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename_notebook(
        operation_config: &crate::OperationConfig,
        notebook_name: &str,
        request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename_notebook::Response, rename_notebook::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/notebooks/{}/rename", operation_config.base_path(), notebook_name);
        let mut url = url::Url::parse(url_str).map_err(rename_notebook::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename_notebook::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(rename_notebook::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(rename_notebook::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rename_notebook::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename_notebook::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename_notebook::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| rename_notebook::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename_notebook::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename_notebook {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod notebook_operation_result {
    use super::{models, API_VERSION};
    pub async fn get(operation_config: &crate::OperationConfig, operation_id: &str) -> std::result::Result<get::Response, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/notebookOperationResults/{}", operation_config.base_path(), operation_id);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(get::Response::Ok200),
            http::StatusCode::CREATED => Ok(get::Response::Created201),
            http::StatusCode::ACCEPTED => Ok(get::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(get::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Created201,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod pipeline {
    use super::{models, API_VERSION};
    pub async fn get_pipelines_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::PipelineListResponse, get_pipelines_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pipelines", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_pipelines_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_pipelines_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_pipelines_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_pipelines_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PipelineListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_pipelines_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_pipelines_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_pipelines_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_pipelines_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_pipeline(
        operation_config: &crate::OperationConfig,
        pipeline_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::PipelineResource, get_pipeline::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pipelines/{}", operation_config.base_path(), pipeline_name);
        let mut url = url::Url::parse(url_str).map_err(get_pipeline::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_pipeline::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_pipeline::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_pipeline::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PipelineResource =
                    serde_json::from_slice(rsp_body).map_err(|source| get_pipeline::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            http::StatusCode::NOT_MODIFIED => Err(get_pipeline::Error::NotModified304 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_pipeline::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_pipeline::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_pipeline {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotModified304 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_pipeline(
        operation_config: &crate::OperationConfig,
        pipeline_name: &str,
        if_match: Option<&str>,
        pipeline: &models::PipelineResource,
    ) -> std::result::Result<create_or_update_pipeline::Response, create_or_update_pipeline::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pipelines/{}", operation_config.base_path(), pipeline_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_pipeline::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_pipeline::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(pipeline).map_err(create_or_update_pipeline::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_pipeline::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_pipeline::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PipelineResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_pipeline::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_pipeline::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_pipeline::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_pipeline::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_pipeline::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_pipeline {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::PipelineResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_pipeline(
        operation_config: &crate::OperationConfig,
        pipeline_name: &str,
    ) -> std::result::Result<delete_pipeline::Response, delete_pipeline::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pipelines/{}", operation_config.base_path(), pipeline_name);
        let mut url = url::Url::parse(url_str).map_err(delete_pipeline::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_pipeline::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_pipeline::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_pipeline::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_pipeline::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_pipeline::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_pipeline::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_pipeline::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_pipeline::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_pipeline {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename_pipeline(
        operation_config: &crate::OperationConfig,
        pipeline_name: &str,
        request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename_pipeline::Response, rename_pipeline::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pipelines/{}/rename", operation_config.base_path(), pipeline_name);
        let mut url = url::Url::parse(url_str).map_err(rename_pipeline::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename_pipeline::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(rename_pipeline::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(rename_pipeline::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rename_pipeline::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename_pipeline::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename_pipeline::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| rename_pipeline::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename_pipeline::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename_pipeline {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_pipeline_run(
        operation_config: &crate::OperationConfig,
        pipeline_name: &str,
        reference_pipeline_run_id: Option<&str>,
        is_recovery: Option<bool>,
        start_activity_name: Option<&str>,
        parameters: Option<&models::ParameterValueSpecification>,
    ) -> std::result::Result<models::CreateRunResponse, create_pipeline_run::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pipelines/{}/createRun", operation_config.base_path(), pipeline_name);
        let mut url = url::Url::parse(url_str).map_err(create_pipeline_run::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_pipeline_run::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(reference_pipeline_run_id) = reference_pipeline_run_id {
            url.query_pairs_mut()
                .append_pair("referencePipelineRunId", reference_pipeline_run_id);
        }
        if let Some(is_recovery) = is_recovery {
            url.query_pairs_mut().append_pair("isRecovery", is_recovery.to_string().as_str());
        }
        if let Some(start_activity_name) = start_activity_name {
            url.query_pairs_mut().append_pair("startActivityName", start_activity_name);
        }
        let req_body = if let Some(parameters) = parameters {
            req_builder = req_builder.header("content-type", "application/json");
            azure_core::to_json(parameters).map_err(create_pipeline_run::Error::SerializeError)?
        } else {
            bytes::Bytes::from_static(azure_core::EMPTY_BODY)
        };
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_pipeline_run::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_pipeline_run::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => {
                let rsp_body = rsp.body();
                let rsp_value: models::CreateRunResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_pipeline_run::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_pipeline_run::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_pipeline_run::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_pipeline_run {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod pipeline_run {
    use super::{models, API_VERSION};
    pub async fn query_pipeline_runs_by_workspace(
        operation_config: &crate::OperationConfig,
        filter_parameters: &models::RunFilterParameters,
    ) -> std::result::Result<models::PipelineRunsQueryResponse, query_pipeline_runs_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/queryPipelineRuns", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(query_pipeline_runs_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(query_pipeline_runs_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(filter_parameters).map_err(query_pipeline_runs_by_workspace::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(query_pipeline_runs_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(query_pipeline_runs_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PipelineRunsQueryResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_pipeline_runs_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_pipeline_runs_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(query_pipeline_runs_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod query_pipeline_runs_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_pipeline_run(
        operation_config: &crate::OperationConfig,
        run_id: &str,
    ) -> std::result::Result<models::PipelineRun, get_pipeline_run::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pipelineruns/{}", operation_config.base_path(), run_id);
        let mut url = url::Url::parse(url_str).map_err(get_pipeline_run::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_pipeline_run::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_pipeline_run::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_pipeline_run::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PipelineRun = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_pipeline_run::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_pipeline_run::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_pipeline_run::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_pipeline_run {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn query_activity_runs(
        operation_config: &crate::OperationConfig,
        pipeline_name: &str,
        run_id: &str,
        filter_parameters: &models::RunFilterParameters,
    ) -> std::result::Result<models::ActivityRunsQueryResponse, query_activity_runs::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pipelines/{}/pipelineruns/{}/queryActivityruns",
            operation_config.base_path(),
            pipeline_name,
            run_id
        );
        let mut url = url::Url::parse(url_str).map_err(query_activity_runs::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(query_activity_runs::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(filter_parameters).map_err(query_activity_runs::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(query_activity_runs::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(query_activity_runs::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ActivityRunsQueryResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(query_activity_runs::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod query_activity_runs {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn cancel_pipeline_run(
        operation_config: &crate::OperationConfig,
        run_id: &str,
        is_recursive: Option<bool>,
    ) -> std::result::Result<(), cancel_pipeline_run::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/pipelineruns/{}/cancel", operation_config.base_path(), run_id);
        let mut url = url::Url::parse(url_str).map_err(cancel_pipeline_run::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(cancel_pipeline_run::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(is_recursive) = is_recursive {
            url.query_pairs_mut().append_pair("isRecursive", is_recursive.to_string().as_str());
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(cancel_pipeline_run::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(cancel_pipeline_run::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| cancel_pipeline_run::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(cancel_pipeline_run::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod cancel_pipeline_run {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod spark_job_definition {
    use super::{models, API_VERSION};
    pub async fn get_spark_job_definitions_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::SparkJobDefinitionsListResponse, get_spark_job_definitions_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sparkJobDefinitions", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_spark_job_definitions_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_spark_job_definitions_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_spark_job_definitions_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_spark_job_definitions_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkJobDefinitionsListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_spark_job_definitions_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_spark_job_definitions_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_spark_job_definitions_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_spark_job_definitions_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_spark_job_definition(
        operation_config: &crate::OperationConfig,
        spark_job_definition_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::SparkJobDefinitionResource, get_spark_job_definition::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sparkJobDefinitions/{}", operation_config.base_path(), spark_job_definition_name);
        let mut url = url::Url::parse(url_str).map_err(get_spark_job_definition::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_spark_job_definition::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_spark_job_definition::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_spark_job_definition::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkJobDefinitionResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            http::StatusCode::NOT_MODIFIED => Err(get_spark_job_definition::Error::NotModified304 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_spark_job_definition::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_spark_job_definition {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotModified304 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_spark_job_definition(
        operation_config: &crate::OperationConfig,
        spark_job_definition_name: &str,
        if_match: Option<&str>,
        spark_job_definition: &models::SparkJobDefinitionResource,
    ) -> std::result::Result<create_or_update_spark_job_definition::Response, create_or_update_spark_job_definition::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sparkJobDefinitions/{}", operation_config.base_path(), spark_job_definition_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_spark_job_definition::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_spark_job_definition::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(spark_job_definition).map_err(create_or_update_spark_job_definition::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_spark_job_definition::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_spark_job_definition::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkJobDefinitionResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_spark_job_definition::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_spark_job_definition::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_spark_job_definition::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_spark_job_definition {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::SparkJobDefinitionResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_spark_job_definition(
        operation_config: &crate::OperationConfig,
        spark_job_definition_name: &str,
    ) -> std::result::Result<delete_spark_job_definition::Response, delete_spark_job_definition::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sparkJobDefinitions/{}", operation_config.base_path(), spark_job_definition_name);
        let mut url = url::Url::parse(url_str).map_err(delete_spark_job_definition::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_spark_job_definition::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(delete_spark_job_definition::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_spark_job_definition::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_spark_job_definition::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_spark_job_definition::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_spark_job_definition::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_spark_job_definition::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_spark_job_definition {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn execute_spark_job_definition(
        operation_config: &crate::OperationConfig,
        spark_job_definition_name: &str,
    ) -> std::result::Result<execute_spark_job_definition::Response, execute_spark_job_definition::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/sparkJobDefinitions/{}/execute",
            operation_config.base_path(),
            spark_job_definition_name
        );
        let mut url = url::Url::parse(url_str).map_err(execute_spark_job_definition::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(execute_spark_job_definition::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(execute_spark_job_definition::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(execute_spark_job_definition::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkBatchJob = serde_json::from_slice(rsp_body)
                    .map_err(|source| execute_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(execute_spark_job_definition::Response::Accepted202(rsp_value))
            }
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkBatchJob = serde_json::from_slice(rsp_body)
                    .map_err(|source| execute_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(execute_spark_job_definition::Response::Ok200(rsp_value))
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| execute_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(execute_spark_job_definition::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod execute_spark_job_definition {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Accepted202(models::SparkBatchJob),
            Ok200(models::SparkBatchJob),
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename_spark_job_definition(
        operation_config: &crate::OperationConfig,
        spark_job_definition_name: &str,
        request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename_spark_job_definition::Response, rename_spark_job_definition::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/sparkJobDefinitions/{}/rename",
            operation_config.base_path(),
            spark_job_definition_name
        );
        let mut url = url::Url::parse(url_str).map_err(rename_spark_job_definition::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename_spark_job_definition::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(rename_spark_job_definition::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(rename_spark_job_definition::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rename_spark_job_definition::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename_spark_job_definition::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename_spark_job_definition::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| rename_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename_spark_job_definition::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename_spark_job_definition {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn debug_spark_job_definition(
        operation_config: &crate::OperationConfig,
        spark_job_definition_azure_resource: &models::SparkJobDefinitionResource,
    ) -> std::result::Result<debug_spark_job_definition::Response, debug_spark_job_definition::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/debugSparkJobDefinition", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(debug_spark_job_definition::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(debug_spark_job_definition::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body =
            azure_core::to_json(spark_job_definition_azure_resource).map_err(debug_spark_job_definition::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(debug_spark_job_definition::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(debug_spark_job_definition::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::ACCEPTED => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkBatchJob = serde_json::from_slice(rsp_body)
                    .map_err(|source| debug_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(debug_spark_job_definition::Response::Accepted202(rsp_value))
            }
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SparkBatchJob = serde_json::from_slice(rsp_body)
                    .map_err(|source| debug_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(debug_spark_job_definition::Response::Ok200(rsp_value))
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| debug_spark_job_definition::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(debug_spark_job_definition::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod debug_spark_job_definition {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Accepted202(models::SparkBatchJob),
            Ok200(models::SparkBatchJob),
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod sql_pools {
    use super::{models, API_VERSION};
    pub async fn list(operation_config: &crate::OperationConfig) -> std::result::Result<models::SqlPoolInfoListResult, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sqlPools", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SqlPoolInfoListResult =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get(operation_config: &crate::OperationConfig, sql_pool_name: &str) -> std::result::Result<models::SqlPool, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sqlPools/{}", operation_config.base_path(), sql_pool_name);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SqlPool =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod sql_script {
    use super::{models, API_VERSION};
    pub async fn get_sql_scripts_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::SqlScriptsListResponse, get_sql_scripts_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sqlScripts", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_sql_scripts_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_sql_scripts_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_sql_scripts_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_sql_scripts_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SqlScriptsListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_sql_scripts_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_sql_scripts_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_sql_scripts_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_sql_scripts_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_sql_script(
        operation_config: &crate::OperationConfig,
        sql_script_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::SqlScriptResource, get_sql_script::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sqlScripts/{}", operation_config.base_path(), sql_script_name);
        let mut url = url::Url::parse(url_str).map_err(get_sql_script::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_sql_script::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_sql_script::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_sql_script::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SqlScriptResource =
                    serde_json::from_slice(rsp_body).map_err(|source| get_sql_script::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            http::StatusCode::NOT_MODIFIED => Err(get_sql_script::Error::NotModified304 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_sql_script::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_sql_script::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_sql_script {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotModified304 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_sql_script(
        operation_config: &crate::OperationConfig,
        sql_script_name: &str,
        if_match: Option<&str>,
        sql_script: &models::SqlScriptResource,
    ) -> std::result::Result<create_or_update_sql_script::Response, create_or_update_sql_script::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sqlScripts/{}", operation_config.base_path(), sql_script_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_sql_script::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_sql_script::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(sql_script).map_err(create_or_update_sql_script::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_sql_script::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_sql_script::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SqlScriptResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_sql_script::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_sql_script::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_sql_script::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_sql_script::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_sql_script::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_sql_script {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::SqlScriptResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_sql_script(
        operation_config: &crate::OperationConfig,
        sql_script_name: &str,
    ) -> std::result::Result<delete_sql_script::Response, delete_sql_script::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sqlScripts/{}", operation_config.base_path(), sql_script_name);
        let mut url = url::Url::parse(url_str).map_err(delete_sql_script::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_sql_script::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_sql_script::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_sql_script::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_sql_script::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_sql_script::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_sql_script::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| delete_sql_script::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_sql_script::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_sql_script {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn rename_sql_script(
        operation_config: &crate::OperationConfig,
        sql_script_name: &str,
        request: &models::ArtifactRenameRequest,
    ) -> std::result::Result<rename_sql_script::Response, rename_sql_script::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/sqlScripts/{}/rename", operation_config.base_path(), sql_script_name);
        let mut url = url::Url::parse(url_str).map_err(rename_sql_script::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rename_sql_script::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(request).map_err(rename_sql_script::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(rename_sql_script::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rename_sql_script::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(rename_sql_script::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(rename_sql_script::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| rename_sql_script::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rename_sql_script::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rename_sql_script {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod trigger {
    use super::{models, API_VERSION};
    pub async fn get_triggers_by_workspace(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::TriggerListResponse, get_triggers_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/triggers", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get_triggers_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_triggers_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_triggers_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_triggers_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TriggerListResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_triggers_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_triggers_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_triggers_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_triggers_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_trigger(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
        if_none_match: Option<&str>,
    ) -> std::result::Result<models::TriggerResource, get_trigger::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/triggers/{}", operation_config.base_path(), trigger_name);
        let mut url = url::Url::parse(url_str).map_err(get_trigger::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_trigger::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_none_match) = if_none_match {
            req_builder = req_builder.header("If-None-Match", if_none_match);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_trigger::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_trigger::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TriggerResource =
                    serde_json::from_slice(rsp_body).map_err(|source| get_trigger::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            http::StatusCode::NOT_MODIFIED => Err(get_trigger::Error::NotModified304 {}),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| get_trigger::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_trigger::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_trigger {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("Error response #response_type")]
            NotModified304 {},
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update_trigger(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
        if_match: Option<&str>,
        trigger: &models::TriggerResource,
    ) -> std::result::Result<create_or_update_trigger::Response, create_or_update_trigger::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/triggers/{}", operation_config.base_path(), trigger_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update_trigger::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update_trigger::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(if_match) = if_match {
            req_builder = req_builder.header("If-Match", if_match);
        }
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(trigger).map_err(create_or_update_trigger::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(create_or_update_trigger::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update_trigger::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TriggerResource = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_trigger::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update_trigger::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update_trigger::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update_trigger::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update_trigger::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update_trigger {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::TriggerResource),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete_trigger(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
    ) -> std::result::Result<delete_trigger::Response, delete_trigger::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/triggers/{}", operation_config.base_path(), trigger_name);
        let mut url = url::Url::parse(url_str).map_err(delete_trigger::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete_trigger::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete_trigger::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(delete_trigger::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete_trigger::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete_trigger::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete_trigger::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete_trigger::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete_trigger::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete_trigger {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn subscribe_trigger_to_events(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
    ) -> std::result::Result<subscribe_trigger_to_events::Response, subscribe_trigger_to_events::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/triggers/{}/subscribeToEvents", operation_config.base_path(), trigger_name);
        let mut url = url::Url::parse(url_str).map_err(subscribe_trigger_to_events::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(subscribe_trigger_to_events::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(subscribe_trigger_to_events::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(subscribe_trigger_to_events::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TriggerSubscriptionOperationStatus = serde_json::from_slice(rsp_body)
                    .map_err(|source| subscribe_trigger_to_events::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(subscribe_trigger_to_events::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(subscribe_trigger_to_events::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| subscribe_trigger_to_events::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(subscribe_trigger_to_events::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod subscribe_trigger_to_events {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::TriggerSubscriptionOperationStatus),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_event_subscription_status(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
    ) -> std::result::Result<models::TriggerSubscriptionOperationStatus, get_event_subscription_status::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/triggers/{}/getEventSubscriptionStatus",
            operation_config.base_path(),
            trigger_name
        );
        let mut url = url::Url::parse(url_str).map_err(get_event_subscription_status::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_event_subscription_status::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(get_event_subscription_status::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_event_subscription_status::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TriggerSubscriptionOperationStatus = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_event_subscription_status::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_event_subscription_status::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_event_subscription_status::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_event_subscription_status {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn unsubscribe_trigger_from_events(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
    ) -> std::result::Result<unsubscribe_trigger_from_events::Response, unsubscribe_trigger_from_events::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/triggers/{}/unsubscribeFromEvents", operation_config.base_path(), trigger_name);
        let mut url = url::Url::parse(url_str).map_err(unsubscribe_trigger_from_events::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(unsubscribe_trigger_from_events::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(unsubscribe_trigger_from_events::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(unsubscribe_trigger_from_events::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TriggerSubscriptionOperationStatus = serde_json::from_slice(rsp_body)
                    .map_err(|source| unsubscribe_trigger_from_events::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(unsubscribe_trigger_from_events::Response::Ok200(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(unsubscribe_trigger_from_events::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| unsubscribe_trigger_from_events::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(unsubscribe_trigger_from_events::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod unsubscribe_trigger_from_events {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::TriggerSubscriptionOperationStatus),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn start_trigger(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
    ) -> std::result::Result<(), start_trigger::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/triggers/{}/start", operation_config.base_path(), trigger_name);
        let mut url = url::Url::parse(url_str).map_err(start_trigger::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(start_trigger::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(start_trigger::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(start_trigger::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| start_trigger::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(start_trigger::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod start_trigger {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn stop_trigger(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
    ) -> std::result::Result<(), stop_trigger::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/triggers/{}/stop", operation_config.base_path(), trigger_name);
        let mut url = url::Url::parse(url_str).map_err(stop_trigger::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(stop_trigger::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(stop_trigger::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(stop_trigger::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| stop_trigger::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(stop_trigger::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod stop_trigger {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod trigger_run {
    use super::{models, API_VERSION};
    pub async fn rerun_trigger_instance(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
        run_id: &str,
    ) -> std::result::Result<(), rerun_trigger_instance::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/triggers/{}/triggerRuns/{}/rerun",
            operation_config.base_path(),
            trigger_name,
            run_id
        );
        let mut url = url::Url::parse(url_str).map_err(rerun_trigger_instance::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(rerun_trigger_instance::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(rerun_trigger_instance::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(rerun_trigger_instance::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| rerun_trigger_instance::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(rerun_trigger_instance::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod rerun_trigger_instance {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn cancel_trigger_instance(
        operation_config: &crate::OperationConfig,
        trigger_name: &str,
        run_id: &str,
    ) -> std::result::Result<(), cancel_trigger_instance::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/triggers/{}/triggerRuns/{}/cancel",
            operation_config.base_path(),
            trigger_name,
            run_id
        );
        let mut url = url::Url::parse(url_str).map_err(cancel_trigger_instance::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(cancel_trigger_instance::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(cancel_trigger_instance::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(cancel_trigger_instance::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(()),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| cancel_trigger_instance::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(cancel_trigger_instance::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod cancel_trigger_instance {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn query_trigger_runs_by_workspace(
        operation_config: &crate::OperationConfig,
        filter_parameters: &models::RunFilterParameters,
    ) -> std::result::Result<models::TriggerRunsQueryResponse, query_trigger_runs_by_workspace::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/queryTriggerRuns", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(query_trigger_runs_by_workspace::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(query_trigger_runs_by_workspace::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(filter_parameters).map_err(query_trigger_runs_by_workspace::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder
            .body(req_body)
            .map_err(query_trigger_runs_by_workspace::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(query_trigger_runs_by_workspace::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::TriggerRunsQueryResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_trigger_runs_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_trigger_runs_by_workspace::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(query_trigger_runs_by_workspace::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod query_trigger_runs_by_workspace {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::CloudError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod workspace {
    use super::{models, API_VERSION};
    pub async fn get(operation_config: &crate::OperationConfig) -> std::result::Result<models::Workspace, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/workspace", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::Workspace =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorContract =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::ErrorContract,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
