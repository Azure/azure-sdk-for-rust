#![doc = "generated by AutoRust 0.1.0"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
use super::{models, API_VERSION};
#[non_exhaustive]
#[derive(Debug, thiserror :: Error)]
#[allow(non_camel_case_types)]
pub enum Error {
    #[error(transparent)]
    GetClusterManifest(#[from] get_cluster_manifest::Error),
    #[error(transparent)]
    GetClusterHealth(#[from] get_cluster_health::Error),
    #[error(transparent)]
    GetClusterHealthUsingPolicy(#[from] get_cluster_health_using_policy::Error),
    #[error(transparent)]
    GetClusterHealthChunk(#[from] get_cluster_health_chunk::Error),
    #[error(transparent)]
    GetClusterHealthChunkUsingPolicyAndAdvancedFilters(#[from] get_cluster_health_chunk_using_policy_and_advanced_filters::Error),
    #[error(transparent)]
    ReportClusterHealth(#[from] report_cluster_health::Error),
    #[error(transparent)]
    GetProvisionedFabricCodeVersionInfoList(#[from] get_provisioned_fabric_code_version_info_list::Error),
    #[error(transparent)]
    GetProvisionedFabricConfigVersionInfoList(#[from] get_provisioned_fabric_config_version_info_list::Error),
    #[error(transparent)]
    GetClusterUpgradeProgress(#[from] get_cluster_upgrade_progress::Error),
    #[error(transparent)]
    GetClusterConfiguration(#[from] get_cluster_configuration::Error),
    #[error(transparent)]
    GetClusterConfigurationUpgradeStatus(#[from] get_cluster_configuration_upgrade_status::Error),
    #[error(transparent)]
    GetUpgradeOrchestrationServiceState(#[from] get_upgrade_orchestration_service_state::Error),
    #[error(transparent)]
    SetUpgradeOrchestrationServiceState(#[from] set_upgrade_orchestration_service_state::Error),
    #[error(transparent)]
    ProvisionCluster(#[from] provision_cluster::Error),
    #[error(transparent)]
    UnprovisionCluster(#[from] unprovision_cluster::Error),
    #[error(transparent)]
    RollbackClusterUpgrade(#[from] rollback_cluster_upgrade::Error),
    #[error(transparent)]
    ResumeClusterUpgrade(#[from] resume_cluster_upgrade::Error),
    #[error(transparent)]
    StartClusterUpgrade(#[from] start_cluster_upgrade::Error),
    #[error(transparent)]
    StartClusterConfigurationUpgrade(#[from] start_cluster_configuration_upgrade::Error),
    #[error(transparent)]
    UpdateClusterUpgrade(#[from] update_cluster_upgrade::Error),
    #[error(transparent)]
    GetAadMetadata(#[from] get_aad_metadata::Error),
    #[error(transparent)]
    GetClusterVersion(#[from] get_cluster_version::Error),
    #[error(transparent)]
    GetClusterLoad(#[from] get_cluster_load::Error),
    #[error(transparent)]
    ToggleVerboseServicePlacementHealthReporting(#[from] toggle_verbose_service_placement_health_reporting::Error),
    #[error(transparent)]
    GetNodeInfoList(#[from] get_node_info_list::Error),
    #[error(transparent)]
    GetNodeInfo(#[from] get_node_info::Error),
    #[error(transparent)]
    GetNodeHealth(#[from] get_node_health::Error),
    #[error(transparent)]
    GetNodeHealthUsingPolicy(#[from] get_node_health_using_policy::Error),
    #[error(transparent)]
    ReportNodeHealth(#[from] report_node_health::Error),
    #[error(transparent)]
    GetNodeLoadInfo(#[from] get_node_load_info::Error),
    #[error(transparent)]
    DisableNode(#[from] disable_node::Error),
    #[error(transparent)]
    EnableNode(#[from] enable_node::Error),
    #[error(transparent)]
    RemoveNodeState(#[from] remove_node_state::Error),
    #[error(transparent)]
    RestartNode(#[from] restart_node::Error),
    #[error(transparent)]
    RemoveConfigurationOverrides(#[from] remove_configuration_overrides::Error),
    #[error(transparent)]
    GetConfigurationOverrides(#[from] get_configuration_overrides::Error),
    #[error(transparent)]
    AddConfigurationParameterOverrides(#[from] add_configuration_parameter_overrides::Error),
    #[error(transparent)]
    RemoveNodeTags(#[from] remove_node_tags::Error),
    #[error(transparent)]
    AddNodeTags(#[from] add_node_tags::Error),
    #[error(transparent)]
    GetApplicationTypeInfoList(#[from] get_application_type_info_list::Error),
    #[error(transparent)]
    GetApplicationTypeInfoListByName(#[from] get_application_type_info_list_by_name::Error),
    #[error(transparent)]
    ProvisionApplicationType(#[from] provision_application_type::Error),
    #[error(transparent)]
    UnprovisionApplicationType(#[from] unprovision_application_type::Error),
    #[error(transparent)]
    GetServiceTypeInfoList(#[from] get_service_type_info_list::Error),
    #[error(transparent)]
    GetServiceTypeInfoByName(#[from] get_service_type_info_by_name::Error),
    #[error(transparent)]
    GetServiceManifest(#[from] get_service_manifest::Error),
    #[error(transparent)]
    GetDeployedServiceTypeInfoList(#[from] get_deployed_service_type_info_list::Error),
    #[error(transparent)]
    GetDeployedServiceTypeInfoByName(#[from] get_deployed_service_type_info_by_name::Error),
    #[error(transparent)]
    CreateApplication(#[from] create_application::Error),
    #[error(transparent)]
    DeleteApplication(#[from] delete_application::Error),
    #[error(transparent)]
    GetApplicationLoadInfo(#[from] get_application_load_info::Error),
    #[error(transparent)]
    GetApplicationInfoList(#[from] get_application_info_list::Error),
    #[error(transparent)]
    GetApplicationInfo(#[from] get_application_info::Error),
    #[error(transparent)]
    GetApplicationHealth(#[from] get_application_health::Error),
    #[error(transparent)]
    GetApplicationHealthUsingPolicy(#[from] get_application_health_using_policy::Error),
    #[error(transparent)]
    ReportApplicationHealth(#[from] report_application_health::Error),
    #[error(transparent)]
    StartApplicationUpgrade(#[from] start_application_upgrade::Error),
    #[error(transparent)]
    GetApplicationUpgrade(#[from] get_application_upgrade::Error),
    #[error(transparent)]
    UpdateApplicationUpgrade(#[from] update_application_upgrade::Error),
    #[error(transparent)]
    UpdateApplication(#[from] update_application::Error),
    #[error(transparent)]
    ResumeApplicationUpgrade(#[from] resume_application_upgrade::Error),
    #[error(transparent)]
    RollbackApplicationUpgrade(#[from] rollback_application_upgrade::Error),
    #[error(transparent)]
    GetDeployedApplicationInfoList(#[from] get_deployed_application_info_list::Error),
    #[error(transparent)]
    GetDeployedApplicationInfo(#[from] get_deployed_application_info::Error),
    #[error(transparent)]
    GetDeployedApplicationHealth(#[from] get_deployed_application_health::Error),
    #[error(transparent)]
    GetDeployedApplicationHealthUsingPolicy(#[from] get_deployed_application_health_using_policy::Error),
    #[error(transparent)]
    ReportDeployedApplicationHealth(#[from] report_deployed_application_health::Error),
    #[error(transparent)]
    GetApplicationManifest(#[from] get_application_manifest::Error),
    #[error(transparent)]
    GetServiceInfoList(#[from] get_service_info_list::Error),
    #[error(transparent)]
    GetServiceInfo(#[from] get_service_info::Error),
    #[error(transparent)]
    GetApplicationNameInfo(#[from] get_application_name_info::Error),
    #[error(transparent)]
    CreateService(#[from] create_service::Error),
    #[error(transparent)]
    CreateServiceFromTemplate(#[from] create_service_from_template::Error),
    #[error(transparent)]
    DeleteService(#[from] delete_service::Error),
    #[error(transparent)]
    UpdateService(#[from] update_service::Error),
    #[error(transparent)]
    GetServiceDescription(#[from] get_service_description::Error),
    #[error(transparent)]
    GetServiceHealth(#[from] get_service_health::Error),
    #[error(transparent)]
    GetServiceHealthUsingPolicy(#[from] get_service_health_using_policy::Error),
    #[error(transparent)]
    ReportServiceHealth(#[from] report_service_health::Error),
    #[error(transparent)]
    ResolveService(#[from] resolve_service::Error),
    #[error(transparent)]
    GetUnplacedReplicaInformation(#[from] get_unplaced_replica_information::Error),
    #[error(transparent)]
    GetLoadedPartitionInfoList(#[from] get_loaded_partition_info_list::Error),
    #[error(transparent)]
    GetPartitionInfoList(#[from] get_partition_info_list::Error),
    #[error(transparent)]
    GetPartitionInfo(#[from] get_partition_info::Error),
    #[error(transparent)]
    GetServiceNameInfo(#[from] get_service_name_info::Error),
    #[error(transparent)]
    GetPartitionHealth(#[from] get_partition_health::Error),
    #[error(transparent)]
    GetPartitionHealthUsingPolicy(#[from] get_partition_health_using_policy::Error),
    #[error(transparent)]
    ReportPartitionHealth(#[from] report_partition_health::Error),
    #[error(transparent)]
    GetPartitionLoadInformation(#[from] get_partition_load_information::Error),
    #[error(transparent)]
    ResetPartitionLoad(#[from] reset_partition_load::Error),
    #[error(transparent)]
    RecoverPartition(#[from] recover_partition::Error),
    #[error(transparent)]
    RecoverServicePartitions(#[from] recover_service_partitions::Error),
    #[error(transparent)]
    RecoverSystemPartitions(#[from] recover_system_partitions::Error),
    #[error(transparent)]
    RecoverAllPartitions(#[from] recover_all_partitions::Error),
    #[error(transparent)]
    MovePrimaryReplica(#[from] move_primary_replica::Error),
    #[error(transparent)]
    MoveSecondaryReplica(#[from] move_secondary_replica::Error),
    #[error(transparent)]
    UpdatePartitionLoad(#[from] update_partition_load::Error),
    #[error(transparent)]
    MoveInstance(#[from] move_instance::Error),
    #[error(transparent)]
    MoveAuxiliaryReplica(#[from] move_auxiliary_replica::Error),
    #[error(transparent)]
    CreateRepairTask(#[from] create_repair_task::Error),
    #[error(transparent)]
    CancelRepairTask(#[from] cancel_repair_task::Error),
    #[error(transparent)]
    DeleteRepairTask(#[from] delete_repair_task::Error),
    #[error(transparent)]
    GetRepairTaskList(#[from] get_repair_task_list::Error),
    #[error(transparent)]
    ForceApproveRepairTask(#[from] force_approve_repair_task::Error),
    #[error(transparent)]
    UpdateRepairTaskHealthPolicy(#[from] update_repair_task_health_policy::Error),
    #[error(transparent)]
    UpdateRepairExecutionState(#[from] update_repair_execution_state::Error),
    #[error(transparent)]
    GetReplicaInfoList(#[from] get_replica_info_list::Error),
    #[error(transparent)]
    GetReplicaInfo(#[from] get_replica_info::Error),
    #[error(transparent)]
    GetReplicaHealth(#[from] get_replica_health::Error),
    #[error(transparent)]
    GetReplicaHealthUsingPolicy(#[from] get_replica_health_using_policy::Error),
    #[error(transparent)]
    ReportReplicaHealth(#[from] report_replica_health::Error),
    #[error(transparent)]
    GetDeployedServiceReplicaInfoList(#[from] get_deployed_service_replica_info_list::Error),
    #[error(transparent)]
    GetDeployedServiceReplicaDetailInfo(#[from] get_deployed_service_replica_detail_info::Error),
    #[error(transparent)]
    GetDeployedServiceReplicaDetailInfoByPartitionId(#[from] get_deployed_service_replica_detail_info_by_partition_id::Error),
    #[error(transparent)]
    RestartReplica(#[from] restart_replica::Error),
    #[error(transparent)]
    RemoveReplica(#[from] remove_replica::Error),
    #[error(transparent)]
    GetDeployedServicePackageInfoList(#[from] get_deployed_service_package_info_list::Error),
    #[error(transparent)]
    GetDeployedServicePackageInfoListByName(#[from] get_deployed_service_package_info_list_by_name::Error),
    #[error(transparent)]
    GetDeployedServicePackageHealth(#[from] get_deployed_service_package_health::Error),
    #[error(transparent)]
    GetDeployedServicePackageHealthUsingPolicy(#[from] get_deployed_service_package_health_using_policy::Error),
    #[error(transparent)]
    ReportDeployedServicePackageHealth(#[from] report_deployed_service_package_health::Error),
    #[error(transparent)]
    DeployServicePackageToNode(#[from] deploy_service_package_to_node::Error),
    #[error(transparent)]
    GetDeployedCodePackageInfoList(#[from] get_deployed_code_package_info_list::Error),
    #[error(transparent)]
    RestartDeployedCodePackage(#[from] restart_deployed_code_package::Error),
    #[error(transparent)]
    GetContainerLogsDeployedOnNode(#[from] get_container_logs_deployed_on_node::Error),
    #[error(transparent)]
    InvokeContainerApi(#[from] invoke_container_api::Error),
    #[error(transparent)]
    CreateComposeDeployment(#[from] create_compose_deployment::Error),
    #[error(transparent)]
    GetComposeDeploymentStatus(#[from] get_compose_deployment_status::Error),
    #[error(transparent)]
    GetComposeDeploymentStatusList(#[from] get_compose_deployment_status_list::Error),
    #[error(transparent)]
    GetComposeDeploymentUpgradeProgress(#[from] get_compose_deployment_upgrade_progress::Error),
    #[error(transparent)]
    RemoveComposeDeployment(#[from] remove_compose_deployment::Error),
    #[error(transparent)]
    StartComposeDeploymentUpgrade(#[from] start_compose_deployment_upgrade::Error),
    #[error(transparent)]
    StartRollbackComposeDeploymentUpgrade(#[from] start_rollback_compose_deployment_upgrade::Error),
    #[error(transparent)]
    GetChaos(#[from] get_chaos::Error),
    #[error(transparent)]
    StartChaos(#[from] start_chaos::Error),
    #[error(transparent)]
    StopChaos(#[from] stop_chaos::Error),
    #[error(transparent)]
    GetChaosEvents(#[from] get_chaos_events::Error),
    #[error(transparent)]
    GetChaosSchedule(#[from] get_chaos_schedule::Error),
    #[error(transparent)]
    PostChaosSchedule(#[from] post_chaos_schedule::Error),
    #[error(transparent)]
    GetImageStoreContent(#[from] get_image_store_content::Error),
    #[error(transparent)]
    UploadFile(#[from] upload_file::Error),
    #[error(transparent)]
    DeleteImageStoreContent(#[from] delete_image_store_content::Error),
    #[error(transparent)]
    GetImageStoreRootContent(#[from] get_image_store_root_content::Error),
    #[error(transparent)]
    CopyImageStoreContent(#[from] copy_image_store_content::Error),
    #[error(transparent)]
    DeleteImageStoreUploadSession(#[from] delete_image_store_upload_session::Error),
    #[error(transparent)]
    CommitImageStoreUploadSession(#[from] commit_image_store_upload_session::Error),
    #[error(transparent)]
    GetImageStoreUploadSessionById(#[from] get_image_store_upload_session_by_id::Error),
    #[error(transparent)]
    GetImageStoreUploadSessionByPath(#[from] get_image_store_upload_session_by_path::Error),
    #[error(transparent)]
    UploadFileChunk(#[from] upload_file_chunk::Error),
    #[error(transparent)]
    GetImageStoreRootFolderSize(#[from] get_image_store_root_folder_size::Error),
    #[error(transparent)]
    GetImageStoreFolderSize(#[from] get_image_store_folder_size::Error),
    #[error(transparent)]
    GetImageStoreInfo(#[from] get_image_store_info::Error),
    #[error(transparent)]
    InvokeInfrastructureCommand(#[from] invoke_infrastructure_command::Error),
    #[error(transparent)]
    InvokeInfrastructureQuery(#[from] invoke_infrastructure_query::Error),
    #[error(transparent)]
    StartDataLoss(#[from] start_data_loss::Error),
    #[error(transparent)]
    GetDataLossProgress(#[from] get_data_loss_progress::Error),
    #[error(transparent)]
    StartQuorumLoss(#[from] start_quorum_loss::Error),
    #[error(transparent)]
    GetQuorumLossProgress(#[from] get_quorum_loss_progress::Error),
    #[error(transparent)]
    StartPartitionRestart(#[from] start_partition_restart::Error),
    #[error(transparent)]
    GetPartitionRestartProgress(#[from] get_partition_restart_progress::Error),
    #[error(transparent)]
    StartNodeTransition(#[from] start_node_transition::Error),
    #[error(transparent)]
    GetNodeTransitionProgress(#[from] get_node_transition_progress::Error),
    #[error(transparent)]
    GetFaultOperationList(#[from] get_fault_operation_list::Error),
    #[error(transparent)]
    CancelOperation(#[from] cancel_operation::Error),
    #[error(transparent)]
    CreateBackupPolicy(#[from] create_backup_policy::Error),
    #[error(transparent)]
    DeleteBackupPolicy(#[from] delete_backup_policy::Error),
    #[error(transparent)]
    GetBackupPolicyList(#[from] get_backup_policy_list::Error),
    #[error(transparent)]
    GetBackupPolicyByName(#[from] get_backup_policy_by_name::Error),
    #[error(transparent)]
    GetAllEntitiesBackedUpByPolicy(#[from] get_all_entities_backed_up_by_policy::Error),
    #[error(transparent)]
    UpdateBackupPolicy(#[from] update_backup_policy::Error),
    #[error(transparent)]
    EnableApplicationBackup(#[from] enable_application_backup::Error),
    #[error(transparent)]
    DisableApplicationBackup(#[from] disable_application_backup::Error),
    #[error(transparent)]
    GetApplicationBackupConfigurationInfo(#[from] get_application_backup_configuration_info::Error),
    #[error(transparent)]
    GetApplicationBackupList(#[from] get_application_backup_list::Error),
    #[error(transparent)]
    SuspendApplicationBackup(#[from] suspend_application_backup::Error),
    #[error(transparent)]
    ResumeApplicationBackup(#[from] resume_application_backup::Error),
    #[error(transparent)]
    EnableServiceBackup(#[from] enable_service_backup::Error),
    #[error(transparent)]
    DisableServiceBackup(#[from] disable_service_backup::Error),
    #[error(transparent)]
    GetServiceBackupConfigurationInfo(#[from] get_service_backup_configuration_info::Error),
    #[error(transparent)]
    GetServiceBackupList(#[from] get_service_backup_list::Error),
    #[error(transparent)]
    SuspendServiceBackup(#[from] suspend_service_backup::Error),
    #[error(transparent)]
    ResumeServiceBackup(#[from] resume_service_backup::Error),
    #[error(transparent)]
    EnablePartitionBackup(#[from] enable_partition_backup::Error),
    #[error(transparent)]
    DisablePartitionBackup(#[from] disable_partition_backup::Error),
    #[error(transparent)]
    GetPartitionBackupConfigurationInfo(#[from] get_partition_backup_configuration_info::Error),
    #[error(transparent)]
    GetPartitionBackupList(#[from] get_partition_backup_list::Error),
    #[error(transparent)]
    SuspendPartitionBackup(#[from] suspend_partition_backup::Error),
    #[error(transparent)]
    ResumePartitionBackup(#[from] resume_partition_backup::Error),
    #[error(transparent)]
    BackupPartition(#[from] backup_partition::Error),
    #[error(transparent)]
    GetPartitionBackupProgress(#[from] get_partition_backup_progress::Error),
    #[error(transparent)]
    RestorePartition(#[from] restore_partition::Error),
    #[error(transparent)]
    GetPartitionRestoreProgress(#[from] get_partition_restore_progress::Error),
    #[error(transparent)]
    GetBackupsFromBackupLocation(#[from] get_backups_from_backup_location::Error),
    #[error(transparent)]
    CreateName(#[from] create_name::Error),
    #[error(transparent)]
    GetNameExistsInfo(#[from] get_name_exists_info::Error),
    #[error(transparent)]
    DeleteName(#[from] delete_name::Error),
    #[error(transparent)]
    GetSubNameInfoList(#[from] get_sub_name_info_list::Error),
    #[error(transparent)]
    GetPropertyInfoList(#[from] get_property_info_list::Error),
    #[error(transparent)]
    GetPropertyInfo(#[from] get_property_info::Error),
    #[error(transparent)]
    PutProperty(#[from] put_property::Error),
    #[error(transparent)]
    DeleteProperty(#[from] delete_property::Error),
    #[error(transparent)]
    SubmitPropertyBatch(#[from] submit_property_batch::Error),
    #[error(transparent)]
    GetClusterEventList(#[from] get_cluster_event_list::Error),
    #[error(transparent)]
    GetContainersEventList(#[from] get_containers_event_list::Error),
    #[error(transparent)]
    GetNodeEventList(#[from] get_node_event_list::Error),
    #[error(transparent)]
    GetNodesEventList(#[from] get_nodes_event_list::Error),
    #[error(transparent)]
    GetApplicationEventList(#[from] get_application_event_list::Error),
    #[error(transparent)]
    GetApplicationsEventList(#[from] get_applications_event_list::Error),
    #[error(transparent)]
    GetServiceEventList(#[from] get_service_event_list::Error),
    #[error(transparent)]
    GetServicesEventList(#[from] get_services_event_list::Error),
    #[error(transparent)]
    GetPartitionEventList(#[from] get_partition_event_list::Error),
    #[error(transparent)]
    GetPartitionsEventList(#[from] get_partitions_event_list::Error),
    #[error(transparent)]
    GetPartitionReplicaEventList(#[from] get_partition_replica_event_list::Error),
    #[error(transparent)]
    GetPartitionReplicasEventList(#[from] get_partition_replicas_event_list::Error),
    #[error(transparent)]
    GetCorrelatedEventList(#[from] get_correlated_event_list::Error),
    #[error(transparent)]
    MeshSecret_Get(#[from] mesh_secret::get::Error),
    #[error(transparent)]
    MeshSecret_CreateOrUpdate(#[from] mesh_secret::create_or_update::Error),
    #[error(transparent)]
    MeshSecret_Delete(#[from] mesh_secret::delete::Error),
    #[error(transparent)]
    MeshSecret_List(#[from] mesh_secret::list::Error),
    #[error(transparent)]
    MeshSecretValue_Get(#[from] mesh_secret_value::get::Error),
    #[error(transparent)]
    MeshSecretValue_AddValue(#[from] mesh_secret_value::add_value::Error),
    #[error(transparent)]
    MeshSecretValue_Delete(#[from] mesh_secret_value::delete::Error),
    #[error(transparent)]
    MeshSecretValue_List(#[from] mesh_secret_value::list::Error),
    #[error(transparent)]
    MeshSecretValue_Show(#[from] mesh_secret_value::show::Error),
    #[error(transparent)]
    MeshVolume_Get(#[from] mesh_volume::get::Error),
    #[error(transparent)]
    MeshVolume_CreateOrUpdate(#[from] mesh_volume::create_or_update::Error),
    #[error(transparent)]
    MeshVolume_Delete(#[from] mesh_volume::delete::Error),
    #[error(transparent)]
    MeshVolume_List(#[from] mesh_volume::list::Error),
    #[error(transparent)]
    MeshNetwork_Get(#[from] mesh_network::get::Error),
    #[error(transparent)]
    MeshNetwork_CreateOrUpdate(#[from] mesh_network::create_or_update::Error),
    #[error(transparent)]
    MeshNetwork_Delete(#[from] mesh_network::delete::Error),
    #[error(transparent)]
    MeshNetwork_List(#[from] mesh_network::list::Error),
    #[error(transparent)]
    MeshApplication_Get(#[from] mesh_application::get::Error),
    #[error(transparent)]
    MeshApplication_CreateOrUpdate(#[from] mesh_application::create_or_update::Error),
    #[error(transparent)]
    MeshApplication_Delete(#[from] mesh_application::delete::Error),
    #[error(transparent)]
    MeshApplication_List(#[from] mesh_application::list::Error),
    #[error(transparent)]
    MeshApplication_GetUpgradeProgress(#[from] mesh_application::get_upgrade_progress::Error),
    #[error(transparent)]
    MeshService_Get(#[from] mesh_service::get::Error),
    #[error(transparent)]
    MeshService_List(#[from] mesh_service::list::Error),
    #[error(transparent)]
    MeshCodePackage_GetContainerLogs(#[from] mesh_code_package::get_container_logs::Error),
    #[error(transparent)]
    MeshServiceReplica_Get(#[from] mesh_service_replica::get::Error),
    #[error(transparent)]
    MeshServiceReplica_List(#[from] mesh_service_replica::list::Error),
    #[error(transparent)]
    MeshGateway_Get(#[from] mesh_gateway::get::Error),
    #[error(transparent)]
    MeshGateway_CreateOrUpdate(#[from] mesh_gateway::create_or_update::Error),
    #[error(transparent)]
    MeshGateway_Delete(#[from] mesh_gateway::delete::Error),
    #[error(transparent)]
    MeshGateway_List(#[from] mesh_gateway::list::Error),
}
pub async fn get_cluster_manifest(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterManifest, get_cluster_manifest::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetClusterManifest", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_manifest::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_manifest::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_cluster_manifest::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_manifest::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterManifest = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_manifest::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_manifest::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_manifest::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_manifest {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_health(
    operation_config: &crate::OperationConfig,
    nodes_health_state_filter: Option<i64>,
    applications_health_state_filter: Option<i64>,
    events_health_state_filter: Option<i64>,
    exclude_health_statistics: Option<bool>,
    include_system_application_health_statistics: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterHealth, get_cluster_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetClusterHealth", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(nodes_health_state_filter) = nodes_health_state_filter {
        url.query_pairs_mut()
            .append_pair("NodesHealthStateFilter", nodes_health_state_filter.to_string().as_str());
    }
    if let Some(applications_health_state_filter) = applications_health_state_filter {
        url.query_pairs_mut().append_pair(
            "ApplicationsHealthStateFilter",
            applications_health_state_filter.to_string().as_str(),
        );
    }
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(include_system_application_health_statistics) = include_system_application_health_statistics {
        url.query_pairs_mut().append_pair(
            "IncludeSystemApplicationHealthStatistics",
            include_system_application_health_statistics.to_string().as_str(),
        );
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_cluster_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterHealth =
                serde_json::from_slice(rsp_body).map_err(|source| get_cluster_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_cluster_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_health_using_policy(
    operation_config: &crate::OperationConfig,
    nodes_health_state_filter: Option<i64>,
    applications_health_state_filter: Option<i64>,
    events_health_state_filter: Option<i64>,
    exclude_health_statistics: Option<bool>,
    include_system_application_health_statistics: Option<bool>,
    cluster_health_policies: Option<&models::ClusterHealthPolicies>,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterHealth, get_cluster_health_using_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetClusterHealth", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_health_using_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_health_using_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(nodes_health_state_filter) = nodes_health_state_filter {
        url.query_pairs_mut()
            .append_pair("NodesHealthStateFilter", nodes_health_state_filter.to_string().as_str());
    }
    if let Some(applications_health_state_filter) = applications_health_state_filter {
        url.query_pairs_mut().append_pair(
            "ApplicationsHealthStateFilter",
            applications_health_state_filter.to_string().as_str(),
        );
    }
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(include_system_application_health_statistics) = include_system_application_health_statistics {
        url.query_pairs_mut().append_pair(
            "IncludeSystemApplicationHealthStatistics",
            include_system_application_health_statistics.to_string().as_str(),
        );
    }
    let req_body = if let Some(cluster_health_policies) = cluster_health_policies {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(cluster_health_policies).map_err(get_cluster_health_using_policy::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_cluster_health_using_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_health_using_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_health_using_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_health_using_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_health_chunk(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterHealthChunk, get_cluster_health_chunk::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetClusterHealthChunk", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_health_chunk::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_health_chunk::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_cluster_health_chunk::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_health_chunk::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterHealthChunk = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_health_chunk::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_health_chunk::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_health_chunk::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_health_chunk {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_health_chunk_using_policy_and_advanced_filters(
    operation_config: &crate::OperationConfig,
    cluster_health_chunk_query_description: Option<&models::ClusterHealthChunkQueryDescription>,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterHealthChunk, get_cluster_health_chunk_using_policy_and_advanced_filters::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetClusterHealthChunk", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_health_chunk_using_policy_and_advanced_filters::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_health_chunk_using_policy_and_advanced_filters::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = if let Some(cluster_health_chunk_query_description) = cluster_health_chunk_query_description {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(cluster_health_chunk_query_description)
            .map_err(get_cluster_health_chunk_using_policy_and_advanced_filters::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_cluster_health_chunk_using_policy_and_advanced_filters::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_health_chunk_using_policy_and_advanced_filters::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterHealthChunk = serde_json::from_slice(rsp_body).map_err(|source| {
                get_cluster_health_chunk_using_policy_and_advanced_filters::Error::DeserializeError(source, rsp_body.clone())
            })?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body).map_err(|source| {
                get_cluster_health_chunk_using_policy_and_advanced_filters::Error::DeserializeError(source, rsp_body.clone())
            })?;
            Err(get_cluster_health_chunk_using_policy_and_advanced_filters::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_health_chunk_using_policy_and_advanced_filters {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn report_cluster_health(
    operation_config: &crate::OperationConfig,
    health_information: &models::HealthInformation,
    immediate: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), report_cluster_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/ReportClusterHealth", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(report_cluster_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(report_cluster_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(health_information).map_err(report_cluster_health::Error::SerializeError)?;
    if let Some(immediate) = immediate {
        url.query_pairs_mut().append_pair("Immediate", immediate.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(report_cluster_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(report_cluster_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| report_cluster_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(report_cluster_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod report_cluster_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_provisioned_fabric_code_version_info_list(
    operation_config: &crate::OperationConfig,
    code_version: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::FabricCodeVersionInfoList, get_provisioned_fabric_code_version_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetProvisionedCodeVersions", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_provisioned_fabric_code_version_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_provisioned_fabric_code_version_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(code_version) = code_version {
        url.query_pairs_mut().append_pair("CodeVersion", code_version);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_provisioned_fabric_code_version_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_provisioned_fabric_code_version_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricCodeVersionInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_provisioned_fabric_code_version_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_provisioned_fabric_code_version_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_provisioned_fabric_code_version_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_provisioned_fabric_code_version_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_provisioned_fabric_config_version_info_list(
    operation_config: &crate::OperationConfig,
    config_version: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::FabricConfigVersionInfoList, get_provisioned_fabric_config_version_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetProvisionedConfigVersions", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_provisioned_fabric_config_version_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_provisioned_fabric_config_version_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(config_version) = config_version {
        url.query_pairs_mut().append_pair("ConfigVersion", config_version);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_provisioned_fabric_config_version_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_provisioned_fabric_config_version_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricConfigVersionInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_provisioned_fabric_config_version_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_provisioned_fabric_config_version_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_provisioned_fabric_config_version_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_provisioned_fabric_config_version_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_upgrade_progress(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterUpgradeProgressObject, get_cluster_upgrade_progress::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetUpgradeProgress", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_upgrade_progress::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_upgrade_progress::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_cluster_upgrade_progress::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_upgrade_progress::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterUpgradeProgressObject = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_upgrade_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_upgrade_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_upgrade_progress::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_upgrade_progress {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_configuration(
    operation_config: &crate::OperationConfig,
    configuration_api_version: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterConfiguration, get_cluster_configuration::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetClusterConfiguration", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_configuration::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_configuration::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut()
        .append_pair("ConfigurationApiVersion", configuration_api_version);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_cluster_configuration::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_configuration::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterConfiguration = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_configuration::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_configuration::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_configuration::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_configuration {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_configuration_upgrade_status(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterConfigurationUpgradeStatusInfo, get_cluster_configuration_upgrade_status::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetClusterConfigurationUpgradeStatus", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_configuration_upgrade_status::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_configuration_upgrade_status::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_cluster_configuration_upgrade_status::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_configuration_upgrade_status::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterConfigurationUpgradeStatusInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_configuration_upgrade_status::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_configuration_upgrade_status::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_configuration_upgrade_status::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_configuration_upgrade_status {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_upgrade_orchestration_service_state(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::UpgradeOrchestrationServiceState, get_upgrade_orchestration_service_state::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetUpgradeOrchestrationServiceState", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_upgrade_orchestration_service_state::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_upgrade_orchestration_service_state::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_upgrade_orchestration_service_state::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_upgrade_orchestration_service_state::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::UpgradeOrchestrationServiceState = serde_json::from_slice(rsp_body)
                .map_err(|source| get_upgrade_orchestration_service_state::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_upgrade_orchestration_service_state::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_upgrade_orchestration_service_state::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_upgrade_orchestration_service_state {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn set_upgrade_orchestration_service_state(
    operation_config: &crate::OperationConfig,
    upgrade_orchestration_service_state: &models::UpgradeOrchestrationServiceState,
    timeout: Option<i64>,
) -> std::result::Result<models::UpgradeOrchestrationServiceStateSummary, set_upgrade_orchestration_service_state::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/SetUpgradeOrchestrationServiceState", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(set_upgrade_orchestration_service_state::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(set_upgrade_orchestration_service_state::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(upgrade_orchestration_service_state).map_err(set_upgrade_orchestration_service_state::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(set_upgrade_orchestration_service_state::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(set_upgrade_orchestration_service_state::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::UpgradeOrchestrationServiceStateSummary = serde_json::from_slice(rsp_body)
                .map_err(|source| set_upgrade_orchestration_service_state::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| set_upgrade_orchestration_service_state::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(set_upgrade_orchestration_service_state::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod set_upgrade_orchestration_service_state {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn provision_cluster(
    operation_config: &crate::OperationConfig,
    provision_fabric_description: &models::ProvisionFabricDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), provision_cluster::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/Provision", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(provision_cluster::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(provision_cluster::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(provision_fabric_description).map_err(provision_cluster::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(provision_cluster::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(provision_cluster::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| provision_cluster::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(provision_cluster::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod provision_cluster {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn unprovision_cluster(
    operation_config: &crate::OperationConfig,
    unprovision_fabric_description: &models::UnprovisionFabricDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), unprovision_cluster::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/Unprovision", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(unprovision_cluster::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(unprovision_cluster::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(unprovision_fabric_description).map_err(unprovision_cluster::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(unprovision_cluster::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(unprovision_cluster::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| unprovision_cluster::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(unprovision_cluster::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod unprovision_cluster {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn rollback_cluster_upgrade(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<(), rollback_cluster_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/RollbackUpgrade", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(rollback_cluster_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(rollback_cluster_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(rollback_cluster_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(rollback_cluster_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| rollback_cluster_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(rollback_cluster_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod rollback_cluster_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn resume_cluster_upgrade(
    operation_config: &crate::OperationConfig,
    resume_cluster_upgrade_description: &models::ResumeClusterUpgradeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), resume_cluster_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/MoveToNextUpgradeDomain", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(resume_cluster_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(resume_cluster_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(resume_cluster_upgrade_description).map_err(resume_cluster_upgrade::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(resume_cluster_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(resume_cluster_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| resume_cluster_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(resume_cluster_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod resume_cluster_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_cluster_upgrade(
    operation_config: &crate::OperationConfig,
    start_cluster_upgrade_description: &models::StartClusterUpgradeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), start_cluster_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/Upgrade", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(start_cluster_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_cluster_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(start_cluster_upgrade_description).map_err(start_cluster_upgrade::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(start_cluster_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_cluster_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| start_cluster_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_cluster_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_cluster_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_cluster_configuration_upgrade(
    operation_config: &crate::OperationConfig,
    cluster_configuration_upgrade_description: &models::ClusterConfigurationUpgradeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), start_cluster_configuration_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/StartClusterConfigurationUpgrade", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(start_cluster_configuration_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_cluster_configuration_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(cluster_configuration_upgrade_description)
        .map_err(start_cluster_configuration_upgrade::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(start_cluster_configuration_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_cluster_configuration_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| start_cluster_configuration_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_cluster_configuration_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_cluster_configuration_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_cluster_upgrade(
    operation_config: &crate::OperationConfig,
    update_cluster_upgrade_description: &models::UpdateClusterUpgradeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), update_cluster_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/UpdateUpgrade", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(update_cluster_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_cluster_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(update_cluster_upgrade_description).map_err(update_cluster_upgrade::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_cluster_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_cluster_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_cluster_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_cluster_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_cluster_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_aad_metadata(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::AadMetadataObject, get_aad_metadata::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetAadMetadata", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_aad_metadata::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_aad_metadata::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_aad_metadata::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_aad_metadata::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::AadMetadataObject =
                serde_json::from_slice(rsp_body).map_err(|source| get_aad_metadata::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_aad_metadata::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_aad_metadata::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_aad_metadata {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_version(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterVersion, get_cluster_version::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetClusterVersion", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_version::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_version::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_cluster_version::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_version::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterVersion = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_version::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_version::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_version::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_version {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_load(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ClusterLoadInfo, get_cluster_load::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetLoadInformation", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_load::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_load::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_cluster_load::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_load::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterLoadInfo =
                serde_json::from_slice(rsp_body).map_err(|source| get_cluster_load::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_cluster_load::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_load::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_load {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn toggle_verbose_service_placement_health_reporting(
    operation_config: &crate::OperationConfig,
    enabled: bool,
    timeout: Option<i64>,
) -> std::result::Result<(), toggle_verbose_service_placement_health_reporting::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/ToggleVerboseServicePlacementHealthReporting", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(toggle_verbose_service_placement_health_reporting::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(toggle_verbose_service_placement_health_reporting::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("Enabled", enabled.to_string().as_str());
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(toggle_verbose_service_placement_health_reporting::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(toggle_verbose_service_placement_health_reporting::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| toggle_verbose_service_placement_health_reporting::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(toggle_verbose_service_placement_health_reporting::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod toggle_verbose_service_placement_health_reporting {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_node_info_list(
    operation_config: &crate::OperationConfig,
    continuation_token: Option<&str>,
    node_status_filter: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedNodeInfoList, get_node_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_node_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_node_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(node_status_filter) = node_status_filter {
        url.query_pairs_mut().append_pair("NodeStatusFilter", node_status_filter);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_node_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_node_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedNodeInfoList =
                serde_json::from_slice(rsp_body).map_err(|source| get_node_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_node_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_node_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_node_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_node_info(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<get_node_info::Response, get_node_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(get_node_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_node_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_node_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_node_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::NodeInfo =
                serde_json::from_slice(rsp_body).map_err(|source| get_node_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_node_info::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_node_info::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_node_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_node_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_node_info {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::NodeInfo),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_node_health(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    events_health_state_filter: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::NodeHealth, get_node_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/GetHealth", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(get_node_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_node_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_node_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_node_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::NodeHealth =
                serde_json::from_slice(rsp_body).map_err(|source| get_node_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_node_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_node_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_node_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_node_health_using_policy(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    events_health_state_filter: Option<i64>,
    cluster_health_policy: Option<&models::ClusterHealthPolicy>,
    timeout: Option<i64>,
) -> std::result::Result<models::NodeHealth, get_node_health_using_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/GetHealth", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(get_node_health_using_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_node_health_using_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    let req_body = if let Some(cluster_health_policy) = cluster_health_policy {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(cluster_health_policy).map_err(get_node_health_using_policy::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_node_health_using_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_node_health_using_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::NodeHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_node_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_node_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_node_health_using_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_node_health_using_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn report_node_health(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    health_information: &models::HealthInformation,
    immediate: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), report_node_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/ReportHealth", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(report_node_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(report_node_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(health_information).map_err(report_node_health::Error::SerializeError)?;
    if let Some(immediate) = immediate {
        url.query_pairs_mut().append_pair("Immediate", immediate.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(report_node_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(report_node_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| report_node_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(report_node_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod report_node_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_node_load_info(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::NodeLoadInfo, get_node_load_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/GetLoadInformation", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(get_node_load_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_node_load_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_node_load_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_node_load_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::NodeLoadInfo =
                serde_json::from_slice(rsp_body).map_err(|source| get_node_load_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_node_load_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_node_load_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_node_load_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn disable_node(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    deactivation_intent_description: &models::DeactivationIntentDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), disable_node::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/Deactivate", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(disable_node::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(disable_node::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(deactivation_intent_description).map_err(disable_node::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(disable_node::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(disable_node::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| disable_node::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(disable_node::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod disable_node {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn enable_node(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), enable_node::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/Activate", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(enable_node::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(enable_node::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(enable_node::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(enable_node::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| enable_node::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(enable_node::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod enable_node {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn remove_node_state(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), remove_node_state::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/RemoveNodeState", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(remove_node_state::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(remove_node_state::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(remove_node_state::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(remove_node_state::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| remove_node_state::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(remove_node_state::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod remove_node_state {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restart_node(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    restart_node_description: &models::RestartNodeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), restart_node::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/Restart", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(restart_node::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restart_node::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(restart_node_description).map_err(restart_node::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(restart_node::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restart_node::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| restart_node::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restart_node::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restart_node {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn remove_configuration_overrides(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), remove_configuration_overrides::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/RemoveConfigurationOverrides",
        operation_config.base_path(),
        node_name
    );
    let mut url = url::Url::parse(url_str).map_err(remove_configuration_overrides::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(remove_configuration_overrides::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(remove_configuration_overrides::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(remove_configuration_overrides::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| remove_configuration_overrides::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(remove_configuration_overrides::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod remove_configuration_overrides {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_configuration_overrides(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ConfigParameterOverrideList, get_configuration_overrides::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/GetConfigurationOverrides", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(get_configuration_overrides::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_configuration_overrides::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_configuration_overrides::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_configuration_overrides::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ConfigParameterOverrideList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_configuration_overrides::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_configuration_overrides::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_configuration_overrides::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_configuration_overrides {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn add_configuration_parameter_overrides(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    config_parameter_override_list: &models::ConfigParameterOverrideList,
    force: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), add_configuration_parameter_overrides::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/AddConfigurationParameterOverrides",
        operation_config.base_path(),
        node_name
    );
    let mut url = url::Url::parse(url_str).map_err(add_configuration_parameter_overrides::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(add_configuration_parameter_overrides::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(config_parameter_override_list).map_err(add_configuration_parameter_overrides::Error::SerializeError)?;
    if let Some(force) = force {
        url.query_pairs_mut().append_pair("Force", force.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(add_configuration_parameter_overrides::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(add_configuration_parameter_overrides::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| add_configuration_parameter_overrides::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(add_configuration_parameter_overrides::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod add_configuration_parameter_overrides {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn remove_node_tags(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    node_tags: &models::NodeTagsList,
) -> std::result::Result<(), remove_node_tags::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/RemoveNodeTags", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(remove_node_tags::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(remove_node_tags::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(node_tags).map_err(remove_node_tags::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(remove_node_tags::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(remove_node_tags::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| remove_node_tags::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(remove_node_tags::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod remove_node_tags {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn add_node_tags(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    node_tags: &models::NodeTagsList,
) -> std::result::Result<(), add_node_tags::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/AddNodeTags", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(add_node_tags::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(add_node_tags::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(node_tags).map_err(add_node_tags::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(add_node_tags::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(add_node_tags::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| add_node_tags::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(add_node_tags::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod add_node_tags {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_type_info_list(
    operation_config: &crate::OperationConfig,
    application_type_definition_kind_filter: Option<i64>,
    exclude_application_parameters: Option<bool>,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedApplicationTypeInfoList, get_application_type_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ApplicationTypes", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_application_type_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_type_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(application_type_definition_kind_filter) = application_type_definition_kind_filter {
        url.query_pairs_mut().append_pair(
            "ApplicationTypeDefinitionKindFilter",
            application_type_definition_kind_filter.to_string().as_str(),
        );
    }
    if let Some(exclude_application_parameters) = exclude_application_parameters {
        url.query_pairs_mut()
            .append_pair("ExcludeApplicationParameters", exclude_application_parameters.to_string().as_str());
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_type_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_type_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedApplicationTypeInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_type_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_type_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_type_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_type_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_type_info_list_by_name(
    operation_config: &crate::OperationConfig,
    application_type_name: &str,
    application_type_version: Option<&str>,
    exclude_application_parameters: Option<bool>,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedApplicationTypeInfoList, get_application_type_info_list_by_name::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ApplicationTypes/{}", operation_config.base_path(), application_type_name);
    let mut url = url::Url::parse(url_str).map_err(get_application_type_info_list_by_name::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_type_info_list_by_name::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(application_type_version) = application_type_version {
        url.query_pairs_mut()
            .append_pair("ApplicationTypeVersion", application_type_version);
    }
    if let Some(exclude_application_parameters) = exclude_application_parameters {
        url.query_pairs_mut()
            .append_pair("ExcludeApplicationParameters", exclude_application_parameters.to_string().as_str());
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_type_info_list_by_name::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_type_info_list_by_name::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedApplicationTypeInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_type_info_list_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_type_info_list_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_type_info_list_by_name::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_type_info_list_by_name {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn provision_application_type(
    operation_config: &crate::OperationConfig,
    provision_application_type_description_base_required_body_param: &models::ProvisionApplicationTypeDescriptionBase,
    timeout: Option<i64>,
) -> std::result::Result<provision_application_type::Response, provision_application_type::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ApplicationTypes/$/Provision", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(provision_application_type::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(provision_application_type::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(provision_application_type_description_base_required_body_param)
        .map_err(provision_application_type::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(provision_application_type::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(provision_application_type::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(provision_application_type::Response::Ok200),
        http::StatusCode::ACCEPTED => Ok(provision_application_type::Response::Accepted202),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| provision_application_type::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(provision_application_type::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod provision_application_type {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200,
        Accepted202,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn unprovision_application_type(
    operation_config: &crate::OperationConfig,
    application_type_name: &str,
    unprovision_application_type_description_info: &models::UnprovisionApplicationTypeDescriptionInfo,
    timeout: Option<i64>,
) -> std::result::Result<unprovision_application_type::Response, unprovision_application_type::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/ApplicationTypes/{}/$/Unprovision",
        operation_config.base_path(),
        application_type_name
    );
    let mut url = url::Url::parse(url_str).map_err(unprovision_application_type::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(unprovision_application_type::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(unprovision_application_type_description_info).map_err(unprovision_application_type::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(unprovision_application_type::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(unprovision_application_type::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(unprovision_application_type::Response::Ok200),
        http::StatusCode::ACCEPTED => Ok(unprovision_application_type::Response::Accepted202),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| unprovision_application_type::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(unprovision_application_type::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod unprovision_application_type {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200,
        Accepted202,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_type_info_list(
    operation_config: &crate::OperationConfig,
    application_type_name: &str,
    application_type_version: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ServiceTypeInfoList, get_service_type_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/ApplicationTypes/{}/$/GetServiceTypes",
        operation_config.base_path(),
        application_type_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_service_type_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_type_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut()
        .append_pair("ApplicationTypeVersion", application_type_version);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_type_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_type_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceTypeInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_type_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_type_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_type_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_type_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_type_info_by_name(
    operation_config: &crate::OperationConfig,
    application_type_name: &str,
    application_type_version: &str,
    service_type_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<get_service_type_info_by_name::Response, get_service_type_info_by_name::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/ApplicationTypes/{}/$/GetServiceTypes/{}",
        operation_config.base_path(),
        application_type_name,
        service_type_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_service_type_info_by_name::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_type_info_by_name::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut()
        .append_pair("ApplicationTypeVersion", application_type_version);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_type_info_by_name::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_type_info_by_name::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceTypeInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_type_info_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_service_type_info_by_name::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_service_type_info_by_name::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_type_info_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_type_info_by_name::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_type_info_by_name {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ServiceTypeInfo),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_manifest(
    operation_config: &crate::OperationConfig,
    application_type_name: &str,
    application_type_version: &str,
    service_manifest_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ServiceTypeManifest, get_service_manifest::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/ApplicationTypes/{}/$/GetServiceManifest",
        operation_config.base_path(),
        application_type_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_service_manifest::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_manifest::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut()
        .append_pair("ApplicationTypeVersion", application_type_version);
    url.query_pairs_mut().append_pair("ServiceManifestName", service_manifest_name);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_service_manifest::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_manifest::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceTypeManifest = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_manifest::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_manifest::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_manifest::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_manifest {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_type_info_list(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_manifest_name: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedServiceTypeInfoList, get_deployed_service_type_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetServiceTypes",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_type_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_type_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(service_manifest_name) = service_manifest_name {
        url.query_pairs_mut().append_pair("ServiceManifestName", service_manifest_name);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_type_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_type_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServiceTypeInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_type_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_type_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_service_type_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_type_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_type_info_by_name(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_type_name: &str,
    service_manifest_name: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<get_deployed_service_type_info_by_name::Response, get_deployed_service_type_info_by_name::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetServiceTypes/{}",
        operation_config.base_path(),
        node_name,
        application_id,
        service_type_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_type_info_by_name::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_type_info_by_name::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(service_manifest_name) = service_manifest_name {
        url.query_pairs_mut().append_pair("ServiceManifestName", service_manifest_name);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_type_info_by_name::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_type_info_by_name::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServiceTypeInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_type_info_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_deployed_service_type_info_by_name::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_deployed_service_type_info_by_name::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_type_info_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_service_type_info_by_name::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_type_info_by_name {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::DeployedServiceTypeInfoList),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_application(
    operation_config: &crate::OperationConfig,
    application_description: &models::ApplicationDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), create_application::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/$/Create", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(create_application::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_application::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(application_description).map_err(create_application::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(create_application::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_application::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::CREATED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| create_application::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_application::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_application {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_application(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    force_remove: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), delete_application::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/Delete", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(delete_application::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_application::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(force_remove) = force_remove {
        url.query_pairs_mut().append_pair("ForceRemove", force_remove.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_application::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_application::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| delete_application::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_application::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_application {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_load_info(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<get_application_load_info::Response, get_application_load_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Applications/{}/$/GetLoadInformation",
        operation_config.base_path(),
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_application_load_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_load_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_load_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_load_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationLoadInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_load_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_application_load_info::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_application_load_info::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_load_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_load_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_load_info {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ApplicationLoadInfo),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_info_list(
    operation_config: &crate::OperationConfig,
    application_definition_kind_filter: Option<i64>,
    application_type_name: Option<&str>,
    exclude_application_parameters: Option<bool>,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedApplicationInfoList, get_application_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_application_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(application_definition_kind_filter) = application_definition_kind_filter {
        url.query_pairs_mut().append_pair(
            "ApplicationDefinitionKindFilter",
            application_definition_kind_filter.to_string().as_str(),
        );
    }
    if let Some(application_type_name) = application_type_name {
        url.query_pairs_mut().append_pair("ApplicationTypeName", application_type_name);
    }
    if let Some(exclude_application_parameters) = exclude_application_parameters {
        url.query_pairs_mut()
            .append_pair("ExcludeApplicationParameters", exclude_application_parameters.to_string().as_str());
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedApplicationInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_info(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    exclude_application_parameters: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<get_application_info::Response, get_application_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(get_application_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(exclude_application_parameters) = exclude_application_parameters {
        url.query_pairs_mut()
            .append_pair("ExcludeApplicationParameters", exclude_application_parameters.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_application_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_application_info::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_application_info::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_info {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ApplicationInfo),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_health(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    events_health_state_filter: Option<i64>,
    deployed_applications_health_state_filter: Option<i64>,
    services_health_state_filter: Option<i64>,
    exclude_health_statistics: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::ApplicationHealth, get_application_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/GetHealth", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(get_application_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(deployed_applications_health_state_filter) = deployed_applications_health_state_filter {
        url.query_pairs_mut().append_pair(
            "DeployedApplicationsHealthStateFilter",
            deployed_applications_health_state_filter.to_string().as_str(),
        );
    }
    if let Some(services_health_state_filter) = services_health_state_filter {
        url.query_pairs_mut()
            .append_pair("ServicesHealthStateFilter", services_health_state_filter.to_string().as_str());
    }
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_health_using_policy(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    events_health_state_filter: Option<i64>,
    deployed_applications_health_state_filter: Option<i64>,
    services_health_state_filter: Option<i64>,
    exclude_health_statistics: Option<bool>,
    application_health_policy: Option<&models::ApplicationHealthPolicy>,
    timeout: Option<i64>,
) -> std::result::Result<models::ApplicationHealth, get_application_health_using_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/GetHealth", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(get_application_health_using_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_health_using_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(deployed_applications_health_state_filter) = deployed_applications_health_state_filter {
        url.query_pairs_mut().append_pair(
            "DeployedApplicationsHealthStateFilter",
            deployed_applications_health_state_filter.to_string().as_str(),
        );
    }
    if let Some(services_health_state_filter) = services_health_state_filter {
        url.query_pairs_mut()
            .append_pair("ServicesHealthStateFilter", services_health_state_filter.to_string().as_str());
    }
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    let req_body = if let Some(application_health_policy) = application_health_policy {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(application_health_policy).map_err(get_application_health_using_policy::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_health_using_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_health_using_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_health_using_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_health_using_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn report_application_health(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    health_information: &models::HealthInformation,
    immediate: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), report_application_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/ReportHealth", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(report_application_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(report_application_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(health_information).map_err(report_application_health::Error::SerializeError)?;
    if let Some(immediate) = immediate {
        url.query_pairs_mut().append_pair("Immediate", immediate.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(report_application_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(report_application_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| report_application_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(report_application_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod report_application_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_application_upgrade(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    application_upgrade_description: &models::ApplicationUpgradeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), start_application_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/Upgrade", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(start_application_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_application_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(application_upgrade_description).map_err(start_application_upgrade::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(start_application_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_application_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| start_application_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_application_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_application_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_upgrade(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ApplicationUpgradeProgressInfo, get_application_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Applications/{}/$/GetUpgradeProgress",
        operation_config.base_path(),
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_application_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationUpgradeProgressInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_application_upgrade(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    application_upgrade_update_description: &models::ApplicationUpgradeUpdateDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), update_application_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/UpdateUpgrade", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(update_application_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_application_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(application_upgrade_update_description).map_err(update_application_upgrade::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_application_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_application_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_application_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_application_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_application_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_application(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    application_update_description: &models::ApplicationUpdateDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), update_application::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/Update", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(update_application::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_application::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(application_update_description).map_err(update_application::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(update_application::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_application::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| update_application::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_application::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_application {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn resume_application_upgrade(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    resume_application_upgrade_description: &models::ResumeApplicationUpgradeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), resume_application_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Applications/{}/$/MoveToNextUpgradeDomain",
        operation_config.base_path(),
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(resume_application_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(resume_application_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(resume_application_upgrade_description).map_err(resume_application_upgrade::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(resume_application_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(resume_application_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| resume_application_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(resume_application_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod resume_application_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn rollback_application_upgrade(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), rollback_application_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/RollbackUpgrade", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(rollback_application_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(rollback_application_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(rollback_application_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(rollback_application_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| rollback_application_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(rollback_application_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod rollback_application_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_application_info_list(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    timeout: Option<i64>,
    include_health_state: Option<bool>,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
) -> std::result::Result<models::PagedDeployedApplicationInfoList, get_deployed_application_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/GetApplications", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(get_deployed_application_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_application_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    if let Some(include_health_state) = include_health_state {
        url.query_pairs_mut()
            .append_pair("IncludeHealthState", include_health_state.to_string().as_str());
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_application_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_application_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedDeployedApplicationInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_application_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_application_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_application_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_application_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_application_info(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    timeout: Option<i64>,
    include_health_state: Option<bool>,
) -> std::result::Result<get_deployed_application_info::Response, get_deployed_application_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_application_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_application_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    if let Some(include_health_state) = include_health_state {
        url.query_pairs_mut()
            .append_pair("IncludeHealthState", include_health_state.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_application_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_application_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedApplicationInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_application_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_deployed_application_info::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_deployed_application_info::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_application_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_application_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_application_info {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::DeployedApplicationInfo),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_application_health(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    events_health_state_filter: Option<i64>,
    deployed_service_packages_health_state_filter: Option<i64>,
    exclude_health_statistics: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedApplicationHealth, get_deployed_application_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetHealth",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_application_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_application_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(deployed_service_packages_health_state_filter) = deployed_service_packages_health_state_filter {
        url.query_pairs_mut().append_pair(
            "DeployedServicePackagesHealthStateFilter",
            deployed_service_packages_health_state_filter.to_string().as_str(),
        );
    }
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_application_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_application_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedApplicationHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_application_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_application_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_application_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_application_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_application_health_using_policy(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    events_health_state_filter: Option<i64>,
    deployed_service_packages_health_state_filter: Option<i64>,
    application_health_policy: Option<&models::ApplicationHealthPolicy>,
    exclude_health_statistics: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedApplicationHealth, get_deployed_application_health_using_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetHealth",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_application_health_using_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_application_health_using_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(deployed_service_packages_health_state_filter) = deployed_service_packages_health_state_filter {
        url.query_pairs_mut().append_pair(
            "DeployedServicePackagesHealthStateFilter",
            deployed_service_packages_health_state_filter.to_string().as_str(),
        );
    }
    let req_body = if let Some(application_health_policy) = application_health_policy {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(application_health_policy).map_err(get_deployed_application_health_using_policy::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_application_health_using_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_application_health_using_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedApplicationHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_application_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_application_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_application_health_using_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_application_health_using_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn report_deployed_application_health(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    health_information: &models::HealthInformation,
    immediate: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), report_deployed_application_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/ReportHealth",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(report_deployed_application_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(report_deployed_application_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(health_information).map_err(report_deployed_application_health::Error::SerializeError)?;
    if let Some(immediate) = immediate {
        url.query_pairs_mut().append_pair("Immediate", immediate.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(report_deployed_application_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(report_deployed_application_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| report_deployed_application_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(report_deployed_application_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod report_deployed_application_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_manifest(
    operation_config: &crate::OperationConfig,
    application_type_name: &str,
    application_type_version: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ApplicationTypeManifest, get_application_manifest::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/ApplicationTypes/{}/$/GetApplicationManifest",
        operation_config.base_path(),
        application_type_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_application_manifest::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_manifest::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut()
        .append_pair("ApplicationTypeVersion", application_type_version);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_manifest::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_manifest::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationTypeManifest = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_manifest::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_manifest::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_manifest::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_manifest {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_info_list(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    service_type_name: Option<&str>,
    continuation_token: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedServiceInfoList, get_service_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/GetServices", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(get_service_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(service_type_name) = service_type_name {
        url.query_pairs_mut().append_pair("ServiceTypeName", service_type_name);
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedServiceInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_info(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    service_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<get_service_info::Response, get_service_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Applications/{}/$/GetServices/{}",
        operation_config.base_path(),
        application_id,
        service_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_service_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_service_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceInfo =
                serde_json::from_slice(rsp_body).map_err(|source| get_service_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_service_info::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_service_info::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_service_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_info {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ServiceInfo),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_name_info(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ApplicationNameInfo, get_application_name_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/GetApplicationName", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(get_application_name_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_name_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_name_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_name_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationNameInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_name_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_name_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_name_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_name_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_service(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    service_description: &models::ServiceDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), create_service::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Applications/{}/$/GetServices/$/Create",
        operation_config.base_path(),
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(create_service::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_service::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(service_description).map_err(create_service::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(create_service::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_service::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| create_service::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_service::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_service {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_service_from_template(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    service_from_template_description: &models::ServiceFromTemplateDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), create_service_from_template::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Applications/{}/$/GetServices/$/CreateFromTemplate",
        operation_config.base_path(),
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(create_service_from_template::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_service_from_template::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(service_from_template_description).map_err(create_service_from_template::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(create_service_from_template::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_service_from_template::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| create_service_from_template::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_service_from_template::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_service_from_template {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_service(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    force_remove: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), delete_service::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/Delete", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(delete_service::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_service::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(force_remove) = force_remove {
        url.query_pairs_mut().append_pair("ForceRemove", force_remove.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_service::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_service::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| delete_service::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_service::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_service {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_service(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    service_update_description: &models::ServiceUpdateDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), update_service::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/Update", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(update_service::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_service::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(service_update_description).map_err(update_service::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(update_service::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_service::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| update_service::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_service::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_service {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_description(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ServiceDescription, get_service_description::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/GetDescription", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(get_service_description::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_description::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_description::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_description::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceDescription = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_description::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_description::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_description::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_description {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_health(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    events_health_state_filter: Option<i64>,
    partitions_health_state_filter: Option<i64>,
    exclude_health_statistics: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::ServiceHealth, get_service_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/GetHealth", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(get_service_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(partitions_health_state_filter) = partitions_health_state_filter {
        url.query_pairs_mut()
            .append_pair("PartitionsHealthStateFilter", partitions_health_state_filter.to_string().as_str());
    }
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_service_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceHealth =
                serde_json::from_slice(rsp_body).map_err(|source| get_service_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_service_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_health_using_policy(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    events_health_state_filter: Option<i64>,
    partitions_health_state_filter: Option<i64>,
    application_health_policy: Option<&models::ApplicationHealthPolicy>,
    exclude_health_statistics: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::ServiceHealth, get_service_health_using_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/GetHealth", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(get_service_health_using_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_health_using_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(partitions_health_state_filter) = partitions_health_state_filter {
        url.query_pairs_mut()
            .append_pair("PartitionsHealthStateFilter", partitions_health_state_filter.to_string().as_str());
    }
    let req_body = if let Some(application_health_policy) = application_health_policy {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(application_health_policy).map_err(get_service_health_using_policy::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_health_using_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_health_using_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_health_using_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_health_using_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn report_service_health(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    health_information: &models::HealthInformation,
    immediate: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), report_service_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/ReportHealth", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(report_service_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(report_service_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(health_information).map_err(report_service_health::Error::SerializeError)?;
    if let Some(immediate) = immediate {
        url.query_pairs_mut().append_pair("Immediate", immediate.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(report_service_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(report_service_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| report_service_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(report_service_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod report_service_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn resolve_service(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_key_type: Option<i64>,
    partition_key_value: Option<&str>,
    previous_rsp_version: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::ResolvedServicePartition, resolve_service::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/ResolvePartition", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(resolve_service::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(resolve_service::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(partition_key_type) = partition_key_type {
        url.query_pairs_mut()
            .append_pair("PartitionKeyType", partition_key_type.to_string().as_str());
    }
    if let Some(partition_key_value) = partition_key_value {
        url.query_pairs_mut().append_pair("PartitionKeyValue", partition_key_value);
    }
    if let Some(previous_rsp_version) = previous_rsp_version {
        url.query_pairs_mut().append_pair("PreviousRspVersion", previous_rsp_version);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(resolve_service::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(resolve_service::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ResolvedServicePartition =
                serde_json::from_slice(rsp_body).map_err(|source| resolve_service::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| resolve_service::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(resolve_service::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod resolve_service {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_unplaced_replica_information(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: Option<&str>,
    only_query_primaries: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::UnplacedReplicaInformation, get_unplaced_replica_information::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Services/{}/$/GetUnplacedReplicaInformation",
        operation_config.base_path(),
        service_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_unplaced_replica_information::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_unplaced_replica_information::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(partition_id) = partition_id {
        url.query_pairs_mut().append_pair("PartitionId", partition_id);
    }
    if let Some(only_query_primaries) = only_query_primaries {
        url.query_pairs_mut()
            .append_pair("OnlyQueryPrimaries", only_query_primaries.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_unplaced_replica_information::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_unplaced_replica_information::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::UnplacedReplicaInformation = serde_json::from_slice(rsp_body)
                .map_err(|source| get_unplaced_replica_information::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_unplaced_replica_information::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_unplaced_replica_information::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_unplaced_replica_information {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_loaded_partition_info_list(
    operation_config: &crate::OperationConfig,
    metric_name: &str,
    service_name: Option<&str>,
    ordering: Option<&str>,
    max_results: Option<i64>,
    continuation_token: Option<&str>,
) -> std::result::Result<models::LoadedPartitionInformationResultList, get_loaded_partition_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetLoadedPartitionInfoList", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_loaded_partition_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_loaded_partition_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("MetricName", metric_name);
    if let Some(service_name) = service_name {
        url.query_pairs_mut().append_pair("ServiceName", service_name);
    }
    if let Some(ordering) = ordering {
        url.query_pairs_mut().append_pair("Ordering", ordering);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_loaded_partition_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_loaded_partition_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::LoadedPartitionInformationResultList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_loaded_partition_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_loaded_partition_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_loaded_partition_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_loaded_partition_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_info_list(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    continuation_token: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedServicePartitionInfoList, get_partition_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/GetPartitions", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedServicePartitionInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_info(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<get_partition_info::Response, get_partition_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_partition_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServicePartitionInfo =
                serde_json::from_slice(rsp_body).map_err(|source| get_partition_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_partition_info::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_partition_info::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_partition_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_info {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ServicePartitionInfo),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_name_info(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ServiceNameInfo, get_service_name_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/GetServiceName", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_service_name_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_name_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_name_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_name_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceNameInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_name_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_name_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_name_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_name_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_health(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    events_health_state_filter: Option<i64>,
    replicas_health_state_filter: Option<i64>,
    exclude_health_statistics: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::PartitionHealth, get_partition_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/GetHealth", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(replicas_health_state_filter) = replicas_health_state_filter {
        url.query_pairs_mut()
            .append_pair("ReplicasHealthStateFilter", replicas_health_state_filter.to_string().as_str());
    }
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_partition_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_health_using_policy(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    events_health_state_filter: Option<i64>,
    replicas_health_state_filter: Option<i64>,
    application_health_policy: Option<&models::ApplicationHealthPolicy>,
    exclude_health_statistics: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::PartitionHealth, get_partition_health_using_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/GetHealth", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_health_using_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_health_using_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(replicas_health_state_filter) = replicas_health_state_filter {
        url.query_pairs_mut()
            .append_pair("ReplicasHealthStateFilter", replicas_health_state_filter.to_string().as_str());
    }
    let req_body = if let Some(application_health_policy) = application_health_policy {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(application_health_policy).map_err(get_partition_health_using_policy::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(exclude_health_statistics) = exclude_health_statistics {
        url.query_pairs_mut()
            .append_pair("ExcludeHealthStatistics", exclude_health_statistics.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_health_using_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_health_using_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_health_using_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_health_using_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn report_partition_health(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    health_information: &models::HealthInformation,
    immediate: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), report_partition_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/ReportHealth", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(report_partition_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(report_partition_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(health_information).map_err(report_partition_health::Error::SerializeError)?;
    if let Some(immediate) = immediate {
        url.query_pairs_mut().append_pair("Immediate", immediate.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(report_partition_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(report_partition_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| report_partition_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(report_partition_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod report_partition_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_load_information(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::PartitionLoadInformation, get_partition_load_information::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/GetLoadInformation", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_load_information::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_load_information::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_load_information::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_load_information::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionLoadInformation = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_load_information::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_load_information::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_load_information::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_load_information {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn reset_partition_load(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), reset_partition_load::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/ResetLoad", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(reset_partition_load::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(reset_partition_load::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(reset_partition_load::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(reset_partition_load::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| reset_partition_load::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(reset_partition_load::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod reset_partition_load {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_partition(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), recover_partition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/Recover", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(recover_partition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_partition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(recover_partition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_partition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| recover_partition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_partition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_partition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_service_partitions(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), recover_service_partitions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Services/$/{}/$/GetPartitions/$/Recover",
        operation_config.base_path(),
        service_id
    );
    let mut url = url::Url::parse(url_str).map_err(recover_service_partitions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_service_partitions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(recover_service_partitions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_service_partitions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_service_partitions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_service_partitions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_service_partitions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_system_partitions(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<(), recover_system_partitions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/RecoverSystemPartitions", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(recover_system_partitions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_system_partitions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(recover_system_partitions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_system_partitions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_system_partitions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_system_partitions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_system_partitions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn recover_all_partitions(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<(), recover_all_partitions::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/RecoverAllPartitions", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(recover_all_partitions::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(recover_all_partitions::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(recover_all_partitions::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(recover_all_partitions::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| recover_all_partitions::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(recover_all_partitions::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod recover_all_partitions {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn move_primary_replica(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    node_name: Option<&str>,
    ignore_constraints: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), move_primary_replica::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/MovePrimaryReplica", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(move_primary_replica::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(move_primary_replica::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(node_name) = node_name {
        url.query_pairs_mut().append_pair("NodeName", node_name);
    }
    if let Some(ignore_constraints) = ignore_constraints {
        url.query_pairs_mut()
            .append_pair("IgnoreConstraints", ignore_constraints.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(move_primary_replica::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(move_primary_replica::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| move_primary_replica::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(move_primary_replica::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod move_primary_replica {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn move_secondary_replica(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    current_node_name: &str,
    new_node_name: Option<&str>,
    ignore_constraints: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), move_secondary_replica::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Partitions/{}/$/MoveSecondaryReplica",
        operation_config.base_path(),
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(move_secondary_replica::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(move_secondary_replica::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("CurrentNodeName", current_node_name);
    if let Some(new_node_name) = new_node_name {
        url.query_pairs_mut().append_pair("NewNodeName", new_node_name);
    }
    if let Some(ignore_constraints) = ignore_constraints {
        url.query_pairs_mut()
            .append_pair("IgnoreConstraints", ignore_constraints.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(move_secondary_replica::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(move_secondary_replica::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| move_secondary_replica::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(move_secondary_replica::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod move_secondary_replica {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_partition_load(
    operation_config: &crate::OperationConfig,
    partition_metric_load_description_list: &models::PartitionMetricLoadDescriptionList,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedUpdatePartitionLoadResultList, update_partition_load::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/UpdatePartitionLoad", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(update_partition_load::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_partition_load::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(partition_metric_load_description_list).map_err(update_partition_load::Error::SerializeError)?;
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_partition_load::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_partition_load::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedUpdatePartitionLoadResultList = serde_json::from_slice(rsp_body)
                .map_err(|source| update_partition_load::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_partition_load::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_partition_load::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_partition_load {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn move_instance(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: &str,
    current_node_name: Option<&str>,
    new_node_name: Option<&str>,
    ignore_constraints: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), move_instance::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Services/{}/$/GetPartitions/{}/$/MoveInstance",
        operation_config.base_path(),
        service_id,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(move_instance::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(move_instance::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(current_node_name) = current_node_name {
        url.query_pairs_mut().append_pair("CurrentNodeName", current_node_name);
    }
    if let Some(new_node_name) = new_node_name {
        url.query_pairs_mut().append_pair("NewNodeName", new_node_name);
    }
    if let Some(ignore_constraints) = ignore_constraints {
        url.query_pairs_mut()
            .append_pair("IgnoreConstraints", ignore_constraints.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(move_instance::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(move_instance::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| move_instance::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(move_instance::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod move_instance {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn move_auxiliary_replica(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: &str,
    current_node_name: Option<&str>,
    new_node_name: Option<&str>,
    ignore_constraints: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), move_auxiliary_replica::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Services/{}/$/GetPartitions/{}/$/MoveAuxiliaryReplica",
        operation_config.base_path(),
        service_id,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(move_auxiliary_replica::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(move_auxiliary_replica::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(current_node_name) = current_node_name {
        url.query_pairs_mut().append_pair("CurrentNodeName", current_node_name);
    }
    if let Some(new_node_name) = new_node_name {
        url.query_pairs_mut().append_pair("NewNodeName", new_node_name);
    }
    if let Some(ignore_constraints) = ignore_constraints {
        url.query_pairs_mut()
            .append_pair("IgnoreConstraints", ignore_constraints.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(move_auxiliary_replica::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(move_auxiliary_replica::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| move_auxiliary_replica::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(move_auxiliary_replica::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod move_auxiliary_replica {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_repair_task(
    operation_config: &crate::OperationConfig,
    repair_task: &models::RepairTask,
) -> std::result::Result<models::RepairTaskUpdateInfo, create_repair_task::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/CreateRepairTask", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(create_repair_task::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_repair_task::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(repair_task).map_err(create_repair_task::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(create_repair_task::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_repair_task::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RepairTaskUpdateInfo =
                serde_json::from_slice(rsp_body).map_err(|source| create_repair_task::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| create_repair_task::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_repair_task::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_repair_task {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn cancel_repair_task(
    operation_config: &crate::OperationConfig,
    repair_task_cancel_description: &models::RepairTaskCancelDescription,
) -> std::result::Result<models::RepairTaskUpdateInfo, cancel_repair_task::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/CancelRepairTask", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(cancel_repair_task::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(cancel_repair_task::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(repair_task_cancel_description).map_err(cancel_repair_task::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(cancel_repair_task::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(cancel_repair_task::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RepairTaskUpdateInfo =
                serde_json::from_slice(rsp_body).map_err(|source| cancel_repair_task::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| cancel_repair_task::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(cancel_repair_task::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod cancel_repair_task {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_repair_task(
    operation_config: &crate::OperationConfig,
    repair_task_delete_description: &models::RepairTaskDeleteDescription,
) -> std::result::Result<(), delete_repair_task::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/DeleteRepairTask", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(delete_repair_task::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_repair_task::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(repair_task_delete_description).map_err(delete_repair_task::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_repair_task::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_repair_task::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| delete_repair_task::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_repair_task::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_repair_task {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_repair_task_list(
    operation_config: &crate::OperationConfig,
    task_id_filter: Option<&str>,
    state_filter: Option<i64>,
    executor_filter: Option<&str>,
) -> std::result::Result<models::RepairTaskList, get_repair_task_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/GetRepairTaskList", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_repair_task_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_repair_task_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(task_id_filter) = task_id_filter {
        url.query_pairs_mut().append_pair("TaskIdFilter", task_id_filter);
    }
    if let Some(state_filter) = state_filter {
        url.query_pairs_mut().append_pair("StateFilter", state_filter.to_string().as_str());
    }
    if let Some(executor_filter) = executor_filter {
        url.query_pairs_mut().append_pair("ExecutorFilter", executor_filter);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_repair_task_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_repair_task_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RepairTaskList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_repair_task_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_repair_task_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_repair_task_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_repair_task_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn force_approve_repair_task(
    operation_config: &crate::OperationConfig,
    repair_task_approve_description: &models::RepairTaskApproveDescription,
) -> std::result::Result<models::RepairTaskUpdateInfo, force_approve_repair_task::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/ForceApproveRepairTask", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(force_approve_repair_task::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(force_approve_repair_task::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(repair_task_approve_description).map_err(force_approve_repair_task::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(force_approve_repair_task::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(force_approve_repair_task::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RepairTaskUpdateInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| force_approve_repair_task::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| force_approve_repair_task::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(force_approve_repair_task::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod force_approve_repair_task {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_repair_task_health_policy(
    operation_config: &crate::OperationConfig,
    repair_task_update_health_policy_description: &models::RepairTaskUpdateHealthPolicyDescription,
) -> std::result::Result<models::RepairTaskUpdateInfo, update_repair_task_health_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/UpdateRepairTaskHealthPolicy", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(update_repair_task_health_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_repair_task_health_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(repair_task_update_health_policy_description)
        .map_err(update_repair_task_health_policy::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_repair_task_health_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_repair_task_health_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RepairTaskUpdateInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| update_repair_task_health_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_repair_task_health_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_repair_task_health_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_repair_task_health_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_repair_execution_state(
    operation_config: &crate::OperationConfig,
    repair_task: &models::RepairTask,
) -> std::result::Result<models::RepairTaskUpdateInfo, update_repair_execution_state::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/UpdateRepairExecutionState", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(update_repair_execution_state::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_repair_execution_state::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(repair_task).map_err(update_repair_execution_state::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_repair_execution_state::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_repair_execution_state::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RepairTaskUpdateInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| update_repair_execution_state::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_repair_execution_state::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_repair_execution_state::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_repair_execution_state {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_replica_info_list(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    continuation_token: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedReplicaInfoList, get_replica_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/GetReplicas", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_replica_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_replica_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_replica_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_replica_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedReplicaInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_replica_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_replica_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_replica_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_replica_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_replica_info(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    replica_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<get_replica_info::Response, get_replica_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Partitions/{}/$/GetReplicas/{}",
        operation_config.base_path(),
        partition_id,
        replica_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_replica_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_replica_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_replica_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_replica_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ReplicaInfo =
                serde_json::from_slice(rsp_body).map_err(|source| get_replica_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_replica_info::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_replica_info::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_replica_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_replica_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_replica_info {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ReplicaInfo),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_replica_health(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    replica_id: &str,
    events_health_state_filter: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::ReplicaHealth, get_replica_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Partitions/{}/$/GetReplicas/{}/$/GetHealth",
        operation_config.base_path(),
        partition_id,
        replica_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_replica_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_replica_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_replica_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_replica_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ReplicaHealth =
                serde_json::from_slice(rsp_body).map_err(|source| get_replica_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_replica_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_replica_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_replica_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_replica_health_using_policy(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    replica_id: &str,
    events_health_state_filter: Option<i64>,
    application_health_policy: Option<&models::ApplicationHealthPolicy>,
    timeout: Option<i64>,
) -> std::result::Result<models::ReplicaHealth, get_replica_health_using_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Partitions/{}/$/GetReplicas/{}/$/GetHealth",
        operation_config.base_path(),
        partition_id,
        replica_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_replica_health_using_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_replica_health_using_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    let req_body = if let Some(application_health_policy) = application_health_policy {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(application_health_policy).map_err(get_replica_health_using_policy::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_replica_health_using_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_replica_health_using_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ReplicaHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_replica_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_replica_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_replica_health_using_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_replica_health_using_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn report_replica_health(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    replica_id: &str,
    service_kind: &str,
    health_information: &models::HealthInformation,
    immediate: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), report_replica_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Partitions/{}/$/GetReplicas/{}/$/ReportHealth",
        operation_config.base_path(),
        partition_id,
        replica_id
    );
    let mut url = url::Url::parse(url_str).map_err(report_replica_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(report_replica_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("ServiceKind", service_kind);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(health_information).map_err(report_replica_health::Error::SerializeError)?;
    if let Some(immediate) = immediate {
        url.query_pairs_mut().append_pair("Immediate", immediate.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(report_replica_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(report_replica_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| report_replica_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(report_replica_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod report_replica_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_replica_info_list(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    partition_id: Option<&str>,
    service_manifest_name: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<get_deployed_service_replica_info_list::Response, get_deployed_service_replica_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetReplicas",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_replica_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_replica_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(partition_id) = partition_id {
        url.query_pairs_mut().append_pair("PartitionId", partition_id);
    }
    if let Some(service_manifest_name) = service_manifest_name {
        url.query_pairs_mut().append_pair("ServiceManifestName", service_manifest_name);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_replica_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_replica_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServiceReplicaInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_replica_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_deployed_service_replica_info_list::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_deployed_service_replica_info_list::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_replica_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_service_replica_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_replica_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::DeployedServiceReplicaInfoList),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_replica_detail_info(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    partition_id: &str,
    replica_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedServiceReplicaDetailInfo, get_deployed_service_replica_detail_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetPartitions/{}/$/GetReplicas/{}/$/GetDetail",
        operation_config.base_path(),
        node_name,
        partition_id,
        replica_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_replica_detail_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_replica_detail_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_replica_detail_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_replica_detail_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServiceReplicaDetailInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_replica_detail_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_replica_detail_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_service_replica_detail_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_replica_detail_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_replica_detail_info_by_partition_id(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedServiceReplicaDetailInfo, get_deployed_service_replica_detail_info_by_partition_id::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetPartitions/{}/$/GetReplicas",
        operation_config.base_path(),
        node_name,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_replica_detail_info_by_partition_id::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_replica_detail_info_by_partition_id::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_replica_detail_info_by_partition_id::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_replica_detail_info_by_partition_id::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServiceReplicaDetailInfo = serde_json::from_slice(rsp_body).map_err(|source| {
                get_deployed_service_replica_detail_info_by_partition_id::Error::DeserializeError(source, rsp_body.clone())
            })?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body).map_err(|source| {
                get_deployed_service_replica_detail_info_by_partition_id::Error::DeserializeError(source, rsp_body.clone())
            })?;
            Err(get_deployed_service_replica_detail_info_by_partition_id::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_replica_detail_info_by_partition_id {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restart_replica(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    partition_id: &str,
    replica_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), restart_replica::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetPartitions/{}/$/GetReplicas/{}/$/Restart",
        operation_config.base_path(),
        node_name,
        partition_id,
        replica_id
    );
    let mut url = url::Url::parse(url_str).map_err(restart_replica::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restart_replica::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(restart_replica::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restart_replica::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| restart_replica::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restart_replica::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restart_replica {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn remove_replica(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    partition_id: &str,
    replica_id: &str,
    force_remove: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), remove_replica::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetPartitions/{}/$/GetReplicas/{}/$/Delete",
        operation_config.base_path(),
        node_name,
        partition_id,
        replica_id
    );
    let mut url = url::Url::parse(url_str).map_err(remove_replica::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(remove_replica::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(force_remove) = force_remove {
        url.query_pairs_mut().append_pair("ForceRemove", force_remove.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(remove_replica::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(remove_replica::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| remove_replica::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(remove_replica::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod remove_replica {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_package_info_list(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedServicePackageInfoList, get_deployed_service_package_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_package_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_package_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_package_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_package_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServicePackageInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_package_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_package_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_service_package_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_package_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_package_info_list_by_name(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_package_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<get_deployed_service_package_info_list_by_name::Response, get_deployed_service_package_info_list_by_name::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages/{}",
        operation_config.base_path(),
        node_name,
        application_id,
        service_package_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_package_info_list_by_name::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_package_info_list_by_name::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_package_info_list_by_name::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_package_info_list_by_name::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServicePackageInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_package_info_list_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(get_deployed_service_package_info_list_by_name::Response::Ok200(rsp_value))
        }
        http::StatusCode::NO_CONTENT => Ok(get_deployed_service_package_info_list_by_name::Response::NoContent204),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_package_info_list_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_service_package_info_list_by_name::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_package_info_list_by_name {
    use super::{models, API_VERSION};
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::DeployedServicePackageInfoList),
        NoContent204,
    }
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_package_health(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_package_name: &str,
    events_health_state_filter: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedServicePackageHealth, get_deployed_service_package_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages/{}/$/GetHealth",
        operation_config.base_path(),
        node_name,
        application_id,
        service_package_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_package_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_package_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_package_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_package_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServicePackageHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_package_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_package_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_service_package_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_package_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_service_package_health_using_policy(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_package_name: &str,
    events_health_state_filter: Option<i64>,
    application_health_policy: Option<&models::ApplicationHealthPolicy>,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedServicePackageHealth, get_deployed_service_package_health_using_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages/{}/$/GetHealth",
        operation_config.base_path(),
        node_name,
        application_id,
        service_package_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_service_package_health_using_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_service_package_health_using_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(events_health_state_filter) = events_health_state_filter {
        url.query_pairs_mut()
            .append_pair("EventsHealthStateFilter", events_health_state_filter.to_string().as_str());
    }
    let req_body = if let Some(application_health_policy) = application_health_policy {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(application_health_policy).map_err(get_deployed_service_package_health_using_policy::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_service_package_health_using_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_service_package_health_using_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedServicePackageHealth = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_package_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_service_package_health_using_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_service_package_health_using_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_service_package_health_using_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn report_deployed_service_package_health(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_package_name: &str,
    health_information: &models::HealthInformation,
    immediate: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<(), report_deployed_service_package_health::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages/{}/$/ReportHealth",
        operation_config.base_path(),
        node_name,
        application_id,
        service_package_name
    );
    let mut url = url::Url::parse(url_str).map_err(report_deployed_service_package_health::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(report_deployed_service_package_health::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(health_information).map_err(report_deployed_service_package_health::Error::SerializeError)?;
    if let Some(immediate) = immediate {
        url.query_pairs_mut().append_pair("Immediate", immediate.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(report_deployed_service_package_health::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(report_deployed_service_package_health::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| report_deployed_service_package_health::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(report_deployed_service_package_health::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod report_deployed_service_package_health {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn deploy_service_package_to_node(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    deploy_service_package_to_node_description: &models::DeployServicePackageToNodeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), deploy_service_package_to_node::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Nodes/{}/$/DeployServicePackage", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(deploy_service_package_to_node::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(deploy_service_package_to_node::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(deploy_service_package_to_node_description).map_err(deploy_service_package_to_node::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(deploy_service_package_to_node::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(deploy_service_package_to_node::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| deploy_service_package_to_node::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(deploy_service_package_to_node::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod deploy_service_package_to_node {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_deployed_code_package_info_list(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_manifest_name: Option<&str>,
    code_package_name: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::DeployedCodePackageInfoList, get_deployed_code_package_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetCodePackages",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_deployed_code_package_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_deployed_code_package_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(service_manifest_name) = service_manifest_name {
        url.query_pairs_mut().append_pair("ServiceManifestName", service_manifest_name);
    }
    if let Some(code_package_name) = code_package_name {
        url.query_pairs_mut().append_pair("CodePackageName", code_package_name);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_deployed_code_package_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_deployed_code_package_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::DeployedCodePackageInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_code_package_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_deployed_code_package_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_deployed_code_package_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_deployed_code_package_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restart_deployed_code_package(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    restart_deployed_code_package_description: &models::RestartDeployedCodePackageDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), restart_deployed_code_package::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetCodePackages/$/Restart",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(restart_deployed_code_package::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restart_deployed_code_package::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(restart_deployed_code_package_description).map_err(restart_deployed_code_package::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(restart_deployed_code_package::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restart_deployed_code_package::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| restart_deployed_code_package::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restart_deployed_code_package::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restart_deployed_code_package {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_container_logs_deployed_on_node(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_manifest_name: &str,
    code_package_name: &str,
    tail: Option<&str>,
    previous: Option<bool>,
    timeout: Option<i64>,
) -> std::result::Result<models::ContainerLogs, get_container_logs_deployed_on_node::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetCodePackages/$/ContainerLogs",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_container_logs_deployed_on_node::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_container_logs_deployed_on_node::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("ServiceManifestName", service_manifest_name);
    url.query_pairs_mut().append_pair("CodePackageName", code_package_name);
    if let Some(tail) = tail {
        url.query_pairs_mut().append_pair("Tail", tail);
    }
    if let Some(previous) = previous {
        url.query_pairs_mut().append_pair("Previous", previous.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_container_logs_deployed_on_node::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_container_logs_deployed_on_node::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ContainerLogs = serde_json::from_slice(rsp_body)
                .map_err(|source| get_container_logs_deployed_on_node::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_container_logs_deployed_on_node::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_container_logs_deployed_on_node::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_container_logs_deployed_on_node {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn invoke_container_api(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    application_id: &str,
    service_manifest_name: &str,
    code_package_name: &str,
    code_package_instance_id: &str,
    timeout: Option<i64>,
    container_api_request_body: &models::ContainerApiRequestBody,
) -> std::result::Result<models::ContainerApiResponse, invoke_container_api::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Nodes/{}/$/GetApplications/{}/$/GetCodePackages/$/ContainerApi",
        operation_config.base_path(),
        node_name,
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(invoke_container_api::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(invoke_container_api::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("ServiceManifestName", service_manifest_name);
    url.query_pairs_mut().append_pair("CodePackageName", code_package_name);
    url.query_pairs_mut().append_pair("CodePackageInstanceId", code_package_instance_id);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(container_api_request_body).map_err(invoke_container_api::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(invoke_container_api::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(invoke_container_api::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ContainerApiResponse = serde_json::from_slice(rsp_body)
                .map_err(|source| invoke_container_api::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| invoke_container_api::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(invoke_container_api::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod invoke_container_api {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_compose_deployment(
    operation_config: &crate::OperationConfig,
    create_compose_deployment_description: &models::CreateComposeDeploymentDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), create_compose_deployment::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ComposeDeployments/$/Create", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(create_compose_deployment::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_compose_deployment::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(create_compose_deployment_description).map_err(create_compose_deployment::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(create_compose_deployment::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_compose_deployment::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| create_compose_deployment::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_compose_deployment::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_compose_deployment {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_compose_deployment_status(
    operation_config: &crate::OperationConfig,
    deployment_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ComposeDeploymentStatusInfo, get_compose_deployment_status::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ComposeDeployments/{}", operation_config.base_path(), deployment_name);
    let mut url = url::Url::parse(url_str).map_err(get_compose_deployment_status::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_compose_deployment_status::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_compose_deployment_status::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_compose_deployment_status::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ComposeDeploymentStatusInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_compose_deployment_status::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_compose_deployment_status::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_compose_deployment_status::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_compose_deployment_status {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_compose_deployment_status_list(
    operation_config: &crate::OperationConfig,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedComposeDeploymentStatusInfoList, get_compose_deployment_status_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ComposeDeployments", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_compose_deployment_status_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_compose_deployment_status_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_compose_deployment_status_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_compose_deployment_status_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedComposeDeploymentStatusInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_compose_deployment_status_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_compose_deployment_status_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_compose_deployment_status_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_compose_deployment_status_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_compose_deployment_upgrade_progress(
    operation_config: &crate::OperationConfig,
    deployment_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ComposeDeploymentUpgradeProgressInfo, get_compose_deployment_upgrade_progress::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/ComposeDeployments/{}/$/GetUpgradeProgress",
        operation_config.base_path(),
        deployment_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_compose_deployment_upgrade_progress::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_compose_deployment_upgrade_progress::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_compose_deployment_upgrade_progress::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_compose_deployment_upgrade_progress::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ComposeDeploymentUpgradeProgressInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_compose_deployment_upgrade_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_compose_deployment_upgrade_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_compose_deployment_upgrade_progress::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_compose_deployment_upgrade_progress {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn remove_compose_deployment(
    operation_config: &crate::OperationConfig,
    deployment_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), remove_compose_deployment::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ComposeDeployments/{}/$/Delete", operation_config.base_path(), deployment_name);
    let mut url = url::Url::parse(url_str).map_err(remove_compose_deployment::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(remove_compose_deployment::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(remove_compose_deployment::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(remove_compose_deployment::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| remove_compose_deployment::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(remove_compose_deployment::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod remove_compose_deployment {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_compose_deployment_upgrade(
    operation_config: &crate::OperationConfig,
    deployment_name: &str,
    compose_deployment_upgrade_description: &models::ComposeDeploymentUpgradeDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), start_compose_deployment_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ComposeDeployments/{}/$/Upgrade", operation_config.base_path(), deployment_name);
    let mut url = url::Url::parse(url_str).map_err(start_compose_deployment_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_compose_deployment_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(compose_deployment_upgrade_description).map_err(start_compose_deployment_upgrade::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(start_compose_deployment_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_compose_deployment_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| start_compose_deployment_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_compose_deployment_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_compose_deployment_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_rollback_compose_deployment_upgrade(
    operation_config: &crate::OperationConfig,
    deployment_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), start_rollback_compose_deployment_upgrade::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/ComposeDeployments/{}/$/RollbackUpgrade",
        operation_config.base_path(),
        deployment_name
    );
    let mut url = url::Url::parse(url_str).map_err(start_rollback_compose_deployment_upgrade::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_rollback_compose_deployment_upgrade::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(start_rollback_compose_deployment_upgrade::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_rollback_compose_deployment_upgrade::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| start_rollback_compose_deployment_upgrade::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_rollback_compose_deployment_upgrade::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_rollback_compose_deployment_upgrade {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_chaos(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::Chaos, get_chaos::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Tools/Chaos", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_chaos::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_chaos::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_chaos::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_chaos::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::Chaos =
                serde_json::from_slice(rsp_body).map_err(|source| get_chaos::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_chaos::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_chaos::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_chaos {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_chaos(
    operation_config: &crate::OperationConfig,
    chaos_parameters: &models::ChaosParameters,
    timeout: Option<i64>,
) -> std::result::Result<(), start_chaos::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Tools/Chaos/$/Start", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(start_chaos::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_chaos::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(chaos_parameters).map_err(start_chaos::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(start_chaos::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_chaos::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| start_chaos::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_chaos::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_chaos {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn stop_chaos(operation_config: &crate::OperationConfig, timeout: Option<i64>) -> std::result::Result<(), stop_chaos::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Tools/Chaos/$/Stop", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(stop_chaos::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(stop_chaos::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(stop_chaos::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(stop_chaos::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| stop_chaos::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(stop_chaos::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod stop_chaos {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_chaos_events(
    operation_config: &crate::OperationConfig,
    continuation_token: Option<&str>,
    start_time_utc: Option<&str>,
    end_time_utc: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::ChaosEventsSegment, get_chaos_events::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Tools/Chaos/Events", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_chaos_events::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_chaos_events::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(start_time_utc) = start_time_utc {
        url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    }
    if let Some(end_time_utc) = end_time_utc {
        url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_chaos_events::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_chaos_events::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ChaosEventsSegment =
                serde_json::from_slice(rsp_body).map_err(|source| get_chaos_events::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_chaos_events::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_chaos_events::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_chaos_events {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_chaos_schedule(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ChaosScheduleDescription, get_chaos_schedule::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Tools/Chaos/Schedule", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_chaos_schedule::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_chaos_schedule::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_chaos_schedule::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_chaos_schedule::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ChaosScheduleDescription =
                serde_json::from_slice(rsp_body).map_err(|source| get_chaos_schedule::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_chaos_schedule::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_chaos_schedule::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_chaos_schedule {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn post_chaos_schedule(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
    chaos_schedule: &models::ChaosScheduleDescription,
) -> std::result::Result<(), post_chaos_schedule::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Tools/Chaos/Schedule", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(post_chaos_schedule::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(post_chaos_schedule::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(chaos_schedule).map_err(post_chaos_schedule::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(post_chaos_schedule::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(post_chaos_schedule::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| post_chaos_schedule::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(post_chaos_schedule::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod post_chaos_schedule {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_image_store_content(
    operation_config: &crate::OperationConfig,
    content_path: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::ImageStoreContent, get_image_store_content::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/{}", operation_config.base_path(), content_path);
    let mut url = url::Url::parse(url_str).map_err(get_image_store_content::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_image_store_content::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_image_store_content::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_image_store_content::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ImageStoreContent = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_content::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_content::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_image_store_content::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_image_store_content {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn upload_file(
    operation_config: &crate::OperationConfig,
    content_path: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), upload_file::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/{}", operation_config.base_path(), content_path);
    let mut url = url::Url::parse(url_str).map_err(upload_file::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(upload_file::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(upload_file::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(upload_file::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| upload_file::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(upload_file::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod upload_file {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_image_store_content(
    operation_config: &crate::OperationConfig,
    content_path: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), delete_image_store_content::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/{}", operation_config.base_path(), content_path);
    let mut url = url::Url::parse(url_str).map_err(delete_image_store_content::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_image_store_content::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(delete_image_store_content::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_image_store_content::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_image_store_content::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_image_store_content::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_image_store_content {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_image_store_root_content(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ImageStoreContent, get_image_store_root_content::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_image_store_root_content::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_image_store_root_content::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_image_store_root_content::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_image_store_root_content::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ImageStoreContent = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_root_content::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_root_content::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_image_store_root_content::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_image_store_root_content {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn copy_image_store_content(
    operation_config: &crate::OperationConfig,
    image_store_copy_description: &models::ImageStoreCopyDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), copy_image_store_content::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/$/Copy", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(copy_image_store_content::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(copy_image_store_content::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(image_store_copy_description).map_err(copy_image_store_content::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(copy_image_store_content::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(copy_image_store_content::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| copy_image_store_content::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(copy_image_store_content::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod copy_image_store_content {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_image_store_upload_session(
    operation_config: &crate::OperationConfig,
    session_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), delete_image_store_upload_session::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/$/DeleteUploadSession", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(delete_image_store_upload_session::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_image_store_upload_session::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("session-id", session_id);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(delete_image_store_upload_session::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_image_store_upload_session::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_image_store_upload_session::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_image_store_upload_session::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_image_store_upload_session {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn commit_image_store_upload_session(
    operation_config: &crate::OperationConfig,
    session_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), commit_image_store_upload_session::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/$/CommitUploadSession", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(commit_image_store_upload_session::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(commit_image_store_upload_session::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("session-id", session_id);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(commit_image_store_upload_session::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(commit_image_store_upload_session::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| commit_image_store_upload_session::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(commit_image_store_upload_session::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod commit_image_store_upload_session {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_image_store_upload_session_by_id(
    operation_config: &crate::OperationConfig,
    session_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::UploadSession, get_image_store_upload_session_by_id::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/$/GetUploadSession", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_image_store_upload_session_by_id::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_image_store_upload_session_by_id::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("session-id", session_id);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_image_store_upload_session_by_id::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_image_store_upload_session_by_id::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::UploadSession = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_upload_session_by_id::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_upload_session_by_id::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_image_store_upload_session_by_id::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_image_store_upload_session_by_id {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_image_store_upload_session_by_path(
    operation_config: &crate::OperationConfig,
    content_path: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::UploadSession, get_image_store_upload_session_by_path::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/{}/$/GetUploadSession", operation_config.base_path(), content_path);
    let mut url = url::Url::parse(url_str).map_err(get_image_store_upload_session_by_path::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_image_store_upload_session_by_path::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_image_store_upload_session_by_path::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_image_store_upload_session_by_path::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::UploadSession = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_upload_session_by_path::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_upload_session_by_path::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_image_store_upload_session_by_path::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_image_store_upload_session_by_path {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn upload_file_chunk(
    operation_config: &crate::OperationConfig,
    content_path: &str,
    session_id: &str,
    content_range: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), upload_file_chunk::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/{}/$/UploadChunk", operation_config.base_path(), content_path);
    let mut url = url::Url::parse(url_str).map_err(upload_file_chunk::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(upload_file_chunk::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("session-id", session_id);
    req_builder = req_builder.header("Content-Range", content_range);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(upload_file_chunk::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(upload_file_chunk::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| upload_file_chunk::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(upload_file_chunk::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod upload_file_chunk {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_image_store_root_folder_size(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::FolderSizeInfo, get_image_store_root_folder_size::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/$/FolderSize", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_image_store_root_folder_size::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_image_store_root_folder_size::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_image_store_root_folder_size::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_image_store_root_folder_size::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::FolderSizeInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_root_folder_size::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_root_folder_size::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_image_store_root_folder_size::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_image_store_root_folder_size {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_image_store_folder_size(
    operation_config: &crate::OperationConfig,
    content_path: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::FolderSizeInfo, get_image_store_folder_size::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/{}/$/FolderSize", operation_config.base_path(), content_path);
    let mut url = url::Url::parse(url_str).map_err(get_image_store_folder_size::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_image_store_folder_size::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_image_store_folder_size::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_image_store_folder_size::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::FolderSizeInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_folder_size::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_folder_size::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_image_store_folder_size::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_image_store_folder_size {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_image_store_info(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
) -> std::result::Result<models::ImageStoreInfo, get_image_store_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/ImageStore/$/Info", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_image_store_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_image_store_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_image_store_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_image_store_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ImageStoreInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_image_store_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_image_store_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_image_store_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn invoke_infrastructure_command(
    operation_config: &crate::OperationConfig,
    command: &str,
    service_id: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::InfrastructureServiceResponse, invoke_infrastructure_command::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/InvokeInfrastructureCommand", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(invoke_infrastructure_command::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(invoke_infrastructure_command::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("Command", command);
    if let Some(service_id) = service_id {
        url.query_pairs_mut().append_pair("ServiceId", service_id);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(invoke_infrastructure_command::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(invoke_infrastructure_command::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::InfrastructureServiceResponse = serde_json::from_slice(rsp_body)
                .map_err(|source| invoke_infrastructure_command::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| invoke_infrastructure_command::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(invoke_infrastructure_command::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod invoke_infrastructure_command {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn invoke_infrastructure_query(
    operation_config: &crate::OperationConfig,
    command: &str,
    service_id: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::InfrastructureServiceResponse, invoke_infrastructure_query::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/$/InvokeInfrastructureQuery", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(invoke_infrastructure_query::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(invoke_infrastructure_query::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("Command", command);
    if let Some(service_id) = service_id {
        url.query_pairs_mut().append_pair("ServiceId", service_id);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(invoke_infrastructure_query::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(invoke_infrastructure_query::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::InfrastructureServiceResponse = serde_json::from_slice(rsp_body)
                .map_err(|source| invoke_infrastructure_query::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| invoke_infrastructure_query::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(invoke_infrastructure_query::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod invoke_infrastructure_query {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_data_loss(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: &str,
    operation_id: &str,
    data_loss_mode: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), start_data_loss::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Faults/Services/{}/$/GetPartitions/{}/$/StartDataLoss",
        operation_config.base_path(),
        service_id,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(start_data_loss::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_data_loss::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    url.query_pairs_mut().append_pair("DataLossMode", data_loss_mode);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(start_data_loss::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_data_loss::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| start_data_loss::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_data_loss::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_data_loss {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_data_loss_progress(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: &str,
    operation_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::PartitionDataLossProgress, get_data_loss_progress::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Faults/Services/{}/$/GetPartitions/{}/$/GetDataLossProgress",
        operation_config.base_path(),
        service_id,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_data_loss_progress::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_data_loss_progress::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_data_loss_progress::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_data_loss_progress::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionDataLossProgress = serde_json::from_slice(rsp_body)
                .map_err(|source| get_data_loss_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_data_loss_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_data_loss_progress::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_data_loss_progress {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_quorum_loss(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: &str,
    operation_id: &str,
    quorum_loss_mode: &str,
    quorum_loss_duration: i64,
    timeout: Option<i64>,
) -> std::result::Result<(), start_quorum_loss::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Faults/Services/{}/$/GetPartitions/{}/$/StartQuorumLoss",
        operation_config.base_path(),
        service_id,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(start_quorum_loss::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_quorum_loss::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    url.query_pairs_mut().append_pair("QuorumLossMode", quorum_loss_mode);
    url.query_pairs_mut()
        .append_pair("QuorumLossDuration", quorum_loss_duration.to_string().as_str());
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(start_quorum_loss::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_quorum_loss::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| start_quorum_loss::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_quorum_loss::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_quorum_loss {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_quorum_loss_progress(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: &str,
    operation_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::PartitionQuorumLossProgress, get_quorum_loss_progress::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Faults/Services/{}/$/GetPartitions/{}/$/GetQuorumLossProgress",
        operation_config.base_path(),
        service_id,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_quorum_loss_progress::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_quorum_loss_progress::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_quorum_loss_progress::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_quorum_loss_progress::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionQuorumLossProgress = serde_json::from_slice(rsp_body)
                .map_err(|source| get_quorum_loss_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_quorum_loss_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_quorum_loss_progress::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_quorum_loss_progress {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_partition_restart(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: &str,
    operation_id: &str,
    restart_partition_mode: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), start_partition_restart::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Faults/Services/{}/$/GetPartitions/{}/$/StartRestart",
        operation_config.base_path(),
        service_id,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(start_partition_restart::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_partition_restart::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    url.query_pairs_mut().append_pair("RestartPartitionMode", restart_partition_mode);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(start_partition_restart::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_partition_restart::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| start_partition_restart::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_partition_restart::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_partition_restart {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_restart_progress(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    partition_id: &str,
    operation_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::PartitionRestartProgress, get_partition_restart_progress::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Faults/Services/{}/$/GetPartitions/{}/$/GetRestartProgress",
        operation_config.base_path(),
        service_id,
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_partition_restart_progress::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_restart_progress::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_restart_progress::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_restart_progress::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionRestartProgress = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_restart_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_restart_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_restart_progress::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_restart_progress {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn start_node_transition(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    operation_id: &str,
    node_transition_type: &str,
    node_instance_id: &str,
    stop_duration_in_seconds: i32,
    timeout: Option<i64>,
) -> std::result::Result<(), start_node_transition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Faults/Nodes/{}/$/StartTransition/", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(start_node_transition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(start_node_transition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    url.query_pairs_mut().append_pair("NodeTransitionType", node_transition_type);
    url.query_pairs_mut().append_pair("NodeInstanceId", node_instance_id);
    url.query_pairs_mut()
        .append_pair("StopDurationInSeconds", stop_duration_in_seconds.to_string().as_str());
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(start_node_transition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(start_node_transition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| start_node_transition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(start_node_transition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod start_node_transition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_node_transition_progress(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    operation_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::NodeTransitionProgress, get_node_transition_progress::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Faults/Nodes/{}/$/GetTransitionProgress",
        operation_config.base_path(),
        node_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_node_transition_progress::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_node_transition_progress::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_node_transition_progress::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_node_transition_progress::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::NodeTransitionProgress = serde_json::from_slice(rsp_body)
                .map_err(|source| get_node_transition_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_node_transition_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_node_transition_progress::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_node_transition_progress {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_fault_operation_list(
    operation_config: &crate::OperationConfig,
    type_filter: i64,
    state_filter: i64,
    timeout: Option<i64>,
) -> std::result::Result<models::OperationStatusList, get_fault_operation_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Faults/", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_fault_operation_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_fault_operation_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("TypeFilter", type_filter.to_string().as_str());
    url.query_pairs_mut().append_pair("StateFilter", state_filter.to_string().as_str());
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_fault_operation_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_fault_operation_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::OperationStatusList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_fault_operation_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_fault_operation_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_fault_operation_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_fault_operation_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn cancel_operation(
    operation_config: &crate::OperationConfig,
    operation_id: &str,
    force: bool,
    timeout: Option<i64>,
) -> std::result::Result<(), cancel_operation::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Faults/$/Cancel", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(cancel_operation::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(cancel_operation::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("OperationId", operation_id);
    url.query_pairs_mut().append_pair("Force", force.to_string().as_str());
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(cancel_operation::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(cancel_operation::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| cancel_operation::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(cancel_operation::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod cancel_operation {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_backup_policy(
    operation_config: &crate::OperationConfig,
    backup_policy_description: &models::BackupPolicyDescription,
    timeout: Option<i64>,
    validate_connection: Option<bool>,
) -> std::result::Result<(), create_backup_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/BackupRestore/BackupPolicies/$/Create", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(create_backup_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_backup_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(backup_policy_description).map_err(create_backup_policy::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    if let Some(validate_connection) = validate_connection {
        url.query_pairs_mut()
            .append_pair("ValidateConnection", validate_connection.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(create_backup_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_backup_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::CREATED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| create_backup_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_backup_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_backup_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_backup_policy(
    operation_config: &crate::OperationConfig,
    backup_policy_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), delete_backup_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/BackupRestore/BackupPolicies/{}/$/Delete",
        operation_config.base_path(),
        backup_policy_name
    );
    let mut url = url::Url::parse(url_str).map_err(delete_backup_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_backup_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_backup_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_backup_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| delete_backup_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_backup_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_backup_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_backup_policy_list(
    operation_config: &crate::OperationConfig,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedBackupPolicyDescriptionList, get_backup_policy_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/BackupRestore/BackupPolicies", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_backup_policy_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_backup_policy_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_backup_policy_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_backup_policy_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedBackupPolicyDescriptionList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_backup_policy_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_backup_policy_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_backup_policy_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_backup_policy_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_backup_policy_by_name(
    operation_config: &crate::OperationConfig,
    backup_policy_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::BackupPolicyDescription, get_backup_policy_by_name::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/BackupRestore/BackupPolicies/{}",
        operation_config.base_path(),
        backup_policy_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_backup_policy_by_name::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_backup_policy_by_name::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_backup_policy_by_name::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_backup_policy_by_name::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::BackupPolicyDescription = serde_json::from_slice(rsp_body)
                .map_err(|source| get_backup_policy_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_backup_policy_by_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_backup_policy_by_name::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_backup_policy_by_name {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_all_entities_backed_up_by_policy(
    operation_config: &crate::OperationConfig,
    backup_policy_name: &str,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedBackupEntityList, get_all_entities_backed_up_by_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/BackupRestore/BackupPolicies/{}/$/GetBackupEnabledEntities",
        operation_config.base_path(),
        backup_policy_name
    );
    let mut url = url::Url::parse(url_str).map_err(get_all_entities_backed_up_by_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_all_entities_backed_up_by_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_all_entities_backed_up_by_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_all_entities_backed_up_by_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedBackupEntityList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_all_entities_backed_up_by_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_all_entities_backed_up_by_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_all_entities_backed_up_by_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_all_entities_backed_up_by_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn update_backup_policy(
    operation_config: &crate::OperationConfig,
    backup_policy_description: &models::BackupPolicyDescription,
    backup_policy_name: &str,
    timeout: Option<i64>,
    validate_connection: Option<bool>,
) -> std::result::Result<(), update_backup_policy::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/BackupRestore/BackupPolicies/{}/$/Update",
        operation_config.base_path(),
        backup_policy_name
    );
    let mut url = url::Url::parse(url_str).map_err(update_backup_policy::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_backup_policy::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(backup_policy_description).map_err(update_backup_policy::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    if let Some(validate_connection) = validate_connection {
        url.query_pairs_mut()
            .append_pair("ValidateConnection", validate_connection.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(update_backup_policy::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_backup_policy::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| update_backup_policy::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(update_backup_policy::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod update_backup_policy {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn enable_application_backup(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    enable_backup_description: &models::EnableBackupDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), enable_application_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/EnableBackup", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(enable_application_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(enable_application_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(enable_backup_description).map_err(enable_application_backup::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(enable_application_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(enable_application_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| enable_application_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(enable_application_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod enable_application_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn disable_application_backup(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    timeout: Option<i64>,
    disable_backup_description: Option<&models::DisableBackupDescription>,
) -> std::result::Result<(), disable_application_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/DisableBackup", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(disable_application_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(disable_application_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = if let Some(disable_backup_description) = disable_backup_description {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(disable_backup_description).map_err(disable_application_backup::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(disable_application_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(disable_application_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| disable_application_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(disable_application_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod disable_application_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_backup_configuration_info(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedBackupConfigurationInfoList, get_application_backup_configuration_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Applications/{}/$/GetBackupConfigurationInfo",
        operation_config.base_path(),
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_application_backup_configuration_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_backup_configuration_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_backup_configuration_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_backup_configuration_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedBackupConfigurationInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_backup_configuration_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_backup_configuration_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_backup_configuration_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_backup_configuration_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_backup_list(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    timeout: Option<i64>,
    latest: Option<bool>,
    start_date_time_filter: Option<&str>,
    end_date_time_filter: Option<&str>,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
) -> std::result::Result<models::PagedBackupInfoList, get_application_backup_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/GetBackups", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(get_application_backup_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_backup_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    if let Some(latest) = latest {
        url.query_pairs_mut().append_pair("Latest", latest.to_string().as_str());
    }
    if let Some(start_date_time_filter) = start_date_time_filter {
        url.query_pairs_mut().append_pair("StartDateTimeFilter", start_date_time_filter);
    }
    if let Some(end_date_time_filter) = end_date_time_filter {
        url.query_pairs_mut().append_pair("EndDateTimeFilter", end_date_time_filter);
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_backup_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_backup_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedBackupInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_backup_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_backup_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_backup_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_backup_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn suspend_application_backup(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), suspend_application_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/SuspendBackup", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(suspend_application_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(suspend_application_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(suspend_application_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(suspend_application_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| suspend_application_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(suspend_application_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod suspend_application_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn resume_application_backup(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), resume_application_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Applications/{}/$/ResumeBackup", operation_config.base_path(), application_id);
    let mut url = url::Url::parse(url_str).map_err(resume_application_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(resume_application_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(resume_application_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(resume_application_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| resume_application_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(resume_application_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod resume_application_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn enable_service_backup(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    enable_backup_description: &models::EnableBackupDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), enable_service_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/EnableBackup", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(enable_service_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(enable_service_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(enable_backup_description).map_err(enable_service_backup::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(enable_service_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(enable_service_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| enable_service_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(enable_service_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod enable_service_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn disable_service_backup(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    disable_backup_description: Option<&models::DisableBackupDescription>,
    timeout: Option<i64>,
) -> std::result::Result<(), disable_service_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/DisableBackup", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(disable_service_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(disable_service_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = if let Some(disable_backup_description) = disable_backup_description {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(disable_backup_description).map_err(disable_service_backup::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(disable_service_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(disable_service_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| disable_service_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(disable_service_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod disable_service_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_backup_configuration_info(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedBackupConfigurationInfoList, get_service_backup_configuration_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Services/{}/$/GetBackupConfigurationInfo",
        operation_config.base_path(),
        service_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_service_backup_configuration_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_backup_configuration_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_backup_configuration_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_backup_configuration_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedBackupConfigurationInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_backup_configuration_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_backup_configuration_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_backup_configuration_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_backup_configuration_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_backup_list(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    timeout: Option<i64>,
    latest: Option<bool>,
    start_date_time_filter: Option<&str>,
    end_date_time_filter: Option<&str>,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
) -> std::result::Result<models::PagedBackupInfoList, get_service_backup_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/GetBackups", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(get_service_backup_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_backup_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    if let Some(latest) = latest {
        url.query_pairs_mut().append_pair("Latest", latest.to_string().as_str());
    }
    if let Some(start_date_time_filter) = start_date_time_filter {
        url.query_pairs_mut().append_pair("StartDateTimeFilter", start_date_time_filter);
    }
    if let Some(end_date_time_filter) = end_date_time_filter {
        url.query_pairs_mut().append_pair("EndDateTimeFilter", end_date_time_filter);
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_backup_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_backup_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedBackupInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_backup_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_backup_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_backup_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_backup_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn suspend_service_backup(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), suspend_service_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/SuspendBackup", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(suspend_service_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(suspend_service_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(suspend_service_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(suspend_service_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| suspend_service_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(suspend_service_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod suspend_service_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn resume_service_backup(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), resume_service_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Services/{}/$/ResumeBackup", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(resume_service_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(resume_service_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(resume_service_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(resume_service_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| resume_service_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(resume_service_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod resume_service_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn enable_partition_backup(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    enable_backup_description: &models::EnableBackupDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), enable_partition_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/EnableBackup", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(enable_partition_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(enable_partition_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(enable_backup_description).map_err(enable_partition_backup::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(enable_partition_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(enable_partition_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| enable_partition_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(enable_partition_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod enable_partition_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn disable_partition_backup(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    disable_backup_description: Option<&models::DisableBackupDescription>,
    timeout: Option<i64>,
) -> std::result::Result<(), disable_partition_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/DisableBackup", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(disable_partition_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(disable_partition_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = if let Some(disable_backup_description) = disable_backup_description {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(disable_backup_description).map_err(disable_partition_backup::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(disable_partition_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(disable_partition_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| disable_partition_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(disable_partition_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod disable_partition_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_backup_configuration_info(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::PartitionBackupConfigurationInfo, get_partition_backup_configuration_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/Partitions/{}/$/GetBackupConfigurationInfo",
        operation_config.base_path(),
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_partition_backup_configuration_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_backup_configuration_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_backup_configuration_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_backup_configuration_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionBackupConfigurationInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_backup_configuration_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_backup_configuration_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_backup_configuration_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_backup_configuration_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_backup_list(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
    latest: Option<bool>,
    start_date_time_filter: Option<&str>,
    end_date_time_filter: Option<&str>,
) -> std::result::Result<models::PagedBackupInfoList, get_partition_backup_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/GetBackups", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_backup_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_backup_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    if let Some(latest) = latest {
        url.query_pairs_mut().append_pair("Latest", latest.to_string().as_str());
    }
    if let Some(start_date_time_filter) = start_date_time_filter {
        url.query_pairs_mut().append_pair("StartDateTimeFilter", start_date_time_filter);
    }
    if let Some(end_date_time_filter) = end_date_time_filter {
        url.query_pairs_mut().append_pair("EndDateTimeFilter", end_date_time_filter);
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_backup_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_backup_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedBackupInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_backup_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_backup_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_backup_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_backup_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn suspend_partition_backup(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), suspend_partition_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/SuspendBackup", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(suspend_partition_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(suspend_partition_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(suspend_partition_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(suspend_partition_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| suspend_partition_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(suspend_partition_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod suspend_partition_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn resume_partition_backup(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), resume_partition_backup::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/ResumeBackup", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(resume_partition_backup::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(resume_partition_backup::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(resume_partition_backup::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(resume_partition_backup::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| resume_partition_backup::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(resume_partition_backup::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod resume_partition_backup {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn backup_partition(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    backup_partition_description: Option<&models::BackupPartitionDescription>,
    backup_timeout: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<(), backup_partition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/Backup", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(backup_partition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(backup_partition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    let req_body = if let Some(backup_partition_description) = backup_partition_description {
        req_builder = req_builder.header("content-type", "application/json");
        azure_core::to_json(backup_partition_description).map_err(backup_partition::Error::SerializeError)?
    } else {
        bytes::Bytes::from_static(azure_core::EMPTY_BODY)
    };
    if let Some(backup_timeout) = backup_timeout {
        url.query_pairs_mut()
            .append_pair("BackupTimeout", backup_timeout.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(backup_partition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(backup_partition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| backup_partition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(backup_partition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod backup_partition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_backup_progress(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::BackupProgressInfo, get_partition_backup_progress::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/GetBackupProgress", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_backup_progress::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_backup_progress::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_backup_progress::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_backup_progress::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::BackupProgressInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_backup_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_backup_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_backup_progress::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_backup_progress {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn restore_partition(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    restore_partition_description: &models::RestorePartitionDescription,
    restore_timeout: Option<i64>,
    timeout: Option<i64>,
) -> std::result::Result<(), restore_partition::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/Restore", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(restore_partition::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(restore_partition::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(restore_partition_description).map_err(restore_partition::Error::SerializeError)?;
    if let Some(restore_timeout) = restore_timeout {
        url.query_pairs_mut()
            .append_pair("RestoreTimeout", restore_timeout.to_string().as_str());
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(restore_partition::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(restore_partition::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::ACCEPTED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| restore_partition::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(restore_partition::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod restore_partition {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_restore_progress(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::RestoreProgressInfo, get_partition_restore_progress::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Partitions/{}/$/GetRestoreProgress", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_restore_progress::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_restore_progress::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_restore_progress::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_restore_progress::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::RestoreProgressInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_restore_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_restore_progress::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_restore_progress::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_restore_progress {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_backups_from_backup_location(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
    continuation_token: Option<&str>,
    max_results: Option<i64>,
    get_backup_by_storage_query_description: &models::GetBackupByStorageQueryDescription,
) -> std::result::Result<models::PagedBackupInfoList, get_backups_from_backup_location::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/BackupRestore/$/GetBackups", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_backups_from_backup_location::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_backups_from_backup_location::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(max_results) = max_results {
        url.query_pairs_mut().append_pair("MaxResults", max_results.to_string().as_str());
    }
    req_builder = req_builder.header("content-type", "application/json");
    let req_body =
        azure_core::to_json(get_backup_by_storage_query_description).map_err(get_backups_from_backup_location::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_backups_from_backup_location::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_backups_from_backup_location::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedBackupInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_backups_from_backup_location::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_backups_from_backup_location::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_backups_from_backup_location::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_backups_from_backup_location {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn create_name(
    operation_config: &crate::OperationConfig,
    name_description: &models::NameDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), create_name::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/$/Create", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(create_name::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(create_name::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(name_description).map_err(create_name::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(create_name::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(create_name::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::CREATED => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| create_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(create_name::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod create_name {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_name_exists_info(
    operation_config: &crate::OperationConfig,
    name_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), get_name_exists_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/{}", operation_config.base_path(), name_id);
    let mut url = url::Url::parse(url_str).map_err(get_name_exists_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_name_exists_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_name_exists_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_name_exists_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_name_exists_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_name_exists_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_name_exists_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_name(
    operation_config: &crate::OperationConfig,
    name_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), delete_name::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/{}", operation_config.base_path(), name_id);
    let mut url = url::Url::parse(url_str).map_err(delete_name::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_name::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_name::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_name::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| delete_name::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_name::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_name {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_sub_name_info_list(
    operation_config: &crate::OperationConfig,
    name_id: &str,
    recursive: Option<bool>,
    continuation_token: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedSubNameInfoList, get_sub_name_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/{}/$/GetSubNames", operation_config.base_path(), name_id);
    let mut url = url::Url::parse(url_str).map_err(get_sub_name_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_sub_name_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(recursive) = recursive {
        url.query_pairs_mut().append_pair("Recursive", recursive.to_string().as_str());
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_sub_name_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_sub_name_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedSubNameInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_sub_name_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_sub_name_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_sub_name_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_sub_name_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_property_info_list(
    operation_config: &crate::OperationConfig,
    name_id: &str,
    include_values: Option<bool>,
    continuation_token: Option<&str>,
    timeout: Option<i64>,
) -> std::result::Result<models::PagedPropertyInfoList, get_property_info_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/{}/$/GetProperties", operation_config.base_path(), name_id);
    let mut url = url::Url::parse(url_str).map_err(get_property_info_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_property_info_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(include_values) = include_values {
        url.query_pairs_mut()
            .append_pair("IncludeValues", include_values.to_string().as_str());
    }
    if let Some(continuation_token) = continuation_token {
        url.query_pairs_mut().append_pair("ContinuationToken", continuation_token);
    }
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_property_info_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_property_info_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PagedPropertyInfoList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_property_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_property_info_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_property_info_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_property_info_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_property_info(
    operation_config: &crate::OperationConfig,
    name_id: &str,
    property_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::PropertyInfo, get_property_info::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/{}/$/GetProperty", operation_config.base_path(), name_id);
    let mut url = url::Url::parse(url_str).map_err(get_property_info::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_property_info::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("PropertyName", property_name);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_property_info::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_property_info::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PropertyInfo =
                serde_json::from_slice(rsp_body).map_err(|source| get_property_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| get_property_info::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_property_info::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_property_info {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn put_property(
    operation_config: &crate::OperationConfig,
    name_id: &str,
    property_description: &models::PropertyDescription,
    timeout: Option<i64>,
) -> std::result::Result<(), put_property::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/{}/$/GetProperty", operation_config.base_path(), name_id);
    let mut url = url::Url::parse(url_str).map_err(put_property::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(put_property::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(property_description).map_err(put_property::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(put_property::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(put_property::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| put_property::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(put_property::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod put_property {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn delete_property(
    operation_config: &crate::OperationConfig,
    name_id: &str,
    property_name: &str,
    timeout: Option<i64>,
) -> std::result::Result<(), delete_property::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/{}/$/GetProperty", operation_config.base_path(), name_id);
    let mut url = url::Url::parse(url_str).map_err(delete_property::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::DELETE);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(delete_property::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    url.query_pairs_mut().append_pair("PropertyName", property_name);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(delete_property::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(delete_property::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => Ok(()),
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError =
                serde_json::from_slice(rsp_body).map_err(|source| delete_property::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(delete_property::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod delete_property {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn submit_property_batch(
    operation_config: &crate::OperationConfig,
    name_id: &str,
    property_batch_description_list: &models::PropertyBatchDescriptionList,
    timeout: Option<i64>,
) -> std::result::Result<models::SuccessfulPropertyBatchInfo, submit_property_batch::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/Names/{}/$/GetProperties/$/SubmitBatch", operation_config.base_path(), name_id);
    let mut url = url::Url::parse(url_str).map_err(submit_property_batch::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::POST);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(submit_property_batch::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(property_batch_description_list).map_err(submit_property_batch::Error::SerializeError)?;
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(submit_property_batch::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(submit_property_batch::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SuccessfulPropertyBatchInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| submit_property_batch::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        http::StatusCode::CONFLICT => {
            let rsp_body = rsp.body();
            let rsp_value: models::FailedPropertyBatchInfo = serde_json::from_slice(rsp_body)
                .map_err(|source| submit_property_batch::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(submit_property_batch::Error::Conflict409 { value: rsp_value })
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| submit_property_batch::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(submit_property_batch::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod submit_property_batch {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("Error response #response_type")]
        Conflict409 { value: models::FailedPropertyBatchInfo },
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_cluster_event_list(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::ClusterEventList, get_cluster_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Cluster/Events", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_cluster_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_cluster_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_cluster_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_cluster_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ClusterEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_cluster_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_cluster_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_cluster_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_containers_event_list(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::ContainerInstanceEventList, get_containers_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Containers/Events", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_containers_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_containers_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_containers_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_containers_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ContainerInstanceEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_containers_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_containers_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_containers_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_containers_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_node_event_list(
    operation_config: &crate::OperationConfig,
    node_name: &str,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::NodeEventList, get_node_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Nodes/{}/$/Events", operation_config.base_path(), node_name);
    let mut url = url::Url::parse(url_str).map_err(get_node_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_node_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_node_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_node_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::NodeEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_node_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_node_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_node_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_node_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_nodes_event_list(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::NodeEventList, get_nodes_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Nodes/Events", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_nodes_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_nodes_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder.body(req_body).map_err(get_nodes_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_nodes_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::NodeEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_nodes_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_nodes_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_nodes_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_nodes_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_application_event_list(
    operation_config: &crate::OperationConfig,
    application_id: &str,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::ApplicationEventList, get_application_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/EventsStore/Applications/{}/$/Events",
        operation_config.base_path(),
        application_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_application_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_application_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_application_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_application_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_application_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_application_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_application_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_applications_event_list(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::ApplicationEventList, get_applications_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Applications/Events", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_applications_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_applications_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_applications_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_applications_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ApplicationEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_applications_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_applications_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_applications_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_applications_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_service_event_list(
    operation_config: &crate::OperationConfig,
    service_id: &str,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::ServiceEventList, get_service_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Services/{}/$/Events", operation_config.base_path(), service_id);
    let mut url = url::Url::parse(url_str).map_err(get_service_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_service_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_service_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_service_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_service_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_service_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_service_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_services_event_list(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::ServiceEventList, get_services_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Services/Events", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_services_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_services_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_services_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_services_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ServiceEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_services_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_services_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_services_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_services_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_event_list(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::PartitionEventList, get_partition_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Partitions/{}/$/Events", operation_config.base_path(), partition_id);
    let mut url = url::Url::parse(url_str).map_err(get_partition_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partitions_event_list(
    operation_config: &crate::OperationConfig,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::PartitionEventList, get_partitions_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!("{}/EventsStore/Partitions/Events", operation_config.base_path(),);
    let mut url = url::Url::parse(url_str).map_err(get_partitions_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partitions_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partitions_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partitions_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::PartitionEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partitions_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partitions_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partitions_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partitions_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_replica_event_list(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    replica_id: &str,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::ReplicaEventList, get_partition_replica_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/EventsStore/Partitions/{}/$/Replicas/{}/$/Events",
        operation_config.base_path(),
        partition_id,
        replica_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_partition_replica_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_replica_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_replica_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_replica_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ReplicaEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_replica_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_replica_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_replica_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_replica_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_partition_replicas_event_list(
    operation_config: &crate::OperationConfig,
    partition_id: &str,
    timeout: Option<i64>,
    start_time_utc: &str,
    end_time_utc: &str,
    events_types_filter: Option<&str>,
    exclude_analysis_events: Option<bool>,
    skip_correlation_lookup: Option<bool>,
) -> std::result::Result<models::ReplicaEventList, get_partition_replicas_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/EventsStore/Partitions/{}/$/Replicas/Events",
        operation_config.base_path(),
        partition_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_partition_replicas_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_partition_replicas_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    url.query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
    url.query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
    if let Some(events_types_filter) = events_types_filter {
        url.query_pairs_mut().append_pair("EventsTypesFilter", events_types_filter);
    }
    if let Some(exclude_analysis_events) = exclude_analysis_events {
        url.query_pairs_mut()
            .append_pair("ExcludeAnalysisEvents", exclude_analysis_events.to_string().as_str());
    }
    if let Some(skip_correlation_lookup) = skip_correlation_lookup {
        url.query_pairs_mut()
            .append_pair("SkipCorrelationLookup", skip_correlation_lookup.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_partition_replicas_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_partition_replicas_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::ReplicaEventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_replicas_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_partition_replicas_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_partition_replicas_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_partition_replicas_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub async fn get_correlated_event_list(
    operation_config: &crate::OperationConfig,
    event_instance_id: &str,
    timeout: Option<i64>,
) -> std::result::Result<models::EventList, get_correlated_event_list::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/EventsStore/CorrelatedEvents/{}/$/Events",
        operation_config.base_path(),
        event_instance_id
    );
    let mut url = url::Url::parse(url_str).map_err(get_correlated_event_list::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::GET);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(get_correlated_event_list::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    if let Some(timeout) = timeout {
        url.query_pairs_mut().append_pair("timeout", timeout.to_string().as_str());
    }
    let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(get_correlated_event_list::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(get_correlated_event_list::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::EventList = serde_json::from_slice(rsp_body)
                .map_err(|source| get_correlated_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                .map_err(|source| get_correlated_event_list::Error::DeserializeError(source, rsp_body.clone()))?;
            Err(get_correlated_event_list::Error::DefaultResponse {
                status_code,
                value: rsp_value,
            })
        }
    }
}
pub mod get_correlated_event_list {
    use super::{models, API_VERSION};
    #[derive(Debug, thiserror :: Error)]
    pub enum Error {
        #[error("HTTP status code {}", status_code)]
        DefaultResponse {
            status_code: http::StatusCode,
            value: models::FabricError,
        },
        #[error("Failed to parse request URL: {0}")]
        ParseUrlError(url::ParseError),
        #[error("Failed to build request: {0}")]
        BuildRequestError(http::Error),
        #[error("Failed to execute request: {0}")]
        ExecuteRequestError(azure_core::HttpError),
        #[error("Failed to serialize request body: {0}")]
        SerializeError(serde_json::Error),
        #[error("Failed to deserialize response: {0}, body: {1:?}")]
        DeserializeError(serde_json::Error, bytes::Bytes),
        #[error("Failed to get access token: {0}")]
        GetTokenError(azure_core::Error),
    }
}
pub mod mesh_secret {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        secret_resource_name: &str,
    ) -> std::result::Result<models::SecretResourceDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Secrets/{}", operation_config.base_path(), secret_resource_name);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecretResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        secret_resource_name: &str,
        secret_resource_description: &models::SecretResourceDescription,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Secrets/{}", operation_config.base_path(), secret_resource_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(secret_resource_description).map_err(create_or_update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_or_update::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecretResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecretResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::SecretResourceDescription),
            Created201(models::SecretResourceDescription),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        secret_resource_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Secrets/{}", operation_config.base_path(), secret_resource_name);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::PagedSecretResourceDescriptionList, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Secrets", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PagedSecretResourceDescriptionList =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod mesh_secret_value {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        secret_resource_name: &str,
        secret_value_resource_name: &str,
    ) -> std::result::Result<models::SecretValueResourceDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Secrets/{}/values/{}",
            operation_config.base_path(),
            secret_resource_name,
            secret_value_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecretValueResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn add_value(
        operation_config: &crate::OperationConfig,
        secret_resource_name: &str,
        secret_value_resource_name: &str,
        secret_value_resource_description: &models::SecretValueResourceDescription,
    ) -> std::result::Result<add_value::Response, add_value::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Secrets/{}/values/{}",
            operation_config.base_path(),
            secret_resource_name,
            secret_value_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(add_value::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(add_value::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(secret_value_resource_description).map_err(add_value::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(add_value::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(add_value::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecretValueResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| add_value::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(add_value::Response::Ok200(rsp_value))
            }
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecretValueResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| add_value::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(add_value::Response::Created201(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(add_value::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| add_value::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(add_value::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod add_value {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::SecretValueResourceDescription),
            Created201(models::SecretValueResourceDescription),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        secret_resource_name: &str,
        secret_value_resource_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Secrets/{}/values/{}",
            operation_config.base_path(),
            secret_resource_name,
            secret_value_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        secret_resource_name: &str,
    ) -> std::result::Result<models::PagedSecretValueResourceDescriptionList, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Secrets/{}/values", operation_config.base_path(), secret_resource_name);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PagedSecretValueResourceDescriptionList =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn show(
        operation_config: &crate::OperationConfig,
        secret_resource_name: &str,
        secret_value_resource_name: &str,
    ) -> std::result::Result<models::SecretValue, show::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Secrets/{}/values/{}/list_value",
            operation_config.base_path(),
            secret_resource_name,
            secret_value_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(show::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(show::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.header(http::header::CONTENT_LENGTH, 0);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(show::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(show::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::SecretValue =
                    serde_json::from_slice(rsp_body).map_err(|source| show::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| show::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(show::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod show {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod mesh_volume {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        volume_resource_name: &str,
    ) -> std::result::Result<models::VolumeResourceDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Volumes/{}", operation_config.base_path(), volume_resource_name);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::VolumeResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        volume_resource_name: &str,
        volume_resource_description: &models::VolumeResourceDescription,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Volumes/{}", operation_config.base_path(), volume_resource_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(volume_resource_description).map_err(create_or_update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_or_update::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::VolumeResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::VolumeResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::VolumeResourceDescription),
            Created201(models::VolumeResourceDescription),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        volume_resource_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Volumes/{}", operation_config.base_path(), volume_resource_name);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::PagedVolumeResourceDescriptionList, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Volumes", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PagedVolumeResourceDescriptionList =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod mesh_network {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        network_resource_name: &str,
    ) -> std::result::Result<models::NetworkResourceDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Networks/{}", operation_config.base_path(), network_resource_name);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::NetworkResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        network_resource_name: &str,
        network_resource_description: &models::NetworkResourceDescription,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Networks/{}", operation_config.base_path(), network_resource_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(network_resource_description).map_err(create_or_update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_or_update::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::NetworkResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::NetworkResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::NetworkResourceDescription),
            Created201(models::NetworkResourceDescription),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        network_resource_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Networks/{}", operation_config.base_path(), network_resource_name);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::PagedNetworkResourceDescriptionList, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Networks", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PagedNetworkResourceDescriptionList =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod mesh_application {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
    ) -> std::result::Result<models::ApplicationResourceDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}",
            operation_config.base_path(),
            application_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ApplicationResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
        application_resource_description: &models::ApplicationResourceDescription,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}",
            operation_config.base_path(),
            application_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(create_or_update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(application_resource_description).map_err(create_or_update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_or_update::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ApplicationResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::ApplicationResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::ApplicationResourceDescription),
            Created201(models::ApplicationResourceDescription),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}",
            operation_config.base_path(),
            application_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::PagedApplicationResourceDescriptionList, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Applications", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PagedApplicationResourceDescriptionList =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn get_upgrade_progress(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
    ) -> std::result::Result<models::ApplicationResourceUpgradeProgressInfo, get_upgrade_progress::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}/$/GetUpgradeProgress",
            operation_config.base_path(),
            application_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(get_upgrade_progress::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_upgrade_progress::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_upgrade_progress::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_upgrade_progress::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ApplicationResourceUpgradeProgressInfo = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_upgrade_progress::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_upgrade_progress::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_upgrade_progress::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_upgrade_progress {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod mesh_service {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
        service_resource_name: &str,
    ) -> std::result::Result<models::ServiceResourceDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}/Services/{}",
            operation_config.base_path(),
            application_resource_name,
            service_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ServiceResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
    ) -> std::result::Result<models::PagedServiceResourceDescriptionList, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}/Services",
            operation_config.base_path(),
            application_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PagedServiceResourceDescriptionList =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod mesh_code_package {
    use super::{models, API_VERSION};
    pub async fn get_container_logs(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
        service_resource_name: &str,
        replica_name: &str,
        code_package_name: &str,
        tail: Option<&str>,
    ) -> std::result::Result<models::ContainerLogs, get_container_logs::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}/Services/{}/Replicas/{}/CodePackages/{}/Logs",
            operation_config.base_path(),
            application_resource_name,
            service_resource_name,
            replica_name,
            code_package_name
        );
        let mut url = url::Url::parse(url_str).map_err(get_container_logs::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_container_logs::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(tail) = tail {
            url.query_pairs_mut().append_pair("Tail", tail);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_container_logs::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_container_logs::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ContainerLogs = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_container_logs::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_container_logs::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_container_logs::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get_container_logs {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod mesh_service_replica {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
        service_resource_name: &str,
        replica_name: &str,
    ) -> std::result::Result<models::ServiceReplicaDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}/Services/{}/Replicas/{}",
            operation_config.base_path(),
            application_resource_name,
            service_resource_name,
            replica_name
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ServiceReplicaDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
        service_resource_name: &str,
    ) -> std::result::Result<models::PagedServiceReplicaDescriptionList, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}/Services/{}/Replicas",
            operation_config.base_path(),
            application_resource_name,
            service_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PagedServiceReplicaDescriptionList =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
pub mod mesh_gateway {
    use super::{models, API_VERSION};
    pub async fn get(
        operation_config: &crate::OperationConfig,
        gateway_resource_name: &str,
    ) -> std::result::Result<models::GatewayResourceDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Gateways/{}", operation_config.base_path(), gateway_resource_name);
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::GatewayResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod get {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn create_or_update(
        operation_config: &crate::OperationConfig,
        gateway_resource_name: &str,
        gateway_resource_description: &models::GatewayResourceDescription,
    ) -> std::result::Result<create_or_update::Response, create_or_update::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Gateways/{}", operation_config.base_path(), gateway_resource_name);
        let mut url = url::Url::parse(url_str).map_err(create_or_update::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::PUT);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(create_or_update::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(gateway_resource_description).map_err(create_or_update::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(create_or_update::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(create_or_update::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::GatewayResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Ok200(rsp_value))
            }
            http::StatusCode::CREATED => {
                let rsp_body = rsp.body();
                let rsp_value: models::GatewayResourceDescription = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(create_or_update::Response::Created201(rsp_value))
            }
            http::StatusCode::ACCEPTED => Ok(create_or_update::Response::Accepted202),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError = serde_json::from_slice(rsp_body)
                    .map_err(|source| create_or_update::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(create_or_update::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod create_or_update {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::GatewayResourceDescription),
            Created201(models::GatewayResourceDescription),
            Accepted202,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn delete(
        operation_config: &crate::OperationConfig,
        gateway_resource_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Gateways/{}", operation_config.base_path(), gateway_resource_name);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod delete {
        use super::{models, API_VERSION};
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
    pub async fn list(
        operation_config: &crate::OperationConfig,
    ) -> std::result::Result<models::PagedGatewayResourceDescriptionList, list::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Gateways", operation_config.base_path(),);
        let mut url = url::Url::parse(url_str).map_err(list::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(list::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::PagedGatewayResourceDescriptionList =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| list::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(list::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
    pub mod list {
        use super::{models, API_VERSION};
        #[derive(Debug, thiserror :: Error)]
        pub enum Error {
            #[error("HTTP status code {}", status_code)]
            DefaultResponse {
                status_code: http::StatusCode,
                value: models::FabricError,
            },
            #[error("Failed to parse request URL: {0}")]
            ParseUrlError(url::ParseError),
            #[error("Failed to build request: {0}")]
            BuildRequestError(http::Error),
            #[error("Failed to execute request: {0}")]
            ExecuteRequestError(azure_core::HttpError),
            #[error("Failed to serialize request body: {0}")]
            SerializeError(serde_json::Error),
            #[error("Failed to deserialize response: {0}, body: {1:?}")]
            DeserializeError(serde_json::Error, bytes::Bytes),
            #[error("Failed to get access token: {0}")]
            GetTokenError(azure_core::Error),
        }
    }
}
