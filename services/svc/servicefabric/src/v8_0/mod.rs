#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::redundant_clone)]
pub mod models;
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
    options: azure_core::ClientOptions,
}
pub const DEFAULT_ENDPOINT: &str = "https://localhost:19080";
impl ClientBuilder {
    #[doc = "Create a new instance of `ClientBuilder`."]
    #[must_use]
    pub fn new(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
            options: azure_core::ClientOptions::default(),
        }
    }
    #[doc = "Set the endpoint."]
    #[must_use]
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    #[doc = "Set the scopes."]
    #[must_use]
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    #[doc = "Set the retry options."]
    #[must_use]
    pub fn retry(mut self, retry: impl Into<azure_core::RetryOptions>) -> Self {
        self.options = self.options.retry(retry);
        self
    }
    #[doc = "Set the transport options."]
    #[must_use]
    pub fn transport(mut self, transport: impl Into<azure_core::TransportOptions>) -> Self {
        self.options = self.options.transport(transport);
        self
    }
    #[doc = "Convert the builder into a `Client` instance."]
    #[must_use]
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self.scopes.unwrap_or_else(|| vec![format!("{}/", endpoint)]);
        Client::new(endpoint, self.credential, scopes, self.options)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn token_credential(&self) -> &dyn azure_core::auth::TokenCredential {
        self.credential.as_ref()
    }
    pub(crate) fn scopes(&self) -> Vec<&str> {
        self.scopes.iter().map(String::as_str).collect()
    }
    pub(crate) async fn send(&self, request: &mut azure_core::Request) -> azure_core::Result<azure_core::Response> {
        let mut context = azure_core::Context::default();
        self.pipeline.send(&mut context, request).await
    }
    #[doc = "Create a new `ClientBuilder`."]
    #[must_use]
    pub fn builder(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> ClientBuilder {
        ClientBuilder::new(credential)
    }
    #[doc = "Create a new `Client`."]
    #[must_use]
    pub fn new(
        endpoint: impl Into<String>,
        credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
        scopes: Vec<String>,
        options: azure_core::ClientOptions,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            options,
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn mesh_application_client(&self) -> mesh_application::Client {
        mesh_application::Client(self.clone())
    }
    pub fn mesh_code_package_client(&self) -> mesh_code_package::Client {
        mesh_code_package::Client(self.clone())
    }
    pub fn mesh_gateway_client(&self) -> mesh_gateway::Client {
        mesh_gateway::Client(self.clone())
    }
    pub fn mesh_network_client(&self) -> mesh_network::Client {
        mesh_network::Client(self.clone())
    }
    pub fn mesh_secret_client(&self) -> mesh_secret::Client {
        mesh_secret::Client(self.clone())
    }
    pub fn mesh_secret_value_client(&self) -> mesh_secret_value::Client {
        mesh_secret_value::Client(self.clone())
    }
    pub fn mesh_service_client(&self) -> mesh_service::Client {
        mesh_service::Client(self.clone())
    }
    pub fn mesh_service_replica_client(&self) -> mesh_service_replica::Client {
        mesh_service_replica::Client(self.clone())
    }
    pub fn mesh_volume_client(&self) -> mesh_volume::Client {
        mesh_volume::Client(self.clone())
    }
}
impl Client {
    #[doc = "Get the Service Fabric cluster manifest."]
    #[doc = "Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,\nsecurity configurations, fault, and upgrade domain topologies, etc.\n\nThese properties are specified as part of the ClusterConfig.JSON file while deploying a stand-alone cluster. However, most of the information in the cluster manifest\nis generated internally by service fabric during cluster deployment in other deployment scenarios (e.g. when using Azure portal).\n\nThe contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation."]
    pub fn get_cluster_manifest(&self) -> get_cluster_manifest::Builder {
        get_cluster_manifest::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric cluster."]
    #[doc = "Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.\nSimilarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state."]
    pub fn get_cluster_health(&self) -> get_cluster_health::Builder {
        get_cluster_health::Builder {
            client: self.clone(),
            nodes_health_state_filter: None,
            applications_health_state_filter: None,
            events_health_state_filter: None,
            exclude_health_statistics: None,
            include_system_application_health_statistics: None,
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric cluster using the specified policy."]
    #[doc = "Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.\nSimilarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.\nUse ClusterHealthPolicies to override the health policies used to evaluate the health."]
    pub fn get_cluster_health_using_policy(&self) -> get_cluster_health_using_policy::Builder {
        get_cluster_health_using_policy::Builder {
            client: self.clone(),
            nodes_health_state_filter: None,
            applications_health_state_filter: None,
            events_health_state_filter: None,
            exclude_health_statistics: None,
            include_system_application_health_statistics: None,
            cluster_health_policies: None,
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric cluster using health chunks."]
    #[doc = "Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.\nTo expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description."]
    pub fn get_cluster_health_chunk(&self) -> get_cluster_health_chunk::Builder {
        get_cluster_health_chunk::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric cluster using health chunks."]
    #[doc = "Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.\nThe query description allows users to specify health policies for evaluating the cluster and its children.\nUsers can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.\nThe query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return\nonly services that are in Error or Warning, and all partitions and replicas for one of these services."]
    pub fn get_cluster_health_chunk_using_policy_and_advanced_filters(
        &self,
    ) -> get_cluster_health_chunk_using_policy_and_advanced_filters::Builder {
        get_cluster_health_chunk_using_policy_and_advanced_filters::Builder {
            client: self.clone(),
            cluster_health_chunk_query_description: None,
            timeout: None,
        }
    }
    #[doc = "Sends a health report on the Service Fabric cluster."]
    #[doc = "Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.\nThe report is sent to a Service Fabric gateway node, which forwards to the health store.\nThe report may be accepted by the gateway, but rejected by the health store after extra validation.\nFor example, the health store may reject the report because of an invalid parameter, like a stale sequence number.\nTo see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `health_information`: Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager."]
    pub fn report_cluster_health(&self, health_information: impl Into<models::HealthInformation>) -> report_cluster_health::Builder {
        report_cluster_health::Builder {
            client: self.clone(),
            health_information: health_information.into(),
            immediate: None,
            timeout: None,
        }
    }
    #[doc = "Gets a list of fabric code versions that are provisioned in a Service Fabric cluster."]
    #[doc = "Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version."]
    pub fn get_provisioned_fabric_code_version_info_list(&self) -> get_provisioned_fabric_code_version_info_list::Builder {
        get_provisioned_fabric_code_version_info_list::Builder {
            client: self.clone(),
            code_version: None,
            timeout: None,
        }
    }
    #[doc = "Gets a list of fabric config versions that are provisioned in a Service Fabric cluster."]
    #[doc = "Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version."]
    pub fn get_provisioned_fabric_config_version_info_list(&self) -> get_provisioned_fabric_config_version_info_list::Builder {
        get_provisioned_fabric_config_version_info_list::Builder {
            client: self.clone(),
            config_version: None,
            timeout: None,
        }
    }
    #[doc = "Gets the progress of the current cluster upgrade."]
    #[doc = "Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, get the last state of the previous cluster upgrade."]
    pub fn get_cluster_upgrade_progress(&self) -> get_cluster_upgrade_progress::Builder {
        get_cluster_upgrade_progress::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Get the Service Fabric standalone cluster configuration."]
    #[doc = "The cluster configuration contains properties of the cluster that include different node types on the cluster,\nsecurity configurations, fault, and upgrade domain topologies, etc."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `configuration_api_version`: The API version of the Standalone cluster json configuration."]
    pub fn get_cluster_configuration(&self, configuration_api_version: impl Into<String>) -> get_cluster_configuration::Builder {
        get_cluster_configuration::Builder {
            client: self.clone(),
            configuration_api_version: configuration_api_version.into(),
            timeout: None,
        }
    }
    #[doc = "Get the cluster configuration upgrade status of a Service Fabric standalone cluster."]
    #[doc = "Get the cluster configuration upgrade status details of a Service Fabric standalone cluster."]
    pub fn get_cluster_configuration_upgrade_status(&self) -> get_cluster_configuration_upgrade_status::Builder {
        get_cluster_configuration_upgrade_status::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Get the service state of Service Fabric Upgrade Orchestration Service."]
    #[doc = "Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes."]
    pub fn get_upgrade_orchestration_service_state(&self) -> get_upgrade_orchestration_service_state::Builder {
        get_upgrade_orchestration_service_state::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Update the service state of Service Fabric Upgrade Orchestration Service."]
    #[doc = "Update the service state of Service Fabric Upgrade Orchestration Service. This API is internally used for support purposes."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `upgrade_orchestration_service_state`: Service state of Service Fabric Upgrade Orchestration Service."]
    pub fn set_upgrade_orchestration_service_state(
        &self,
        upgrade_orchestration_service_state: impl Into<models::UpgradeOrchestrationServiceState>,
    ) -> set_upgrade_orchestration_service_state::Builder {
        set_upgrade_orchestration_service_state::Builder {
            client: self.clone(),
            upgrade_orchestration_service_state: upgrade_orchestration_service_state.into(),
            timeout: None,
        }
    }
    #[doc = "Provision the code or configuration packages of a Service Fabric cluster."]
    #[doc = "Validate and provision the code or configuration packages of a Service Fabric cluster."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `provision_fabric_description`: Describes the parameters for provisioning a cluster."]
    pub fn provision_cluster(
        &self,
        provision_fabric_description: impl Into<models::ProvisionFabricDescription>,
    ) -> provision_cluster::Builder {
        provision_cluster::Builder {
            client: self.clone(),
            provision_fabric_description: provision_fabric_description.into(),
            timeout: None,
        }
    }
    #[doc = "Unprovision the code or configuration packages of a Service Fabric cluster."]
    #[doc = "It is supported to unprovision code and configuration separately."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `unprovision_fabric_description`: Describes the parameters for unprovisioning a cluster."]
    pub fn unprovision_cluster(
        &self,
        unprovision_fabric_description: impl Into<models::UnprovisionFabricDescription>,
    ) -> unprovision_cluster::Builder {
        unprovision_cluster::Builder {
            client: self.clone(),
            unprovision_fabric_description: unprovision_fabric_description.into(),
            timeout: None,
        }
    }
    #[doc = "Roll back the upgrade of a Service Fabric cluster."]
    #[doc = "Roll back the code or configuration upgrade of a Service Fabric cluster."]
    pub fn rollback_cluster_upgrade(&self) -> rollback_cluster_upgrade::Builder {
        rollback_cluster_upgrade::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Make the cluster upgrade move on to the next upgrade domain."]
    #[doc = "Make the cluster code or configuration upgrade move on to the next upgrade domain if appropriate."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `resume_cluster_upgrade_description`: Describes the parameters for resuming a cluster upgrade."]
    pub fn resume_cluster_upgrade(
        &self,
        resume_cluster_upgrade_description: impl Into<models::ResumeClusterUpgradeDescription>,
    ) -> resume_cluster_upgrade::Builder {
        resume_cluster_upgrade::Builder {
            client: self.clone(),
            resume_cluster_upgrade_description: resume_cluster_upgrade_description.into(),
            timeout: None,
        }
    }
    #[doc = "Start upgrading the code or configuration version of a Service Fabric cluster."]
    #[doc = "Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `start_cluster_upgrade_description`: Describes the parameters for starting a cluster upgrade."]
    pub fn start_cluster_upgrade(
        &self,
        start_cluster_upgrade_description: impl Into<models::StartClusterUpgradeDescription>,
    ) -> start_cluster_upgrade::Builder {
        start_cluster_upgrade::Builder {
            client: self.clone(),
            start_cluster_upgrade_description: start_cluster_upgrade_description.into(),
            timeout: None,
        }
    }
    #[doc = "Start upgrading the configuration of a Service Fabric standalone cluster."]
    #[doc = "Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `cluster_configuration_upgrade_description`: Parameters for a standalone cluster configuration upgrade."]
    pub fn start_cluster_configuration_upgrade(
        &self,
        cluster_configuration_upgrade_description: impl Into<models::ClusterConfigurationUpgradeDescription>,
    ) -> start_cluster_configuration_upgrade::Builder {
        start_cluster_configuration_upgrade::Builder {
            client: self.clone(),
            cluster_configuration_upgrade_description: cluster_configuration_upgrade_description.into(),
            timeout: None,
        }
    }
    #[doc = "Update the upgrade parameters of a Service Fabric cluster upgrade."]
    #[doc = "Update the upgrade parameters used during a Service Fabric cluster upgrade."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `update_cluster_upgrade_description`: Parameters for updating a cluster upgrade."]
    pub fn update_cluster_upgrade(
        &self,
        update_cluster_upgrade_description: impl Into<models::UpdateClusterUpgradeDescription>,
    ) -> update_cluster_upgrade::Builder {
        update_cluster_upgrade::Builder {
            client: self.clone(),
            update_cluster_upgrade_description: update_cluster_upgrade_description.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the Azure Active Directory metadata used for secured connection to cluster."]
    #[doc = "Gets the Azure Active Directory metadata used for secured connection to cluster.\nThis API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster."]
    pub fn get_aad_metadata(&self) -> get_aad_metadata::Builder {
        get_aad_metadata::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Get the current Service Fabric cluster version."]
    #[doc = "If a cluster upgrade is happening, then this API will return the lowest (older) version of the current and target cluster runtime versions."]
    pub fn get_cluster_version(&self) -> get_cluster_version::Builder {
        get_cluster_version::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Gets the load of a Service Fabric cluster."]
    #[doc = "Retrieves the load information of a Service Fabric cluster for all the metrics that have load or capacity defined."]
    pub fn get_cluster_load(&self) -> get_cluster_load::Builder {
        get_cluster_load::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Changes the verbosity of service placement health reporting."]
    #[doc = "If verbosity is set to true, then detailed health reports will be generated when replicas cannot be placed or dropped.\nIf verbosity is set to false, then no health reports will be generated when replicas cannot be placed or dropped."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `enabled`: The verbosity of service placement health reporting."]
    pub fn toggle_verbose_service_placement_health_reporting(
        &self,
        enabled: bool,
    ) -> toggle_verbose_service_placement_health_reporting::Builder {
        toggle_verbose_service_placement_health_reporting::Builder {
            client: self.clone(),
            enabled,
            timeout: None,
        }
    }
    #[doc = "Gets the list of nodes in the Service Fabric cluster."]
    #[doc = "The response includes the name, status, ID, health, uptime, and other details about the nodes."]
    pub fn get_node_info_list(&self) -> get_node_info_list::Builder {
        get_node_info_list::Builder {
            client: self.clone(),
            continuation_token: None,
            node_status_filter: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Gets the information about a specific node in the Service Fabric cluster."]
    #[doc = "The response includes the name, status, ID, health, uptime, and other details about the node."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn get_node_info(&self, node_name: impl Into<String>) -> get_node_info::Builder {
        get_node_info::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric node."]
    #[doc = "Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn get_node_health(&self, node_name: impl Into<String>) -> get_node_health::Builder {
        get_node_health::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            events_health_state_filter: None,
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric node, by using the specified health policy."]
    #[doc = "Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn get_node_health_using_policy(&self, node_name: impl Into<String>) -> get_node_health_using_policy::Builder {
        get_node_health_using_policy::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            events_health_state_filter: None,
            cluster_health_policy: None,
            timeout: None,
        }
    }
    #[doc = "Sends a health report on the Service Fabric node."]
    #[doc = "Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.\nThe report is sent to a Service Fabric gateway node, which forwards to the health store.\nThe report may be accepted by the gateway, but rejected by the health store after extra validation.\nFor example, the health store may reject the report because of an invalid parameter, like a stale sequence number.\nTo see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `health_information`: Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager."]
    pub fn report_node_health(
        &self,
        node_name: impl Into<String>,
        health_information: impl Into<models::HealthInformation>,
    ) -> report_node_health::Builder {
        report_node_health::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            health_information: health_information.into(),
            immediate: None,
            timeout: None,
        }
    }
    #[doc = "Gets the load information of a Service Fabric node."]
    #[doc = "Retrieves the load information of a Service Fabric node for all the metrics that have load or capacity defined."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn get_node_load_info(&self, node_name: impl Into<String>) -> get_node_load_info::Builder {
        get_node_load_info::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            timeout: None,
        }
    }
    #[doc = "Deactivate a Service Fabric cluster node with the specified deactivation intent."]
    #[doc = "Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node that is deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete, this will cancel the deactivation. A node that goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `deactivation_intent_description`: Describes the intent or reason for deactivating the node."]
    pub fn disable_node(
        &self,
        node_name: impl Into<String>,
        deactivation_intent_description: impl Into<models::DeactivationIntentDescription>,
    ) -> disable_node::Builder {
        disable_node::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            deactivation_intent_description: deactivation_intent_description.into(),
            timeout: None,
        }
    }
    #[doc = "Activate a Service Fabric cluster node that is currently deactivated."]
    #[doc = "Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn enable_node(&self, node_name: impl Into<String>) -> enable_node::Builder {
        enable_node::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            timeout: None,
        }
    }
    #[doc = "Notifies Service Fabric that the persisted state on a node has been permanently removed or lost."]
    #[doc = "This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can come back up with its state intact. Starting from Service Fabric 6.5, in order to use this API for seed nodes, please change the seed nodes to regular (non-seed) nodes and then invoke this API to remove the node state. If the cluster is running on Azure, after the seed node goes down, Service Fabric will try to change it to a non-seed node automatically. To make this happen, make sure the number of non-seed nodes in the primary node type is no less than the number of Down seed nodes. If necessary, add more nodes to the primary node type to achieve this. For standalone cluster, if the Down seed node is not expected to come back up with its state intact, please remove the node from the cluster, see https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-windows-server-add-remove-nodes"]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn remove_node_state(&self, node_name: impl Into<String>) -> remove_node_state::Builder {
        remove_node_state::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            timeout: None,
        }
    }
    #[doc = "Restarts a Service Fabric cluster node."]
    #[doc = "Restarts a Service Fabric cluster node that is already started."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `restart_node_description`: The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process."]
    pub fn restart_node(
        &self,
        node_name: impl Into<String>,
        restart_node_description: impl Into<models::RestartNodeDescription>,
    ) -> restart_node::Builder {
        restart_node::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            restart_node_description: restart_node_description.into(),
            timeout: None,
        }
    }
    #[doc = "Removes configuration overrides on the specified node."]
    #[doc = "This api allows removing all existing configuration overrides on specified node."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn remove_configuration_overrides(&self, node_name: impl Into<String>) -> remove_configuration_overrides::Builder {
        remove_configuration_overrides::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of configuration overrides on the specified node."]
    #[doc = "This api allows getting all existing configuration overrides on the specified node."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn get_configuration_overrides(&self, node_name: impl Into<String>) -> get_configuration_overrides::Builder {
        get_configuration_overrides::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            timeout: None,
        }
    }
    #[doc = "Adds the list of configuration overrides on the specified node."]
    #[doc = "This api allows adding all existing configuration overrides on the specified node."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `config_parameter_override_list`: Description for adding list of configuration overrides."]
    pub fn add_configuration_parameter_overrides(
        &self,
        node_name: impl Into<String>,
        config_parameter_override_list: impl Into<models::ConfigParameterOverrideList>,
    ) -> add_configuration_parameter_overrides::Builder {
        add_configuration_parameter_overrides::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            config_parameter_override_list: config_parameter_override_list.into(),
            force: None,
            timeout: None,
        }
    }
    #[doc = "Removes the list of tags from the specified node."]
    #[doc = "This api allows removing set of tags from the specified node."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `node_tags`: Description for adding list of node tags."]
    pub fn remove_node_tags(&self, node_name: impl Into<String>, node_tags: impl Into<models::NodeTagsList>) -> remove_node_tags::Builder {
        remove_node_tags::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            node_tags: node_tags.into(),
        }
    }
    #[doc = "Adds the list of tags on the specified node."]
    #[doc = "This api allows adding tags to the specified node."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `node_tags`: Description for adding list of node tags."]
    pub fn add_node_tags(&self, node_name: impl Into<String>, node_tags: impl Into<models::NodeTagsList>) -> add_node_tags::Builder {
        add_node_tags::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            node_tags: node_tags.into(),
        }
    }
    #[doc = "Gets the list of application types in the Service Fabric cluster."]
    #[doc = "Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages."]
    pub fn get_application_type_info_list(&self) -> get_application_type_info_list::Builder {
        get_application_type_info_list::Builder {
            client: self.clone(),
            application_type_definition_kind_filter: None,
            exclude_application_parameters: None,
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Gets the list of application types in the Service Fabric cluster matching exactly the specified name."]
    #[doc = "Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status, and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. For example, if there are 10 application types but a page only fits the first three application types, or if max results is set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_type_name`: The name of the application type."]
    pub fn get_application_type_info_list_by_name(
        &self,
        application_type_name: impl Into<String>,
    ) -> get_application_type_info_list_by_name::Builder {
        get_application_type_info_list_by_name::Builder {
            client: self.clone(),
            application_type_name: application_type_name.into(),
            application_type_version: None,
            exclude_application_parameters: None,
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg' package in the external store or using the application package in the image store."]
    #[doc = "Provisions a Service Fabric application type with the cluster. The provision is required before any new applications can be instantiated.\nThe provision operation can be performed either on the application package specified by the relativePathInImageStore, or by using the URI of the external '.sfpkg'."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `provision_application_type_description_base_required_body_param`: The base type of provision application type description which supports either image store-based provision or external store-based provision."]
    pub fn provision_application_type(
        &self,
        provision_application_type_description_base_required_body_param: impl Into<models::ProvisionApplicationTypeDescriptionBase>,
    ) -> provision_application_type::Builder {
        provision_application_type::Builder {
            client: self.clone(),
            provision_application_type_description_base_required_body_param:
                provision_application_type_description_base_required_body_param.into(),
            timeout: None,
        }
    }
    #[doc = "Removes or unregisters a Service Fabric application type from the cluster."]
    #[doc = "This operation can only be performed if all application instances of the application type have been deleted. Once the application type is unregistered, no new application instances can be created for this particular application type."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_type_name`: The name of the application type."]
    #[doc = "* `unprovision_application_type_description_info`: The relative path for the application package in the image store specified during the prior copy operation."]
    pub fn unprovision_application_type(
        &self,
        application_type_name: impl Into<String>,
        unprovision_application_type_description_info: impl Into<models::UnprovisionApplicationTypeDescriptionInfo>,
    ) -> unprovision_application_type::Builder {
        unprovision_application_type::Builder {
            client: self.clone(),
            application_type_name: application_type_name.into(),
            unprovision_application_type_description_info: unprovision_application_type_description_info.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster."]
    #[doc = "Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_type_name`: The name of the application type."]
    #[doc = "* `application_type_version`: The version of the application type."]
    pub fn get_service_type_info_list(
        &self,
        application_type_name: impl Into<String>,
        application_type_version: impl Into<String>,
    ) -> get_service_type_info_list::Builder {
        get_service_type_info_list::Builder {
            client: self.clone(),
            application_type_name: application_type_name.into(),
            application_type_version: application_type_version.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster."]
    #[doc = "Gets the information about a specific service type that is supported by a provisioned application type in a Service Fabric cluster. The provided application type must exist. Otherwise, a 404 status is returned. A 204 response is returned if the specified service type is not found in the cluster."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_type_name`: The name of the application type."]
    #[doc = "* `application_type_version`: The version of the application type."]
    #[doc = "* `service_type_name`: Specifies the name of a Service Fabric service type."]
    pub fn get_service_type_info_by_name(
        &self,
        application_type_name: impl Into<String>,
        application_type_version: impl Into<String>,
        service_type_name: impl Into<String>,
    ) -> get_service_type_info_by_name::Builder {
        get_service_type_info_by_name::Builder {
            client: self.clone(),
            application_type_name: application_type_name.into(),
            application_type_version: application_type_version.into(),
            service_type_name: service_type_name.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the manifest describing a service type."]
    #[doc = "Gets the manifest describing a service type. The response contains the service manifest XML as a string."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_type_name`: The name of the application type."]
    #[doc = "* `application_type_version`: The version of the application type."]
    #[doc = "* `service_manifest_name`: The name of a service manifest registered as part of an application type in a Service Fabric cluster."]
    pub fn get_service_manifest(
        &self,
        application_type_name: impl Into<String>,
        application_type_version: impl Into<String>,
        service_manifest_name: impl Into<String>,
    ) -> get_service_manifest::Builder {
        get_service_manifest::Builder {
            client: self.clone(),
            application_type_name: application_type_name.into(),
            application_type_version: application_type_version.into(),
            service_manifest_name: service_manifest_name.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster."]
    #[doc = "Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_deployed_service_type_info_list(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
    ) -> get_deployed_service_type_info_list::Builder {
        get_deployed_service_type_info_list::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_manifest_name: None,
            timeout: None,
        }
    }
    #[doc = "Gets the information about a specified service type of the application deployed on a node in a Service Fabric cluster."]
    #[doc = "Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation ID of the service package. Each entry represents one activation of a service type, differentiated by the activation ID."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_type_name`: Specifies the name of a Service Fabric service type."]
    pub fn get_deployed_service_type_info_by_name(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        service_type_name: impl Into<String>,
    ) -> get_deployed_service_type_info_by_name::Builder {
        get_deployed_service_type_info_by_name::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_type_name: service_type_name.into(),
            service_manifest_name: None,
            timeout: None,
        }
    }
    #[doc = "Creates a Service Fabric application."]
    #[doc = "Creates a Service Fabric application using the specified description."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_description`: Description for creating an application."]
    pub fn create_application(&self, application_description: impl Into<models::ApplicationDescription>) -> create_application::Builder {
        create_application::Builder {
            client: self.clone(),
            application_description: application_description.into(),
            timeout: None,
        }
    }
    #[doc = "Deletes an existing Service Fabric application."]
    #[doc = "An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if a service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of its services."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn delete_application(&self, application_id: impl Into<String>) -> delete_application::Builder {
        delete_application::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            force_remove: None,
            timeout: None,
        }
    }
    #[doc = "Gets load information about a Service Fabric application."]
    #[doc = "Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the application is occupying currently, and application load metric information about the application."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_application_load_info(&self, application_id: impl Into<String>) -> get_application_load_info::Builder {
        get_application_load_info::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of applications created in the Service Fabric cluster that match the specified filters."]
    #[doc = "Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match the specified filters. The response includes the name, type, status, parameters, and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time."]
    pub fn get_application_info_list(&self) -> get_application_info_list::Builder {
        get_application_info_list::Builder {
            client: self.clone(),
            application_definition_kind_filter: None,
            application_type_name: None,
            exclude_application_parameters: None,
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Gets information about a Service Fabric application."]
    #[doc = "Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters, and other details about the application."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_application_info(&self, application_id: impl Into<String>) -> get_application_info::Builder {
        get_application_info::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            exclude_application_parameters: None,
            timeout: None,
        }
    }
    #[doc = "Gets the health of the service fabric application."]
    #[doc = "Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the health store, it will return Error."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_application_health(&self, application_id: impl Into<String>) -> get_application_health::Builder {
        get_application_health::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            events_health_state_filter: None,
            deployed_applications_health_state_filter: None,
            services_health_state_filter: None,
            exclude_health_statistics: None,
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric application using the specified policy."]
    #[doc = "Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_application_health_using_policy(&self, application_id: impl Into<String>) -> get_application_health_using_policy::Builder {
        get_application_health_using_policy::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            events_health_state_filter: None,
            deployed_applications_health_state_filter: None,
            services_health_state_filter: None,
            exclude_health_statistics: None,
            application_health_policy: None,
            timeout: None,
        }
    }
    #[doc = "Sends a health report on the Service Fabric application."]
    #[doc = "Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.\nThe report is sent to a Service Fabric gateway Application, which forwards to the health store.\nThe report may be accepted by the gateway, but rejected by the health store after extra validation.\nFor example, the health store may reject the report because of an invalid parameter, like a stale sequence number.\nTo see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `health_information`: Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager."]
    pub fn report_application_health(
        &self,
        application_id: impl Into<String>,
        health_information: impl Into<models::HealthInformation>,
    ) -> report_application_health::Builder {
        report_application_health::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            health_information: health_information.into(),
            immediate: None,
            timeout: None,
        }
    }
    #[doc = "Starts upgrading an application in the Service Fabric cluster."]
    #[doc = "Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.\nNote, [ApplicationParameter](https://docs.microsoft.com/dotnet/api/system.fabric.description.applicationdescription.applicationparameters)s are not preserved across an application upgrade.\nIn order to preserve current application parameters, the user should get the parameters using [GetApplicationInfo](./GetApplicationInfo.md) operation first and pass them into the upgrade API call as shown in the example."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `application_upgrade_description`: Parameters for an application upgrade."]
    pub fn start_application_upgrade(
        &self,
        application_id: impl Into<String>,
        application_upgrade_description: impl Into<models::ApplicationUpgradeDescription>,
    ) -> start_application_upgrade::Builder {
        start_application_upgrade::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            application_upgrade_description: application_upgrade_description.into(),
            timeout: None,
        }
    }
    #[doc = "Gets details for the latest upgrade performed on this application."]
    #[doc = "Returns information about the state of the latest application upgrade along with details to aid debugging application health issues."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_application_upgrade(&self, application_id: impl Into<String>) -> get_application_upgrade::Builder {
        get_application_upgrade::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            timeout: None,
        }
    }
    #[doc = "Updates an ongoing application upgrade in the Service Fabric cluster."]
    #[doc = "Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `application_upgrade_update_description`: Parameters for updating an existing application upgrade."]
    pub fn update_application_upgrade(
        &self,
        application_id: impl Into<String>,
        application_upgrade_update_description: impl Into<models::ApplicationUpgradeUpdateDescription>,
    ) -> update_application_upgrade::Builder {
        update_application_upgrade::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            application_upgrade_update_description: application_upgrade_update_description.into(),
            timeout: None,
        }
    }
    #[doc = "Resumes upgrading an application in the Service Fabric cluster."]
    #[doc = "Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `resume_application_upgrade_description`: Describes the parameters for resuming an application upgrade."]
    pub fn resume_application_upgrade(
        &self,
        application_id: impl Into<String>,
        resume_application_upgrade_description: impl Into<models::ResumeApplicationUpgradeDescription>,
    ) -> resume_application_upgrade::Builder {
        resume_application_upgrade::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            resume_application_upgrade_description: resume_application_upgrade_description.into(),
            timeout: None,
        }
    }
    #[doc = "Starts rolling back the currently on-going upgrade of an application in the Service Fabric cluster."]
    #[doc = "Starts rolling back the current application upgrade to the previous version. This API can only be used to roll back the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version, including rolling back to a previous version."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn rollback_application_upgrade(&self, application_id: impl Into<String>) -> rollback_application_upgrade::Builder {
        rollback_application_upgrade::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of applications deployed on a Service Fabric node."]
    #[doc = "Gets the list of applications deployed on a Service Fabric node. The results do not include information about deployed system applications unless explicitly queried for by ID. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    pub fn get_deployed_application_info_list(&self, node_name: impl Into<String>) -> get_deployed_application_info_list::Builder {
        get_deployed_application_info_list::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            timeout: None,
            include_health_state: None,
            continuation_token: None,
            max_results: None,
        }
    }
    #[doc = "Gets the information about an application deployed on a Service Fabric node."]
    #[doc = "This query returns system application information if the application ID provided is for system application. Results encompass deployed applications in active, activating, and downloading states. This query requires that the node name corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service Fabric nodes on the cluster."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_deployed_application_info(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
    ) -> get_deployed_application_info::Builder {
        get_deployed_application_info::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            timeout: None,
            include_health_state: None,
        }
    }
    #[doc = "Gets the information about health of an application deployed on a Service Fabric node."]
    #[doc = "Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_deployed_application_health(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
    ) -> get_deployed_application_health::Builder {
        get_deployed_application_health::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            events_health_state_filter: None,
            deployed_service_packages_health_state_filter: None,
            exclude_health_statistics: None,
            timeout: None,
        }
    }
    #[doc = "Gets the information about health of an application deployed on a Service Fabric node. using the specified policy."]
    #[doc = "Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_deployed_application_health_using_policy(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
    ) -> get_deployed_application_health_using_policy::Builder {
        get_deployed_application_health_using_policy::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            events_health_state_filter: None,
            deployed_service_packages_health_state_filter: None,
            application_health_policy: None,
            exclude_health_statistics: None,
            timeout: None,
        }
    }
    #[doc = "Sends a health report on the Service Fabric application deployed on a Service Fabric node."]
    #[doc = "Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.\nThe report is sent to a Service Fabric gateway Service, which forwards to the health store.\nThe report may be accepted by the gateway, but rejected by the health store after extra validation.\nFor example, the health store may reject the report because of an invalid parameter, like a stale sequence number.\nTo see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `health_information`: Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager."]
    pub fn report_deployed_application_health(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        health_information: impl Into<models::HealthInformation>,
    ) -> report_deployed_application_health::Builder {
        report_deployed_application_health::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            health_information: health_information.into(),
            immediate: None,
            timeout: None,
        }
    }
    #[doc = "Gets the manifest describing an application type."]
    #[doc = "The response contains the application manifest XML as a string."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_type_name`: The name of the application type."]
    #[doc = "* `application_type_version`: The version of the application type."]
    pub fn get_application_manifest(
        &self,
        application_type_name: impl Into<String>,
        application_type_version: impl Into<String>,
    ) -> get_application_manifest::Builder {
        get_application_manifest::Builder {
            client: self.clone(),
            application_type_name: application_type_name.into(),
            application_type_version: application_type_version.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the information about all services belonging to the application specified by the application ID."]
    #[doc = "Returns the information about all services belonging to the application specified by the application ID."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_service_info_list(&self, application_id: impl Into<String>) -> get_service_info_list::Builder {
        get_service_info_list::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            service_type_name: None,
            continuation_token: None,
            timeout: None,
        }
    }
    #[doc = "Gets the information about the specific service belonging to the Service Fabric application."]
    #[doc = "Returns the information about the specified service belonging to the specified Service Fabric application."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_service_info(&self, application_id: impl Into<String>, service_id: impl Into<String>) -> get_service_info::Builder {
        get_service_info::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            service_id: service_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the name of the Service Fabric application for a service."]
    #[doc = "Gets the name of the application for the specified service. A 404 FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID does not exist."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_application_name_info(&self, service_id: impl Into<String>) -> get_application_name_info::Builder {
        get_application_name_info::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            timeout: None,
        }
    }
    #[doc = "Creates the specified Service Fabric service."]
    #[doc = "This api allows creating a new Service Fabric stateless or stateful service under a specified Service Fabric application. The description for creating the service includes partitioning information and optional properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_description`: The information necessary to create a service."]
    pub fn create_service(
        &self,
        application_id: impl Into<String>,
        service_description: impl Into<models::ServiceDescription>,
    ) -> create_service::Builder {
        create_service::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            service_description: service_description.into(),
            timeout: None,
        }
    }
    #[doc = "Creates a Service Fabric service from the service template."]
    #[doc = "Creates a Service Fabric service from the service template defined in the application manifest. A service template contains the properties that will be same for the service instance of the same type. The API allows overriding the properties that are usually different for different services of the same service type."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_from_template_description`: Describes the service that needs to be created from the template defined in the application manifest."]
    pub fn create_service_from_template(
        &self,
        application_id: impl Into<String>,
        service_from_template_description: impl Into<models::ServiceFromTemplateDescription>,
    ) -> create_service_from_template::Builder {
        create_service_from_template::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            service_from_template_description: service_from_template_description.into(),
            timeout: None,
        }
    }
    #[doc = "Deletes an existing Service Fabric service."]
    #[doc = "A service must be created before it can be deleted. By default, Service Fabric will try to close service replicas in a graceful manner and then delete the service. However, if the service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn delete_service(&self, service_id: impl Into<String>) -> delete_service::Builder {
        delete_service::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            force_remove: None,
            timeout: None,
        }
    }
    #[doc = "Updates a Service Fabric service using the specified update description."]
    #[doc = "This API allows updating properties of a running Service Fabric service. The set of properties that can be updated are a subset of the properties that were specified at the time of creating the service. The current set of properties can be obtained using `GetServiceDescription` API. Note that updating the properties of a running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a long running background operation that involves moving the application from one version to another, one upgrade domain at a time, whereas update applies the new properties immediately to the service."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `service_update_description`: The information necessary to update a service."]
    pub fn update_service(
        &self,
        service_id: impl Into<String>,
        service_update_description: impl Into<models::ServiceUpdateDescription>,
    ) -> update_service::Builder {
        update_service::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            service_update_description: service_update_description.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the description of an existing Service Fabric service."]
    #[doc = "Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_service_description(&self, service_id: impl Into<String>) -> get_service_description::Builder {
        get_service_description::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the health of the specified Service Fabric service."]
    #[doc = "Gets the health information of the specified service.\nUse EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.\nUse PartitionsHealthStateFilter to filter the collection of partitions returned.\nIf you specify a service that does not exist in the health store, this request returns an error."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_service_health(&self, service_id: impl Into<String>) -> get_service_health::Builder {
        get_service_health::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            events_health_state_filter: None,
            partitions_health_state_filter: None,
            exclude_health_statistics: None,
            timeout: None,
        }
    }
    #[doc = "Gets the health of the specified Service Fabric service, by using the specified health policy."]
    #[doc = "Gets the health information of the specified service.\nIf the application health policy is specified, the health evaluation uses it to get the aggregated health state.\nIf the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.\nUse EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.\nUse PartitionsHealthStateFilter to filter the collection of partitions returned.\nIf you specify a service that does not exist in the health store, this request returns an error."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_service_health_using_policy(&self, service_id: impl Into<String>) -> get_service_health_using_policy::Builder {
        get_service_health_using_policy::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            events_health_state_filter: None,
            partitions_health_state_filter: None,
            application_health_policy: None,
            exclude_health_statistics: None,
            timeout: None,
        }
    }
    #[doc = "Sends a health report on the Service Fabric service."]
    #[doc = "Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.\nThe report is sent to a Service Fabric gateway Service, which forwards to the health store.\nThe report may be accepted by the gateway, but rejected by the health store after extra validation.\nFor example, the health store may reject the report because of an invalid parameter, like a stale sequence number.\nTo see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `health_information`: Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager."]
    pub fn report_service_health(
        &self,
        service_id: impl Into<String>,
        health_information: impl Into<models::HealthInformation>,
    ) -> report_service_health::Builder {
        report_service_health::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            health_information: health_information.into(),
            immediate: None,
            timeout: None,
        }
    }
    #[doc = "Resolve a Service Fabric partition."]
    #[doc = "Resolve a Service Fabric service partition to get the endpoints of the service replicas."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn resolve_service(&self, service_id: impl Into<String>) -> resolve_service::Builder {
        resolve_service::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_key_type: None,
            partition_key_value: None,
            previous_rsp_version: None,
            timeout: None,
        }
    }
    #[doc = "Gets the information about unplaced replica of the service."]
    #[doc = "Returns the information about the unplaced replicas of the service.\nIf PartitionId is specified, then result will contain information only about unplaced replicas for that partition.\nIf PartitionId is not specified, then result will contain information about unplaced replicas for all partitions of that service.\nIf OnlyQueryPrimaries is set to true, then result will contain information only about primary replicas, and will ignore unplaced secondary replicas."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_unplaced_replica_information(&self, service_id: impl Into<String>) -> get_unplaced_replica_information::Builder {
        get_unplaced_replica_information::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_id: None,
            only_query_primaries: None,
            timeout: None,
        }
    }
    #[doc = "Gets ordered list of partitions."]
    #[doc = "Retrieves partitions which are most/least loaded according to specified metric."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `metric_name`: Name of the metric based on which to get ordered list of partitions."]
    pub fn get_loaded_partition_info_list(&self, metric_name: impl Into<String>) -> get_loaded_partition_info_list::Builder {
        get_loaded_partition_info_list::Builder {
            client: self.clone(),
            metric_name: metric_name.into(),
            service_name: None,
            ordering: None,
            max_results: None,
            continuation_token: None,
        }
    }
    #[doc = "Gets the list of partitions of a Service Fabric service."]
    #[doc = "The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_partition_info_list(&self, service_id: impl Into<String>) -> get_partition_info_list::Builder {
        get_partition_info_list::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            continuation_token: None,
            timeout: None,
        }
    }
    #[doc = "Gets the information about a Service Fabric partition."]
    #[doc = "Gets the information about the specified partition. The response includes the partition ID, partitioning scheme information, keys supported by the partition, status, health, and other details about the partition."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_partition_info(&self, partition_id: impl Into<String>) -> get_partition_info::Builder {
        get_partition_info::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the name of the Service Fabric service for a partition."]
    #[doc = "Gets name of the service for the specified partition. A 404 error is returned if the partition ID does not exist in the cluster."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_service_name_info(&self, partition_id: impl Into<String>) -> get_service_name_info::Builder {
        get_service_name_info::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the health of the specified Service Fabric partition."]
    #[doc = "Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.\nUse ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.\nIf you specify a partition that does not exist in the health store, this request returns an error."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_partition_health(&self, partition_id: impl Into<String>) -> get_partition_health::Builder {
        get_partition_health::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            events_health_state_filter: None,
            replicas_health_state_filter: None,
            exclude_health_statistics: None,
            timeout: None,
        }
    }
    #[doc = "Gets the health of the specified Service Fabric partition, by using the specified health policy."]
    #[doc = "Gets the health information of the specified partition.\nIf the application health policy is specified, the health evaluation uses it to get the aggregated health state.\nIf the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.\nUse EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.\nUse ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.\nIf you specify a partition that does not exist in the health store, this request returns an error."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_partition_health_using_policy(&self, partition_id: impl Into<String>) -> get_partition_health_using_policy::Builder {
        get_partition_health_using_policy::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            events_health_state_filter: None,
            replicas_health_state_filter: None,
            application_health_policy: None,
            exclude_health_statistics: None,
            timeout: None,
        }
    }
    #[doc = "Sends a health report on the Service Fabric partition."]
    #[doc = "Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.\nThe report is sent to a Service Fabric gateway Partition, which forwards to the health store.\nThe report may be accepted by the gateway, but rejected by the health store after extra validation.\nFor example, the health store may reject the report because of an invalid parameter, like a stale sequence number.\nTo see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `health_information`: Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager."]
    pub fn report_partition_health(
        &self,
        partition_id: impl Into<String>,
        health_information: impl Into<models::HealthInformation>,
    ) -> report_partition_health::Builder {
        report_partition_health::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            health_information: health_information.into(),
            immediate: None,
            timeout: None,
        }
    }
    #[doc = "Gets the load information of the specified Service Fabric partition."]
    #[doc = "Returns information about the load of a specified partition.\nThe response includes a list of load reports for a Service Fabric partition.\nEach report includes the load metric name, value, and last reported time in UTC."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_partition_load_information(&self, partition_id: impl Into<String>) -> get_partition_load_information::Builder {
        get_partition_load_information::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Resets the current load of a Service Fabric partition."]
    #[doc = "Resets the current load of a Service Fabric partition to the default load for the service."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn reset_partition_load(&self, partition_id: impl Into<String>) -> reset_partition_load::Builder {
        reset_partition_load::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Indicates to the Service Fabric cluster that it should attempt to recover a specific partition that is currently stuck in quorum loss."]
    #[doc = "This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn recover_partition(&self, partition_id: impl Into<String>) -> recover_partition::Builder {
        recover_partition::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss."]
    #[doc = "Indicates to the Service Fabric cluster that it should attempt to recover the specified service that is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn recover_service_partitions(&self, service_id: impl Into<String>) -> recover_service_partitions::Builder {
        recover_service_partitions::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            timeout: None,
        }
    }
    #[doc = "Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss."]
    #[doc = "Indicates to the Service Fabric cluster that it should attempt to recover the system services that are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss."]
    pub fn recover_system_partitions(&self) -> recover_system_partitions::Builder {
        recover_system_partitions::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss."]
    #[doc = "This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss."]
    pub fn recover_all_partitions(&self) -> recover_all_partitions::Builder {
        recover_all_partitions::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Moves the primary replica of a partition of a stateful service."]
    #[doc = "This command moves the primary replica of a partition of a stateful service, respecting all constraints.\nIf NodeName parameter is specified, primary will be moved to the specified node (if constraints allow it).\nIf NodeName parameter is not specified, primary replica will be moved to a random node in the cluster.\nIf IgnoreConstraints parameter is specified and set to true, then primary will be moved regardless of the constraints."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn move_primary_replica(&self, partition_id: impl Into<String>) -> move_primary_replica::Builder {
        move_primary_replica::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            node_name: None,
            ignore_constraints: None,
            timeout: None,
        }
    }
    #[doc = "Moves the secondary replica of a partition of a stateful service."]
    #[doc = "This command moves the secondary replica of a partition of a stateful service, respecting all constraints.\nCurrentNodeName parameter must be specified to identify the replica that is moved.\nSource node name must be specified, but new node name can be omitted, and in that case replica is moved to a random node.\nIf IgnoreConstraints parameter is specified and set to true, then secondary will be moved regardless of the constraints."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `current_node_name`: The name of the source node for secondary replica move."]
    pub fn move_secondary_replica(
        &self,
        partition_id: impl Into<String>,
        current_node_name: impl Into<String>,
    ) -> move_secondary_replica::Builder {
        move_secondary_replica::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            current_node_name: current_node_name.into(),
            new_node_name: None,
            ignore_constraints: None,
            timeout: None,
        }
    }
    #[doc = "Update the loads of provided partitions for specific metrics."]
    #[doc = "Updates the load value and predicted load value for all the partitions provided for specified metrics."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_metric_load_description_list`: Description of updating load for list of partitions."]
    pub fn update_partition_load(
        &self,
        partition_metric_load_description_list: impl Into<models::PartitionMetricLoadDescriptionList>,
    ) -> update_partition_load::Builder {
        update_partition_load::Builder {
            client: self.clone(),
            partition_metric_load_description_list: partition_metric_load_description_list.into(),
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Moves the instance of a partition of a stateless service."]
    #[doc = "This command moves the instance of a partition of a stateless service, respecting all constraints.\nPartition id and service name must be specified to be able to move the instance.\nCurrentNodeName when specified identifies the instance that is moved. If not specified, random instance will be moved \nNew node name can be omitted, and in that case instance is moved to a random node.\nIf IgnoreConstraints parameter is specified and set to true, then instance will be moved regardless of the constraints."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn move_instance(&self, service_id: impl Into<String>, partition_id: impl Into<String>) -> move_instance::Builder {
        move_instance::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_id: partition_id.into(),
            current_node_name: None,
            new_node_name: None,
            ignore_constraints: None,
            timeout: None,
        }
    }
    #[doc = "Creates a new repair task."]
    #[doc = "For clusters that have the Repair Manager Service configured,\nthis API provides a way to create repair tasks that run automatically or manually.\nFor repair tasks that run automatically, an appropriate repair executor\nmust be running for each repair action to run automatically.\nThese are currently only available in specially-configured Azure Cloud Services.\n\nTo create a manual repair task, provide the set of impacted node names and the\nexpected impact. When the state of the created repair task changes to approved,\nyou can safely perform repair actions on those nodes.\n\nThis API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `repair_task`: Describes the repair task to be created or updated."]
    pub fn create_repair_task(&self, repair_task: impl Into<models::RepairTask>) -> create_repair_task::Builder {
        create_repair_task::Builder {
            client: self.clone(),
            repair_task: repair_task.into(),
        }
    }
    #[doc = "Requests the cancellation of the given repair task."]
    #[doc = "This API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `repair_task_cancel_description`: Describes the repair task to be cancelled."]
    pub fn cancel_repair_task(
        &self,
        repair_task_cancel_description: impl Into<models::RepairTaskCancelDescription>,
    ) -> cancel_repair_task::Builder {
        cancel_repair_task::Builder {
            client: self.clone(),
            repair_task_cancel_description: repair_task_cancel_description.into(),
        }
    }
    #[doc = "Deletes a completed repair task."]
    #[doc = "This API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `repair_task_delete_description`: Describes the repair task to be deleted."]
    pub fn delete_repair_task(
        &self,
        repair_task_delete_description: impl Into<models::RepairTaskDeleteDescription>,
    ) -> delete_repair_task::Builder {
        delete_repair_task::Builder {
            client: self.clone(),
            repair_task_delete_description: repair_task_delete_description.into(),
        }
    }
    #[doc = "Gets a list of repair tasks matching the given filters."]
    #[doc = "This API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    pub fn get_repair_task_list(&self) -> get_repair_task_list::Builder {
        get_repair_task_list::Builder {
            client: self.clone(),
            task_id_filter: None,
            state_filter: None,
            executor_filter: None,
        }
    }
    #[doc = "Forces the approval of the given repair task."]
    #[doc = "This API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `repair_task_approve_description`: Describes the repair task to be approved."]
    pub fn force_approve_repair_task(
        &self,
        repair_task_approve_description: impl Into<models::RepairTaskApproveDescription>,
    ) -> force_approve_repair_task::Builder {
        force_approve_repair_task::Builder {
            client: self.clone(),
            repair_task_approve_description: repair_task_approve_description.into(),
        }
    }
    #[doc = "Updates the health policy of the given repair task."]
    #[doc = "This API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `repair_task_update_health_policy_description`: Describes the repair task healthy policy to be updated."]
    pub fn update_repair_task_health_policy(
        &self,
        repair_task_update_health_policy_description: impl Into<models::RepairTaskUpdateHealthPolicyDescription>,
    ) -> update_repair_task_health_policy::Builder {
        update_repair_task_health_policy::Builder {
            client: self.clone(),
            repair_task_update_health_policy_description: repair_task_update_health_policy_description.into(),
        }
    }
    #[doc = "Updates the execution state of a repair task."]
    #[doc = "This API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `repair_task`: Describes the repair task to be created or updated."]
    pub fn update_repair_execution_state(&self, repair_task: impl Into<models::RepairTask>) -> update_repair_execution_state::Builder {
        update_repair_execution_state::Builder {
            client: self.clone(),
            repair_task: repair_task.into(),
        }
    }
    #[doc = "Gets the information about replicas of a Service Fabric service partition."]
    #[doc = "The GetReplicas endpoint returns information about the replicas of the specified partition. The response includes the ID, role, status, health, node name, uptime, and other details about the replica."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_replica_info_list(&self, partition_id: impl Into<String>) -> get_replica_info_list::Builder {
        get_replica_info_list::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            continuation_token: None,
            timeout: None,
        }
    }
    #[doc = "Gets the information about a replica of a Service Fabric partition."]
    #[doc = "The response includes the ID, role, status, health, node name, uptime, and other details about the replica."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `replica_id`: The identifier of the replica."]
    pub fn get_replica_info(&self, partition_id: impl Into<String>, replica_id: impl Into<String>) -> get_replica_info::Builder {
        get_replica_info::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            replica_id: replica_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric stateful service replica or stateless service instance."]
    #[doc = "Gets the health of a Service Fabric replica.\nUse EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `replica_id`: The identifier of the replica."]
    pub fn get_replica_health(&self, partition_id: impl Into<String>, replica_id: impl Into<String>) -> get_replica_health::Builder {
        get_replica_health::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            replica_id: replica_id.into(),
            events_health_state_filter: None,
            timeout: None,
        }
    }
    #[doc = "Gets the health of a Service Fabric stateful service replica or stateless service instance using the specified policy."]
    #[doc = "Gets the health of a Service Fabric stateful service replica or stateless service instance.\nUse EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.\nUse ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `replica_id`: The identifier of the replica."]
    pub fn get_replica_health_using_policy(
        &self,
        partition_id: impl Into<String>,
        replica_id: impl Into<String>,
    ) -> get_replica_health_using_policy::Builder {
        get_replica_health_using_policy::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            replica_id: replica_id.into(),
            events_health_state_filter: None,
            application_health_policy: None,
            timeout: None,
        }
    }
    #[doc = "Sends a health report on the Service Fabric replica."]
    #[doc = "Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.\nThe report is sent to a Service Fabric gateway Replica, which forwards to the health store.\nThe report may be accepted by the gateway, but rejected by the health store after extra validation.\nFor example, the health store may reject the report because of an invalid parameter, like a stale sequence number.\nTo see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `replica_id`: The identifier of the replica."]
    #[doc = "* `service_kind`: The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values."]
    #[doc = "* `health_information`: Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager."]
    pub fn report_replica_health(
        &self,
        partition_id: impl Into<String>,
        replica_id: impl Into<String>,
        service_kind: impl Into<String>,
        health_information: impl Into<models::HealthInformation>,
    ) -> report_replica_health::Builder {
        report_replica_health::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            replica_id: replica_id.into(),
            service_kind: service_kind.into(),
            health_information: health_information.into(),
            immediate: None,
            timeout: None,
        }
    }
    #[doc = "Gets the list of replicas deployed on a Service Fabric node."]
    #[doc = "Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition ID, replica ID, status of the replica, name of the service, name of the service type, and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_deployed_service_replica_info_list(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
    ) -> get_deployed_service_replica_info_list::Builder {
        get_deployed_service_replica_info_list::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            partition_id: None,
            service_manifest_name: None,
            timeout: None,
        }
    }
    #[doc = "Gets the details of replica deployed on a Service Fabric node."]
    #[doc = "Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `replica_id`: The identifier of the replica."]
    pub fn get_deployed_service_replica_detail_info(
        &self,
        node_name: impl Into<String>,
        partition_id: impl Into<String>,
        replica_id: impl Into<String>,
    ) -> get_deployed_service_replica_detail_info::Builder {
        get_deployed_service_replica_detail_info::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            partition_id: partition_id.into(),
            replica_id: replica_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the details of replica deployed on a Service Fabric node."]
    #[doc = "Gets the details of the replica deployed on a Service Fabric node. The information includes service kind, service name, current service operation, current service operation start date time, partition ID, replica/instance ID, reported load, and other information."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_deployed_service_replica_detail_info_by_partition_id(
        &self,
        node_name: impl Into<String>,
        partition_id: impl Into<String>,
    ) -> get_deployed_service_replica_detail_info_by_partition_id::Builder {
        get_deployed_service_replica_detail_info_by_partition_id::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Restarts a service replica of a persisted service running on a node."]
    #[doc = "Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `replica_id`: The identifier of the replica."]
    pub fn restart_replica(
        &self,
        node_name: impl Into<String>,
        partition_id: impl Into<String>,
        replica_id: impl Into<String>,
    ) -> restart_replica::Builder {
        restart_replica::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            partition_id: partition_id.into(),
            replica_id: replica_id.into(),
            timeout: None,
        }
    }
    #[doc = "Removes a service replica running on a node."]
    #[doc = "This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services. In addition, the forceRemove flag impacts all other replicas hosted in the same process."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `replica_id`: The identifier of the replica."]
    pub fn remove_replica(
        &self,
        node_name: impl Into<String>,
        partition_id: impl Into<String>,
        replica_id: impl Into<String>,
    ) -> remove_replica::Builder {
        remove_replica::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            partition_id: partition_id.into(),
            replica_id: replica_id.into(),
            force_remove: None,
            timeout: None,
        }
    }
    #[doc = "Gets the list of service packages deployed on a Service Fabric node."]
    #[doc = "Returns the information about the service packages deployed on a Service Fabric node for the given application."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_deployed_service_package_info_list(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
    ) -> get_deployed_service_package_info_list::Builder {
        get_deployed_service_package_info_list::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of service packages deployed on a Service Fabric node matching exactly the specified name."]
    #[doc = "Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_package_name`: The name of the service package."]
    pub fn get_deployed_service_package_info_list_by_name(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        service_package_name: impl Into<String>,
    ) -> get_deployed_service_package_info_list_by_name::Builder {
        get_deployed_service_package_info_list_by_name::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_package_name: service_package_name.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the information about health of a service package for a specific application deployed for a Service Fabric node and application."]
    #[doc = "Gets the information about health of a service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_package_name`: The name of the service package."]
    pub fn get_deployed_service_package_health(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        service_package_name: impl Into<String>,
    ) -> get_deployed_service_package_health::Builder {
        get_deployed_service_package_health::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_package_name: service_package_name.into(),
            events_health_state_filter: None,
            timeout: None,
        }
    }
    #[doc = "Gets the information about health of service package for a specific application deployed on a Service Fabric node using the specified policy."]
    #[doc = "Gets the information about health of a service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_package_name`: The name of the service package."]
    pub fn get_deployed_service_package_health_using_policy(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        service_package_name: impl Into<String>,
    ) -> get_deployed_service_package_health_using_policy::Builder {
        get_deployed_service_package_health_using_policy::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_package_name: service_package_name.into(),
            events_health_state_filter: None,
            application_health_policy: None,
            timeout: None,
        }
    }
    #[doc = "Sends a health report on the Service Fabric deployed service package."]
    #[doc = "Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.\nThe report is sent to a Service Fabric gateway Service, which forwards to the health store.\nThe report may be accepted by the gateway, but rejected by the health store after extra validation.\nFor example, the health store may reject the report because of an invalid parameter, like a stale sequence number.\nTo see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_package_name`: The name of the service package."]
    #[doc = "* `health_information`: Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager."]
    pub fn report_deployed_service_package_health(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        service_package_name: impl Into<String>,
        health_information: impl Into<models::HealthInformation>,
    ) -> report_deployed_service_package_health::Builder {
        report_deployed_service_package_health::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_package_name: service_package_name.into(),
            health_information: health_information.into(),
            immediate: None,
            timeout: None,
        }
    }
    #[doc = "Downloads all of the code packages associated with specified service manifest on the specified node."]
    #[doc = "This API provides a way to download code packages including the container images on a specific node outside of the normal application deployment and upgrade path. This is useful for the large code packages and container images to be present on the node before the actual application deployment and upgrade, thus significantly reducing the total time required for the deployment or upgrade."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `deploy_service_package_to_node_description`: Describes information for deploying a service package to a Service Fabric node."]
    pub fn deploy_service_package_to_node(
        &self,
        node_name: impl Into<String>,
        deploy_service_package_to_node_description: impl Into<models::DeployServicePackageToNodeDescription>,
    ) -> deploy_service_package_to_node::Builder {
        deploy_service_package_to_node::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            deploy_service_package_to_node_description: deploy_service_package_to_node_description.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of code packages deployed on a Service Fabric node."]
    #[doc = "Gets the list of code packages deployed on a Service Fabric node for the given application."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_deployed_code_package_info_list(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
    ) -> get_deployed_code_package_info_list::Builder {
        get_deployed_code_package_info_list::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_manifest_name: None,
            code_package_name: None,
            timeout: None,
        }
    }
    #[doc = "Restarts a code package deployed on a Service Fabric node in a cluster."]
    #[doc = "Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `restart_deployed_code_package_description`: Describes the deployed code package on Service Fabric node to restart."]
    pub fn restart_deployed_code_package(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        restart_deployed_code_package_description: impl Into<models::RestartDeployedCodePackageDescription>,
    ) -> restart_deployed_code_package::Builder {
        restart_deployed_code_package::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            restart_deployed_code_package_description: restart_deployed_code_package_description.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the container logs for container deployed on a Service Fabric node."]
    #[doc = "Gets the container logs for container deployed on a Service Fabric node for the given code package."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_manifest_name`: The name of a service manifest registered as part of an application type in a Service Fabric cluster."]
    #[doc = "* `code_package_name`: The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster."]
    pub fn get_container_logs_deployed_on_node(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        service_manifest_name: impl Into<String>,
        code_package_name: impl Into<String>,
    ) -> get_container_logs_deployed_on_node::Builder {
        get_container_logs_deployed_on_node::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_manifest_name: service_manifest_name.into(),
            code_package_name: code_package_name.into(),
            tail: None,
            previous: None,
            timeout: None,
        }
    }
    #[doc = "Invoke container API on a container deployed on a Service Fabric node."]
    #[doc = "Invoke container API on a container deployed on a Service Fabric node for the given code package."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `service_manifest_name`: The name of a service manifest registered as part of an application type in a Service Fabric cluster."]
    #[doc = "* `code_package_name`: The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster."]
    #[doc = "* `code_package_instance_id`: ID that uniquely identifies a code package instance deployed on a service fabric node."]
    #[doc = "* `container_api_request_body`: Parameters for making container API call"]
    pub fn invoke_container_api(
        &self,
        node_name: impl Into<String>,
        application_id: impl Into<String>,
        service_manifest_name: impl Into<String>,
        code_package_name: impl Into<String>,
        code_package_instance_id: impl Into<String>,
        container_api_request_body: impl Into<models::ContainerApiRequestBody>,
    ) -> invoke_container_api::Builder {
        invoke_container_api::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            application_id: application_id.into(),
            service_manifest_name: service_manifest_name.into(),
            code_package_name: code_package_name.into(),
            code_package_instance_id: code_package_instance_id.into(),
            container_api_request_body: container_api_request_body.into(),
            timeout: None,
        }
    }
    #[doc = "Creates a Service Fabric compose deployment."]
    #[doc = "Compose is a file format that describes multi-container applications. This API allows deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is created, its status can be tracked via the `GetComposeDeploymentStatus` API."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `create_compose_deployment_description`: Describes the compose deployment that needs to be created."]
    pub fn create_compose_deployment(
        &self,
        create_compose_deployment_description: impl Into<models::CreateComposeDeploymentDescription>,
    ) -> create_compose_deployment::Builder {
        create_compose_deployment::Builder {
            client: self.clone(),
            create_compose_deployment_description: create_compose_deployment_description.into(),
            timeout: None,
        }
    }
    #[doc = "Gets information about a Service Fabric compose deployment."]
    #[doc = "Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status, and other details about the deployment."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `deployment_name`: The identity of the deployment."]
    pub fn get_compose_deployment_status(&self, deployment_name: impl Into<String>) -> get_compose_deployment_status::Builder {
        get_compose_deployment_status::Builder {
            client: self.clone(),
            deployment_name: deployment_name.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of compose deployments created in the Service Fabric cluster."]
    #[doc = "Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status, and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page."]
    pub fn get_compose_deployment_status_list(&self) -> get_compose_deployment_status_list::Builder {
        get_compose_deployment_status_list::Builder {
            client: self.clone(),
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Gets details for the latest upgrade performed on this Service Fabric compose deployment."]
    #[doc = "Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `deployment_name`: The identity of the deployment."]
    pub fn get_compose_deployment_upgrade_progress(
        &self,
        deployment_name: impl Into<String>,
    ) -> get_compose_deployment_upgrade_progress::Builder {
        get_compose_deployment_upgrade_progress::Builder {
            client: self.clone(),
            deployment_name: deployment_name.into(),
            timeout: None,
        }
    }
    #[doc = "Deletes an existing Service Fabric compose deployment from cluster."]
    #[doc = "Deletes an existing Service Fabric compose deployment."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `deployment_name`: The identity of the deployment."]
    pub fn remove_compose_deployment(&self, deployment_name: impl Into<String>) -> remove_compose_deployment::Builder {
        remove_compose_deployment::Builder {
            client: self.clone(),
            deployment_name: deployment_name.into(),
            timeout: None,
        }
    }
    #[doc = "Starts upgrading a compose deployment in the Service Fabric cluster."]
    #[doc = "Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `deployment_name`: The identity of the deployment."]
    #[doc = "* `compose_deployment_upgrade_description`: Parameters for upgrading compose deployment."]
    pub fn start_compose_deployment_upgrade(
        &self,
        deployment_name: impl Into<String>,
        compose_deployment_upgrade_description: impl Into<models::ComposeDeploymentUpgradeDescription>,
    ) -> start_compose_deployment_upgrade::Builder {
        start_compose_deployment_upgrade::Builder {
            client: self.clone(),
            deployment_name: deployment_name.into(),
            compose_deployment_upgrade_description: compose_deployment_upgrade_description.into(),
            timeout: None,
        }
    }
    #[doc = "Starts rolling back a compose deployment upgrade in the Service Fabric cluster."]
    #[doc = "Rollback a service fabric compose deployment upgrade."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `deployment_name`: The identity of the deployment."]
    pub fn start_rollback_compose_deployment_upgrade(
        &self,
        deployment_name: impl Into<String>,
    ) -> start_rollback_compose_deployment_upgrade::Builder {
        start_rollback_compose_deployment_upgrade::Builder {
            client: self.clone(),
            deployment_name: deployment_name.into(),
            timeout: None,
        }
    }
    #[doc = "Get the status of Chaos."]
    #[doc = "Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule."]
    pub fn get_chaos(&self) -> get_chaos::Builder {
        get_chaos::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Starts Chaos in the cluster."]
    #[doc = "If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.\nIf Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.\nRefer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `chaos_parameters`: Describes all the parameters to configure a Chaos run."]
    pub fn start_chaos(&self, chaos_parameters: impl Into<models::ChaosParameters>) -> start_chaos::Builder {
        start_chaos::Builder {
            client: self.clone(),
            chaos_parameters: chaos_parameters.into(),
            timeout: None,
        }
    }
    #[doc = "Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state."]
    #[doc = "Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state.\nOnce a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling."]
    pub fn stop_chaos(&self) -> stop_chaos::Builder {
        stop_chaos::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Gets the next segment of the Chaos events based on the continuation token or the time range."]
    #[doc = "To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range\nthrough StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call.\nWhen there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token."]
    pub fn get_chaos_events(&self) -> get_chaos_events::Builder {
        get_chaos_events::Builder {
            client: self.clone(),
            continuation_token: None,
            start_time_utc: None,
            end_time_utc: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Get the Chaos Schedule defining when and how to run Chaos."]
    #[doc = "Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos."]
    pub fn get_chaos_schedule(&self) -> get_chaos_schedule::Builder {
        get_chaos_schedule::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Set the schedule used by Chaos."]
    #[doc = "Chaos will automatically schedule runs based on the Chaos Schedule.\nThe Chaos Schedule will be updated if the provided version matches the version on the server.\nWhen updating the Chaos Schedule, the version on the server is incremented by 1.\nThe version on the server will wrap back to 0 after reaching a large number.\nIf Chaos is running when this call is made, the call will fail."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `chaos_schedule`: Describes the schedule used by Chaos."]
    pub fn post_chaos_schedule(&self, chaos_schedule: impl Into<models::ChaosScheduleDescription>) -> post_chaos_schedule::Builder {
        post_chaos_schedule::Builder {
            client: self.clone(),
            chaos_schedule: chaos_schedule.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the image store content information."]
    #[doc = "Returns the information about the image store content at the specified contentPath. The contentPath is relative to the root of the image store."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `content_path`: Relative path to file or folder in the image store from its root."]
    pub fn get_image_store_content(&self, content_path: impl Into<String>) -> get_image_store_content::Builder {
        get_image_store_content::Builder {
            client: self.clone(),
            content_path: content_path.into(),
            timeout: None,
        }
    }
    #[doc = "Uploads contents of the file to the image store."]
    #[doc = "Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named \"_.dir\". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `content_path`: Relative path to file or folder in the image store from its root."]
    pub fn upload_file(&self, content_path: impl Into<String>) -> upload_file::Builder {
        upload_file::Builder {
            client: self.clone(),
            content_path: content_path.into(),
            timeout: None,
        }
    }
    #[doc = "Deletes existing image store content."]
    #[doc = "Deletes existing image store content being found within the given image store relative path. This command can be used to delete uploaded application packages once they are provisioned."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `content_path`: Relative path to file or folder in the image store from its root."]
    pub fn delete_image_store_content(&self, content_path: impl Into<String>) -> delete_image_store_content::Builder {
        delete_image_store_content::Builder {
            client: self.clone(),
            content_path: content_path.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the content information at the root of the image store."]
    #[doc = "Returns the information about the image store content at the root of the image store."]
    pub fn get_image_store_root_content(&self) -> get_image_store_root_content::Builder {
        get_image_store_root_content::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Copies image store content internally"]
    #[doc = "Copies the image store content from the source image store relative path to the destination image store relative path."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `image_store_copy_description`: Describes the copy description for the image store."]
    pub fn copy_image_store_content(
        &self,
        image_store_copy_description: impl Into<models::ImageStoreCopyDescription>,
    ) -> copy_image_store_content::Builder {
        copy_image_store_content::Builder {
            client: self.clone(),
            image_store_copy_description: image_store_copy_description.into(),
            timeout: None,
        }
    }
    #[doc = "Cancels an image store upload session."]
    #[doc = "The DELETE request will cause the existing upload session to expire and remove any previously uploaded file chunks."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `session_id`: A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed."]
    pub fn delete_image_store_upload_session(&self, session_id: impl Into<String>) -> delete_image_store_upload_session::Builder {
        delete_image_store_upload_session::Builder {
            client: self.clone(),
            session_id: session_id.into(),
            timeout: None,
        }
    }
    #[doc = "Commit an image store upload session."]
    #[doc = "When all file chunks have been uploaded, the upload session needs to be committed explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30 minutes after the last chunk received. "]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `session_id`: A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed."]
    pub fn commit_image_store_upload_session(&self, session_id: impl Into<String>) -> commit_image_store_upload_session::Builder {
        commit_image_store_upload_session::Builder {
            client: self.clone(),
            session_id: session_id.into(),
            timeout: None,
        }
    }
    #[doc = "Get the image store upload session by ID."]
    #[doc = "Gets the image store upload session identified by the given ID. User can query the upload session at any time during uploading. "]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `session_id`: A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed."]
    pub fn get_image_store_upload_session_by_id(&self, session_id: impl Into<String>) -> get_image_store_upload_session_by_id::Builder {
        get_image_store_upload_session_by_id::Builder {
            client: self.clone(),
            session_id: session_id.into(),
            timeout: None,
        }
    }
    #[doc = "Get the image store upload session by relative path."]
    #[doc = "Gets the image store upload session associated with the given image store relative path. User can query the upload session at any time during uploading. "]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `content_path`: Relative path to file or folder in the image store from its root."]
    pub fn get_image_store_upload_session_by_path(
        &self,
        content_path: impl Into<String>,
    ) -> get_image_store_upload_session_by_path::Builder {
        get_image_store_upload_session_by_path::Builder {
            client: self.clone(),
            content_path: content_path.into(),
            timeout: None,
        }
    }
    #[doc = "Uploads a file chunk to the image store relative path."]
    #[doc = "Uploads a file chunk to the image store with the specified upload session ID and image store relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file upload from scratch whenever there is a network interruption. Use this option if the file size is large.\n\nTo perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store relative path already exists, it will be overwritten when the upload session commits."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `content_path`: Relative path to file or folder in the image store from its root."]
    #[doc = "* `session_id`: A GUID generated by the user for a file uploading. It identifies an image store upload session which keeps track of all file chunks until it is committed."]
    #[doc = "* `content_range`: When uploading file chunks to the image store, the Content-Range header field need to be configured and sent with a request. The format should looks like \"bytes {First-Byte-Position}-{Last-Byte-Position}/{File-Length}\". For example, Content-Range:bytes 300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes."]
    pub fn upload_file_chunk(
        &self,
        content_path: impl Into<String>,
        session_id: impl Into<String>,
        content_range: impl Into<String>,
    ) -> upload_file_chunk::Builder {
        upload_file_chunk::Builder {
            client: self.clone(),
            content_path: content_path.into(),
            session_id: session_id.into(),
            content_range: content_range.into(),
            timeout: None,
        }
    }
    #[doc = "Get the folder size at the root of the image store."]
    #[doc = "Returns the total size of files at the root and children folders in image store."]
    pub fn get_image_store_root_folder_size(&self) -> get_image_store_root_folder_size::Builder {
        get_image_store_root_folder_size::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Get the size of a folder in image store"]
    #[doc = "Gets the total size of file under a image store folder, specified by contentPath. The contentPath is relative to the root of the image store."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `content_path`: Relative path to file or folder in the image store from its root."]
    pub fn get_image_store_folder_size(&self, content_path: impl Into<String>) -> get_image_store_folder_size::Builder {
        get_image_store_folder_size::Builder {
            client: self.clone(),
            content_path: content_path.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the overall ImageStore information"]
    #[doc = "Returns information about the primary ImageStore replica, such as disk capacity and available disk space at the node it is on, and several categories of the ImageStore's file system usage."]
    pub fn get_image_store_info(&self) -> get_image_store_info::Builder {
        get_image_store_info::Builder {
            client: self.clone(),
            timeout: None,
        }
    }
    #[doc = "Invokes an administrative command on the given Infrastructure Service instance."]
    #[doc = "For clusters that have one or more instances of the Infrastructure Service configured,\nthis API provides a way to send infrastructure-specific commands to a particular\ninstance of the Infrastructure Service.\n\nAvailable commands and their corresponding response formats vary depending upon\nthe infrastructure on which the cluster is running.\n\nThis API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `command`: The text of the command to be invoked. The content of the command is infrastructure-specific."]
    pub fn invoke_infrastructure_command(&self, command: impl Into<String>) -> invoke_infrastructure_command::Builder {
        invoke_infrastructure_command::Builder {
            client: self.clone(),
            command: command.into(),
            service_id: None,
            timeout: None,
        }
    }
    #[doc = "Invokes a read-only query on the given infrastructure service instance."]
    #[doc = "For clusters that have one or more instances of the Infrastructure Service configured,\nthis API provides a way to send infrastructure-specific queries to a particular\ninstance of the Infrastructure Service.\n\nAvailable commands and their corresponding response formats vary depending upon\nthe infrastructure on which the cluster is running.\n\nThis API supports the Service Fabric platform; it is not meant to be used directly from your code."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `command`: The text of the command to be invoked. The content of the command is infrastructure-specific."]
    pub fn invoke_infrastructure_query(&self, command: impl Into<String>) -> invoke_infrastructure_query::Builder {
        invoke_infrastructure_query::Builder {
            client: self.clone(),
            command: command.into(),
            service_id: None,
            timeout: None,
        }
    }
    #[doc = "This API will induce data loss for the specified partition. It will trigger a call to the OnDataLossAsync API of the partition."]
    #[doc = "This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.\nActual data loss will depend on the specified DataLossMode.\n\n- PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.\n- FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.\n\nThis API should only be called with a stateful service as the target.\n\nCalling this API with a system service as the target is not advised.\n\nNote:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.\nIt will not restore data if the command has progressed far enough to cause data loss.\n\nCall the GetDataLossProgress API with the same OperationId to return information on the operation started with this API."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    #[doc = "* `data_loss_mode`: This enum is passed to the StartDataLoss API to indicate what type of data loss to induce."]
    pub fn start_data_loss(
        &self,
        service_id: impl Into<String>,
        partition_id: impl Into<String>,
        operation_id: impl Into<String>,
        data_loss_mode: impl Into<String>,
    ) -> start_data_loss::Builder {
        start_data_loss::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_id: partition_id.into(),
            operation_id: operation_id.into(),
            data_loss_mode: data_loss_mode.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the progress of a partition data loss operation started using the StartDataLoss API."]
    #[doc = "Gets the progress of a data loss operation started with StartDataLoss, using the OperationId."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    pub fn get_data_loss_progress(
        &self,
        service_id: impl Into<String>,
        partition_id: impl Into<String>,
        operation_id: impl Into<String>,
    ) -> get_data_loss_progress::Builder {
        get_data_loss_progress::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_id: partition_id.into(),
            operation_id: operation_id.into(),
            timeout: None,
        }
    }
    #[doc = "Induces quorum loss for a given stateful service partition."]
    #[doc = "This API is useful for a temporary quorum loss situation on your service.\n\nCall the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.\n\nThis can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    #[doc = "* `quorum_loss_mode`: This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce."]
    #[doc = "* `quorum_loss_duration`: The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds."]
    pub fn start_quorum_loss(
        &self,
        service_id: impl Into<String>,
        partition_id: impl Into<String>,
        operation_id: impl Into<String>,
        quorum_loss_mode: impl Into<String>,
        quorum_loss_duration: i64,
    ) -> start_quorum_loss::Builder {
        start_quorum_loss::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_id: partition_id.into(),
            operation_id: operation_id.into(),
            quorum_loss_mode: quorum_loss_mode.into(),
            quorum_loss_duration,
            timeout: None,
        }
    }
    #[doc = "Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss API."]
    #[doc = "Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    pub fn get_quorum_loss_progress(
        &self,
        service_id: impl Into<String>,
        partition_id: impl Into<String>,
        operation_id: impl Into<String>,
    ) -> get_quorum_loss_progress::Builder {
        get_quorum_loss_progress::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_id: partition_id.into(),
            operation_id: operation_id.into(),
            timeout: None,
        }
    }
    #[doc = "This API will restart some or all replicas or instances of the specified partition."]
    #[doc = "This API is useful for testing failover.\n\nIf used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.\n\nCall the GetPartitionRestartProgress API using the same OperationId to get the progress."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    #[doc = "* `restart_partition_mode`: Describe which partitions to restart."]
    pub fn start_partition_restart(
        &self,
        service_id: impl Into<String>,
        partition_id: impl Into<String>,
        operation_id: impl Into<String>,
        restart_partition_mode: impl Into<String>,
    ) -> start_partition_restart::Builder {
        start_partition_restart::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_id: partition_id.into(),
            operation_id: operation_id.into(),
            restart_partition_mode: restart_partition_mode.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the progress of a PartitionRestart operation started using StartPartitionRestart."]
    #[doc = "Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    pub fn get_partition_restart_progress(
        &self,
        service_id: impl Into<String>,
        partition_id: impl Into<String>,
        operation_id: impl Into<String>,
    ) -> get_partition_restart_progress::Builder {
        get_partition_restart_progress::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            partition_id: partition_id.into(),
            operation_id: operation_id.into(),
            timeout: None,
        }
    }
    #[doc = "Starts or stops a cluster node."]
    #[doc = "Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in \"Start\" for the NodeTransitionType parameter.\nTo stop a node, pass in \"Stop\" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.\nCall GetNodeTransitionProgress with the same OperationId to get the progress of the operation."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    #[doc = "* `node_transition_type`: Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up."]
    #[doc = "* `node_instance_id`: The node instance ID of the target node.  This can be determined through GetNodeInfo API."]
    #[doc = "* `stop_duration_in_seconds`: The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up."]
    pub fn start_node_transition(
        &self,
        node_name: impl Into<String>,
        operation_id: impl Into<String>,
        node_transition_type: impl Into<String>,
        node_instance_id: impl Into<String>,
        stop_duration_in_seconds: i32,
    ) -> start_node_transition::Builder {
        start_node_transition::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            operation_id: operation_id.into(),
            node_transition_type: node_transition_type.into(),
            node_instance_id: node_instance_id.into(),
            stop_duration_in_seconds,
            timeout: None,
        }
    }
    #[doc = "Gets the progress of an operation started using StartNodeTransition."]
    #[doc = "Gets the progress of an operation started with StartNodeTransition using the provided OperationId."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    pub fn get_node_transition_progress(
        &self,
        node_name: impl Into<String>,
        operation_id: impl Into<String>,
    ) -> get_node_transition_progress::Builder {
        get_node_transition_progress::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            operation_id: operation_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets a list of user-induced fault operations filtered by provided input."]
    #[doc = "Gets the list of user-induced fault operations filtered by provided input."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `type_filter`: Used to filter on OperationType for user-induced operations.\n\n- 65535 - select all\n- 1 - select PartitionDataLoss.\n- 2 - select PartitionQuorumLoss.\n- 4 - select PartitionRestart.\n- 8 - select NodeTransition."]
    #[doc = "* `state_filter`: Used to filter on OperationState's for user-induced operations.\n\n- 65535 - select All\n- 1 - select Running\n- 2 - select RollingBack\n- 8 - select Completed\n- 16 - select Faulted\n- 32 - select Cancelled\n- 64 - select ForceCancelled"]
    pub fn get_fault_operation_list(&self, type_filter: i64, state_filter: i64) -> get_fault_operation_list::Builder {
        get_fault_operation_list::Builder {
            client: self.clone(),
            type_filter,
            state_filter,
            timeout: None,
        }
    }
    #[doc = "Cancels a user-induced fault operation."]
    #[doc = "The following APIs start fault operations that may be cancelled by using CancelOperation: StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.\n\nIf force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state\nmay be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already\nbeen called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.\nClarification: OperationState.RollingBack means that the system will be/is cleaning up internal system state caused by executing the command.  It will not restore data if the\ntest command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.\nIt will not restore the target partition's data, if the command progressed far enough to cause data loss.\n\nImportant note:  if this API is invoked with force==true, internal state may be left behind."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `operation_id`: A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API"]
    #[doc = "* `force`: Indicates whether to gracefully roll back and clean up internal system state modified by executing the user-induced operation."]
    pub fn cancel_operation(&self, operation_id: impl Into<String>, force: bool) -> cancel_operation::Builder {
        cancel_operation::Builder {
            client: self.clone(),
            operation_id: operation_id.into(),
            force,
            timeout: None,
        }
    }
    #[doc = "Creates a backup policy."]
    #[doc = "Creates a backup policy which can be associated later with a Service Fabric application, service or a partition for periodic backup."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `backup_policy_description`: Describes the backup policy."]
    pub fn create_backup_policy(
        &self,
        backup_policy_description: impl Into<models::BackupPolicyDescription>,
    ) -> create_backup_policy::Builder {
        create_backup_policy::Builder {
            client: self.clone(),
            backup_policy_description: backup_policy_description.into(),
            timeout: None,
            validate_connection: None,
        }
    }
    #[doc = "Deletes the backup policy."]
    #[doc = "Deletes an existing backup policy. A backup policy must be created before it can be deleted. A currently active backup policy, associated with any Service Fabric application, service or partition, cannot be deleted without first deleting the mapping."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `backup_policy_name`: The name of the backup policy."]
    pub fn delete_backup_policy(&self, backup_policy_name: impl Into<String>) -> delete_backup_policy::Builder {
        delete_backup_policy::Builder {
            client: self.clone(),
            backup_policy_name: backup_policy_name.into(),
            timeout: None,
        }
    }
    #[doc = "Gets all the backup policies configured."]
    #[doc = "Get a list of all the backup policies configured."]
    pub fn get_backup_policy_list(&self) -> get_backup_policy_list::Builder {
        get_backup_policy_list::Builder {
            client: self.clone(),
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Gets a particular backup policy by name."]
    #[doc = "Gets a particular backup policy identified by {backupPolicyName}"]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `backup_policy_name`: The name of the backup policy."]
    pub fn get_backup_policy_by_name(&self, backup_policy_name: impl Into<String>) -> get_backup_policy_by_name::Builder {
        get_backup_policy_by_name::Builder {
            client: self.clone(),
            backup_policy_name: backup_policy_name.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of backup entities that are associated with this policy."]
    #[doc = "Returns a list of Service Fabric application, service or partition which are associated with this backup policy."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `backup_policy_name`: The name of the backup policy."]
    pub fn get_all_entities_backed_up_by_policy(
        &self,
        backup_policy_name: impl Into<String>,
    ) -> get_all_entities_backed_up_by_policy::Builder {
        get_all_entities_backed_up_by_policy::Builder {
            client: self.clone(),
            backup_policy_name: backup_policy_name.into(),
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Updates the backup policy."]
    #[doc = "Updates the backup policy identified by {backupPolicyName}"]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `backup_policy_description`: Describes the backup policy."]
    #[doc = "* `backup_policy_name`: The name of the backup policy."]
    pub fn update_backup_policy(
        &self,
        backup_policy_description: impl Into<models::BackupPolicyDescription>,
        backup_policy_name: impl Into<String>,
    ) -> update_backup_policy::Builder {
        update_backup_policy::Builder {
            client: self.clone(),
            backup_policy_description: backup_policy_description.into(),
            backup_policy_name: backup_policy_name.into(),
            timeout: None,
            validate_connection: None,
        }
    }
    #[doc = "Enables periodic backup of stateful partitions under this Service Fabric application."]
    #[doc = "Enables periodic backup of stateful partitions which are part of this Service Fabric application. Each partition is backed up individually as per the specified backup policy description. \nNote only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `enable_backup_description`: Specifies the parameters for enabling backup."]
    pub fn enable_application_backup(
        &self,
        application_id: impl Into<String>,
        enable_backup_description: impl Into<models::EnableBackupDescription>,
    ) -> enable_application_backup::Builder {
        enable_application_backup::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            enable_backup_description: enable_backup_description.into(),
            timeout: None,
        }
    }
    #[doc = "Disables periodic backup of Service Fabric application."]
    #[doc = "Disables periodic backup of Service Fabric application which was previously enabled."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn disable_application_backup(&self, application_id: impl Into<String>) -> disable_application_backup::Builder {
        disable_application_backup::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            timeout: None,
            disable_backup_description: None,
        }
    }
    #[doc = "Gets the Service Fabric application backup configuration information."]
    #[doc = "Gets the Service Fabric backup configuration information for the application and the services and partitions under this application."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_application_backup_configuration_info(
        &self,
        application_id: impl Into<String>,
    ) -> get_application_backup_configuration_info::Builder {
        get_application_backup_configuration_info::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Gets the list of backups available for every partition in this application."]
    #[doc = "Returns a list of backups available for every partition in this Service Fabric application. The server enumerates all the backups available at the backup location configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn get_application_backup_list(&self, application_id: impl Into<String>) -> get_application_backup_list::Builder {
        get_application_backup_list::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            timeout: None,
            latest: None,
            start_date_time_filter: None,
            end_date_time_filter: None,
            continuation_token: None,
            max_results: None,
        }
    }
    #[doc = "Suspends periodic backup for the specified Service Fabric application."]
    #[doc = "The application which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire application's hierarchy. It means all the services and partitions under this application are now suspended for backup."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn suspend_application_backup(&self, application_id: impl Into<String>) -> suspend_application_backup::Builder {
        suspend_application_backup::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            timeout: None,
        }
    }
    #[doc = "Resumes periodic backup of a Service Fabric application which was previously suspended."]
    #[doc = "The previously suspended Service Fabric application resumes taking periodic backup as per the backup policy currently configured for the same."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    pub fn resume_application_backup(&self, application_id: impl Into<String>) -> resume_application_backup::Builder {
        resume_application_backup::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            timeout: None,
        }
    }
    #[doc = "Enables periodic backup of stateful partitions under this Service Fabric service."]
    #[doc = "Enables periodic backup of stateful partitions which are part of this Service Fabric service. Each partition is backed up individually as per the specified backup policy description. In case the application, which the service is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup for this service and its partitions (unless explicitly overridden at the partition level).\nNote only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `enable_backup_description`: Specifies the parameters for enabling backup."]
    pub fn enable_service_backup(
        &self,
        service_id: impl Into<String>,
        enable_backup_description: impl Into<models::EnableBackupDescription>,
    ) -> enable_service_backup::Builder {
        enable_service_backup::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            enable_backup_description: enable_backup_description.into(),
            timeout: None,
        }
    }
    #[doc = "Disables periodic backup of Service Fabric service which was previously enabled."]
    #[doc = "Disables periodic backup of Service Fabric service which was previously enabled. Backup must be explicitly enabled before it can be disabled.\nIn case the backup is enabled for the Service Fabric application, which this service is part of, this service would continue to be periodically backed up as per the policy mapped at the application level."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn disable_service_backup(&self, service_id: impl Into<String>) -> disable_service_backup::Builder {
        disable_service_backup::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            disable_backup_description: None,
            timeout: None,
        }
    }
    #[doc = "Gets the Service Fabric service backup configuration information."]
    #[doc = "Gets the Service Fabric backup configuration information for the service and the partitions under this service."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_service_backup_configuration_info(&self, service_id: impl Into<String>) -> get_service_backup_configuration_info::Builder {
        get_service_backup_configuration_info::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            continuation_token: None,
            max_results: None,
            timeout: None,
        }
    }
    #[doc = "Gets the list of backups available for every partition in this service."]
    #[doc = "Returns a list of backups available for every partition in this Service Fabric service. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for every partition."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn get_service_backup_list(&self, service_id: impl Into<String>) -> get_service_backup_list::Builder {
        get_service_backup_list::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            timeout: None,
            latest: None,
            start_date_time_filter: None,
            end_date_time_filter: None,
            continuation_token: None,
            max_results: None,
        }
    }
    #[doc = "Suspends periodic backup for the specified Service Fabric service."]
    #[doc = "The service which is configured to take periodic backups, is suspended for taking further backups till it is resumed again. This operation applies to the entire service's hierarchy. It means all the partitions under this service are now suspended for backup."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn suspend_service_backup(&self, service_id: impl Into<String>) -> suspend_service_backup::Builder {
        suspend_service_backup::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            timeout: None,
        }
    }
    #[doc = "Resumes periodic backup of a Service Fabric service which was previously suspended."]
    #[doc = "The previously suspended Service Fabric service resumes taking periodic backup as per the backup policy currently configured for the same."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    pub fn resume_service_backup(&self, service_id: impl Into<String>) -> resume_service_backup::Builder {
        resume_service_backup::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            timeout: None,
        }
    }
    #[doc = "Enables periodic backup of the stateful persisted partition."]
    #[doc = "Enables periodic backup of stateful persisted partition. Each partition is backed up as per the specified backup policy description. In case the application or service, which is partition is part of, is already enabled for backup then this operation would override the policy being used to take the periodic backup of this partition.\nNote only C# based Reliable Actor and Reliable Stateful services are currently supported for periodic backup."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `enable_backup_description`: Specifies the parameters for enabling backup."]
    pub fn enable_partition_backup(
        &self,
        partition_id: impl Into<String>,
        enable_backup_description: impl Into<models::EnableBackupDescription>,
    ) -> enable_partition_backup::Builder {
        enable_partition_backup::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            enable_backup_description: enable_backup_description.into(),
            timeout: None,
        }
    }
    #[doc = "Disables periodic backup of Service Fabric partition which was previously enabled."]
    #[doc = "Disables periodic backup of partition which was previously enabled. Backup must be explicitly enabled before it can be disabled. \nIn case the backup is enabled for the Service Fabric application or service, which this partition is part of, this partition would continue to be periodically backed up as per the policy mapped at the higher level entity."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn disable_partition_backup(&self, partition_id: impl Into<String>) -> disable_partition_backup::Builder {
        disable_partition_backup::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            disable_backup_description: None,
            timeout: None,
        }
    }
    #[doc = "Gets the partition backup configuration information"]
    #[doc = "Gets the Service Fabric Backup configuration information for the specified partition."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_partition_backup_configuration_info(
        &self,
        partition_id: impl Into<String>,
    ) -> get_partition_backup_configuration_info::Builder {
        get_partition_backup_configuration_info::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of backups available for the specified partition."]
    #[doc = "Returns a list of backups available for the specified partition. The server enumerates all the backups available in the backup store configured in the backup policy. It also allows filtering of the result based on start and end datetime or just fetching the latest available backup for the partition."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_partition_backup_list(&self, partition_id: impl Into<String>) -> get_partition_backup_list::Builder {
        get_partition_backup_list::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
            latest: None,
            start_date_time_filter: None,
            end_date_time_filter: None,
        }
    }
    #[doc = "Suspends periodic backup for the specified partition."]
    #[doc = "The partition which is configured to take periodic backups, is suspended for taking further backups till it is resumed again."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn suspend_partition_backup(&self, partition_id: impl Into<String>) -> suspend_partition_backup::Builder {
        suspend_partition_backup::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Resumes periodic backup of partition which was previously suspended."]
    #[doc = "The previously suspended partition resumes taking periodic backup as per the backup policy currently configured for the same."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn resume_partition_backup(&self, partition_id: impl Into<String>) -> resume_partition_backup::Builder {
        resume_partition_backup::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Triggers backup of the partition's state."]
    #[doc = "Creates a backup of the stateful persisted partition's state. In case the partition is already being periodically backed up, then by default the new backup is created at the same backup storage. One can also override the same by specifying the backup storage details as part of the request body. Once the backup is initiated, its progress can be tracked using the GetBackupProgress operation. \nIn case, the operation times out, specify a greater backup timeout value in the query parameter."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn backup_partition(&self, partition_id: impl Into<String>) -> backup_partition::Builder {
        backup_partition::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            backup_partition_description: None,
            backup_timeout: None,
            timeout: None,
        }
    }
    #[doc = "Gets details for the latest backup triggered for this partition."]
    #[doc = "Returns information about the state of the latest backup along with details or failure reason in case of completion."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_partition_backup_progress(&self, partition_id: impl Into<String>) -> get_partition_backup_progress::Builder {
        get_partition_backup_progress::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Triggers restore of the state of the partition using the specified restore partition description."]
    #[doc = "Restores the state of a of the stateful persisted partition using the specified backup point. In case the partition is already being periodically backed up, then by default the backup point is looked for in the storage specified in backup policy. One can also override the same by specifying the backup storage details as part of the restore partition description in body. Once the restore is initiated, its progress can be tracked using the GetRestoreProgress operation. \nIn case, the operation times out, specify a greater restore timeout value in the query parameter."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `restore_partition_description`: Describes the parameters to restore the partition."]
    pub fn restore_partition(
        &self,
        partition_id: impl Into<String>,
        restore_partition_description: impl Into<models::RestorePartitionDescription>,
    ) -> restore_partition::Builder {
        restore_partition::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            restore_partition_description: restore_partition_description.into(),
            restore_timeout: None,
            timeout: None,
        }
    }
    #[doc = "Gets details for the latest restore operation triggered for this partition."]
    #[doc = "Returns information about the state of the latest restore operation along with details or failure reason in case of completion."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    pub fn get_partition_restore_progress(&self, partition_id: impl Into<String>) -> get_partition_restore_progress::Builder {
        get_partition_restore_progress::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            timeout: None,
        }
    }
    #[doc = "Gets the list of backups available for the specified backed up entity at the specified backup location."]
    #[doc = "Gets the list of backups available for the specified backed up entity (Application, Service or Partition) at the specified backup location (FileShare or Azure Blob Storage)."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `get_backup_by_storage_query_description`: Describes the filters and backup storage details to be used for enumerating backups."]
    pub fn get_backups_from_backup_location(
        &self,
        get_backup_by_storage_query_description: impl Into<models::GetBackupByStorageQueryDescription>,
    ) -> get_backups_from_backup_location::Builder {
        get_backups_from_backup_location::Builder {
            client: self.clone(),
            get_backup_by_storage_query_description: get_backup_by_storage_query_description.into(),
            timeout: None,
            continuation_token: None,
            max_results: None,
        }
    }
    #[doc = "Creates a Service Fabric name."]
    #[doc = "Creates the specified Service Fabric name."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_description`: Describes the Service Fabric name to be created."]
    pub fn create_name(&self, name_description: impl Into<models::NameDescription>) -> create_name::Builder {
        create_name::Builder {
            client: self.clone(),
            name_description: name_description.into(),
            timeout: None,
        }
    }
    #[doc = "Returns whether the Service Fabric name exists."]
    #[doc = "Returns whether the specified Service Fabric name exists."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_id`: The Service Fabric name, without the 'fabric:' URI scheme."]
    pub fn get_name_exists_info(&self, name_id: impl Into<String>) -> get_name_exists_info::Builder {
        get_name_exists_info::Builder {
            client: self.clone(),
            name_id: name_id.into(),
            timeout: None,
        }
    }
    #[doc = "Deletes a Service Fabric name."]
    #[doc = "Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_id`: The Service Fabric name, without the 'fabric:' URI scheme."]
    pub fn delete_name(&self, name_id: impl Into<String>) -> delete_name::Builder {
        delete_name::Builder {
            client: self.clone(),
            name_id: name_id.into(),
            timeout: None,
        }
    }
    #[doc = "Enumerates all the Service Fabric names under a given name."]
    #[doc = "Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token, which can be used to get the next page. Querying a name that doesn't exist will fail."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_id`: The Service Fabric name, without the 'fabric:' URI scheme."]
    pub fn get_sub_name_info_list(&self, name_id: impl Into<String>) -> get_sub_name_info_list::Builder {
        get_sub_name_info_list::Builder {
            client: self.clone(),
            name_id: name_id.into(),
            recursive: None,
            continuation_token: None,
            timeout: None,
        }
    }
    #[doc = "Gets information on all Service Fabric properties under a given name."]
    #[doc = "A Service Fabric name can have one or more named properties that store custom information. This operation gets the information about these properties in a paged list. The information includes name, value, and metadata about each of the properties."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_id`: The Service Fabric name, without the 'fabric:' URI scheme."]
    pub fn get_property_info_list(&self, name_id: impl Into<String>) -> get_property_info_list::Builder {
        get_property_info_list::Builder {
            client: self.clone(),
            name_id: name_id.into(),
            include_values: None,
            continuation_token: None,
            timeout: None,
        }
    }
    #[doc = "Gets the specified Service Fabric property."]
    #[doc = "Gets the specified Service Fabric property under a given name. This will always return both value and metadata."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_id`: The Service Fabric name, without the 'fabric:' URI scheme."]
    #[doc = "* `property_name`: Specifies the name of the property to get."]
    pub fn get_property_info(&self, name_id: impl Into<String>, property_name: impl Into<String>) -> get_property_info::Builder {
        get_property_info::Builder {
            client: self.clone(),
            name_id: name_id.into(),
            property_name: property_name.into(),
            timeout: None,
        }
    }
    #[doc = "Creates or updates a Service Fabric property."]
    #[doc = "Creates or updates the specified Service Fabric property under a given name."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_id`: The Service Fabric name, without the 'fabric:' URI scheme."]
    #[doc = "* `property_description`: Describes the Service Fabric property to be created."]
    pub fn put_property(
        &self,
        name_id: impl Into<String>,
        property_description: impl Into<models::PropertyDescription>,
    ) -> put_property::Builder {
        put_property::Builder {
            client: self.clone(),
            name_id: name_id.into(),
            property_description: property_description.into(),
            timeout: None,
        }
    }
    #[doc = "Deletes the specified Service Fabric property."]
    #[doc = "Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_id`: The Service Fabric name, without the 'fabric:' URI scheme."]
    #[doc = "* `property_name`: Specifies the name of the property to get."]
    pub fn delete_property(&self, name_id: impl Into<String>, property_name: impl Into<String>) -> delete_property::Builder {
        delete_property::Builder {
            client: self.clone(),
            name_id: name_id.into(),
            property_name: property_name.into(),
            timeout: None,
        }
    }
    #[doc = "Submits a property batch."]
    #[doc = "Submits a batch of property operations. Either all or none of the operations will be committed."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `name_id`: The Service Fabric name, without the 'fabric:' URI scheme."]
    #[doc = "* `property_batch_description_list`: Describes the property batch operations to be submitted."]
    pub fn submit_property_batch(
        &self,
        name_id: impl Into<String>,
        property_batch_description_list: impl Into<models::PropertyBatchDescriptionList>,
    ) -> submit_property_batch::Builder {
        submit_property_batch::Builder {
            client: self.clone(),
            name_id: name_id.into(),
            property_batch_description_list: property_batch_description_list.into(),
            timeout: None,
        }
    }
    #[doc = "Gets all Cluster-related events."]
    #[doc = "The response is list of ClusterEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_cluster_event_list(
        &self,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_cluster_event_list::Builder {
        get_cluster_event_list::Builder {
            client: self.clone(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets all Containers-related events."]
    #[doc = "The response is list of ContainerInstanceEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_containers_event_list(
        &self,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_containers_event_list::Builder {
        get_containers_event_list::Builder {
            client: self.clone(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets a Node-related events."]
    #[doc = "The response is list of NodeEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `node_name`: The name of the node."]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_node_event_list(
        &self,
        node_name: impl Into<String>,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_node_event_list::Builder {
        get_node_event_list::Builder {
            client: self.clone(),
            node_name: node_name.into(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets all Nodes-related Events."]
    #[doc = "The response is list of NodeEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_nodes_event_list(
        &self,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_nodes_event_list::Builder {
        get_nodes_event_list::Builder {
            client: self.clone(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets an Application-related events."]
    #[doc = "The response is list of ApplicationEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `application_id`: The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in previous versions."]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_application_event_list(
        &self,
        application_id: impl Into<String>,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_application_event_list::Builder {
        get_application_event_list::Builder {
            client: self.clone(),
            application_id: application_id.into(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets all Applications-related events."]
    #[doc = "The response is list of ApplicationEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_applications_event_list(
        &self,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_applications_event_list::Builder {
        get_applications_event_list::Builder {
            client: self.clone(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets a Service-related events."]
    #[doc = "The response is list of ServiceEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `service_id`: The identity of the service. This ID is typically the full name of the service without the 'fabric:' URI scheme.\nStarting from version 6.0, hierarchical names are delimited with the \"~\" character.\nFor example, if the service name is \"fabric:/myapp/app1/svc1\", the service identity would be \"myapp~app1~svc1\" in 6.0+ and \"myapp/app1/svc1\" in previous versions."]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_service_event_list(
        &self,
        service_id: impl Into<String>,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_service_event_list::Builder {
        get_service_event_list::Builder {
            client: self.clone(),
            service_id: service_id.into(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets all Services-related events."]
    #[doc = "The response is list of ServiceEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_services_event_list(
        &self,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_services_event_list::Builder {
        get_services_event_list::Builder {
            client: self.clone(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets a Partition-related events."]
    #[doc = "The response is list of PartitionEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_partition_event_list(
        &self,
        partition_id: impl Into<String>,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_partition_event_list::Builder {
        get_partition_event_list::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets all Partitions-related events."]
    #[doc = "The response is list of PartitionEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_partitions_event_list(
        &self,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_partitions_event_list::Builder {
        get_partitions_event_list::Builder {
            client: self.clone(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets a Partition Replica-related events."]
    #[doc = "The response is list of ReplicaEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `replica_id`: The identifier of the replica."]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_partition_replica_event_list(
        &self,
        partition_id: impl Into<String>,
        replica_id: impl Into<String>,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_partition_replica_event_list::Builder {
        get_partition_replica_event_list::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            replica_id: replica_id.into(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets all Replicas-related events for a Partition."]
    #[doc = "The response is list of ReplicaEvent objects."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `partition_id`: The identity of the partition."]
    #[doc = "* `start_time_utc`: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    #[doc = "* `end_time_utc`: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ."]
    pub fn get_partition_replicas_event_list(
        &self,
        partition_id: impl Into<String>,
        start_time_utc: impl Into<String>,
        end_time_utc: impl Into<String>,
    ) -> get_partition_replicas_event_list::Builder {
        get_partition_replicas_event_list::Builder {
            client: self.clone(),
            partition_id: partition_id.into(),
            start_time_utc: start_time_utc.into(),
            end_time_utc: end_time_utc.into(),
            timeout: None,
            events_types_filter: None,
            exclude_analysis_events: None,
            skip_correlation_lookup: None,
        }
    }
    #[doc = "Gets all correlated events for a given event."]
    #[doc = "The response is list of FabricEvents."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `event_instance_id`: The EventInstanceId."]
    pub fn get_correlated_event_list(&self, event_instance_id: impl Into<String>) -> get_correlated_event_list::Builder {
        get_correlated_event_list::Builder {
            client: self.clone(),
            event_instance_id: event_instance_id.into(),
            timeout: None,
        }
    }
}
pub mod get_cluster_manifest {
    use super::models;
    type Response = models::ClusterManifest;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetClusterManifest", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterManifest = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_health {
    use super::models;
    type Response = models::ClusterHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) nodes_health_state_filter: Option<i64>,
        pub(crate) applications_health_state_filter: Option<i64>,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) include_system_application_health_statistics: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering of the node health state objects returned in the result of cluster health query\nbased on their health state. The possible values for this parameter include integer value of one of the\nfollowing health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.\nIf not specified, all entries are returned.\nThe state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn nodes_health_state_filter(mut self, nodes_health_state_filter: i64) -> Self {
            self.nodes_health_state_filter = Some(nodes_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the application health state objects returned in the result of cluster health\nquery based on their health state.\nThe possible values for this parameter include integer value obtained from members or bitwise operations\non members of HealthStateFilter enumeration. Only applications that match the filter are returned.\nAll applications are used to evaluate the aggregated health state. If not specified, all entries are returned.\nThe state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn applications_health_state_filter(mut self, applications_health_state_filter: i64) -> Self {
            self.applications_health_state_filter = Some(applications_health_state_filter);
            self
        }
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.\nIf IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.\nOtherwise, the query result includes health statistics only for user applications.\nThe health statistics must be included in the query result for this parameter to be applied."]
        pub fn include_system_application_health_statistics(mut self, include_system_application_health_statistics: bool) -> Self {
            self.include_system_application_health_statistics = Some(include_system_application_health_statistics);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetClusterHealth", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(nodes_health_state_filter) = &this.nodes_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("NodesHealthStateFilter", &nodes_health_state_filter.to_string());
                    }
                    if let Some(applications_health_state_filter) = &this.applications_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ApplicationsHealthStateFilter", &applications_health_state_filter.to_string());
                    }
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(include_system_application_health_statistics) = &this.include_system_application_health_statistics {
                        req.url_mut().query_pairs_mut().append_pair(
                            "IncludeSystemApplicationHealthStatistics",
                            &include_system_application_health_statistics.to_string(),
                        );
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_health_using_policy {
    use super::models;
    type Response = models::ClusterHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) nodes_health_state_filter: Option<i64>,
        pub(crate) applications_health_state_filter: Option<i64>,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) include_system_application_health_statistics: Option<bool>,
        pub(crate) cluster_health_policies: Option<models::ClusterHealthPolicies>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering of the node health state objects returned in the result of cluster health query\nbased on their health state. The possible values for this parameter include integer value of one of the\nfollowing health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.\nIf not specified, all entries are returned.\nThe state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn nodes_health_state_filter(mut self, nodes_health_state_filter: i64) -> Self {
            self.nodes_health_state_filter = Some(nodes_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the application health state objects returned in the result of cluster health\nquery based on their health state.\nThe possible values for this parameter include integer value obtained from members or bitwise operations\non members of HealthStateFilter enumeration. Only applications that match the filter are returned.\nAll applications are used to evaluate the aggregated health state. If not specified, all entries are returned.\nThe state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn applications_health_state_filter(mut self, applications_health_state_filter: i64) -> Self {
            self.applications_health_state_filter = Some(applications_health_state_filter);
            self
        }
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.\nIf IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.\nOtherwise, the query result includes health statistics only for user applications.\nThe health statistics must be included in the query result for this parameter to be applied."]
        pub fn include_system_application_health_statistics(mut self, include_system_application_health_statistics: bool) -> Self {
            self.include_system_application_health_statistics = Some(include_system_application_health_statistics);
            self
        }
        #[doc = "Describes the health policies used to evaluate the cluster health.\nIf not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.\nBy default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.\nIf the application health policy map is specified, and it has an entry for an application, the specified application health policy\nis used to evaluate the application health."]
        pub fn cluster_health_policies(mut self, cluster_health_policies: impl Into<models::ClusterHealthPolicies>) -> Self {
            self.cluster_health_policies = Some(cluster_health_policies.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetClusterHealth", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(nodes_health_state_filter) = &this.nodes_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("NodesHealthStateFilter", &nodes_health_state_filter.to_string());
                    }
                    if let Some(applications_health_state_filter) = &this.applications_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ApplicationsHealthStateFilter", &applications_health_state_filter.to_string());
                    }
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(include_system_application_health_statistics) = &this.include_system_application_health_statistics {
                        req.url_mut().query_pairs_mut().append_pair(
                            "IncludeSystemApplicationHealthStatistics",
                            &include_system_application_health_statistics.to_string(),
                        );
                    }
                    let req_body = if let Some(cluster_health_policies) = &this.cluster_health_policies {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(cluster_health_policies)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_health_chunk {
    use super::models;
    type Response = models::ClusterHealthChunk;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetClusterHealthChunk", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterHealthChunk = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_health_chunk_using_policy_and_advanced_filters {
    use super::models;
    type Response = models::ClusterHealthChunk;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) cluster_health_chunk_query_description: Option<models::ClusterHealthChunkQueryDescription>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.\nIf the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.\nBy default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.\nIf the application health policy map is specified, and it has an entry for an application, the specified application health policy\nis used to evaluate the application health.\nUsers can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.\nThe query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return\nonly services that are in Error or Warning, and all partitions and replicas for one of these services."]
        pub fn cluster_health_chunk_query_description(
            mut self,
            cluster_health_chunk_query_description: impl Into<models::ClusterHealthChunkQueryDescription>,
        ) -> Self {
            self.cluster_health_chunk_query_description = Some(cluster_health_chunk_query_description.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetClusterHealthChunk", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let req_body = if let Some(cluster_health_chunk_query_description) = &this.cluster_health_chunk_query_description {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(cluster_health_chunk_query_description)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterHealthChunk = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod report_cluster_health {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) health_information: models::HealthInformation,
        pub(crate) immediate: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "A flag that indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately."]
        pub fn immediate(mut self, immediate: bool) -> Self {
            self.immediate = Some(immediate);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/ReportClusterHealth", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.health_information)?;
                    if let Some(immediate) = &this.immediate {
                        req.url_mut().query_pairs_mut().append_pair("Immediate", &immediate.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_provisioned_fabric_code_version_info_list {
    use super::models;
    type Response = models::FabricCodeVersionInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) code_version: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The product version of Service Fabric."]
        pub fn code_version(mut self, code_version: impl Into<String>) -> Self {
            self.code_version = Some(code_version.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetProvisionedCodeVersions", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(code_version) = &this.code_version {
                        req.url_mut().query_pairs_mut().append_pair("CodeVersion", code_version);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::FabricCodeVersionInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_provisioned_fabric_config_version_info_list {
    use super::models;
    type Response = models::FabricConfigVersionInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) config_version: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The config version of Service Fabric."]
        pub fn config_version(mut self, config_version: impl Into<String>) -> Self {
            self.config_version = Some(config_version.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetProvisionedConfigVersions", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(config_version) = &this.config_version {
                        req.url_mut().query_pairs_mut().append_pair("ConfigVersion", config_version);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::FabricConfigVersionInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_upgrade_progress {
    use super::models;
    type Response = models::ClusterUpgradeProgressObject;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetUpgradeProgress", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterUpgradeProgressObject = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_configuration {
    use super::models;
    type Response = models::ClusterConfiguration;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) configuration_api_version: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetClusterConfiguration", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let configuration_api_version = &this.configuration_api_version;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("ConfigurationApiVersion", configuration_api_version);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterConfiguration = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_configuration_upgrade_status {
    use super::models;
    type Response = models::ClusterConfigurationUpgradeStatusInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetClusterConfigurationUpgradeStatus", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterConfigurationUpgradeStatusInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_upgrade_orchestration_service_state {
    use super::models;
    type Response = models::UpgradeOrchestrationServiceState;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetUpgradeOrchestrationServiceState", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::UpgradeOrchestrationServiceState = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod set_upgrade_orchestration_service_state {
    use super::models;
    type Response = models::UpgradeOrchestrationServiceStateSummary;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) upgrade_orchestration_service_state: models::UpgradeOrchestrationServiceState,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/SetUpgradeOrchestrationServiceState", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.upgrade_orchestration_service_state)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::UpgradeOrchestrationServiceStateSummary = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod provision_cluster {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) provision_fabric_description: models::ProvisionFabricDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/Provision", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.provision_fabric_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod unprovision_cluster {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) unprovision_fabric_description: models::UnprovisionFabricDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/Unprovision", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.unprovision_fabric_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod rollback_cluster_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/RollbackUpgrade", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod resume_cluster_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) resume_cluster_upgrade_description: models::ResumeClusterUpgradeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/MoveToNextUpgradeDomain", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.resume_cluster_upgrade_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_cluster_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) start_cluster_upgrade_description: models::StartClusterUpgradeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/Upgrade", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.start_cluster_upgrade_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_cluster_configuration_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) cluster_configuration_upgrade_description: models::ClusterConfigurationUpgradeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/StartClusterConfigurationUpgrade", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.cluster_configuration_upgrade_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod update_cluster_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) update_cluster_upgrade_description: models::UpdateClusterUpgradeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/UpdateUpgrade", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.update_cluster_upgrade_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_aad_metadata {
    use super::models;
    type Response = models::AadMetadataObject;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetAadMetadata", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::AadMetadataObject = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_version {
    use super::models;
    type Response = models::ClusterVersion;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetClusterVersion", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterVersion = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_load {
    use super::models;
    type Response = models::ClusterLoadInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetLoadInformation", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterLoadInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod toggle_verbose_service_placement_health_reporting {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) enabled: bool,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/$/ToggleVerboseServicePlacementHealthReporting",
                        this.client.endpoint(),
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let enabled = &this.enabled;
                    req.url_mut().query_pairs_mut().append_pair("Enabled", &enabled.to_string());
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_node_info_list {
    use super::models;
    type Response = models::PagedNodeInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) continuation_token: Option<String>,
        pub(crate) node_status_filter: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following."]
        pub fn node_status_filter(mut self, node_status_filter: impl Into<String>) -> Self {
            self.node_status_filter = Some(node_status_filter.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(node_status_filter) = &this.node_status_filter {
                        req.url_mut().query_pairs_mut().append_pair("NodeStatusFilter", node_status_filter);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedNodeInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_node_info {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::NodeInfo),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::NodeInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_node_health {
    use super::models;
    type Response = models::NodeHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/GetHealth", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::NodeHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_node_health_using_policy {
    use super::models;
    type Response = models::NodeHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) cluster_health_policy: Option<models::ClusterHealthPolicy>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy."]
        pub fn cluster_health_policy(mut self, cluster_health_policy: impl Into<models::ClusterHealthPolicy>) -> Self {
            self.cluster_health_policy = Some(cluster_health_policy.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/GetHealth", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    let req_body = if let Some(cluster_health_policy) = &this.cluster_health_policy {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(cluster_health_policy)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::NodeHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod report_node_health {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) health_information: models::HealthInformation,
        pub(crate) immediate: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "A flag that indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately."]
        pub fn immediate(mut self, immediate: bool) -> Self {
            self.immediate = Some(immediate);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/ReportHealth", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.health_information)?;
                    if let Some(immediate) = &this.immediate {
                        req.url_mut().query_pairs_mut().append_pair("Immediate", &immediate.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_node_load_info {
    use super::models;
    type Response = models::NodeLoadInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetLoadInformation",
                        this.client.endpoint(),
                        &this.node_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::NodeLoadInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod disable_node {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) deactivation_intent_description: models::DeactivationIntentDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/Deactivate", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.deactivation_intent_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod enable_node {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/Activate", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod remove_node_state {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/RemoveNodeState", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod restart_node {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) restart_node_description: models::RestartNodeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/Restart", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.restart_node_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod remove_configuration_overrides {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/RemoveConfigurationOverrides",
                        this.client.endpoint(),
                        &this.node_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_configuration_overrides {
    use super::models;
    type Response = models::ConfigParameterOverrideList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetConfigurationOverrides",
                        this.client.endpoint(),
                        &this.node_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ConfigParameterOverrideList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod add_configuration_parameter_overrides {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) config_parameter_override_list: models::ConfigParameterOverrideList,
        pub(crate) force: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Force adding configuration overrides on specified nodes."]
        pub fn force(mut self, force: bool) -> Self {
            self.force = Some(force);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/AddConfigurationParameterOverrides",
                        this.client.endpoint(),
                        &this.node_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.config_parameter_override_list)?;
                    if let Some(force) = &this.force {
                        req.url_mut().query_pairs_mut().append_pair("Force", &force.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod remove_node_tags {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) node_tags: models::NodeTagsList,
    }
    impl Builder {
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/RemoveNodeTags", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.node_tags)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod add_node_tags {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) node_tags: models::NodeTagsList,
    }
    impl Builder {
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/AddNodeTags", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.node_tags)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_type_info_list {
    use super::models;
    type Response = models::PagedApplicationTypeInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_type_definition_kind_filter: Option<i64>,
        pub(crate) exclude_application_parameters: Option<bool>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Used to filter on ApplicationTypeDefinitionKind which is the mechanism used to define a Service Fabric application type.\n- Default - Default value, which performs the same function as selecting \"All\". The value is 0.\n- All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.\n- ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.\n- Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2."]
        pub fn application_type_definition_kind_filter(mut self, application_type_definition_kind_filter: i64) -> Self {
            self.application_type_definition_kind_filter = Some(application_type_definition_kind_filter);
            self
        }
        #[doc = "The flag that specifies whether application parameters will be excluded from the result."]
        pub fn exclude_application_parameters(mut self, exclude_application_parameters: bool) -> Self {
            self.exclude_application_parameters = Some(exclude_application_parameters);
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ApplicationTypes", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(application_type_definition_kind_filter) = &this.application_type_definition_kind_filter {
                        req.url_mut().query_pairs_mut().append_pair(
                            "ApplicationTypeDefinitionKindFilter",
                            &application_type_definition_kind_filter.to_string(),
                        );
                    }
                    if let Some(exclude_application_parameters) = &this.exclude_application_parameters {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeApplicationParameters", &exclude_application_parameters.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedApplicationTypeInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_type_info_list_by_name {
    use super::models;
    type Response = models::PagedApplicationTypeInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_type_name: String,
        pub(crate) application_type_version: Option<String>,
        pub(crate) exclude_application_parameters: Option<bool>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The version of the application type."]
        pub fn application_type_version(mut self, application_type_version: impl Into<String>) -> Self {
            self.application_type_version = Some(application_type_version.into());
            self
        }
        #[doc = "The flag that specifies whether application parameters will be excluded from the result."]
        pub fn exclude_application_parameters(mut self, exclude_application_parameters: bool) -> Self {
            self.exclude_application_parameters = Some(exclude_application_parameters);
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ApplicationTypes/{}",
                        this.client.endpoint(),
                        &this.application_type_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(application_type_version) = &this.application_type_version {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ApplicationTypeVersion", application_type_version);
                    }
                    if let Some(exclude_application_parameters) = &this.exclude_application_parameters {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeApplicationParameters", &exclude_application_parameters.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedApplicationTypeInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod provision_application_type {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200,
        Accepted202,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) provision_application_type_description_base_required_body_param: models::ProvisionApplicationTypeDescriptionBase,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ApplicationTypes/$/Provision", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.provision_application_type_description_base_required_body_param)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(Response::Ok200),
                        azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod unprovision_application_type {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200,
        Accepted202,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_type_name: String,
        pub(crate) unprovision_application_type_description_info: models::UnprovisionApplicationTypeDescriptionInfo,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ApplicationTypes/{}/$/Unprovision",
                        this.client.endpoint(),
                        &this.application_type_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.unprovision_application_type_description_info)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(Response::Ok200),
                        azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_type_info_list {
    use super::models;
    type Response = models::ServiceTypeInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_type_name: String,
        pub(crate) application_type_version: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ApplicationTypes/{}/$/GetServiceTypes",
                        this.client.endpoint(),
                        &this.application_type_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let application_type_version = &this.application_type_version;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("ApplicationTypeVersion", application_type_version);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceTypeInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_type_info_by_name {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ServiceTypeInfo),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_type_name: String,
        pub(crate) application_type_version: String,
        pub(crate) service_type_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ApplicationTypes/{}/$/GetServiceTypes/{}",
                        this.client.endpoint(),
                        &this.application_type_name,
                        &this.service_type_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let application_type_version = &this.application_type_version;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("ApplicationTypeVersion", application_type_version);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceTypeInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_manifest {
    use super::models;
    type Response = models::ServiceTypeManifest;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_type_name: String,
        pub(crate) application_type_version: String,
        pub(crate) service_manifest_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ApplicationTypes/{}/$/GetServiceManifest",
                        this.client.endpoint(),
                        &this.application_type_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let application_type_version = &this.application_type_version;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("ApplicationTypeVersion", application_type_version);
                    let service_manifest_name = &this.service_manifest_name;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("ServiceManifestName", service_manifest_name);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceTypeManifest = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_type_info_list {
    use super::models;
    type Response = models::DeployedServiceTypeInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_manifest_name: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest."]
        pub fn service_manifest_name(mut self, service_manifest_name: impl Into<String>) -> Self {
            self.service_manifest_name = Some(service_manifest_name.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetServiceTypes",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(service_manifest_name) = &this.service_manifest_name {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ServiceManifestName", service_manifest_name);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServiceTypeInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_type_info_by_name {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::DeployedServiceTypeInfoList),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_type_name: String,
        pub(crate) service_manifest_name: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest."]
        pub fn service_manifest_name(mut self, service_manifest_name: impl Into<String>) -> Self {
            self.service_manifest_name = Some(service_manifest_name.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetServiceTypes/{}",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id,
                        &this.service_type_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(service_manifest_name) = &this.service_manifest_name {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ServiceManifestName", service_manifest_name);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServiceTypeInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod create_application {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_description: models::ApplicationDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Applications/$/Create", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.application_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Created => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod delete_application {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) force_remove: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas."]
        pub fn force_remove(mut self, force_remove: bool) -> Self {
            self.force_remove = Some(force_remove);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/Delete",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(force_remove) = &this.force_remove {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ForceRemove", &force_remove.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_load_info {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ApplicationLoadInfo),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetLoadInformation",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationLoadInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_info_list {
    use super::models;
    type Response = models::PagedApplicationInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_definition_kind_filter: Option<i64>,
        pub(crate) application_type_name: Option<String>,
        pub(crate) exclude_application_parameters: Option<bool>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Used to filter on ApplicationDefinitionKind, which is the mechanism used to define a Service Fabric application.\n- Default - Default value, which performs the same function as selecting \"All\". The value is 0.\n- All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.\n- ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.\n- Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2."]
        pub fn application_definition_kind_filter(mut self, application_definition_kind_filter: i64) -> Self {
            self.application_definition_kind_filter = Some(application_definition_kind_filter);
            self
        }
        #[doc = "The application type name used to filter the applications to query for. This value should not contain the application type version."]
        pub fn application_type_name(mut self, application_type_name: impl Into<String>) -> Self {
            self.application_type_name = Some(application_type_name.into());
            self
        }
        #[doc = "The flag that specifies whether application parameters will be excluded from the result."]
        pub fn exclude_application_parameters(mut self, exclude_application_parameters: bool) -> Self {
            self.exclude_application_parameters = Some(exclude_application_parameters);
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Applications", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(application_definition_kind_filter) = &this.application_definition_kind_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ApplicationDefinitionKindFilter", &application_definition_kind_filter.to_string());
                    }
                    if let Some(application_type_name) = &this.application_type_name {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ApplicationTypeName", application_type_name);
                    }
                    if let Some(exclude_application_parameters) = &this.exclude_application_parameters {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeApplicationParameters", &exclude_application_parameters.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedApplicationInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_info {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ApplicationInfo),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) exclude_application_parameters: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The flag that specifies whether application parameters will be excluded from the result."]
        pub fn exclude_application_parameters(mut self, exclude_application_parameters: bool) -> Self {
            self.exclude_application_parameters = Some(exclude_application_parameters);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Applications/{}", this.client.endpoint(), &this.application_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(exclude_application_parameters) = &this.exclude_application_parameters {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeApplicationParameters", &exclude_application_parameters.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_health {
    use super::models;
    type Response = models::ApplicationHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) deployed_applications_health_state_filter: Option<i64>,
        pub(crate) services_health_state_filter: Option<i64>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\nAll deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.\nThe state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn deployed_applications_health_state_filter(mut self, deployed_applications_health_state_filter: i64) -> Self {
            self.deployed_applications_health_state_filter = Some(deployed_applications_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the services health state objects returned in the result of services health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly services that match the filter are returned. All services are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,\nobtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn services_health_state_filter(mut self, services_health_state_filter: i64) -> Self {
            self.services_health_state_filter = Some(services_health_state_filter);
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetHealth",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(deployed_applications_health_state_filter) = &this.deployed_applications_health_state_filter {
                        req.url_mut().query_pairs_mut().append_pair(
                            "DeployedApplicationsHealthStateFilter",
                            &deployed_applications_health_state_filter.to_string(),
                        );
                    }
                    if let Some(services_health_state_filter) = &this.services_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ServicesHealthStateFilter", &services_health_state_filter.to_string());
                    }
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_health_using_policy {
    use super::models;
    type Response = models::ApplicationHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) deployed_applications_health_state_filter: Option<i64>,
        pub(crate) services_health_state_filter: Option<i64>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) application_health_policy: Option<models::ApplicationHealthPolicy>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\nAll deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.\nThe state values are flag-based enumeration, so the value could be a combination of these values, obtained using bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn deployed_applications_health_state_filter(mut self, deployed_applications_health_state_filter: i64) -> Self {
            self.deployed_applications_health_state_filter = Some(deployed_applications_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the services health state objects returned in the result of services health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly services that match the filter are returned. All services are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values,\nobtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn services_health_state_filter(mut self, services_health_state_filter: i64) -> Self {
            self.services_health_state_filter = Some(services_health_state_filter);
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "Describes the health policies used to evaluate the health of an application or one of its children.\nIf not present, the health evaluation uses the health policy from application manifest or the default health policy."]
        pub fn application_health_policy(mut self, application_health_policy: impl Into<models::ApplicationHealthPolicy>) -> Self {
            self.application_health_policy = Some(application_health_policy.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetHealth",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(deployed_applications_health_state_filter) = &this.deployed_applications_health_state_filter {
                        req.url_mut().query_pairs_mut().append_pair(
                            "DeployedApplicationsHealthStateFilter",
                            &deployed_applications_health_state_filter.to_string(),
                        );
                    }
                    if let Some(services_health_state_filter) = &this.services_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ServicesHealthStateFilter", &services_health_state_filter.to_string());
                    }
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    let req_body = if let Some(application_health_policy) = &this.application_health_policy {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(application_health_policy)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod report_application_health {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) health_information: models::HealthInformation,
        pub(crate) immediate: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "A flag that indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately."]
        pub fn immediate(mut self, immediate: bool) -> Self {
            self.immediate = Some(immediate);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/ReportHealth",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.health_information)?;
                    if let Some(immediate) = &this.immediate {
                        req.url_mut().query_pairs_mut().append_pair("Immediate", &immediate.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_application_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) application_upgrade_description: models::ApplicationUpgradeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/Upgrade",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.application_upgrade_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_upgrade {
    use super::models;
    type Response = models::ApplicationUpgradeProgressInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetUpgradeProgress",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationUpgradeProgressInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod update_application_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) application_upgrade_update_description: models::ApplicationUpgradeUpdateDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/UpdateUpgrade",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.application_upgrade_update_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod resume_application_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) resume_application_upgrade_description: models::ResumeApplicationUpgradeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/MoveToNextUpgradeDomain",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.resume_application_upgrade_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod rollback_application_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/RollbackUpgrade",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_application_info_list {
    use super::models;
    type Response = models::PagedDeployedApplicationInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) include_health_state: Option<bool>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "Include the health state of an entity.\nIf this parameter is false or not specified, then the health state returned is \"Unknown\".\nWhen set to true, the query goes in parallel to the node and the health system service before the results are merged.\nAs a result, the query is more expensive and may take a longer time."]
        pub fn include_health_state(mut self, include_health_state: bool) -> Self {
            self.include_health_state = Some(include_health_state);
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Nodes/{}/$/GetApplications", this.client.endpoint(), &this.node_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    if let Some(include_health_state) = &this.include_health_state {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("IncludeHealthState", &include_health_state.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedDeployedApplicationInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_application_info {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::DeployedApplicationInfo),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) include_health_state: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "Include the health state of an entity.\nIf this parameter is false or not specified, then the health state returned is \"Unknown\".\nWhen set to true, the query goes in parallel to the node and the health system service before the results are merged.\nAs a result, the query is more expensive and may take a longer time."]
        pub fn include_health_state(mut self, include_health_state: bool) -> Self {
            self.include_health_state = Some(include_health_state);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    if let Some(include_health_state) = &this.include_health_state {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("IncludeHealthState", &include_health_state.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedApplicationInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_application_health {
    use super::models;
    type Response = models::DeployedApplicationHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) deployed_service_packages_health_state_filter: Option<i64>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.\nIf not specified, all entries are returned.\nThe state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn deployed_service_packages_health_state_filter(mut self, deployed_service_packages_health_state_filter: i64) -> Self {
            self.deployed_service_packages_health_state_filter = Some(deployed_service_packages_health_state_filter);
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetHealth",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(deployed_service_packages_health_state_filter) = &this.deployed_service_packages_health_state_filter {
                        req.url_mut().query_pairs_mut().append_pair(
                            "DeployedServicePackagesHealthStateFilter",
                            &deployed_service_packages_health_state_filter.to_string(),
                        );
                    }
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedApplicationHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_application_health_using_policy {
    use super::models;
    type Response = models::DeployedApplicationHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) deployed_service_packages_health_state_filter: Option<i64>,
        pub(crate) application_health_policy: Option<models::ApplicationHealthPolicy>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.\nIf not specified, all entries are returned.\nThe state values are flag-based enumeration, so the value can be a combination of these values, obtained using the bitwise 'OR' operator.\nFor example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn deployed_service_packages_health_state_filter(mut self, deployed_service_packages_health_state_filter: i64) -> Self {
            self.deployed_service_packages_health_state_filter = Some(deployed_service_packages_health_state_filter);
            self
        }
        #[doc = "Describes the health policies used to evaluate the health of an application or one of its children.\nIf not present, the health evaluation uses the health policy from application manifest or the default health policy."]
        pub fn application_health_policy(mut self, application_health_policy: impl Into<models::ApplicationHealthPolicy>) -> Self {
            self.application_health_policy = Some(application_health_policy.into());
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetHealth",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(deployed_service_packages_health_state_filter) = &this.deployed_service_packages_health_state_filter {
                        req.url_mut().query_pairs_mut().append_pair(
                            "DeployedServicePackagesHealthStateFilter",
                            &deployed_service_packages_health_state_filter.to_string(),
                        );
                    }
                    let req_body = if let Some(application_health_policy) = &this.application_health_policy {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(application_health_policy)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedApplicationHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod report_deployed_application_health {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) health_information: models::HealthInformation,
        pub(crate) immediate: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "A flag that indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately."]
        pub fn immediate(mut self, immediate: bool) -> Self {
            self.immediate = Some(immediate);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/ReportHealth",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.health_information)?;
                    if let Some(immediate) = &this.immediate {
                        req.url_mut().query_pairs_mut().append_pair("Immediate", &immediate.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_manifest {
    use super::models;
    type Response = models::ApplicationTypeManifest;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_type_name: String,
        pub(crate) application_type_version: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ApplicationTypes/{}/$/GetApplicationManifest",
                        this.client.endpoint(),
                        &this.application_type_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let application_type_version = &this.application_type_version;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("ApplicationTypeVersion", application_type_version);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationTypeManifest = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_info_list {
    use super::models;
    type Response = models::PagedServiceInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) service_type_name: Option<String>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The service type name used to filter the services to query for."]
        pub fn service_type_name(mut self, service_type_name: impl Into<String>) -> Self {
            self.service_type_name = Some(service_type_name.into());
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetServices",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(service_type_name) = &this.service_type_name {
                        req.url_mut().query_pairs_mut().append_pair("ServiceTypeName", service_type_name);
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedServiceInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_info {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ServiceInfo),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) service_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetServices/{}",
                        this.client.endpoint(),
                        &this.application_id,
                        &this.service_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_name_info {
    use super::models;
    type Response = models::ApplicationNameInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Services/{}/$/GetApplicationName",
                        this.client.endpoint(),
                        &this.service_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationNameInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod create_service {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) service_description: models::ServiceDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetServices/$/Create",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.service_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod create_service_from_template {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) service_from_template_description: models::ServiceFromTemplateDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetServices/$/CreateFromTemplate",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.service_from_template_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod delete_service {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) force_remove: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas."]
        pub fn force_remove(mut self, force_remove: bool) -> Self {
            self.force_remove = Some(force_remove);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/Delete", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(force_remove) = &this.force_remove {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ForceRemove", &force_remove.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod update_service {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) service_update_description: models::ServiceUpdateDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/Update", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.service_update_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_description {
    use super::models;
    type Response = models::ServiceDescription;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Services/{}/$/GetDescription",
                        this.client.endpoint(),
                        &this.service_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceDescription = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_health {
    use super::models;
    type Response = models::ServiceHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) partitions_health_state_filter: Option<i64>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value\nobtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn partitions_health_state_filter(mut self, partitions_health_state_filter: i64) -> Self {
            self.partitions_health_state_filter = Some(partitions_health_state_filter);
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/GetHealth", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(partitions_health_state_filter) = &this.partitions_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("PartitionsHealthStateFilter", &partitions_health_state_filter.to_string());
                    }
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_health_using_policy {
    use super::models;
    type Response = models::ServiceHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) partitions_health_state_filter: Option<i64>,
        pub(crate) application_health_policy: Option<models::ApplicationHealthPolicy>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these value\nobtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn partitions_health_state_filter(mut self, partitions_health_state_filter: i64) -> Self {
            self.partitions_health_state_filter = Some(partitions_health_state_filter);
            self
        }
        #[doc = "Describes the health policies used to evaluate the health of an application or one of its children.\nIf not present, the health evaluation uses the health policy from application manifest or the default health policy."]
        pub fn application_health_policy(mut self, application_health_policy: impl Into<models::ApplicationHealthPolicy>) -> Self {
            self.application_health_policy = Some(application_health_policy.into());
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/GetHealth", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(partitions_health_state_filter) = &this.partitions_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("PartitionsHealthStateFilter", &partitions_health_state_filter.to_string());
                    }
                    let req_body = if let Some(application_health_policy) = &this.application_health_policy {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(application_health_policy)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod report_service_health {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) health_information: models::HealthInformation,
        pub(crate) immediate: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "A flag that indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately."]
        pub fn immediate(mut self, immediate: bool) -> Self {
            self.immediate = Some(immediate);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/ReportHealth", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.health_information)?;
                    if let Some(immediate) = &this.immediate {
                        req.url_mut().query_pairs_mut().append_pair("Immediate", &immediate.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod resolve_service {
    use super::models;
    type Response = models::ResolvedServicePartition;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_key_type: Option<i64>,
        pub(crate) partition_key_value: Option<String>,
        pub(crate) previous_rsp_version: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.\n- None (1) - Indicates that the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.\n- Int64Range (2) - Indicates that the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.\n- Named (3) - Indicates that the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3."]
        pub fn partition_key_type(mut self, partition_key_type: i64) -> Self {
            self.partition_key_type = Some(partition_key_type);
            self
        }
        #[doc = "Partition key. This is required if the partition scheme for the service is Int64Range or Named. \nThis is not the partition ID, but rather, either the integer key value, or the name of the partition ID.\nFor example, if your service is using ranged partitions from 0 to 10, then they PartitionKeyValue would be an\ninteger in that range. Query service description to see the range or name."]
        pub fn partition_key_value(mut self, partition_key_value: impl Into<String>) -> Self {
            self.partition_key_value = Some(partition_key_value.into());
            self
        }
        #[doc = "The value in the Version field of the response that was received previously. This is required if the user knows that the result that was gotten previously is stale."]
        pub fn previous_rsp_version(mut self, previous_rsp_version: impl Into<String>) -> Self {
            self.previous_rsp_version = Some(previous_rsp_version.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Services/{}/$/ResolvePartition",
                        this.client.endpoint(),
                        &this.service_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(partition_key_type) = &this.partition_key_type {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("PartitionKeyType", &partition_key_type.to_string());
                    }
                    if let Some(partition_key_value) = &this.partition_key_value {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("PartitionKeyValue", partition_key_value);
                    }
                    if let Some(previous_rsp_version) = &this.previous_rsp_version {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("PreviousRspVersion", previous_rsp_version);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ResolvedServicePartition = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_unplaced_replica_information {
    use super::models;
    type Response = models::UnplacedReplicaInformation;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_id: Option<String>,
        pub(crate) only_query_primaries: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The identity of the partition."]
        pub fn partition_id(mut self, partition_id: impl Into<String>) -> Self {
            self.partition_id = Some(partition_id.into());
            self
        }
        #[doc = "Indicates that unplaced replica information will be queries only for primary replicas."]
        pub fn only_query_primaries(mut self, only_query_primaries: bool) -> Self {
            self.only_query_primaries = Some(only_query_primaries);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Services/{}/$/GetUnplacedReplicaInformation",
                        this.client.endpoint(),
                        &this.service_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(partition_id) = &this.partition_id {
                        req.url_mut().query_pairs_mut().append_pair("PartitionId", partition_id);
                    }
                    if let Some(only_query_primaries) = &this.only_query_primaries {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("OnlyQueryPrimaries", &only_query_primaries.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::UnplacedReplicaInformation = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_loaded_partition_info_list {
    use super::models;
    type Response = models::LoadedPartitionInformationResultList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) metric_name: String,
        pub(crate) service_name: Option<String>,
        pub(crate) ordering: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) continuation_token: Option<String>,
    }
    impl Builder {
        #[doc = "The name of a service."]
        pub fn service_name(mut self, service_name: impl Into<String>) -> Self {
            self.service_name = Some(service_name.into());
            self
        }
        #[doc = "Ordering of partitions' load."]
        pub fn ordering(mut self, ordering: impl Into<String>) -> Self {
            self.ordering = Some(ordering.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetLoadedPartitionInfoList", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let metric_name = &this.metric_name;
                    req.url_mut().query_pairs_mut().append_pair("MetricName", metric_name);
                    if let Some(service_name) = &this.service_name {
                        req.url_mut().query_pairs_mut().append_pair("ServiceName", service_name);
                    }
                    if let Some(ordering) = &this.ordering {
                        req.url_mut().query_pairs_mut().append_pair("Ordering", ordering);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::LoadedPartitionInformationResultList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_info_list {
    use super::models;
    type Response = models::PagedServicePartitionInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) continuation_token: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/GetPartitions", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedServicePartitionInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_info {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ServicePartitionInfo),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Partitions/{}", this.client.endpoint(), &this.partition_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServicePartitionInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_name_info {
    use super::models;
    type Response = models::ServiceNameInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetServiceName",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceNameInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_health {
    use super::models;
    type Response = models::PartitionHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) replicas_health_state_filter: Option<i64>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn replicas_health_state_filter(mut self, replicas_health_state_filter: i64) -> Self {
            self.replicas_health_state_filter = Some(replicas_health_state_filter);
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Partitions/{}/$/GetHealth", this.client.endpoint(), &this.partition_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(replicas_health_state_filter) = &this.replicas_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ReplicasHealthStateFilter", &replicas_health_state_filter.to_string());
                    }
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_health_using_policy {
    use super::models;
    type Response = models::PartitionHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) replicas_health_state_filter: Option<i64>,
        pub(crate) application_health_policy: Option<models::ApplicationHealthPolicy>,
        pub(crate) exclude_health_statistics: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag-based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn replicas_health_state_filter(mut self, replicas_health_state_filter: i64) -> Self {
            self.replicas_health_state_filter = Some(replicas_health_state_filter);
            self
        }
        #[doc = "Describes the health policies used to evaluate the health of an application or one of its children.\nIf not present, the health evaluation uses the health policy from application manifest or the default health policy."]
        pub fn application_health_policy(mut self, application_health_policy: impl Into<models::ApplicationHealthPolicy>) -> Self {
            self.application_health_policy = Some(application_health_policy.into());
            self
        }
        #[doc = "Indicates whether the health statistics should be returned as part of the query result. False by default.\nThe statistics show the number of children entities in health state Ok, Warning, and Error."]
        pub fn exclude_health_statistics(mut self, exclude_health_statistics: bool) -> Self {
            self.exclude_health_statistics = Some(exclude_health_statistics);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Partitions/{}/$/GetHealth", this.client.endpoint(), &this.partition_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(replicas_health_state_filter) = &this.replicas_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ReplicasHealthStateFilter", &replicas_health_state_filter.to_string());
                    }
                    let req_body = if let Some(application_health_policy) = &this.application_health_policy {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(application_health_policy)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(exclude_health_statistics) = &this.exclude_health_statistics {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeHealthStatistics", &exclude_health_statistics.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod report_partition_health {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) health_information: models::HealthInformation,
        pub(crate) immediate: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "A flag that indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately."]
        pub fn immediate(mut self, immediate: bool) -> Self {
            self.immediate = Some(immediate);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/ReportHealth",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.health_information)?;
                    if let Some(immediate) = &this.immediate {
                        req.url_mut().query_pairs_mut().append_pair("Immediate", &immediate.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_load_information {
    use super::models;
    type Response = models::PartitionLoadInformation;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetLoadInformation",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionLoadInformation = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod reset_partition_load {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Partitions/{}/$/ResetLoad", this.client.endpoint(), &this.partition_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod recover_partition {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Partitions/{}/$/Recover", this.client.endpoint(), &this.partition_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod recover_service_partitions {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Services/$/{}/$/GetPartitions/$/Recover",
                        this.client.endpoint(),
                        &this.service_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod recover_system_partitions {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/RecoverSystemPartitions", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod recover_all_partitions {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/RecoverAllPartitions", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod move_primary_replica {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) node_name: Option<String>,
        pub(crate) ignore_constraints: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The name of the node."]
        pub fn node_name(mut self, node_name: impl Into<String>) -> Self {
            self.node_name = Some(node_name.into());
            self
        }
        #[doc = "Ignore constraints when moving a replica or instance. If this parameter is not specified, all constraints are honored."]
        pub fn ignore_constraints(mut self, ignore_constraints: bool) -> Self {
            self.ignore_constraints = Some(ignore_constraints);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/MovePrimaryReplica",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(node_name) = &this.node_name {
                        req.url_mut().query_pairs_mut().append_pair("NodeName", node_name);
                    }
                    if let Some(ignore_constraints) = &this.ignore_constraints {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("IgnoreConstraints", &ignore_constraints.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod move_secondary_replica {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) current_node_name: String,
        pub(crate) new_node_name: Option<String>,
        pub(crate) ignore_constraints: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The name of the target node for secondary replica or instance move. If not specified, replica or instance is moved to a random node."]
        pub fn new_node_name(mut self, new_node_name: impl Into<String>) -> Self {
            self.new_node_name = Some(new_node_name.into());
            self
        }
        #[doc = "Ignore constraints when moving a replica or instance. If this parameter is not specified, all constraints are honored."]
        pub fn ignore_constraints(mut self, ignore_constraints: bool) -> Self {
            self.ignore_constraints = Some(ignore_constraints);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/MoveSecondaryReplica",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let current_node_name = &this.current_node_name;
                    req.url_mut().query_pairs_mut().append_pair("CurrentNodeName", current_node_name);
                    if let Some(new_node_name) = &this.new_node_name {
                        req.url_mut().query_pairs_mut().append_pair("NewNodeName", new_node_name);
                    }
                    if let Some(ignore_constraints) = &this.ignore_constraints {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("IgnoreConstraints", &ignore_constraints.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod update_partition_load {
    use super::models;
    type Response = models::PagedUpdatePartitionLoadResultList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_metric_load_description_list: models::PartitionMetricLoadDescriptionList,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/UpdatePartitionLoad", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.partition_metric_load_description_list)?;
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedUpdatePartitionLoadResultList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod move_instance {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_id: String,
        pub(crate) current_node_name: Option<String>,
        pub(crate) new_node_name: Option<String>,
        pub(crate) ignore_constraints: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The name of the source node for instance move. If not specified, instance is moved from a random node."]
        pub fn current_node_name(mut self, current_node_name: impl Into<String>) -> Self {
            self.current_node_name = Some(current_node_name.into());
            self
        }
        #[doc = "The name of the target node for secondary replica or instance move. If not specified, replica or instance is moved to a random node."]
        pub fn new_node_name(mut self, new_node_name: impl Into<String>) -> Self {
            self.new_node_name = Some(new_node_name.into());
            self
        }
        #[doc = "Ignore constraints when moving a replica or instance. If this parameter is not specified, all constraints are honored."]
        pub fn ignore_constraints(mut self, ignore_constraints: bool) -> Self {
            self.ignore_constraints = Some(ignore_constraints);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Services/{}/$/GetPartitions/{}/$/MoveInstance",
                        this.client.endpoint(),
                        &this.service_id,
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(current_node_name) = &this.current_node_name {
                        req.url_mut().query_pairs_mut().append_pair("CurrentNodeName", current_node_name);
                    }
                    if let Some(new_node_name) = &this.new_node_name {
                        req.url_mut().query_pairs_mut().append_pair("NewNodeName", new_node_name);
                    }
                    if let Some(ignore_constraints) = &this.ignore_constraints {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("IgnoreConstraints", &ignore_constraints.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod create_repair_task {
    use super::models;
    type Response = models::RepairTaskUpdateInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) repair_task: models::RepairTask,
    }
    impl Builder {
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/CreateRepairTask", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.repair_task)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::RepairTaskUpdateInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod cancel_repair_task {
    use super::models;
    type Response = models::RepairTaskUpdateInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) repair_task_cancel_description: models::RepairTaskCancelDescription,
    }
    impl Builder {
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/CancelRepairTask", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.repair_task_cancel_description)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::RepairTaskUpdateInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod delete_repair_task {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) repair_task_delete_description: models::RepairTaskDeleteDescription,
    }
    impl Builder {
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/DeleteRepairTask", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.repair_task_delete_description)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_repair_task_list {
    use super::models;
    type Response = models::RepairTaskList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) task_id_filter: Option<String>,
        pub(crate) state_filter: Option<i64>,
        pub(crate) executor_filter: Option<String>,
    }
    impl Builder {
        #[doc = "The repair task ID prefix to be matched."]
        pub fn task_id_filter(mut self, task_id_filter: impl Into<String>) -> Self {
            self.task_id_filter = Some(task_id_filter.into());
            self
        }
        #[doc = "A bitwise-OR of the following values, specifying which task states should be included in the result list.\n\n- 1 - Created\n- 2 - Claimed\n- 4 - Preparing\n- 8 - Approved\n- 16 - Executing\n- 32 - Restoring\n- 64 - Completed"]
        pub fn state_filter(mut self, state_filter: i64) -> Self {
            self.state_filter = Some(state_filter);
            self
        }
        #[doc = "The name of the repair executor whose claimed tasks should be included in the list."]
        pub fn executor_filter(mut self, executor_filter: impl Into<String>) -> Self {
            self.executor_filter = Some(executor_filter.into());
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/GetRepairTaskList", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(task_id_filter) = &this.task_id_filter {
                        req.url_mut().query_pairs_mut().append_pair("TaskIdFilter", task_id_filter);
                    }
                    if let Some(state_filter) = &this.state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("StateFilter", &state_filter.to_string());
                    }
                    if let Some(executor_filter) = &this.executor_filter {
                        req.url_mut().query_pairs_mut().append_pair("ExecutorFilter", executor_filter);
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::RepairTaskList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod force_approve_repair_task {
    use super::models;
    type Response = models::RepairTaskUpdateInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) repair_task_approve_description: models::RepairTaskApproveDescription,
    }
    impl Builder {
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/ForceApproveRepairTask", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.repair_task_approve_description)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::RepairTaskUpdateInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod update_repair_task_health_policy {
    use super::models;
    type Response = models::RepairTaskUpdateInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) repair_task_update_health_policy_description: models::RepairTaskUpdateHealthPolicyDescription,
    }
    impl Builder {
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/UpdateRepairTaskHealthPolicy", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.repair_task_update_health_policy_description)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::RepairTaskUpdateInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod update_repair_execution_state {
    use super::models;
    type Response = models::RepairTaskUpdateInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) repair_task: models::RepairTask,
    }
    impl Builder {
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/UpdateRepairExecutionState", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.repair_task)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::RepairTaskUpdateInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_replica_info_list {
    use super::models;
    type Response = models::PagedReplicaInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) continuation_token: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetReplicas",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedReplicaInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_replica_info {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::ReplicaInfo),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) replica_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetReplicas/{}",
                        this.client.endpoint(),
                        &this.partition_id,
                        &this.replica_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ReplicaInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_replica_health {
    use super::models;
    type Response = models::ReplicaHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) replica_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetReplicas/{}/$/GetHealth",
                        this.client.endpoint(),
                        &this.partition_id,
                        &this.replica_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ReplicaHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_replica_health_using_policy {
    use super::models;
    type Response = models::ReplicaHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) replica_id: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) application_health_policy: Option<models::ApplicationHealthPolicy>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Describes the health policies used to evaluate the health of an application or one of its children.\nIf not present, the health evaluation uses the health policy from application manifest or the default health policy."]
        pub fn application_health_policy(mut self, application_health_policy: impl Into<models::ApplicationHealthPolicy>) -> Self {
            self.application_health_policy = Some(application_health_policy.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetReplicas/{}/$/GetHealth",
                        this.client.endpoint(),
                        &this.partition_id,
                        &this.replica_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    let req_body = if let Some(application_health_policy) = &this.application_health_policy {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(application_health_policy)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ReplicaHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod report_replica_health {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) replica_id: String,
        pub(crate) service_kind: String,
        pub(crate) health_information: models::HealthInformation,
        pub(crate) immediate: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "A flag that indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately."]
        pub fn immediate(mut self, immediate: bool) -> Self {
            self.immediate = Some(immediate);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetReplicas/{}/$/ReportHealth",
                        this.client.endpoint(),
                        &this.partition_id,
                        &this.replica_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let service_kind = &this.service_kind;
                    req.url_mut().query_pairs_mut().append_pair("ServiceKind", service_kind);
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.health_information)?;
                    if let Some(immediate) = &this.immediate {
                        req.url_mut().query_pairs_mut().append_pair("Immediate", &immediate.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_replica_info_list {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::DeployedServiceReplicaInfoList),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) partition_id: Option<String>,
        pub(crate) service_manifest_name: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The identity of the partition."]
        pub fn partition_id(mut self, partition_id: impl Into<String>) -> Self {
            self.partition_id = Some(partition_id.into());
            self
        }
        #[doc = "The name of a service manifest registered as part of an application type in a Service Fabric cluster."]
        pub fn service_manifest_name(mut self, service_manifest_name: impl Into<String>) -> Self {
            self.service_manifest_name = Some(service_manifest_name.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetReplicas",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(partition_id) = &this.partition_id {
                        req.url_mut().query_pairs_mut().append_pair("PartitionId", partition_id);
                    }
                    if let Some(service_manifest_name) = &this.service_manifest_name {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ServiceManifestName", service_manifest_name);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServiceReplicaInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_replica_detail_info {
    use super::models;
    type Response = models::DeployedServiceReplicaDetailInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) partition_id: String,
        pub(crate) replica_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetPartitions/{}/$/GetReplicas/{}/$/GetDetail",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.partition_id,
                        &this.replica_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServiceReplicaDetailInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_replica_detail_info_by_partition_id {
    use super::models;
    type Response = models::DeployedServiceReplicaDetailInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetPartitions/{}/$/GetReplicas",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServiceReplicaDetailInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod restart_replica {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) partition_id: String,
        pub(crate) replica_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetPartitions/{}/$/GetReplicas/{}/$/Restart",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.partition_id,
                        &this.replica_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod remove_replica {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) partition_id: String,
        pub(crate) replica_id: String,
        pub(crate) force_remove: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas."]
        pub fn force_remove(mut self, force_remove: bool) -> Self {
            self.force_remove = Some(force_remove);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetPartitions/{}/$/GetReplicas/{}/$/Delete",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.partition_id,
                        &this.replica_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(force_remove) = &this.force_remove {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ForceRemove", &force_remove.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_package_info_list {
    use super::models;
    type Response = models::DeployedServicePackageInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServicePackageInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_package_info_list_by_name {
    use super::models;
    #[derive(Debug)]
    pub enum Response {
        Ok200(models::DeployedServicePackageInfoList),
        NoContent204,
    }
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_package_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages/{}",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id,
                        &this.service_package_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServicePackageInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(Response::Ok200(rsp_value))
                        }
                        azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_package_health {
    use super::models;
    type Response = models::DeployedServicePackageHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_package_name: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages/{}/$/GetHealth",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id,
                        &this.service_package_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServicePackageHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_service_package_health_using_policy {
    use super::models;
    type Response = models::DeployedServicePackageHealth;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_package_name: String,
        pub(crate) events_health_state_filter: Option<i64>,
        pub(crate) application_health_policy: Option<models::ApplicationHealthPolicy>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows filtering the collection of HealthEvent objects returned based on health state.\nThe possible values for this parameter include integer value of one of the following health states.\nOnly events that match the filter are returned. All events are used to evaluate the aggregated health state.\nIf not specified, all entries are returned. The state values are flag-based enumeration, so the value could be a combination of these values, obtained using the bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.\n\n- Default - Default value. Matches any HealthState. The value is zero.\n- None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.\n- Ok - Filter that matches input with HealthState value Ok. The value is 2.\n- Warning - Filter that matches input with HealthState value Warning. The value is 4.\n- Error - Filter that matches input with HealthState value Error. The value is 8.\n- All - Filter that matches input with any HealthState value. The value is 65535."]
        pub fn events_health_state_filter(mut self, events_health_state_filter: i64) -> Self {
            self.events_health_state_filter = Some(events_health_state_filter);
            self
        }
        #[doc = "Describes the health policies used to evaluate the health of an application or one of its children.\nIf not present, the health evaluation uses the health policy from application manifest or the default health policy."]
        pub fn application_health_policy(mut self, application_health_policy: impl Into<models::ApplicationHealthPolicy>) -> Self {
            self.application_health_policy = Some(application_health_policy.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages/{}/$/GetHealth",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id,
                        &this.service_package_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(events_health_state_filter) = &this.events_health_state_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsHealthStateFilter", &events_health_state_filter.to_string());
                    }
                    let req_body = if let Some(application_health_policy) = &this.application_health_policy {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(application_health_policy)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedServicePackageHealth = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod report_deployed_service_package_health {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_package_name: String,
        pub(crate) health_information: models::HealthInformation,
        pub(crate) immediate: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "A flag that indicates whether the report should be sent immediately.\nA health report is sent to a Service Fabric gateway Application, which forwards to the health store.\nIf Immediate is set to true, the report is sent immediately from HTTP Gateway to the health store, regardless of the fabric client settings that the HTTP Gateway Application is using.\nThis is useful for critical reports that should be sent as soon as possible.\nDepending on timing and other conditions, sending the report may still fail, for example if the HTTP Gateway is closed or the message doesn't reach the Gateway.\nIf Immediate is set to false, the report is sent based on the health client settings from the HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.\nThis is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.\nBy default, reports are not sent immediately."]
        pub fn immediate(mut self, immediate: bool) -> Self {
            self.immediate = Some(immediate);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetServicePackages/{}/$/ReportHealth",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id,
                        &this.service_package_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.health_information)?;
                    if let Some(immediate) = &this.immediate {
                        req.url_mut().query_pairs_mut().append_pair("Immediate", &immediate.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod deploy_service_package_to_node {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) deploy_service_package_to_node_description: models::DeployServicePackageToNodeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/DeployServicePackage",
                        this.client.endpoint(),
                        &this.node_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.deploy_service_package_to_node_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_deployed_code_package_info_list {
    use super::models;
    type Response = models::DeployedCodePackageInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_manifest_name: Option<String>,
        pub(crate) code_package_name: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The name of a service manifest registered as part of an application type in a Service Fabric cluster."]
        pub fn service_manifest_name(mut self, service_manifest_name: impl Into<String>) -> Self {
            self.service_manifest_name = Some(service_manifest_name.into());
            self
        }
        #[doc = "The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster."]
        pub fn code_package_name(mut self, code_package_name: impl Into<String>) -> Self {
            self.code_package_name = Some(code_package_name.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetCodePackages",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(service_manifest_name) = &this.service_manifest_name {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ServiceManifestName", service_manifest_name);
                    }
                    if let Some(code_package_name) = &this.code_package_name {
                        req.url_mut().query_pairs_mut().append_pair("CodePackageName", code_package_name);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::DeployedCodePackageInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod restart_deployed_code_package {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) restart_deployed_code_package_description: models::RestartDeployedCodePackageDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetCodePackages/$/Restart",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.restart_deployed_code_package_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_container_logs_deployed_on_node {
    use super::models;
    type Response = models::ContainerLogs;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_manifest_name: String,
        pub(crate) code_package_name: String,
        pub(crate) tail: Option<String>,
        pub(crate) previous: Option<bool>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Number of lines to show from the end of the logs. Default is 100. 'all' to show the complete logs."]
        pub fn tail(mut self, tail: impl Into<String>) -> Self {
            self.tail = Some(tail.into());
            self
        }
        #[doc = "Specifies whether to get container logs from exited/dead containers of the code package instance."]
        pub fn previous(mut self, previous: bool) -> Self {
            self.previous = Some(previous);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetCodePackages/$/ContainerLogs",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let service_manifest_name = &this.service_manifest_name;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("ServiceManifestName", service_manifest_name);
                    let code_package_name = &this.code_package_name;
                    req.url_mut().query_pairs_mut().append_pair("CodePackageName", code_package_name);
                    if let Some(tail) = &this.tail {
                        req.url_mut().query_pairs_mut().append_pair("Tail", tail);
                    }
                    if let Some(previous) = &this.previous {
                        req.url_mut().query_pairs_mut().append_pair("Previous", &previous.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ContainerLogs = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod invoke_container_api {
    use super::models;
    type Response = models::ContainerApiResponse;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) application_id: String,
        pub(crate) service_manifest_name: String,
        pub(crate) code_package_name: String,
        pub(crate) code_package_instance_id: String,
        pub(crate) container_api_request_body: models::ContainerApiRequestBody,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Nodes/{}/$/GetApplications/{}/$/GetCodePackages/$/ContainerApi",
                        this.client.endpoint(),
                        &this.node_name,
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let service_manifest_name = &this.service_manifest_name;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("ServiceManifestName", service_manifest_name);
                    let code_package_name = &this.code_package_name;
                    req.url_mut().query_pairs_mut().append_pair("CodePackageName", code_package_name);
                    let code_package_instance_id = &this.code_package_instance_id;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("CodePackageInstanceId", code_package_instance_id);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.container_api_request_body)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ContainerApiResponse = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod create_compose_deployment {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) create_compose_deployment_description: models::CreateComposeDeploymentDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ComposeDeployments/$/Create", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.create_compose_deployment_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_compose_deployment_status {
    use super::models;
    type Response = models::ComposeDeploymentStatusInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) deployment_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ComposeDeployments/{}", this.client.endpoint(), &this.deployment_name))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ComposeDeploymentStatusInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_compose_deployment_status_list {
    use super::models;
    type Response = models::PagedComposeDeploymentStatusInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ComposeDeployments", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedComposeDeploymentStatusInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_compose_deployment_upgrade_progress {
    use super::models;
    type Response = models::ComposeDeploymentUpgradeProgressInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) deployment_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ComposeDeployments/{}/$/GetUpgradeProgress",
                        this.client.endpoint(),
                        &this.deployment_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ComposeDeploymentUpgradeProgressInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod remove_compose_deployment {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) deployment_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ComposeDeployments/{}/$/Delete",
                        this.client.endpoint(),
                        &this.deployment_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_compose_deployment_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) deployment_name: String,
        pub(crate) compose_deployment_upgrade_description: models::ComposeDeploymentUpgradeDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ComposeDeployments/{}/$/Upgrade",
                        this.client.endpoint(),
                        &this.deployment_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.compose_deployment_upgrade_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_rollback_compose_deployment_upgrade {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) deployment_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ComposeDeployments/{}/$/RollbackUpgrade",
                        this.client.endpoint(),
                        &this.deployment_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_chaos {
    use super::models;
    type Response = models::Chaos;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Tools/Chaos", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::Chaos = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_chaos {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) chaos_parameters: models::ChaosParameters,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Tools/Chaos/$/Start", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.chaos_parameters)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod stop_chaos {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Tools/Chaos/$/Stop", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_chaos_events {
    use super::models;
    type Response = models::ChaosEventsSegment;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) continuation_token: Option<String>,
        pub(crate) start_time_utc: Option<String>,
        pub(crate) end_time_utc: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The Windows file time representing the start time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details."]
        pub fn start_time_utc(mut self, start_time_utc: impl Into<String>) -> Self {
            self.start_time_utc = Some(start_time_utc.into());
            self
        }
        #[doc = "The Windows file time representing the end time of the time range for which a Chaos report is to be generated. Consult [DateTime.ToFileTimeUtc Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details."]
        pub fn end_time_utc(mut self, end_time_utc: impl Into<String>) -> Self {
            self.end_time_utc = Some(end_time_utc.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Tools/Chaos/Events", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(start_time_utc) = &this.start_time_utc {
                        req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    }
                    if let Some(end_time_utc) = &this.end_time_utc {
                        req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ChaosEventsSegment = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_chaos_schedule {
    use super::models;
    type Response = models::ChaosScheduleDescription;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Tools/Chaos/Schedule", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ChaosScheduleDescription = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod post_chaos_schedule {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) chaos_schedule: models::ChaosScheduleDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Tools/Chaos/Schedule", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.chaos_schedule)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_image_store_content {
    use super::models;
    type Response = models::ImageStoreContent;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) content_path: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/{}", this.client.endpoint(), &this.content_path))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ImageStoreContent = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod upload_file {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) content_path: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/{}", this.client.endpoint(), &this.content_path))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod delete_image_store_content {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) content_path: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/{}", this.client.endpoint(), &this.content_path))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_image_store_root_content {
    use super::models;
    type Response = models::ImageStoreContent;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ImageStoreContent = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod copy_image_store_content {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) image_store_copy_description: models::ImageStoreCopyDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/$/Copy", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.image_store_copy_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod delete_image_store_upload_session {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) session_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/$/DeleteUploadSession", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let session_id = &this.session_id;
                    req.url_mut().query_pairs_mut().append_pair("session-id", session_id);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod commit_image_store_upload_session {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) session_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/$/CommitUploadSession", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let session_id = &this.session_id;
                    req.url_mut().query_pairs_mut().append_pair("session-id", session_id);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_image_store_upload_session_by_id {
    use super::models;
    type Response = models::UploadSession;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) session_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/$/GetUploadSession", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let session_id = &this.session_id;
                    req.url_mut().query_pairs_mut().append_pair("session-id", session_id);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::UploadSession = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_image_store_upload_session_by_path {
    use super::models;
    type Response = models::UploadSession;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) content_path: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ImageStore/{}/$/GetUploadSession",
                        this.client.endpoint(),
                        &this.content_path
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::UploadSession = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod upload_file_chunk {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) content_path: String,
        pub(crate) session_id: String,
        pub(crate) content_range: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ImageStore/{}/$/UploadChunk",
                        this.client.endpoint(),
                        &this.content_path
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let session_id = &this.session_id;
                    req.url_mut().query_pairs_mut().append_pair("session-id", session_id);
                    req.insert_header("content-range", &this.content_range);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_image_store_root_folder_size {
    use super::models;
    type Response = models::FolderSizeInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/$/FolderSize", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::FolderSizeInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_image_store_folder_size {
    use super::models;
    type Response = models::FolderSizeInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) content_path: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/ImageStore/{}/$/FolderSize",
                        this.client.endpoint(),
                        &this.content_path
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::FolderSizeInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_image_store_info {
    use super::models;
    type Response = models::ImageStoreInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/ImageStore/$/Info", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ImageStoreInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod invoke_infrastructure_command {
    use super::models;
    type Response = models::InfrastructureServiceResponse;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) command: String,
        pub(crate) service_id: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running."]
        pub fn service_id(mut self, service_id: impl Into<String>) -> Self {
            self.service_id = Some(service_id.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/InvokeInfrastructureCommand", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let command = &this.command;
                    req.url_mut().query_pairs_mut().append_pair("Command", command);
                    if let Some(service_id) = &this.service_id {
                        req.url_mut().query_pairs_mut().append_pair("ServiceId", service_id);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::InfrastructureServiceResponse = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod invoke_infrastructure_query {
    use super::models;
    type Response = models::InfrastructureServiceResponse;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) command: String,
        pub(crate) service_id: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The identity of the infrastructure service. This is the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that has more than one instance of infrastructure service running."]
        pub fn service_id(mut self, service_id: impl Into<String>) -> Self {
            self.service_id = Some(service_id.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/$/InvokeInfrastructureQuery", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let command = &this.command;
                    req.url_mut().query_pairs_mut().append_pair("Command", command);
                    if let Some(service_id) = &this.service_id {
                        req.url_mut().query_pairs_mut().append_pair("ServiceId", service_id);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::InfrastructureServiceResponse = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_data_loss {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_id: String,
        pub(crate) operation_id: String,
        pub(crate) data_loss_mode: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Faults/Services/{}/$/GetPartitions/{}/$/StartDataLoss",
                        this.client.endpoint(),
                        &this.service_id,
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    let data_loss_mode = &this.data_loss_mode;
                    req.url_mut().query_pairs_mut().append_pair("DataLossMode", data_loss_mode);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_data_loss_progress {
    use super::models;
    type Response = models::PartitionDataLossProgress;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_id: String,
        pub(crate) operation_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Faults/Services/{}/$/GetPartitions/{}/$/GetDataLossProgress",
                        this.client.endpoint(),
                        &this.service_id,
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionDataLossProgress = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_quorum_loss {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_id: String,
        pub(crate) operation_id: String,
        pub(crate) quorum_loss_mode: String,
        pub(crate) quorum_loss_duration: i64,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Faults/Services/{}/$/GetPartitions/{}/$/StartQuorumLoss",
                        this.client.endpoint(),
                        &this.service_id,
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    let quorum_loss_mode = &this.quorum_loss_mode;
                    req.url_mut().query_pairs_mut().append_pair("QuorumLossMode", quorum_loss_mode);
                    let quorum_loss_duration = &this.quorum_loss_duration;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("QuorumLossDuration", &quorum_loss_duration.to_string());
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_quorum_loss_progress {
    use super::models;
    type Response = models::PartitionQuorumLossProgress;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_id: String,
        pub(crate) operation_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Faults/Services/{}/$/GetPartitions/{}/$/GetQuorumLossProgress",
                        this.client.endpoint(),
                        &this.service_id,
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionQuorumLossProgress = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_partition_restart {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_id: String,
        pub(crate) operation_id: String,
        pub(crate) restart_partition_mode: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Faults/Services/{}/$/GetPartitions/{}/$/StartRestart",
                        this.client.endpoint(),
                        &this.service_id,
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    let restart_partition_mode = &this.restart_partition_mode;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("RestartPartitionMode", restart_partition_mode);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_restart_progress {
    use super::models;
    type Response = models::PartitionRestartProgress;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) partition_id: String,
        pub(crate) operation_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Faults/Services/{}/$/GetPartitions/{}/$/GetRestartProgress",
                        this.client.endpoint(),
                        &this.service_id,
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionRestartProgress = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod start_node_transition {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) operation_id: String,
        pub(crate) node_transition_type: String,
        pub(crate) node_instance_id: String,
        pub(crate) stop_duration_in_seconds: i32,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Faults/Nodes/{}/$/StartTransition/",
                        this.client.endpoint(),
                        &this.node_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    let node_transition_type = &this.node_transition_type;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("NodeTransitionType", node_transition_type);
                    let node_instance_id = &this.node_instance_id;
                    req.url_mut().query_pairs_mut().append_pair("NodeInstanceId", node_instance_id);
                    let stop_duration_in_seconds = &this.stop_duration_in_seconds;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("StopDurationInSeconds", &stop_duration_in_seconds.to_string());
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_node_transition_progress {
    use super::models;
    type Response = models::NodeTransitionProgress;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) operation_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Faults/Nodes/{}/$/GetTransitionProgress",
                        this.client.endpoint(),
                        &this.node_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::NodeTransitionProgress = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_fault_operation_list {
    use super::models;
    type Response = models::OperationStatusList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) type_filter: i64,
        pub(crate) state_filter: i64,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Faults/", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let type_filter = &this.type_filter;
                    req.url_mut().query_pairs_mut().append_pair("TypeFilter", &type_filter.to_string());
                    let state_filter = &this.state_filter;
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair("StateFilter", &state_filter.to_string());
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::OperationStatusList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod cancel_operation {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) operation_id: String,
        pub(crate) force: bool,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Faults/$/Cancel", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let operation_id = &this.operation_id;
                    req.url_mut().query_pairs_mut().append_pair("OperationId", operation_id);
                    let force = &this.force;
                    req.url_mut().query_pairs_mut().append_pair("Force", &force.to_string());
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod create_backup_policy {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) backup_policy_description: models::BackupPolicyDescription,
        pub(crate) timeout: Option<i64>,
        pub(crate) validate_connection: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "Specifies whether to validate the storage connection and credentials before creating or updating the backup policies."]
        pub fn validate_connection(mut self, validate_connection: bool) -> Self {
            self.validate_connection = Some(validate_connection);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/BackupRestore/BackupPolicies/$/Create", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.backup_policy_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    if let Some(validate_connection) = &this.validate_connection {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ValidateConnection", &validate_connection.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Created => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod delete_backup_policy {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) backup_policy_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/BackupRestore/BackupPolicies/{}/$/Delete",
                        this.client.endpoint(),
                        &this.backup_policy_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_backup_policy_list {
    use super::models;
    type Response = models::PagedBackupPolicyDescriptionList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/BackupRestore/BackupPolicies", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedBackupPolicyDescriptionList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_backup_policy_by_name {
    use super::models;
    type Response = models::BackupPolicyDescription;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) backup_policy_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/BackupRestore/BackupPolicies/{}",
                        this.client.endpoint(),
                        &this.backup_policy_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::BackupPolicyDescription = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_all_entities_backed_up_by_policy {
    use super::models;
    type Response = models::PagedBackupEntityList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) backup_policy_name: String,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/BackupRestore/BackupPolicies/{}/$/GetBackupEnabledEntities",
                        this.client.endpoint(),
                        &this.backup_policy_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedBackupEntityList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod update_backup_policy {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) backup_policy_description: models::BackupPolicyDescription,
        pub(crate) backup_policy_name: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) validate_connection: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "Specifies whether to validate the storage connection and credentials before creating or updating the backup policies."]
        pub fn validate_connection(mut self, validate_connection: bool) -> Self {
            self.validate_connection = Some(validate_connection);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/BackupRestore/BackupPolicies/{}/$/Update",
                        this.client.endpoint(),
                        &this.backup_policy_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.backup_policy_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    if let Some(validate_connection) = &this.validate_connection {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ValidateConnection", &validate_connection.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod enable_application_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) enable_backup_description: models::EnableBackupDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/EnableBackup",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.enable_backup_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod disable_application_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) disable_backup_description: Option<models::DisableBackupDescription>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "Specifies the parameters to disable backup for any backup entity."]
        pub fn disable_backup_description(mut self, disable_backup_description: impl Into<models::DisableBackupDescription>) -> Self {
            self.disable_backup_description = Some(disable_backup_description.into());
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/DisableBackup",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = if let Some(disable_backup_description) = &this.disable_backup_description {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(disable_backup_description)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_backup_configuration_info {
    use super::models;
    type Response = models::PagedBackupConfigurationInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetBackupConfigurationInfo",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedBackupConfigurationInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_backup_list {
    use super::models;
    type Response = models::PagedBackupInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) latest: Option<bool>,
        pub(crate) start_date_time_filter: Option<time::OffsetDateTime>,
        pub(crate) end_date_time_filter: Option<time::OffsetDateTime>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "Specifies whether to get only the most recent backup available for a partition for the specified time range."]
        pub fn latest(mut self, latest: bool) -> Self {
            self.latest = Some(latest);
            self
        }
        #[doc = "Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated."]
        pub fn start_date_time_filter(mut self, start_date_time_filter: impl Into<time::OffsetDateTime>) -> Self {
            self.start_date_time_filter = Some(start_date_time_filter.into());
            self
        }
        #[doc = "Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup."]
        pub fn end_date_time_filter(mut self, end_date_time_filter: impl Into<time::OffsetDateTime>) -> Self {
            self.end_date_time_filter = Some(end_date_time_filter.into());
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/GetBackups",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    if let Some(latest) = &this.latest {
                        req.url_mut().query_pairs_mut().append_pair("Latest", &latest.to_string());
                    }
                    if let Some(start_date_time_filter) = &this.start_date_time_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("StartDateTimeFilter", &start_date_time_filter.to_string());
                    }
                    if let Some(end_date_time_filter) = &this.end_date_time_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EndDateTimeFilter", &end_date_time_filter.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedBackupInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod suspend_application_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/SuspendBackup",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod resume_application_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Applications/{}/$/ResumeBackup",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod enable_service_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) enable_backup_description: models::EnableBackupDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/EnableBackup", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.enable_backup_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod disable_service_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) disable_backup_description: Option<models::DisableBackupDescription>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Specifies the parameters to disable backup for any backup entity."]
        pub fn disable_backup_description(mut self, disable_backup_description: impl Into<models::DisableBackupDescription>) -> Self {
            self.disable_backup_description = Some(disable_backup_description.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/DisableBackup", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let req_body = if let Some(disable_backup_description) = &this.disable_backup_description {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(disable_backup_description)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_backup_configuration_info {
    use super::models;
    type Response = models::PagedBackupConfigurationInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Services/{}/$/GetBackupConfigurationInfo",
                        this.client.endpoint(),
                        &this.service_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedBackupConfigurationInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_backup_list {
    use super::models;
    type Response = models::PagedBackupInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) latest: Option<bool>,
        pub(crate) start_date_time_filter: Option<time::OffsetDateTime>,
        pub(crate) end_date_time_filter: Option<time::OffsetDateTime>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "Specifies whether to get only the most recent backup available for a partition for the specified time range."]
        pub fn latest(mut self, latest: bool) -> Self {
            self.latest = Some(latest);
            self
        }
        #[doc = "Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated."]
        pub fn start_date_time_filter(mut self, start_date_time_filter: impl Into<time::OffsetDateTime>) -> Self {
            self.start_date_time_filter = Some(start_date_time_filter.into());
            self
        }
        #[doc = "Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup."]
        pub fn end_date_time_filter(mut self, end_date_time_filter: impl Into<time::OffsetDateTime>) -> Self {
            self.end_date_time_filter = Some(end_date_time_filter.into());
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/GetBackups", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    if let Some(latest) = &this.latest {
                        req.url_mut().query_pairs_mut().append_pair("Latest", &latest.to_string());
                    }
                    if let Some(start_date_time_filter) = &this.start_date_time_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("StartDateTimeFilter", &start_date_time_filter.to_string());
                    }
                    if let Some(end_date_time_filter) = &this.end_date_time_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EndDateTimeFilter", &end_date_time_filter.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedBackupInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod suspend_service_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/SuspendBackup", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod resume_service_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Services/{}/$/ResumeBackup", this.client.endpoint(), &this.service_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod enable_partition_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) enable_backup_description: models::EnableBackupDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/EnableBackup",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.enable_backup_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod disable_partition_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) disable_backup_description: Option<models::DisableBackupDescription>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Specifies the parameters to disable backup for any backup entity."]
        pub fn disable_backup_description(mut self, disable_backup_description: impl Into<models::DisableBackupDescription>) -> Self {
            self.disable_backup_description = Some(disable_backup_description.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/DisableBackup",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let req_body = if let Some(disable_backup_description) = &this.disable_backup_description {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(disable_backup_description)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_backup_configuration_info {
    use super::models;
    type Response = models::PartitionBackupConfigurationInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetBackupConfigurationInfo",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionBackupConfigurationInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_backup_list {
    use super::models;
    type Response = models::PagedBackupInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) latest: Option<bool>,
        pub(crate) start_date_time_filter: Option<time::OffsetDateTime>,
        pub(crate) end_date_time_filter: Option<time::OffsetDateTime>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "Specifies whether to get only the most recent backup available for a partition for the specified time range."]
        pub fn latest(mut self, latest: bool) -> Self {
            self.latest = Some(latest);
            self
        }
        #[doc = "Specify the start date time from which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, all backups from the beginning are enumerated."]
        pub fn start_date_time_filter(mut self, start_date_time_filter: impl Into<time::OffsetDateTime>) -> Self {
            self.start_date_time_filter = Some(start_date_time_filter.into());
            self
        }
        #[doc = "Specify the end date time till which to enumerate backups, in datetime format. The date time must be specified in ISO8601 format. This is an optional parameter. If not specified, enumeration is done till the most recent backup."]
        pub fn end_date_time_filter(mut self, end_date_time_filter: impl Into<time::OffsetDateTime>) -> Self {
            self.end_date_time_filter = Some(end_date_time_filter.into());
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetBackups",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    if let Some(latest) = &this.latest {
                        req.url_mut().query_pairs_mut().append_pair("Latest", &latest.to_string());
                    }
                    if let Some(start_date_time_filter) = &this.start_date_time_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("StartDateTimeFilter", &start_date_time_filter.to_string());
                    }
                    if let Some(end_date_time_filter) = &this.end_date_time_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EndDateTimeFilter", &end_date_time_filter.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedBackupInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod suspend_partition_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/SuspendBackup",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod resume_partition_backup {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/ResumeBackup",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod backup_partition {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) backup_partition_description: Option<models::BackupPartitionDescription>,
        pub(crate) backup_timeout: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Describes the parameters to backup the partition now. If not present, backup operation uses default parameters from the backup policy current associated with this partition."]
        pub fn backup_partition_description(mut self, backup_partition_description: impl Into<models::BackupPartitionDescription>) -> Self {
            self.backup_partition_description = Some(backup_partition_description.into());
            self
        }
        #[doc = "Specifies the maximum amount of time, in minutes, to wait for the backup operation to complete. Post that, the operation completes with timeout error. However, in certain corner cases it could be that though the operation returns back timeout, the backup actually goes through. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. The default value for the same is 10 minutes."]
        pub fn backup_timeout(mut self, backup_timeout: i64) -> Self {
            self.backup_timeout = Some(backup_timeout);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Partitions/{}/$/Backup", this.client.endpoint(), &this.partition_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let req_body = if let Some(backup_partition_description) = &this.backup_partition_description {
                        req.insert_header("content-type", "application/json");
                        azure_core::to_json(backup_partition_description)?
                    } else {
                        azure_core::EMPTY_BODY
                    };
                    if let Some(backup_timeout) = &this.backup_timeout {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("BackupTimeout", &backup_timeout.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_backup_progress {
    use super::models;
    type Response = models::BackupProgressInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetBackupProgress",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::BackupProgressInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod restore_partition {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) restore_partition_description: models::RestorePartitionDescription,
        pub(crate) restore_timeout: Option<i64>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Specifies the maximum amount of time to wait, in minutes, for the restore operation to complete. Post that, the operation returns back with timeout error. However, in certain corner cases it could be that the restore operation goes through even though it completes with timeout. In case of timeout error, its recommended to invoke this operation again with a greater timeout value. the default value for the same is 10 minutes."]
        pub fn restore_timeout(mut self, restore_timeout: i64) -> Self {
            self.restore_timeout = Some(restore_timeout);
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Partitions/{}/$/Restore", this.client.endpoint(), &this.partition_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.restore_partition_description)?;
                    if let Some(restore_timeout) = &this.restore_timeout {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("RestoreTimeout", &restore_timeout.to_string());
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Accepted => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_restore_progress {
    use super::models;
    type Response = models::RestoreProgressInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Partitions/{}/$/GetRestoreProgress",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::RestoreProgressInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_backups_from_backup_location {
    use super::models;
    type Response = models::PagedBackupInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) get_backup_by_storage_query_description: models::GetBackupByStorageQueryDescription,
        pub(crate) timeout: Option<i64>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) max_results: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged query includes as many results as possible that fit in the return message."]
        pub fn max_results(mut self, max_results: i64) -> Self {
            self.max_results = Some(max_results);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/BackupRestore/$/GetBackups", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(max_results) = &this.max_results {
                        req.url_mut().query_pairs_mut().append_pair("MaxResults", &max_results.to_string());
                    }
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.get_backup_by_storage_query_description)?;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedBackupInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod create_name {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_description: models::NameDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Names/$/Create", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.name_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Created => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_name_exists_info {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Names/{}", this.client.endpoint(), &this.name_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod delete_name {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Names/{}", this.client.endpoint(), &this.name_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_sub_name_info_list {
    use super::models;
    type Response = models::PagedSubNameInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_id: String,
        pub(crate) recursive: Option<bool>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows specifying that the search performed should be recursive."]
        pub fn recursive(mut self, recursive: bool) -> Self {
            self.recursive = Some(recursive);
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Names/{}/$/GetSubNames", this.client.endpoint(), &this.name_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(recursive) = &this.recursive {
                        req.url_mut().query_pairs_mut().append_pair("Recursive", &recursive.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedSubNameInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_property_info_list {
    use super::models;
    type Response = models::PagedPropertyInfoList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_id: String,
        pub(crate) include_values: Option<bool>,
        pub(crate) continuation_token: Option<String>,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata."]
        pub fn include_values(mut self, include_values: bool) -> Self {
            self.include_values = Some(include_values);
            self
        }
        #[doc = "The continuation token parameter is used to obtain next set of results. A continuation token with a non-empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results, then the continuation token does not contain a value. The value of this parameter should not be URL encoded."]
        pub fn continuation_token(mut self, continuation_token: impl Into<String>) -> Self {
            self.continuation_token = Some(continuation_token.into());
            self
        }
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Names/{}/$/GetProperties", this.client.endpoint(), &this.name_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(include_values) = &this.include_values {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("IncludeValues", &include_values.to_string());
                    }
                    if let Some(continuation_token) = &this.continuation_token {
                        req.url_mut().query_pairs_mut().append_pair("ContinuationToken", continuation_token);
                    }
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PagedPropertyInfoList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_property_info {
    use super::models;
    type Response = models::PropertyInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_id: String,
        pub(crate) property_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Names/{}/$/GetProperty", this.client.endpoint(), &this.name_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let property_name = &this.property_name;
                    req.url_mut().query_pairs_mut().append_pair("PropertyName", property_name);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PropertyInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod put_property {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_id: String,
        pub(crate) property_description: models::PropertyDescription,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Names/{}/$/GetProperty", this.client.endpoint(), &this.name_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.property_description)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod delete_property {
    use super::models;
    type Response = ();
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_id: String,
        pub(crate) property_name: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/Names/{}/$/GetProperty", this.client.endpoint(), &this.name_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    let property_name = &this.property_name;
                    req.url_mut().query_pairs_mut().append_pair("PropertyName", property_name);
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => Ok(()),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod submit_property_batch {
    use super::models;
    type Response = models::SuccessfulPropertyBatchInfo;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) name_id: String,
        pub(crate) property_batch_description_list: models::PropertyBatchDescriptionList,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/Names/{}/$/GetProperties/$/SubmitBatch",
                        this.client.endpoint(),
                        &this.name_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.property_batch_description_list)?;
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::SuccessfulPropertyBatchInfo = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_cluster_event_list {
    use super::models;
    type Response = models::ClusterEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/EventsStore/Cluster/Events", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ClusterEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_containers_event_list {
    use super::models;
    type Response = models::ContainerInstanceEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/EventsStore/Containers/Events", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ContainerInstanceEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_node_event_list {
    use super::models;
    type Response = models::NodeEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) node_name: String,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/EventsStore/Nodes/{}/$/Events",
                        this.client.endpoint(),
                        &this.node_name
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::NodeEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_nodes_event_list {
    use super::models;
    type Response = models::NodeEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/EventsStore/Nodes/Events", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::NodeEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_application_event_list {
    use super::models;
    type Response = models::ApplicationEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) application_id: String,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/EventsStore/Applications/{}/$/Events",
                        this.client.endpoint(),
                        &this.application_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_applications_event_list {
    use super::models;
    type Response = models::ApplicationEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/EventsStore/Applications/Events", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ApplicationEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_service_event_list {
    use super::models;
    type Response = models::ServiceEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) service_id: String,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/EventsStore/Services/{}/$/Events",
                        this.client.endpoint(),
                        &this.service_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_services_event_list {
    use super::models;
    type Response = models::ServiceEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/EventsStore/Services/Events", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ServiceEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_event_list {
    use super::models;
    type Response = models::PartitionEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/EventsStore/Partitions/{}/$/Events",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partitions_event_list {
    use super::models;
    type Response = models::PartitionEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/EventsStore/Partitions/Events", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::PartitionEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_replica_event_list {
    use super::models;
    type Response = models::ReplicaEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) replica_id: String,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/EventsStore/Partitions/{}/$/Replicas/{}/$/Events",
                        this.client.endpoint(),
                        &this.partition_id,
                        &this.replica_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ReplicaEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_partition_replicas_event_list {
    use super::models;
    type Response = models::ReplicaEventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) partition_id: String,
        pub(crate) start_time_utc: String,
        pub(crate) end_time_utc: String,
        pub(crate) timeout: Option<i64>,
        pub(crate) events_types_filter: Option<String>,
        pub(crate) exclude_analysis_events: Option<bool>,
        pub(crate) skip_correlation_lookup: Option<bool>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        #[doc = "This is a comma separated string specifying the types of FabricEvents that should only be included in the response."]
        pub fn events_types_filter(mut self, events_types_filter: impl Into<String>) -> Self {
            self.events_types_filter = Some(events_types_filter.into());
            self
        }
        #[doc = "This param disables the retrieval of AnalysisEvents if true is passed."]
        pub fn exclude_analysis_events(mut self, exclude_analysis_events: bool) -> Self {
            self.exclude_analysis_events = Some(exclude_analysis_events);
            self
        }
        #[doc = "This param disables the search of CorrelatedEvents information if true is passed. otherwise the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets populated."]
        pub fn skip_correlation_lookup(mut self, skip_correlation_lookup: bool) -> Self {
            self.skip_correlation_lookup = Some(skip_correlation_lookup);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/EventsStore/Partitions/{}/$/Replicas/Events",
                        this.client.endpoint(),
                        &this.partition_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let start_time_utc = &this.start_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("StartTimeUtc", start_time_utc);
                    let end_time_utc = &this.end_time_utc;
                    req.url_mut().query_pairs_mut().append_pair("EndTimeUtc", end_time_utc);
                    if let Some(events_types_filter) = &this.events_types_filter {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("EventsTypesFilter", events_types_filter);
                    }
                    if let Some(exclude_analysis_events) = &this.exclude_analysis_events {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("ExcludeAnalysisEvents", &exclude_analysis_events.to_string());
                    }
                    if let Some(skip_correlation_lookup) = &this.skip_correlation_lookup {
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair("SkipCorrelationLookup", &skip_correlation_lookup.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::ReplicaEventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod get_correlated_event_list {
    use super::models;
    type Response = models::EventList;
    #[derive(Clone)]
    pub struct Builder {
        pub(crate) client: super::Client,
        pub(crate) event_instance_id: String,
        pub(crate) timeout: Option<i64>,
    }
    impl Builder {
        #[doc = "The server timeout for performing the operation in seconds. This timeout specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds."]
        pub fn timeout(mut self, timeout: i64) -> Self {
            self.timeout = Some(timeout);
            self
        }
        pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/EventsStore/CorrelatedEvents/{}/$/Events",
                        this.client.endpoint(),
                        &this.event_instance_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "8.0");
                    if let Some(timeout) = &this.timeout {
                        req.url_mut().query_pairs_mut().append_pair("timeout", &timeout.to_string());
                    }
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    let rsp = this.client.send(&mut req).await?;
                    let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                    match rsp_status {
                        azure_core::StatusCode::Ok => {
                            let rsp_body = rsp_stream.collect().await?;
                            let rsp_value: models::EventList = serde_json::from_slice(&rsp_body)?;
                            Ok(rsp_value)
                        }
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    }
                }
            })
        }
    }
}
pub mod mesh_secret {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the Secret resource with the given name."]
        #[doc = "Gets the information about the Secret resource with the given name. The information include the description and other properties of the Secret."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `secret_resource_name`: The name of the secret resource."]
        pub fn get(&self, secret_resource_name: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                secret_resource_name: secret_resource_name.into(),
            }
        }
        #[doc = "Creates or updates a Secret resource."]
        #[doc = "Creates a Secret resource with the specified name, description and properties. If Secret resource with the same name exists, then it is updated with the specified description and properties. Once created, the kind and contentType of a secret resource cannot be updated."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `secret_resource_name`: The name of the secret resource."]
        #[doc = "* `secret_resource_description`: Description for creating a secret resource."]
        pub fn create_or_update(
            &self,
            secret_resource_name: impl Into<String>,
            secret_resource_description: impl Into<models::SecretResourceDescription>,
        ) -> create_or_update::Builder {
            create_or_update::Builder {
                client: self.0.clone(),
                secret_resource_name: secret_resource_name.into(),
                secret_resource_description: secret_resource_description.into(),
            }
        }
        #[doc = "Deletes the Secret resource."]
        #[doc = "Deletes the specified Secret resource and all of its named values."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `secret_resource_name`: The name of the secret resource."]
        pub fn delete(&self, secret_resource_name: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                secret_resource_name: secret_resource_name.into(),
            }
        }
        #[doc = "Lists all the secret resources."]
        #[doc = "Gets the information about all secret resources in a given resource group. The information include the description and other properties of the Secret."]
        pub fn list(&self) -> list::Builder {
            list::Builder { client: self.0.clone() }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::SecretResourceDescription;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) secret_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Secrets/{}",
                            this.client.endpoint(),
                            &this.secret_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::SecretResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::SecretResourceDescription),
            Created201(models::SecretResourceDescription),
            Accepted202,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) secret_resource_name: String,
            pub(crate) secret_resource_description: models::SecretResourceDescription,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Secrets/{}",
                            this.client.endpoint(),
                            &this.secret_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.secret_resource_description)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::SecretResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Ok200(rsp_value))
                            }
                            azure_core::StatusCode::Created => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::SecretResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Created201(rsp_value))
                            }
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) secret_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Secrets/{}",
                            this.client.endpoint(),
                            &this.secret_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => Ok(Response::Ok200),
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::PagedSecretResourceDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/Resources/Secrets", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::PagedSecretResourceDescriptionList = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod mesh_secret_value {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the specified secret value resource."]
        #[doc = "Get the information about the specified named secret value resources. The information does not include the actual value of the secret."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `secret_resource_name`: The name of the secret resource."]
        #[doc = "* `secret_value_resource_name`: The name of the secret resource value which is typically the version identifier for the value."]
        pub fn get(&self, secret_resource_name: impl Into<String>, secret_value_resource_name: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                secret_resource_name: secret_resource_name.into(),
                secret_value_resource_name: secret_value_resource_name.into(),
            }
        }
        #[doc = "Adds the specified value as a new version of the specified secret resource."]
        #[doc = "Creates a new value of the specified secret resource. The name of the value is typically the version identifier. Once created the value cannot be changed."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `secret_resource_name`: The name of the secret resource."]
        #[doc = "* `secret_value_resource_name`: The name of the secret resource value which is typically the version identifier for the value."]
        #[doc = "* `secret_value_resource_description`: Description for creating a value of a secret resource."]
        pub fn add_value(
            &self,
            secret_resource_name: impl Into<String>,
            secret_value_resource_name: impl Into<String>,
            secret_value_resource_description: impl Into<models::SecretValueResourceDescription>,
        ) -> add_value::Builder {
            add_value::Builder {
                client: self.0.clone(),
                secret_resource_name: secret_resource_name.into(),
                secret_value_resource_name: secret_value_resource_name.into(),
                secret_value_resource_description: secret_value_resource_description.into(),
            }
        }
        #[doc = "Deletes the specified  value of the named secret resource."]
        #[doc = "Deletes the secret value resource identified by the name. The name of the resource is typically the version associated with that value. Deletion will fail if the specified value is in use."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `secret_resource_name`: The name of the secret resource."]
        #[doc = "* `secret_value_resource_name`: The name of the secret resource value which is typically the version identifier for the value."]
        pub fn delete(&self, secret_resource_name: impl Into<String>, secret_value_resource_name: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                secret_resource_name: secret_resource_name.into(),
                secret_value_resource_name: secret_value_resource_name.into(),
            }
        }
        #[doc = "List names of all values of the specified secret resource."]
        #[doc = "Gets information about all secret value resources of the specified secret resource. The information includes the names of the secret value resources, but not the actual values."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `secret_resource_name`: The name of the secret resource."]
        pub fn list(&self, secret_resource_name: impl Into<String>) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                secret_resource_name: secret_resource_name.into(),
            }
        }
        #[doc = "Lists the specified value of the secret resource."]
        #[doc = "Lists the decrypted value of the specified named value of the secret resource. This is a privileged operation."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `secret_resource_name`: The name of the secret resource."]
        #[doc = "* `secret_value_resource_name`: The name of the secret resource value which is typically the version identifier for the value."]
        pub fn show(&self, secret_resource_name: impl Into<String>, secret_value_resource_name: impl Into<String>) -> show::Builder {
            show::Builder {
                client: self.0.clone(),
                secret_resource_name: secret_resource_name.into(),
                secret_value_resource_name: secret_value_resource_name.into(),
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::SecretValueResourceDescription;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) secret_resource_name: String,
            pub(crate) secret_value_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Secrets/{}/values/{}",
                            this.client.endpoint(),
                            &this.secret_resource_name,
                            &this.secret_value_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::SecretValueResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod add_value {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::SecretValueResourceDescription),
            Created201(models::SecretValueResourceDescription),
            Accepted202,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) secret_resource_name: String,
            pub(crate) secret_value_resource_name: String,
            pub(crate) secret_value_resource_description: models::SecretValueResourceDescription,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Secrets/{}/values/{}",
                            this.client.endpoint(),
                            &this.secret_resource_name,
                            &this.secret_value_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.secret_value_resource_description)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::SecretValueResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Ok200(rsp_value))
                            }
                            azure_core::StatusCode::Created => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::SecretValueResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Created201(rsp_value))
                            }
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) secret_resource_name: String,
            pub(crate) secret_value_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Secrets/{}/values/{}",
                            this.client.endpoint(),
                            &this.secret_resource_name,
                            &this.secret_value_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => Ok(Response::Ok200),
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::PagedSecretValueResourceDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) secret_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Secrets/{}/values",
                            this.client.endpoint(),
                            &this.secret_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::PagedSecretValueResourceDescriptionList = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod show {
        use super::models;
        type Response = models::SecretValue;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) secret_resource_name: String,
            pub(crate) secret_value_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Secrets/{}/values/{}/list_value",
                            this.client.endpoint(),
                            &this.secret_resource_name,
                            &this.secret_value_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::SecretValue = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod mesh_volume {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the Volume resource with the given name."]
        #[doc = "Gets the information about the Volume resource with the given name. The information include the description and other properties of the Volume."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `volume_resource_name`: The identity of the volume."]
        pub fn get(&self, volume_resource_name: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                volume_resource_name: volume_resource_name.into(),
            }
        }
        #[doc = "Creates or updates a Volume resource."]
        #[doc = "Creates a Volume resource with the specified name, description and properties. If Volume resource with the same name exists, then it is updated with the specified description and properties."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `volume_resource_name`: The identity of the volume."]
        #[doc = "* `volume_resource_description`: Description for creating a Volume resource."]
        pub fn create_or_update(
            &self,
            volume_resource_name: impl Into<String>,
            volume_resource_description: impl Into<models::VolumeResourceDescription>,
        ) -> create_or_update::Builder {
            create_or_update::Builder {
                client: self.0.clone(),
                volume_resource_name: volume_resource_name.into(),
                volume_resource_description: volume_resource_description.into(),
            }
        }
        #[doc = "Deletes the Volume resource."]
        #[doc = "Deletes the Volume resource identified by the name."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `volume_resource_name`: The identity of the volume."]
        pub fn delete(&self, volume_resource_name: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                volume_resource_name: volume_resource_name.into(),
            }
        }
        #[doc = "Lists all the volume resources."]
        #[doc = "Gets the information about all volume resources in a given resource group. The information include the description and other properties of the Volume."]
        pub fn list(&self) -> list::Builder {
            list::Builder { client: self.0.clone() }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::VolumeResourceDescription;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) volume_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Volumes/{}",
                            this.client.endpoint(),
                            &this.volume_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::VolumeResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::VolumeResourceDescription),
            Created201(models::VolumeResourceDescription),
            Accepted202,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) volume_resource_name: String,
            pub(crate) volume_resource_description: models::VolumeResourceDescription,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Volumes/{}",
                            this.client.endpoint(),
                            &this.volume_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.volume_resource_description)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::VolumeResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Ok200(rsp_value))
                            }
                            azure_core::StatusCode::Created => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::VolumeResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Created201(rsp_value))
                            }
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) volume_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Volumes/{}",
                            this.client.endpoint(),
                            &this.volume_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => Ok(Response::Ok200),
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::PagedVolumeResourceDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/Resources/Volumes", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::PagedVolumeResourceDescriptionList = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod mesh_network {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the Network resource with the given name."]
        #[doc = "Gets the information about the Network resource with the given name. The information include the description and other properties of the Network."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `network_resource_name`: The identity of the network."]
        pub fn get(&self, network_resource_name: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                network_resource_name: network_resource_name.into(),
            }
        }
        #[doc = "Creates or updates a Network resource."]
        #[doc = "Creates a Network resource with the specified name, description and properties. If Network resource with the same name exists, then it is updated with the specified description and properties. Network resource provides connectivity between application services."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `network_resource_name`: The identity of the network."]
        #[doc = "* `network_resource_description`: Description for creating a Network resource."]
        pub fn create_or_update(
            &self,
            network_resource_name: impl Into<String>,
            network_resource_description: impl Into<models::NetworkResourceDescription>,
        ) -> create_or_update::Builder {
            create_or_update::Builder {
                client: self.0.clone(),
                network_resource_name: network_resource_name.into(),
                network_resource_description: network_resource_description.into(),
            }
        }
        #[doc = "Deletes the Network resource."]
        #[doc = "Deletes the Network resource identified by the name."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `network_resource_name`: The identity of the network."]
        pub fn delete(&self, network_resource_name: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                network_resource_name: network_resource_name.into(),
            }
        }
        #[doc = "Lists all the network resources."]
        #[doc = "Gets the information about all network resources in a given resource group. The information include the description and other properties of the Network."]
        pub fn list(&self) -> list::Builder {
            list::Builder { client: self.0.clone() }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::NetworkResourceDescription;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) network_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Networks/{}",
                            this.client.endpoint(),
                            &this.network_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::NetworkResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::NetworkResourceDescription),
            Created201(models::NetworkResourceDescription),
            Accepted202,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) network_resource_name: String,
            pub(crate) network_resource_description: models::NetworkResourceDescription,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Networks/{}",
                            this.client.endpoint(),
                            &this.network_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.network_resource_description)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::NetworkResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Ok200(rsp_value))
                            }
                            azure_core::StatusCode::Created => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::NetworkResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Created201(rsp_value))
                            }
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) network_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Networks/{}",
                            this.client.endpoint(),
                            &this.network_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => Ok(Response::Ok200),
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::PagedNetworkResourceDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/Resources/Networks", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::PagedNetworkResourceDescriptionList = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod mesh_application {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the Application resource with the given name."]
        #[doc = "Gets the information about the Application resource with the given name. The information include the description and other properties of the Application."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        pub fn get(&self, application_resource_name: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
            }
        }
        #[doc = "Creates or updates a Application resource."]
        #[doc = "Creates a Application resource with the specified name, description and properties. If Application resource with the same name exists, then it is updated with the specified description and properties."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        #[doc = "* `application_resource_description`: Description for creating a Application resource."]
        pub fn create_or_update(
            &self,
            application_resource_name: impl Into<String>,
            application_resource_description: impl Into<models::ApplicationResourceDescription>,
        ) -> create_or_update::Builder {
            create_or_update::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
                application_resource_description: application_resource_description.into(),
            }
        }
        #[doc = "Deletes the Application resource."]
        #[doc = "Deletes the Application resource identified by the name."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        pub fn delete(&self, application_resource_name: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
            }
        }
        #[doc = "Lists all the application resources."]
        #[doc = "Gets the information about all application resources in a given resource group. The information include the description and other properties of the Application."]
        pub fn list(&self) -> list::Builder {
            list::Builder { client: self.0.clone() }
        }
        #[doc = "Gets the progress of the latest upgrade performed on this application resource."]
        #[doc = "Gets the upgrade progress information about the Application resource with the given name. The information include percentage of completion and other upgrade state information of the Application resource."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        pub fn get_upgrade_progress(&self, application_resource_name: impl Into<String>) -> get_upgrade_progress::Builder {
            get_upgrade_progress::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::ApplicationResourceDescription;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}",
                            this.client.endpoint(),
                            &this.application_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::ApplicationResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::ApplicationResourceDescription),
            Created201(models::ApplicationResourceDescription),
            Accepted202,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
            pub(crate) application_resource_description: models::ApplicationResourceDescription,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}",
                            this.client.endpoint(),
                            &this.application_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.application_resource_description)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::ApplicationResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Ok200(rsp_value))
                            }
                            azure_core::StatusCode::Created => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::ApplicationResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Created201(rsp_value))
                            }
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}",
                            this.client.endpoint(),
                            &this.application_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => Ok(Response::Ok200),
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::PagedApplicationResourceDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/Resources/Applications", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::PagedApplicationResourceDescriptionList = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_upgrade_progress {
        use super::models;
        type Response = models::ApplicationResourceUpgradeProgressInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}/$/GetUpgradeProgress",
                            this.client.endpoint(),
                            &this.application_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::ApplicationResourceUpgradeProgressInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod mesh_service {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the Service resource with the given name."]
        #[doc = "Gets the information about the Service resource with the given name. The information include the description and other properties of the Service."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        #[doc = "* `service_resource_name`: The identity of the service."]
        pub fn get(&self, application_resource_name: impl Into<String>, service_resource_name: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
                service_resource_name: service_resource_name.into(),
            }
        }
        #[doc = "Lists all the service resources."]
        #[doc = "Gets the information about all services of an application resource. The information include the description and other properties of the Service."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        pub fn list(&self, application_resource_name: impl Into<String>) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::ServiceResourceDescription;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
            pub(crate) service_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}/Services/{}",
                            this.client.endpoint(),
                            &this.application_resource_name,
                            &this.service_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::ServiceResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::PagedServiceResourceDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}/Services",
                            this.client.endpoint(),
                            &this.application_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::PagedServiceResourceDescriptionList = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod mesh_code_package {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the logs from the container."]
        #[doc = "Gets the logs for the container of the specified code package of the service replica."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        #[doc = "* `service_resource_name`: The identity of the service."]
        #[doc = "* `replica_name`: Service Fabric replica name."]
        #[doc = "* `code_package_name`: The name of code package of the service."]
        pub fn get_container_logs(
            &self,
            application_resource_name: impl Into<String>,
            service_resource_name: impl Into<String>,
            replica_name: impl Into<String>,
            code_package_name: impl Into<String>,
        ) -> get_container_logs::Builder {
            get_container_logs::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
                service_resource_name: service_resource_name.into(),
                replica_name: replica_name.into(),
                code_package_name: code_package_name.into(),
                tail: None,
            }
        }
    }
    pub mod get_container_logs {
        use super::models;
        type Response = models::ContainerLogs;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
            pub(crate) service_resource_name: String,
            pub(crate) replica_name: String,
            pub(crate) code_package_name: String,
            pub(crate) tail: Option<String>,
        }
        impl Builder {
            #[doc = "Number of lines to show from the end of the logs. Default is 100. 'all' to show the complete logs."]
            pub fn tail(mut self, tail: impl Into<String>) -> Self {
                self.tail = Some(tail.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}/Services/{}/Replicas/{}/CodePackages/{}/Logs",
                            this.client.endpoint(),
                            &this.application_resource_name,
                            &this.service_resource_name,
                            &this.replica_name,
                            &this.code_package_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        if let Some(tail) = &this.tail {
                            req.url_mut().query_pairs_mut().append_pair("Tail", tail);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::ContainerLogs = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod mesh_service_replica {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the given replica of the service of an application."]
        #[doc = "Gets the information about the service replica with the given name. The information include the description and other properties of the service replica."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        #[doc = "* `service_resource_name`: The identity of the service."]
        #[doc = "* `replica_name`: Service Fabric replica name."]
        pub fn get(
            &self,
            application_resource_name: impl Into<String>,
            service_resource_name: impl Into<String>,
            replica_name: impl Into<String>,
        ) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
                service_resource_name: service_resource_name.into(),
                replica_name: replica_name.into(),
            }
        }
        #[doc = "Lists all the replicas of a service."]
        #[doc = "Gets the information about all replicas of a service. The information include the description and other properties of the service replica."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `application_resource_name`: The identity of the application."]
        #[doc = "* `service_resource_name`: The identity of the service."]
        pub fn list(&self, application_resource_name: impl Into<String>, service_resource_name: impl Into<String>) -> list::Builder {
            list::Builder {
                client: self.0.clone(),
                application_resource_name: application_resource_name.into(),
                service_resource_name: service_resource_name.into(),
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::ServiceReplicaDescription;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
            pub(crate) service_resource_name: String,
            pub(crate) replica_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}/Services/{}/Replicas/{}",
                            this.client.endpoint(),
                            &this.application_resource_name,
                            &this.service_resource_name,
                            &this.replica_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::ServiceReplicaDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::PagedServiceReplicaDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) application_resource_name: String,
            pub(crate) service_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Applications/{}/Services/{}/Replicas",
                            this.client.endpoint(),
                            &this.application_resource_name,
                            &this.service_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::PagedServiceReplicaDescriptionList = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod mesh_gateway {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        #[doc = "Gets the Gateway resource with the given name."]
        #[doc = "Gets the information about the Gateway resource with the given name. The information include the description and other properties of the Gateway."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `gateway_resource_name`: The identity of the gateway."]
        pub fn get(&self, gateway_resource_name: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                gateway_resource_name: gateway_resource_name.into(),
            }
        }
        #[doc = "Creates or updates a Gateway resource."]
        #[doc = "Creates a Gateway resource with the specified name, description and properties. If Gateway resource with the same name exists, then it is updated with the specified description and properties. Use Gateway resource to provide public connectivity to application services."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `gateway_resource_name`: The identity of the gateway."]
        #[doc = "* `gateway_resource_description`: Description for creating a Gateway resource."]
        pub fn create_or_update(
            &self,
            gateway_resource_name: impl Into<String>,
            gateway_resource_description: impl Into<models::GatewayResourceDescription>,
        ) -> create_or_update::Builder {
            create_or_update::Builder {
                client: self.0.clone(),
                gateway_resource_name: gateway_resource_name.into(),
                gateway_resource_description: gateway_resource_description.into(),
            }
        }
        #[doc = "Deletes the Gateway resource."]
        #[doc = "Deletes the Gateway resource identified by the name."]
        #[doc = ""]
        #[doc = "Arguments:"]
        #[doc = "* `gateway_resource_name`: The identity of the gateway."]
        pub fn delete(&self, gateway_resource_name: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                gateway_resource_name: gateway_resource_name.into(),
            }
        }
        #[doc = "Lists all the gateway resources."]
        #[doc = "Gets the information about all gateway resources in a given resource group. The information include the description and other properties of the Gateway."]
        pub fn list(&self) -> list::Builder {
            list::Builder { client: self.0.clone() }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::GatewayResourceDescription;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) gateway_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Gateways/{}",
                            this.client.endpoint(),
                            &this.gateway_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::GatewayResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200(models::GatewayResourceDescription),
            Created201(models::GatewayResourceDescription),
            Accepted202,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) gateway_resource_name: String,
            pub(crate) gateway_resource_description: models::GatewayResourceDescription,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Gateways/{}",
                            this.client.endpoint(),
                            &this.gateway_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.gateway_resource_description)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::GatewayResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Ok200(rsp_value))
                            }
                            azure_core::StatusCode::Created => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::GatewayResourceDescription = serde_json::from_slice(&rsp_body)?;
                                Ok(Response::Created201(rsp_value))
                            }
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        #[derive(Debug)]
        pub enum Response {
            Ok200,
            Accepted202,
            NoContent204,
        }
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) gateway_resource_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/Resources/Gateways/{}",
                            this.client.endpoint(),
                            &this.gateway_resource_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => Ok(Response::Ok200),
                            azure_core::StatusCode::Accepted => Ok(Response::Accepted202),
                            azure_core::StatusCode::NoContent => Ok(Response::NoContent204),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list {
        use super::models;
        type Response = models::PagedGatewayResourceDescriptionList;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/Resources/Gateways", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "8.0");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = rsp_stream.collect().await?;
                                let rsp_value: models::PagedGatewayResourceDescriptionList = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
