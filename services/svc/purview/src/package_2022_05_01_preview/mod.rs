#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::redundant_clone)]
pub mod models;
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
    options: azure_core::ClientOptions,
}
pub const DEFAULT_ENDPOINT: &str = "https://purview.azure.com/workflow";
impl ClientBuilder {
    #[doc = "Create a new instance of `ClientBuilder`."]
    #[must_use]
    pub fn new(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
            options: azure_core::ClientOptions::default(),
        }
    }
    #[doc = "Set the endpoint."]
    #[must_use]
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    #[doc = "Set the scopes."]
    #[must_use]
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    #[doc = "Set the retry options."]
    #[must_use]
    pub fn retry(mut self, retry: impl Into<azure_core::RetryOptions>) -> Self {
        self.options = self.options.retry(retry);
        self
    }
    #[doc = "Set the transport options."]
    #[must_use]
    pub fn transport(mut self, transport: impl Into<azure_core::TransportOptions>) -> Self {
        self.options = self.options.transport(transport);
        self
    }
    #[doc = "Convert the builder into a `Client` instance."]
    #[must_use]
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self.scopes.unwrap_or_else(|| vec![format!("{endpoint}/")]);
        Client::new(endpoint, self.credential, scopes, self.options)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn token_credential(&self) -> &dyn azure_core::auth::TokenCredential {
        self.credential.as_ref()
    }
    pub(crate) fn scopes(&self) -> Vec<&str> {
        self.scopes.iter().map(String::as_str).collect()
    }
    pub(crate) async fn send(&self, request: &mut azure_core::Request) -> azure_core::Result<azure_core::Response> {
        let mut context = azure_core::Context::default();
        self.pipeline.send(&mut context, request).await
    }
    #[doc = "Create a new `ClientBuilder`."]
    #[must_use]
    pub fn builder(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> ClientBuilder {
        ClientBuilder::new(credential)
    }
    #[doc = "Create a new `Client`."]
    #[must_use]
    pub fn new(
        endpoint: impl Into<String>,
        credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
        scopes: Vec<String>,
        options: azure_core::ClientOptions,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            options,
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
}
impl Client {
    #[doc = "List all workflows."]
    pub fn list_workflows(&self) -> list_workflows::RequestBuilder {
        list_workflows::RequestBuilder { client: self.clone() }
    }
    #[doc = "Get a specific workflow."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `workflow_id`: The workflow id."]
    pub fn get_workflow(&self, workflow_id: impl Into<String>) -> get_workflow::RequestBuilder {
        get_workflow::RequestBuilder {
            client: self.clone(),
            workflow_id: workflow_id.into(),
        }
    }
    #[doc = "Create or replace a workflow."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `workflow_id`: The workflow id."]
    #[doc = "* `workflow_create_or_update_command`: Create or update workflow payload."]
    pub fn create_or_replace_workflow(
        &self,
        workflow_id: impl Into<String>,
        workflow_create_or_update_command: impl Into<models::WorkflowCreateOrUpdateCommand>,
    ) -> create_or_replace_workflow::RequestBuilder {
        create_or_replace_workflow::RequestBuilder {
            client: self.clone(),
            workflow_id: workflow_id.into(),
            workflow_create_or_update_command: workflow_create_or_update_command.into(),
        }
    }
    #[doc = "Delete a workflow."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `workflow_id`: The workflow id."]
    pub fn delete_workflow(&self, workflow_id: impl Into<String>) -> delete_workflow::RequestBuilder {
        delete_workflow::RequestBuilder {
            client: self.clone(),
            workflow_id: workflow_id.into(),
        }
    }
    #[doc = "Submit a user request for requestor, a user  request describes user ask to do operation(s) on Purview. If any workflow's trigger matches with an operation in request, a run of the workflow is created."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `user_requests_payload`: The payload of submitting a user request."]
    pub fn submit_user_requests(
        &self,
        user_requests_payload: impl Into<models::UserRequestPayload>,
    ) -> submit_user_requests::RequestBuilder {
        submit_user_requests::RequestBuilder {
            client: self.clone(),
            user_requests_payload: user_requests_payload.into(),
        }
    }
    #[doc = "List workflow runs."]
    pub fn list_workflow_runs(&self) -> list_workflow_runs::RequestBuilder {
        list_workflow_runs::RequestBuilder {
            client: self.clone(),
            time_window: None,
            orderby: None,
            run_statuses: Vec::new(),
            workflow_ids: Vec::new(),
            maxpagesize: None,
        }
    }
    #[doc = "Get a workflow run."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `workflow_run_id`: The workflow run id."]
    pub fn get_workflow_run(&self, workflow_run_id: impl Into<String>) -> get_workflow_run::RequestBuilder {
        get_workflow_run::RequestBuilder {
            client: self.clone(),
            workflow_run_id: workflow_run_id.into(),
        }
    }
    #[doc = "Cancel a workflow run."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `workflow_run_id`: The workflow run id."]
    #[doc = "* `run_cancel_reply`: Reply of canceling a workflow run."]
    pub fn cancel_workflow_run(
        &self,
        workflow_run_id: impl Into<String>,
        run_cancel_reply: impl Into<models::WorkflowRunCancelRequest>,
    ) -> cancel_workflow_run::RequestBuilder {
        cancel_workflow_run::RequestBuilder {
            client: self.clone(),
            workflow_run_id: workflow_run_id.into(),
            run_cancel_reply: run_cancel_reply.into(),
        }
    }
    #[doc = "Get all workflow tasks."]
    pub fn list_workflow_tasks(&self) -> list_workflow_tasks::RequestBuilder {
        list_workflow_tasks::RequestBuilder {
            client: self.clone(),
            view_mode: None,
            workflow_ids: Vec::new(),
            time_window: None,
            maxpagesize: None,
            orderby: None,
            task_types: Vec::new(),
            task_statuses: Vec::new(),
            workflow_name_keyword: None,
        }
    }
    #[doc = "Get a workflow task."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `task_id`: The task id."]
    pub fn get_workflow_task(&self, task_id: impl Into<String>) -> get_workflow_task::RequestBuilder {
        get_workflow_task::RequestBuilder {
            client: self.clone(),
            task_id: task_id.into(),
        }
    }
    #[doc = "Approve an approval task."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `task_id`: The task id."]
    #[doc = "* `approval_response_comment`: The request body of approving an approval request."]
    pub fn approve_approval_task(
        &self,
        task_id: impl Into<String>,
        approval_response_comment: impl Into<models::ApprovalResponseComment>,
    ) -> approve_approval_task::RequestBuilder {
        approve_approval_task::RequestBuilder {
            client: self.clone(),
            task_id: task_id.into(),
            approval_response_comment: approval_response_comment.into(),
        }
    }
    #[doc = "Reject an approval task."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `task_id`: The task id."]
    #[doc = "* `approval_response_comment`: The request body of rejecting an approval request."]
    pub fn reject_approval_task(
        &self,
        task_id: impl Into<String>,
        approval_response_comment: impl Into<models::ApprovalResponseComment>,
    ) -> reject_approval_task::RequestBuilder {
        reject_approval_task::RequestBuilder {
            client: self.clone(),
            task_id: task_id.into(),
            approval_response_comment: approval_response_comment.into(),
        }
    }
    #[doc = "Reassign a workflow task."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `task_id`: The task id."]
    #[doc = "* `reassign_command`: The request body of reassigning a workflow task."]
    pub fn reassign_workflow_task(
        &self,
        task_id: impl Into<String>,
        reassign_command: impl Into<models::ReassignCommand>,
    ) -> reassign_workflow_task::RequestBuilder {
        reassign_workflow_task::RequestBuilder {
            client: self.clone(),
            task_id: task_id.into(),
            reassign_command: reassign_command.into(),
        }
    }
    #[doc = "Update the status of a workflow task request."]
    #[doc = ""]
    #[doc = "Arguments:"]
    #[doc = "* `task_id`: The task id."]
    #[doc = "* `task_update_command`: Request body of updating workflow task request."]
    pub fn update_task_status(
        &self,
        task_id: impl Into<String>,
        task_update_command: impl Into<models::TaskUpdateCommand>,
    ) -> update_task_status::RequestBuilder {
        update_task_status::RequestBuilder {
            client: self.clone(),
            task_id: task_id.into(),
            task_update_command: task_update_command.into(),
        }
    }
}
pub mod list_workflows {
    use super::models;
    pub struct Response(azure_core::Response);
    impl Response {
        pub async fn into_body(self) -> azure_core::Result<models::WorkflowMetadataList> {
            let bytes = self.0.into_body().collect().await?;
            let body: models::WorkflowMetadataList = serde_json::from_slice(&bytes)?;
            Ok(body)
        }
        pub fn into_raw_response(self) -> azure_core::Response {
            self.0
        }
        pub fn as_raw_response(&self) -> &azure_core::Response {
            &self.0
        }
    }
    impl From<Response> for azure_core::Response {
        fn from(rsp: Response) -> Self {
            rsp.into_raw_response()
        }
    }
    impl AsRef<azure_core::Response> for Response {
        fn as_ref(&self) -> &azure_core::Response {
            self.as_raw_response()
        }
    }
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
    }
    impl RequestBuilder {
        pub fn into_stream(self) -> azure_core::Pageable<models::WorkflowMetadataList, azure_core::error::Error> {
            let make_request = move |continuation: Option<String>| {
                let this = self.clone();
                async move {
                    let mut url = azure_core::Url::parse(&format!("{}/workflows", this.client.endpoint(),))?;
                    let rsp = match continuation {
                        Some(value) => {
                            url.set_path("");
                            url = url.join(&value)?;
                            let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                            let credential = this.client.token_credential();
                            let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let has_api_version_already =
                                req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                            if !has_api_version_already {
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                            }
                            let req_body = azure_core::EMPTY_BODY;
                            req.set_body(req_body);
                            this.client.send(&mut req).await?
                        }
                        None => {
                            let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                            let credential = this.client.token_credential();
                            let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                            let req_body = azure_core::EMPTY_BODY;
                            req.set_body(req_body);
                            this.client.send(&mut req).await?
                        }
                    };
                    let rsp = match rsp.status() {
                        azure_core::StatusCode::Ok => Ok(Response(rsp)),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    };
                    rsp?.into_body().await
                }
            };
            azure_core::Pageable::new(make_request)
        }
    }
}
pub mod get_workflow {
    use super::models;
    pub struct Response(azure_core::Response);
    impl Response {
        pub async fn into_body(self) -> azure_core::Result<models::Workflow> {
            let bytes = self.0.into_body().collect().await?;
            let body: models::Workflow = serde_json::from_slice(&bytes)?;
            Ok(body)
        }
        pub fn into_raw_response(self) -> azure_core::Response {
            self.0
        }
        pub fn as_raw_response(&self) -> &azure_core::Response {
            &self.0
        }
    }
    impl From<Response> for azure_core::Response {
        fn from(rsp: Response) -> Self {
            rsp.into_raw_response()
        }
    }
    impl AsRef<azure_core::Response> for Response {
        fn as_ref(&self) -> &azure_core::Response {
            self.as_raw_response()
        }
    }
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) workflow_id: String,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/workflows/{}", this.client.endpoint(), &this.workflow_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
    impl std::future::IntoFuture for RequestBuilder {
        type Output = azure_core::Result<models::Workflow>;
        type IntoFuture = futures::future::BoxFuture<'static, azure_core::Result<models::Workflow>>;
        #[doc = "Returns a future that sends the request and returns the parsed response body."]
        #[doc = ""]
        #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
        #[doc = ""]
        #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
        fn into_future(self) -> Self::IntoFuture {
            Box::pin(async move { self.send().await?.into_body().await })
        }
    }
}
pub mod create_or_replace_workflow {
    use super::models;
    pub struct Response(azure_core::Response);
    impl Response {
        pub async fn into_body(self) -> azure_core::Result<models::Workflow> {
            let bytes = self.0.into_body().collect().await?;
            let body: models::Workflow = serde_json::from_slice(&bytes)?;
            Ok(body)
        }
        pub fn into_raw_response(self) -> azure_core::Response {
            self.0
        }
        pub fn as_raw_response(&self) -> &azure_core::Response {
            &self.0
        }
    }
    impl From<Response> for azure_core::Response {
        fn from(rsp: Response) -> Self {
            rsp.into_raw_response()
        }
    }
    impl AsRef<azure_core::Response> for Response {
        fn as_ref(&self) -> &azure_core::Response {
            self.as_raw_response()
        }
    }
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) workflow_id: String,
        pub(crate) workflow_create_or_update_command: models::WorkflowCreateOrUpdateCommand,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/workflows/{}", this.client.endpoint(), &this.workflow_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.workflow_create_or_update_command)?;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
    impl std::future::IntoFuture for RequestBuilder {
        type Output = azure_core::Result<models::Workflow>;
        type IntoFuture = futures::future::BoxFuture<'static, azure_core::Result<models::Workflow>>;
        #[doc = "Returns a future that sends the request and returns the parsed response body."]
        #[doc = ""]
        #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
        #[doc = ""]
        #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
        fn into_future(self) -> Self::IntoFuture {
            Box::pin(async move { self.send().await?.into_body().await })
        }
    }
}
pub mod delete_workflow {
    use super::models;
    pub struct Response(azure_core::Response);
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) workflow_id: String,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/workflows/{}", this.client.endpoint(), &this.workflow_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
}
pub mod submit_user_requests {
    use super::models;
    pub struct Response(azure_core::Response);
    impl Response {
        pub async fn into_body(self) -> azure_core::Result<models::UserRequestResponse> {
            let bytes = self.0.into_body().collect().await?;
            let body: models::UserRequestResponse = serde_json::from_slice(&bytes)?;
            Ok(body)
        }
        pub fn into_raw_response(self) -> azure_core::Response {
            self.0
        }
        pub fn as_raw_response(&self) -> &azure_core::Response {
            &self.0
        }
    }
    impl From<Response> for azure_core::Response {
        fn from(rsp: Response) -> Self {
            rsp.into_raw_response()
        }
    }
    impl AsRef<azure_core::Response> for Response {
        fn as_ref(&self) -> &azure_core::Response {
            self.as_raw_response()
        }
    }
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) user_requests_payload: models::UserRequestPayload,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/userrequests", this.client.endpoint(),))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.user_requests_payload)?;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
    impl std::future::IntoFuture for RequestBuilder {
        type Output = azure_core::Result<models::UserRequestResponse>;
        type IntoFuture = futures::future::BoxFuture<'static, azure_core::Result<models::UserRequestResponse>>;
        #[doc = "Returns a future that sends the request and returns the parsed response body."]
        #[doc = ""]
        #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
        #[doc = ""]
        #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
        fn into_future(self) -> Self::IntoFuture {
            Box::pin(async move { self.send().await?.into_body().await })
        }
    }
}
pub mod list_workflow_runs {
    use super::models;
    pub struct Response(azure_core::Response);
    impl Response {
        pub async fn into_body(self) -> azure_core::Result<models::WorkflowRunList> {
            let bytes = self.0.into_body().collect().await?;
            let body: models::WorkflowRunList = serde_json::from_slice(&bytes)?;
            Ok(body)
        }
        pub fn into_raw_response(self) -> azure_core::Response {
            self.0
        }
        pub fn as_raw_response(&self) -> &azure_core::Response {
            &self.0
        }
    }
    impl From<Response> for azure_core::Response {
        fn from(rsp: Response) -> Self {
            rsp.into_raw_response()
        }
    }
    impl AsRef<azure_core::Response> for Response {
        fn as_ref(&self) -> &azure_core::Response {
            self.as_raw_response()
        }
    }
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) time_window: Option<String>,
        pub(crate) orderby: Option<String>,
        pub(crate) run_statuses: Vec<String>,
        pub(crate) workflow_ids: Vec<String>,
        pub(crate) maxpagesize: Option<i32>,
    }
    impl RequestBuilder {
        #[doc = "Time window of filtering items."]
        pub fn time_window(mut self, time_window: impl Into<String>) -> Self {
            self.time_window = Some(time_window.into());
            self
        }
        #[doc = "The key word which used to sort the results."]
        pub fn orderby(mut self, orderby: impl Into<String>) -> Self {
            self.orderby = Some(orderby.into());
            self
        }
        #[doc = "Filter workflow runs by workflow run status."]
        pub fn run_statuses(mut self, run_statuses: Vec<String>) -> Self {
            self.run_statuses = run_statuses;
            self
        }
        #[doc = "Filter items by workflow id list."]
        pub fn workflow_ids(mut self, workflow_ids: Vec<String>) -> Self {
            self.workflow_ids = workflow_ids;
            self
        }
        #[doc = "The maximum page size to get the items at one time."]
        pub fn maxpagesize(mut self, maxpagesize: i32) -> Self {
            self.maxpagesize = Some(maxpagesize);
            self
        }
        pub fn into_stream(self) -> azure_core::Pageable<models::WorkflowRunList, azure_core::error::Error> {
            let make_request = move |continuation: Option<String>| {
                let this = self.clone();
                async move {
                    let mut url = azure_core::Url::parse(&format!("{}/workflowruns", this.client.endpoint(),))?;
                    let rsp = match continuation {
                        Some(value) => {
                            url.set_path("");
                            url = url.join(&value)?;
                            let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                            let credential = this.client.token_credential();
                            let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let has_api_version_already =
                                req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                            if !has_api_version_already {
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                            }
                            let req_body = azure_core::EMPTY_BODY;
                            req.set_body(req_body);
                            this.client.send(&mut req).await?
                        }
                        None => {
                            let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                            let credential = this.client.token_credential();
                            let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                            if let Some(time_window) = &this.time_window {
                                req.url_mut().query_pairs_mut().append_pair("timeWindow", time_window);
                            }
                            if let Some(orderby) = &this.orderby {
                                req.url_mut().query_pairs_mut().append_pair("orderby", orderby);
                            }
                            if let Some(maxpagesize) = &this.maxpagesize {
                                req.url_mut().query_pairs_mut().append_pair("maxpagesize", &maxpagesize.to_string());
                            }
                            let req_body = azure_core::EMPTY_BODY;
                            req.set_body(req_body);
                            this.client.send(&mut req).await?
                        }
                    };
                    let rsp = match rsp.status() {
                        azure_core::StatusCode::Ok => Ok(Response(rsp)),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    };
                    rsp?.into_body().await
                }
            };
            azure_core::Pageable::new(make_request)
        }
    }
}
pub mod get_workflow_run {
    use super::models;
    pub struct Response(azure_core::Response);
    impl Response {
        pub async fn into_body(self) -> azure_core::Result<models::WorkflowRun> {
            let bytes = self.0.into_body().collect().await?;
            let body: models::WorkflowRun = serde_json::from_slice(&bytes)?;
            Ok(body)
        }
        pub fn into_raw_response(self) -> azure_core::Response {
            self.0
        }
        pub fn as_raw_response(&self) -> &azure_core::Response {
            &self.0
        }
    }
    impl From<Response> for azure_core::Response {
        fn from(rsp: Response) -> Self {
            rsp.into_raw_response()
        }
    }
    impl AsRef<azure_core::Response> for Response {
        fn as_ref(&self) -> &azure_core::Response {
            self.as_raw_response()
        }
    }
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) workflow_run_id: String,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/workflowruns/{}", this.client.endpoint(), &this.workflow_run_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
    impl std::future::IntoFuture for RequestBuilder {
        type Output = azure_core::Result<models::WorkflowRun>;
        type IntoFuture = futures::future::BoxFuture<'static, azure_core::Result<models::WorkflowRun>>;
        #[doc = "Returns a future that sends the request and returns the parsed response body."]
        #[doc = ""]
        #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
        #[doc = ""]
        #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
        fn into_future(self) -> Self::IntoFuture {
            Box::pin(async move { self.send().await?.into_body().await })
        }
    }
}
pub mod cancel_workflow_run {
    use super::models;
    pub struct Response(azure_core::Response);
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) workflow_run_id: String,
        pub(crate) run_cancel_reply: models::WorkflowRunCancelRequest,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/workflowruns/{}/cancel", this.client.endpoint(), &this.workflow_run_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.run_cancel_reply)?;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
}
pub mod list_workflow_tasks {
    use super::models;
    pub struct Response(azure_core::Response);
    impl Response {
        pub async fn into_body(self) -> azure_core::Result<models::TasksList> {
            let bytes = self.0.into_body().collect().await?;
            let body: models::TasksList = serde_json::from_slice(&bytes)?;
            Ok(body)
        }
        pub fn into_raw_response(self) -> azure_core::Response {
            self.0
        }
        pub fn as_raw_response(&self) -> &azure_core::Response {
            &self.0
        }
    }
    impl From<Response> for azure_core::Response {
        fn from(rsp: Response) -> Self {
            rsp.into_raw_response()
        }
    }
    impl AsRef<azure_core::Response> for Response {
        fn as_ref(&self) -> &azure_core::Response {
            self.as_raw_response()
        }
    }
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) view_mode: Option<String>,
        pub(crate) workflow_ids: Vec<String>,
        pub(crate) time_window: Option<String>,
        pub(crate) maxpagesize: Option<i32>,
        pub(crate) orderby: Option<String>,
        pub(crate) task_types: Vec<String>,
        pub(crate) task_statuses: Vec<String>,
        pub(crate) workflow_name_keyword: Option<String>,
    }
    impl RequestBuilder {
        #[doc = "To filter user's sent, received or history workflow tasks."]
        pub fn view_mode(mut self, view_mode: impl Into<String>) -> Self {
            self.view_mode = Some(view_mode.into());
            self
        }
        #[doc = "Filter items by workflow id list."]
        pub fn workflow_ids(mut self, workflow_ids: Vec<String>) -> Self {
            self.workflow_ids = workflow_ids;
            self
        }
        #[doc = "Time window of filtering items."]
        pub fn time_window(mut self, time_window: impl Into<String>) -> Self {
            self.time_window = Some(time_window.into());
            self
        }
        #[doc = "The maximum page size to get the items at one time."]
        pub fn maxpagesize(mut self, maxpagesize: i32) -> Self {
            self.maxpagesize = Some(maxpagesize);
            self
        }
        #[doc = "The key word which used to sort the results."]
        pub fn orderby(mut self, orderby: impl Into<String>) -> Self {
            self.orderby = Some(orderby.into());
            self
        }
        #[doc = "Filter items by workflow task type."]
        pub fn task_types(mut self, task_types: Vec<String>) -> Self {
            self.task_types = task_types;
            self
        }
        #[doc = "Filter workflow tasks by status."]
        pub fn task_statuses(mut self, task_statuses: Vec<String>) -> Self {
            self.task_statuses = task_statuses;
            self
        }
        #[doc = "The key word which could used to filter workflow item with related workflow."]
        pub fn workflow_name_keyword(mut self, workflow_name_keyword: impl Into<String>) -> Self {
            self.workflow_name_keyword = Some(workflow_name_keyword.into());
            self
        }
        pub fn into_stream(self) -> azure_core::Pageable<models::TasksList, azure_core::error::Error> {
            let make_request = move |continuation: Option<String>| {
                let this = self.clone();
                async move {
                    let mut url = azure_core::Url::parse(&format!("{}/workflowtasks", this.client.endpoint(),))?;
                    let rsp = match continuation {
                        Some(value) => {
                            url.set_path("");
                            url = url.join(&value)?;
                            let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                            let credential = this.client.token_credential();
                            let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            let has_api_version_already =
                                req.url_mut().query_pairs().any(|(k, _)| k == azure_core::query_param::API_VERSION);
                            if !has_api_version_already {
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                            }
                            let req_body = azure_core::EMPTY_BODY;
                            req.set_body(req_body);
                            this.client.send(&mut req).await?
                        }
                        None => {
                            let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                            let credential = this.client.token_credential();
                            let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                            req.insert_header(
                                azure_core::headers::AUTHORIZATION,
                                format!("Bearer {}", token_response.token.secret()),
                            );
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                            if let Some(view_mode) = &this.view_mode {
                                req.url_mut().query_pairs_mut().append_pair("viewMode", view_mode);
                            }
                            if let Some(time_window) = &this.time_window {
                                req.url_mut().query_pairs_mut().append_pair("timeWindow", time_window);
                            }
                            if let Some(maxpagesize) = &this.maxpagesize {
                                req.url_mut().query_pairs_mut().append_pair("maxpagesize", &maxpagesize.to_string());
                            }
                            if let Some(orderby) = &this.orderby {
                                req.url_mut().query_pairs_mut().append_pair("orderby", orderby);
                            }
                            if let Some(workflow_name_keyword) = &this.workflow_name_keyword {
                                req.url_mut()
                                    .query_pairs_mut()
                                    .append_pair("workflowNameKeyword", workflow_name_keyword);
                            }
                            let req_body = azure_core::EMPTY_BODY;
                            req.set_body(req_body);
                            this.client.send(&mut req).await?
                        }
                    };
                    let rsp = match rsp.status() {
                        azure_core::StatusCode::Ok => Ok(Response(rsp)),
                        status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                            status: status_code,
                            error_code: None,
                        })),
                    };
                    rsp?.into_body().await
                }
            };
            azure_core::Pageable::new(make_request)
        }
    }
}
pub mod get_workflow_task {
    use super::models;
    pub struct Response(azure_core::Response);
    impl Response {
        pub async fn into_body(self) -> azure_core::Result<models::WorkflowTask> {
            let bytes = self.0.into_body().collect().await?;
            let body: models::WorkflowTask = serde_json::from_slice(&bytes)?;
            Ok(body)
        }
        pub fn into_raw_response(self) -> azure_core::Response {
            self.0
        }
        pub fn as_raw_response(&self) -> &azure_core::Response {
            &self.0
        }
    }
    impl From<Response> for azure_core::Response {
        fn from(rsp: Response) -> Self {
            rsp.into_raw_response()
        }
    }
    impl AsRef<azure_core::Response> for Response {
        fn as_ref(&self) -> &azure_core::Response {
            self.as_raw_response()
        }
    }
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) task_id: String,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/workflowtasks/{}", this.client.endpoint(), &this.task_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    let req_body = azure_core::EMPTY_BODY;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
    impl std::future::IntoFuture for RequestBuilder {
        type Output = azure_core::Result<models::WorkflowTask>;
        type IntoFuture = futures::future::BoxFuture<'static, azure_core::Result<models::WorkflowTask>>;
        #[doc = "Returns a future that sends the request and returns the parsed response body."]
        #[doc = ""]
        #[doc = "You should not normally call this method directly, simply invoke `.await` which implicitly calls `IntoFuture::into_future`."]
        #[doc = ""]
        #[doc = "See [IntoFuture documentation](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) for more details."]
        fn into_future(self) -> Self::IntoFuture {
            Box::pin(async move { self.send().await?.into_body().await })
        }
    }
}
pub mod approve_approval_task {
    use super::models;
    pub struct Response(azure_core::Response);
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) task_id: String,
        pub(crate) approval_response_comment: models::ApprovalResponseComment,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/workflowtasks/{}/approve-approval",
                        this.client.endpoint(),
                        &this.task_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.approval_response_comment)?;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
}
pub mod reject_approval_task {
    use super::models;
    pub struct Response(azure_core::Response);
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) task_id: String,
        pub(crate) approval_response_comment: models::ApprovalResponseComment,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/workflowtasks/{}/reject-approval",
                        this.client.endpoint(),
                        &this.task_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.approval_response_comment)?;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
}
pub mod reassign_workflow_task {
    use super::models;
    pub struct Response(azure_core::Response);
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) task_id: String,
        pub(crate) reassign_command: models::ReassignCommand,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!("{}/workflowtasks/{}/reassign", this.client.endpoint(), &this.task_id))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.reassign_command)?;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
}
pub mod update_task_status {
    use super::models;
    pub struct Response(azure_core::Response);
    #[derive(Clone)]
    #[doc = r" `RequestBuilder` provides a mechanism for setting optional parameters on a request."]
    #[doc = r""]
    #[doc = r" Each `RequestBuilder` parameter method call returns `Self`, so setting of multiple"]
    #[doc = r" parameters can be chained."]
    #[doc = r""]
    #[doc = r" The building of a request is typically finalized by invoking `.await` on"]
    #[doc = r" `RequestBuilder`. This implicitly invokes the [`IntoFuture::into_future()`](#method.into_future)"]
    #[doc = r" method, which converts `RequestBuilder` into a future that executes the request"]
    #[doc = r" operation and returns a `Result` with the parsed response."]
    #[doc = r""]
    #[doc = r" If you need lower-level access to the raw response details (e.g. to inspect"]
    #[doc = r" response headers or raw body data) then you can finalize the request using the"]
    #[doc = r" [`RequestBuilder::send()`] method which returns a future that resolves to a lower-level"]
    #[doc = r" [`Response`] value."]
    pub struct RequestBuilder {
        pub(crate) client: super::Client,
        pub(crate) task_id: String,
        pub(crate) task_update_command: models::TaskUpdateCommand,
    }
    impl RequestBuilder {
        #[doc = "Returns a future that sends the request and returns a [`Response`] object that provides low-level access to full response details."]
        #[doc = ""]
        #[doc = "You should typically use `.await` (which implicitly calls `IntoFuture::into_future()`) to finalize and send requests rather than `send()`."]
        #[doc = "However, this function can provide more flexibility when required."]
        pub fn send(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
            Box::pin({
                let this = self.clone();
                async move {
                    let url = azure_core::Url::parse(&format!(
                        "{}/workflowtasks/{}/change-task-status",
                        this.client.endpoint(),
                        &this.task_id
                    ))?;
                    let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                    let credential = this.client.token_credential();
                    let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                    req.insert_header(
                        azure_core::headers::AUTHORIZATION,
                        format!("Bearer {}", token_response.token.secret()),
                    );
                    req.url_mut()
                        .query_pairs_mut()
                        .append_pair(azure_core::query_param::API_VERSION, "2022-05-01-preview");
                    req.insert_header("content-type", "application/json");
                    let req_body = azure_core::to_json(&this.task_update_command)?;
                    req.set_body(req_body);
                    Ok(Response(this.client.send(&mut req).await?))
                }
            })
        }
    }
}
