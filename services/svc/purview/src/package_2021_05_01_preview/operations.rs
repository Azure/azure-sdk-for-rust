#![doc = "generated by AutoRust"]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::redundant_clone)]
use super::models;
#[derive(Clone)]
pub struct Client {
    endpoint: String,
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    scopes: Vec<String>,
    pipeline: azure_core::Pipeline,
}
#[derive(Clone)]
pub struct ClientBuilder {
    credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
    endpoint: Option<String>,
    scopes: Option<Vec<String>>,
}
pub const DEFAULT_ENDPOINT: &str = azure_core::resource_manager_endpoint::AZURE_PUBLIC_CLOUD;
impl ClientBuilder {
    pub fn new(credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>) -> Self {
        Self {
            credential,
            endpoint: None,
            scopes: None,
        }
    }
    pub fn endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.endpoint = Some(endpoint.into());
        self
    }
    pub fn scopes(mut self, scopes: &[&str]) -> Self {
        self.scopes = Some(scopes.iter().map(|scope| (*scope).to_owned()).collect());
        self
    }
    pub fn build(self) -> Client {
        let endpoint = self.endpoint.unwrap_or_else(|| DEFAULT_ENDPOINT.to_owned());
        let scopes = self.scopes.unwrap_or_else(|| vec![format!("{}/", endpoint)]);
        Client::new(endpoint, self.credential, scopes)
    }
}
impl Client {
    pub(crate) fn endpoint(&self) -> &str {
        self.endpoint.as_str()
    }
    pub(crate) fn token_credential(&self) -> &dyn azure_core::auth::TokenCredential {
        self.credential.as_ref()
    }
    pub(crate) fn scopes(&self) -> Vec<&str> {
        self.scopes.iter().map(String::as_str).collect()
    }
    pub(crate) async fn send(&self, request: &mut azure_core::Request) -> azure_core::Result<azure_core::Response> {
        let mut context = azure_core::Context::default();
        self.pipeline.send(&mut context, request).await
    }
    pub fn new(
        endpoint: impl Into<String>,
        credential: std::sync::Arc<dyn azure_core::auth::TokenCredential>,
        scopes: Vec<String>,
    ) -> Self {
        let endpoint = endpoint.into();
        let pipeline = azure_core::Pipeline::new(
            option_env!("CARGO_PKG_NAME"),
            option_env!("CARGO_PKG_VERSION"),
            azure_core::ClientOptions::default(),
            Vec::new(),
            Vec::new(),
        );
        Self {
            endpoint,
            credential,
            scopes,
            pipeline,
        }
    }
    pub fn collection(&self) -> collection::Client {
        collection::Client(self.clone())
    }
    pub fn discovery(&self) -> discovery::Client {
        discovery::Client(self.clone())
    }
    pub fn entity(&self) -> entity::Client {
        entity::Client(self.clone())
    }
    pub fn glossary(&self) -> glossary::Client {
        glossary::Client(self.clone())
    }
    pub fn lineage(&self) -> lineage::Client {
        lineage::Client(self.clone())
    }
    pub fn relationship(&self) -> relationship::Client {
        relationship::Client(self.clone())
    }
    pub fn types(&self) -> types::Client {
        types::Client(self.clone())
    }
}
pub mod entity {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn create_or_update(&self, entity: impl Into<models::AtlasEntityWithExtInfo>) -> create_or_update::Builder {
            create_or_update::Builder {
                client: self.0.clone(),
                entity: entity.into(),
            }
        }
        pub fn list_by_guids(&self, guid: Vec<String>) -> list_by_guids::Builder {
            list_by_guids::Builder {
                client: self.0.clone(),
                guid,
                min_ext_info: None,
                ignore_relationships: None,
                exclude_relationship_types: Vec::new(),
            }
        }
        pub fn create_or_update_entities(
            &self,
            entities: impl Into<models::AtlasEntitiesWithExtInfo>,
        ) -> create_or_update_entities::Builder {
            create_or_update_entities::Builder {
                client: self.0.clone(),
                entities: entities.into(),
            }
        }
        pub fn delete_by_guids(&self, guid: Vec<String>) -> delete_by_guids::Builder {
            delete_by_guids::Builder {
                client: self.0.clone(),
                guid,
            }
        }
        pub fn add_classification(&self, request: impl Into<models::ClassificationAssociateRequest>) -> add_classification::Builder {
            add_classification::Builder {
                client: self.0.clone(),
                request: request.into(),
            }
        }
        pub fn get_by_guid(&self, guid: impl Into<String>) -> get_by_guid::Builder {
            get_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                min_ext_info: None,
                ignore_relationships: None,
            }
        }
        pub fn partial_update_entity_attribute_by_guid(
            &self,
            guid: impl Into<String>,
            name: impl Into<String>,
            body: impl Into<serde_json::Value>,
        ) -> partial_update_entity_attribute_by_guid::Builder {
            partial_update_entity_attribute_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                name: name.into(),
                body: body.into(),
            }
        }
        pub fn delete_by_guid(&self, guid: impl Into<String>) -> delete_by_guid::Builder {
            delete_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn get_classification(&self, guid: impl Into<String>, classification_name: impl Into<String>) -> get_classification::Builder {
            get_classification::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                classification_name: classification_name.into(),
            }
        }
        pub fn delete_classification(
            &self,
            guid: impl Into<String>,
            classification_name: impl Into<String>,
        ) -> delete_classification::Builder {
            delete_classification::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                classification_name: classification_name.into(),
            }
        }
        pub fn get_classifications(&self, guid: impl Into<String>) -> get_classifications::Builder {
            get_classifications::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn add_classifications(
            &self,
            guid: impl Into<String>,
            classifications: Vec<models::AtlasClassification>,
        ) -> add_classifications::Builder {
            add_classifications::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                classifications,
            }
        }
        pub fn update_classifications(
            &self,
            guid: impl Into<String>,
            classifications: Vec<models::AtlasClassification>,
        ) -> update_classifications::Builder {
            update_classifications::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                classifications,
            }
        }
        pub fn get_by_unique_attributes(&self, type_name: impl Into<String>) -> get_by_unique_attributes::Builder {
            get_by_unique_attributes::Builder {
                client: self.0.clone(),
                type_name: type_name.into(),
                min_ext_info: None,
                ignore_relationships: None,
                attr_qualified_name: None,
            }
        }
        pub fn partial_update_entity_by_unique_attributes(
            &self,
            type_name: impl Into<String>,
            atlas_entity_with_ext_info: impl Into<models::AtlasEntityWithExtInfo>,
        ) -> partial_update_entity_by_unique_attributes::Builder {
            partial_update_entity_by_unique_attributes::Builder {
                client: self.0.clone(),
                type_name: type_name.into(),
                atlas_entity_with_ext_info: atlas_entity_with_ext_info.into(),
                attr_qualified_name: None,
            }
        }
        pub fn delete_by_unique_attribute(&self, type_name: impl Into<String>) -> delete_by_unique_attribute::Builder {
            delete_by_unique_attribute::Builder {
                client: self.0.clone(),
                type_name: type_name.into(),
                attr_qualified_name: None,
            }
        }
        pub fn delete_classification_by_unique_attribute(
            &self,
            type_name: impl Into<String>,
            classification_name: impl Into<String>,
        ) -> delete_classification_by_unique_attribute::Builder {
            delete_classification_by_unique_attribute::Builder {
                client: self.0.clone(),
                type_name: type_name.into(),
                classification_name: classification_name.into(),
                attr_qualified_name: None,
            }
        }
        pub fn add_classifications_by_unique_attribute(
            &self,
            type_name: impl Into<String>,
            atlas_classification_array: Vec<models::AtlasClassification>,
        ) -> add_classifications_by_unique_attribute::Builder {
            add_classifications_by_unique_attribute::Builder {
                client: self.0.clone(),
                type_name: type_name.into(),
                atlas_classification_array,
                attr_qualified_name: None,
            }
        }
        pub fn update_classifications_by_unique_attribute(
            &self,
            type_name: impl Into<String>,
            atlas_classification_array: Vec<models::AtlasClassification>,
        ) -> update_classifications_by_unique_attribute::Builder {
            update_classifications_by_unique_attribute::Builder {
                client: self.0.clone(),
                type_name: type_name.into(),
                atlas_classification_array,
                attr_qualified_name: None,
            }
        }
        pub fn set_classifications(&self, entity_headers: impl Into<models::AtlasEntityHeaders>) -> set_classifications::Builder {
            set_classifications::Builder {
                client: self.0.clone(),
                entity_headers: entity_headers.into(),
            }
        }
        pub fn get_entities_by_unique_attributes(&self, type_name: impl Into<String>) -> get_entities_by_unique_attributes::Builder {
            get_entities_by_unique_attributes::Builder {
                client: self.0.clone(),
                type_name: type_name.into(),
                min_ext_info: None,
                ignore_relationships: None,
                attr_n_qualified_name: None,
            }
        }
        pub fn get_header(&self, guid: impl Into<String>) -> get_header::Builder {
            get_header::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) entity: models::AtlasEntityWithExtInfo,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.entity)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_by_guids {
        use super::models;
        type Response = models::AtlasEntitiesWithExtInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: Vec<String>,
            pub(crate) min_ext_info: Option<bool>,
            pub(crate) ignore_relationships: Option<bool>,
            pub(crate) exclude_relationship_types: Vec<String>,
        }
        impl Builder {
            pub fn min_ext_info(mut self, min_ext_info: bool) -> Self {
                self.min_ext_info = Some(min_ext_info);
                self
            }
            pub fn ignore_relationships(mut self, ignore_relationships: bool) -> Self {
                self.ignore_relationships = Some(ignore_relationships);
                self
            }
            pub fn exclude_relationship_types(mut self, exclude_relationship_types: Vec<String>) -> Self {
                self.exclude_relationship_types = exclude_relationship_types;
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity/bulk", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let guid = &this.guid;
                        for value in &this.guid {
                            req.url_mut().query_pairs_mut().append_pair("guid", value);
                        }
                        if let Some(min_ext_info) = &this.min_ext_info {
                            req.url_mut().query_pairs_mut().append_pair("minExtInfo", &min_ext_info.to_string());
                        }
                        if let Some(ignore_relationships) = &this.ignore_relationships {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("ignoreRelationships", &ignore_relationships.to_string());
                        }
                        let exclude_relationship_types = &this.exclude_relationship_types;
                        for value in &this.exclude_relationship_types {
                            req.url_mut().query_pairs_mut().append_pair("excludeRelationshipTypes", value);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEntitiesWithExtInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_or_update_entities {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) entities: models::AtlasEntitiesWithExtInfo,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity/bulk", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.entities)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_by_guids {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: Vec<String>,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity/bulk", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let guid = &this.guid;
                        for value in &this.guid {
                            req.url_mut().query_pairs_mut().append_pair("guid", value);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod add_classification {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) request: models::ClassificationAssociateRequest,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity/bulk/classification", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.request)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_by_guid {
        use super::models;
        type Response = models::AtlasEntityWithExtInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) min_ext_info: Option<bool>,
            pub(crate) ignore_relationships: Option<bool>,
        }
        impl Builder {
            pub fn min_ext_info(mut self, min_ext_info: bool) -> Self {
                self.min_ext_info = Some(min_ext_info);
                self
            }
            pub fn ignore_relationships(mut self, ignore_relationships: bool) -> Self {
                self.ignore_relationships = Some(ignore_relationships);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(min_ext_info) = &this.min_ext_info {
                            req.url_mut().query_pairs_mut().append_pair("minExtInfo", &min_ext_info.to_string());
                        }
                        if let Some(ignore_relationships) = &this.ignore_relationships {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("ignoreRelationships", &ignore_relationships.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEntityWithExtInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod partial_update_entity_attribute_by_guid {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) name: String,
            pub(crate) body: serde_json::Value,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let name = &this.name;
                        req.url_mut().query_pairs_mut().append_pair("name", name);
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.body)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_by_guid {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_classification {
        use super::models;
        type Response = models::AtlasClassification;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) classification_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/guid/{}/classification/{}",
                            this.client.endpoint(),
                            &this.guid,
                            &this.classification_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasClassification = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_classification {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) classification_name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/guid/{}/classification/{}",
                            this.client.endpoint(),
                            &this.guid,
                            &this.classification_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_classifications {
        use super::models;
        type Response = models::AtlasClassifications;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/guid/{}/classifications",
                            this.client.endpoint(),
                            &this.guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasClassifications = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod add_classifications {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) classifications: Vec<models::AtlasClassification>,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/guid/{}/classifications",
                            this.client.endpoint(),
                            &this.guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.classifications)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update_classifications {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) classifications: Vec<models::AtlasClassification>,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/guid/{}/classifications",
                            this.client.endpoint(),
                            &this.guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.classifications)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_by_unique_attributes {
        use super::models;
        type Response = models::AtlasEntityWithExtInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) type_name: String,
            pub(crate) min_ext_info: Option<bool>,
            pub(crate) ignore_relationships: Option<bool>,
            pub(crate) attr_qualified_name: Option<String>,
        }
        impl Builder {
            pub fn min_ext_info(mut self, min_ext_info: bool) -> Self {
                self.min_ext_info = Some(min_ext_info);
                self
            }
            pub fn ignore_relationships(mut self, ignore_relationships: bool) -> Self {
                self.ignore_relationships = Some(ignore_relationships);
                self
            }
            pub fn attr_qualified_name(mut self, attr_qualified_name: impl Into<String>) -> Self {
                self.attr_qualified_name = Some(attr_qualified_name.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/uniqueAttribute/type/{}",
                            this.client.endpoint(),
                            &this.type_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(min_ext_info) = &this.min_ext_info {
                            req.url_mut().query_pairs_mut().append_pair("minExtInfo", &min_ext_info.to_string());
                        }
                        if let Some(ignore_relationships) = &this.ignore_relationships {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("ignoreRelationships", &ignore_relationships.to_string());
                        }
                        if let Some(attr_qualified_name) = &this.attr_qualified_name {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("attr:qualifiedName", attr_qualified_name);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEntityWithExtInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod partial_update_entity_by_unique_attributes {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) type_name: String,
            pub(crate) atlas_entity_with_ext_info: models::AtlasEntityWithExtInfo,
            pub(crate) attr_qualified_name: Option<String>,
        }
        impl Builder {
            pub fn attr_qualified_name(mut self, attr_qualified_name: impl Into<String>) -> Self {
                self.attr_qualified_name = Some(attr_qualified_name.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/uniqueAttribute/type/{}",
                            this.client.endpoint(),
                            &this.type_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(attr_qualified_name) = &this.attr_qualified_name {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("attr:qualifiedName", attr_qualified_name);
                        }
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.atlas_entity_with_ext_info)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_by_unique_attribute {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) type_name: String,
            pub(crate) attr_qualified_name: Option<String>,
        }
        impl Builder {
            pub fn attr_qualified_name(mut self, attr_qualified_name: impl Into<String>) -> Self {
                self.attr_qualified_name = Some(attr_qualified_name.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/uniqueAttribute/type/{}",
                            this.client.endpoint(),
                            &this.type_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(attr_qualified_name) = &this.attr_qualified_name {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("attr:qualifiedName", attr_qualified_name);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_classification_by_unique_attribute {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) type_name: String,
            pub(crate) classification_name: String,
            pub(crate) attr_qualified_name: Option<String>,
        }
        impl Builder {
            pub fn attr_qualified_name(mut self, attr_qualified_name: impl Into<String>) -> Self {
                self.attr_qualified_name = Some(attr_qualified_name.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/uniqueAttribute/type/{}/classification/{}",
                            this.client.endpoint(),
                            &this.type_name,
                            &this.classification_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(attr_qualified_name) = &this.attr_qualified_name {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("attr:qualifiedName", attr_qualified_name);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod add_classifications_by_unique_attribute {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) type_name: String,
            pub(crate) atlas_classification_array: Vec<models::AtlasClassification>,
            pub(crate) attr_qualified_name: Option<String>,
        }
        impl Builder {
            pub fn attr_qualified_name(mut self, attr_qualified_name: impl Into<String>) -> Self {
                self.attr_qualified_name = Some(attr_qualified_name.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/uniqueAttribute/type/{}/classifications",
                            this.client.endpoint(),
                            &this.type_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(attr_qualified_name) = &this.attr_qualified_name {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("attr:qualifiedName", attr_qualified_name);
                        }
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.atlas_classification_array)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update_classifications_by_unique_attribute {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) type_name: String,
            pub(crate) atlas_classification_array: Vec<models::AtlasClassification>,
            pub(crate) attr_qualified_name: Option<String>,
        }
        impl Builder {
            pub fn attr_qualified_name(mut self, attr_qualified_name: impl Into<String>) -> Self {
                self.attr_qualified_name = Some(attr_qualified_name.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/uniqueAttribute/type/{}/classifications",
                            this.client.endpoint(),
                            &this.type_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(attr_qualified_name) = &this.attr_qualified_name {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("attr:qualifiedName", attr_qualified_name);
                        }
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.atlas_classification_array)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod set_classifications {
        use super::models;
        type Response = Vec<String>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) entity_headers: models::AtlasEntityHeaders,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/entity/bulk/setClassifications", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.entity_headers)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<String> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_entities_by_unique_attributes {
        use super::models;
        type Response = models::AtlasEntitiesWithExtInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) type_name: String,
            pub(crate) min_ext_info: Option<bool>,
            pub(crate) ignore_relationships: Option<bool>,
            pub(crate) attr_n_qualified_name: Option<String>,
        }
        impl Builder {
            pub fn min_ext_info(mut self, min_ext_info: bool) -> Self {
                self.min_ext_info = Some(min_ext_info);
                self
            }
            pub fn ignore_relationships(mut self, ignore_relationships: bool) -> Self {
                self.ignore_relationships = Some(ignore_relationships);
                self
            }
            pub fn attr_n_qualified_name(mut self, attr_n_qualified_name: impl Into<String>) -> Self {
                self.attr_n_qualified_name = Some(attr_n_qualified_name.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/entity/bulk/uniqueAttribute/type/{}",
                            this.client.endpoint(),
                            &this.type_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(min_ext_info) = &this.min_ext_info {
                            req.url_mut().query_pairs_mut().append_pair("minExtInfo", &min_ext_info.to_string());
                        }
                        if let Some(ignore_relationships) = &this.ignore_relationships {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("ignoreRelationships", &ignore_relationships.to_string());
                        }
                        if let Some(attr_n_qualified_name) = &this.attr_n_qualified_name {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("attr_N:qualifiedName", attr_n_qualified_name);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEntitiesWithExtInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_header {
        use super::models;
        type Response = models::AtlasEntityHeader;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/entity/guid/{}/header", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEntityHeader = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod glossary {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn list_glossaries(&self) -> list_glossaries::Builder {
            list_glossaries::Builder {
                client: self.0.clone(),
                limit: None,
                offset: None,
                sort: None,
                ignore_terms_and_categories: None,
            }
        }
        pub fn create_glossary(&self, atlas_glossary: impl Into<models::AtlasGlossary>) -> create_glossary::Builder {
            create_glossary::Builder {
                client: self.0.clone(),
                atlas_glossary: atlas_glossary.into(),
            }
        }
        pub fn create_glossary_categories(
            &self,
            glossary_category: Vec<models::AtlasGlossaryCategory>,
        ) -> create_glossary_categories::Builder {
            create_glossary_categories::Builder {
                client: self.0.clone(),
                glossary_category,
            }
        }
        pub fn create_glossary_category(
            &self,
            glossary_category: impl Into<models::AtlasGlossaryCategory>,
        ) -> create_glossary_category::Builder {
            create_glossary_category::Builder {
                client: self.0.clone(),
                glossary_category: glossary_category.into(),
            }
        }
        pub fn get_glossary_category(&self, category_guid: impl Into<String>) -> get_glossary_category::Builder {
            get_glossary_category::Builder {
                client: self.0.clone(),
                category_guid: category_guid.into(),
            }
        }
        pub fn update_glossary_category(
            &self,
            category_guid: impl Into<String>,
            glossary_category: impl Into<models::AtlasGlossaryCategory>,
        ) -> update_glossary_category::Builder {
            update_glossary_category::Builder {
                client: self.0.clone(),
                category_guid: category_guid.into(),
                glossary_category: glossary_category.into(),
            }
        }
        pub fn delete_glossary_category(&self, category_guid: impl Into<String>) -> delete_glossary_category::Builder {
            delete_glossary_category::Builder {
                client: self.0.clone(),
                category_guid: category_guid.into(),
            }
        }
        pub fn partial_update_glossary_category(
            &self,
            category_guid: impl Into<String>,
            partial_updates: impl Into<serde_json::Value>,
        ) -> partial_update_glossary_category::Builder {
            partial_update_glossary_category::Builder {
                client: self.0.clone(),
                category_guid: category_guid.into(),
                partial_updates: partial_updates.into(),
            }
        }
        pub fn list_related_categories(&self, category_guid: impl Into<String>) -> list_related_categories::Builder {
            list_related_categories::Builder {
                client: self.0.clone(),
                category_guid: category_guid.into(),
                limit: None,
                offset: None,
                sort: None,
            }
        }
        pub fn list_category_terms(&self, category_guid: impl Into<String>) -> list_category_terms::Builder {
            list_category_terms::Builder {
                client: self.0.clone(),
                category_guid: category_guid.into(),
                limit: None,
                offset: None,
                sort: None,
            }
        }
        pub fn create_glossary_term(&self, glossary_term: impl Into<models::AtlasGlossaryTerm>) -> create_glossary_term::Builder {
            create_glossary_term::Builder {
                client: self.0.clone(),
                glossary_term: glossary_term.into(),
                include_term_hierarchy: None,
            }
        }
        pub fn get_glossary_term(&self, term_guid: impl Into<String>) -> get_glossary_term::Builder {
            get_glossary_term::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
                include_term_hierarchy: None,
            }
        }
        pub fn update_glossary_term(
            &self,
            term_guid: impl Into<String>,
            glossary_term: impl Into<models::AtlasGlossaryTerm>,
        ) -> update_glossary_term::Builder {
            update_glossary_term::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
                glossary_term: glossary_term.into(),
            }
        }
        pub fn delete_glossary_term(&self, term_guid: impl Into<String>) -> delete_glossary_term::Builder {
            delete_glossary_term::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
            }
        }
        pub fn partial_update_glossary_term(
            &self,
            term_guid: impl Into<String>,
            partial_updates: impl Into<serde_json::Value>,
        ) -> partial_update_glossary_term::Builder {
            partial_update_glossary_term::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
                partial_updates: partial_updates.into(),
                include_term_hierarchy: None,
            }
        }
        pub fn create_glossary_terms(&self, glossary_term: Vec<models::AtlasGlossaryTerm>) -> create_glossary_terms::Builder {
            create_glossary_terms::Builder {
                client: self.0.clone(),
                glossary_term,
                include_term_hierarchy: None,
            }
        }
        pub fn get_entities_assigned_with_term(&self, term_guid: impl Into<String>) -> get_entities_assigned_with_term::Builder {
            get_entities_assigned_with_term::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
                limit: None,
                offset: None,
                sort: None,
            }
        }
        pub fn assign_term_to_entities(
            &self,
            term_guid: impl Into<String>,
            related_object_ids: Vec<models::AtlasRelatedObjectId>,
        ) -> assign_term_to_entities::Builder {
            assign_term_to_entities::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
                related_object_ids,
            }
        }
        pub fn remove_term_assignment_from_entities(
            &self,
            term_guid: impl Into<String>,
            related_object_ids: Vec<models::AtlasRelatedObjectId>,
        ) -> remove_term_assignment_from_entities::Builder {
            remove_term_assignment_from_entities::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
                related_object_ids,
            }
        }
        pub fn delete_term_assignment_from_entities(
            &self,
            term_guid: impl Into<String>,
            related_object_ids: Vec<models::AtlasRelatedObjectId>,
        ) -> delete_term_assignment_from_entities::Builder {
            delete_term_assignment_from_entities::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
                related_object_ids,
            }
        }
        pub fn list_related_terms(&self, term_guid: impl Into<String>) -> list_related_terms::Builder {
            list_related_terms::Builder {
                client: self.0.clone(),
                term_guid: term_guid.into(),
                limit: None,
                offset: None,
                sort: None,
            }
        }
        pub fn get_glossary(&self, glossary_guid: impl Into<String>) -> get_glossary::Builder {
            get_glossary::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
            }
        }
        pub fn update_glossary(
            &self,
            glossary_guid: impl Into<String>,
            updated_glossary: impl Into<models::AtlasGlossary>,
        ) -> update_glossary::Builder {
            update_glossary::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                updated_glossary: updated_glossary.into(),
            }
        }
        pub fn delete_glossary(&self, glossary_guid: impl Into<String>) -> delete_glossary::Builder {
            delete_glossary::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
            }
        }
        pub fn list_glossary_categories(&self, glossary_guid: impl Into<String>) -> list_glossary_categories::Builder {
            list_glossary_categories::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                limit: None,
                offset: None,
                sort: None,
            }
        }
        pub fn list_glossary_categories_headers(&self, glossary_guid: impl Into<String>) -> list_glossary_categories_headers::Builder {
            list_glossary_categories_headers::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                limit: None,
                offset: None,
                sort: None,
            }
        }
        pub fn get_detailed_glossary(&self, glossary_guid: impl Into<String>) -> get_detailed_glossary::Builder {
            get_detailed_glossary::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                include_term_hierarchy: None,
            }
        }
        pub fn partial_update_glossary(
            &self,
            glossary_guid: impl Into<String>,
            partial_updates: impl Into<serde_json::Value>,
        ) -> partial_update_glossary::Builder {
            partial_update_glossary::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                partial_updates: partial_updates.into(),
                include_term_hierarchy: None,
            }
        }
        pub fn list_glossary_terms(&self, glossary_guid: impl Into<String>) -> list_glossary_terms::Builder {
            list_glossary_terms::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                include_term_hierarchy: None,
                limit: None,
                offset: None,
                sort: None,
            }
        }
        pub fn list_glossary_term_headers(&self, glossary_guid: impl Into<String>) -> list_glossary_term_headers::Builder {
            list_glossary_term_headers::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                limit: None,
                offset: None,
                sort: None,
            }
        }
        pub fn import_glossary_terms_via_csv(
            &self,
            glossary_guid: impl Into<String>,
            file: impl Into<bytes::Bytes>,
        ) -> import_glossary_terms_via_csv::Builder {
            import_glossary_terms_via_csv::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                file: file.into(),
                include_term_hierarchy: None,
            }
        }
        pub fn import_glossary_terms_via_csv_by_glossary_name(
            &self,
            glossary_name: impl Into<String>,
            file: impl Into<bytes::Bytes>,
        ) -> import_glossary_terms_via_csv_by_glossary_name::Builder {
            import_glossary_terms_via_csv_by_glossary_name::Builder {
                client: self.0.clone(),
                glossary_name: glossary_name.into(),
                file: file.into(),
                include_term_hierarchy: None,
            }
        }
        pub fn get_import_csv_operation_status(&self, operation_guid: impl Into<String>) -> get_import_csv_operation_status::Builder {
            get_import_csv_operation_status::Builder {
                client: self.0.clone(),
                operation_guid: operation_guid.into(),
            }
        }
        pub fn export_glossary_terms_as_csv(
            &self,
            glossary_guid: impl Into<String>,
            term_guids: Vec<models::TermGuid>,
        ) -> export_glossary_terms_as_csv::Builder {
            export_glossary_terms_as_csv::Builder {
                client: self.0.clone(),
                glossary_guid: glossary_guid.into(),
                term_guids,
                include_term_hierarchy: None,
            }
        }
        pub fn list_terms_by_glossary_name(&self, glossary_name: impl Into<String>) -> list_terms_by_glossary_name::Builder {
            list_terms_by_glossary_name::Builder {
                client: self.0.clone(),
                glossary_name: glossary_name.into(),
                limit: None,
                offset: None,
                include_term_hierarchy: None,
            }
        }
    }
    pub mod list_glossaries {
        use super::models;
        type Response = Vec<models::AtlasGlossary>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
            pub(crate) ignore_terms_and_categories: Option<bool>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn ignore_terms_and_categories(mut self, ignore_terms_and_categories: bool) -> Self {
                self.ignore_terms_and_categories = Some(ignore_terms_and_categories);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        if let Some(ignore_terms_and_categories) = &this.ignore_terms_and_categories {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("ignoreTermsAndCategories", &ignore_terms_and_categories.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasGlossary> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_glossary {
        use super::models;
        type Response = models::AtlasGlossary;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) atlas_glossary: models::AtlasGlossary,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.atlas_glossary)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossary = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_glossary_categories {
        use super::models;
        type Response = Vec<models::AtlasGlossaryCategory>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_category: Vec<models::AtlasGlossaryCategory>,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary/categories", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.glossary_category)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasGlossaryCategory> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_glossary_category {
        use super::models;
        type Response = models::AtlasGlossaryCategory;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_category: models::AtlasGlossaryCategory,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary/category", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.glossary_category)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryCategory = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_glossary_category {
        use super::models;
        type Response = models::AtlasGlossaryCategory;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) category_guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/category/{}",
                            this.client.endpoint(),
                            &this.category_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryCategory = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update_glossary_category {
        use super::models;
        type Response = models::AtlasGlossaryCategory;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) category_guid: String,
            pub(crate) glossary_category: models::AtlasGlossaryCategory,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/category/{}",
                            this.client.endpoint(),
                            &this.category_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.glossary_category)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryCategory = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_glossary_category {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) category_guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/category/{}",
                            this.client.endpoint(),
                            &this.category_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod partial_update_glossary_category {
        use super::models;
        type Response = models::AtlasGlossaryCategory;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) category_guid: String,
            pub(crate) partial_updates: serde_json::Value,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/category/{}/partial",
                            this.client.endpoint(),
                            &this.category_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.partial_updates)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryCategory = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_related_categories {
        use super::models;
        type Response = serde_json::Value;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) category_guid: String,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/category/{}/related",
                            this.client.endpoint(),
                            &this.category_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: serde_json::Value = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_category_terms {
        use super::models;
        type Response = Vec<models::AtlasRelatedTermHeader>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) category_guid: String,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/category/{}/terms",
                            this.client.endpoint(),
                            &this.category_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasRelatedTermHeader> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_glossary_term {
        use super::models;
        type Response = models::AtlasGlossaryTerm;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_term: models::AtlasGlossaryTerm,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary/term", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.glossary_term)?;
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryTerm = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_glossary_term {
        use super::models;
        type Response = models::AtlasGlossaryTerm;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/glossary/term/{}", this.client.endpoint(), &this.term_guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryTerm = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update_glossary_term {
        use super::models;
        type Response = models::AtlasGlossaryTerm;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
            pub(crate) glossary_term: models::AtlasGlossaryTerm,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/glossary/term/{}", this.client.endpoint(), &this.term_guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.glossary_term)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryTerm = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_glossary_term {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/glossary/term/{}", this.client.endpoint(), &this.term_guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod partial_update_glossary_term {
        use super::models;
        type Response = models::AtlasGlossaryTerm;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
            pub(crate) partial_updates: serde_json::Value,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/term/{}/partial",
                            this.client.endpoint(),
                            &this.term_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.partial_updates)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryTerm = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_glossary_terms {
        use super::models;
        type Response = Vec<models::AtlasGlossaryTerm>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_term: Vec<models::AtlasGlossaryTerm>,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary/terms", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.glossary_term)?;
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasGlossaryTerm> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_entities_assigned_with_term {
        use super::models;
        type Response = Vec<models::AtlasRelatedObjectId>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/terms/{}/assignedEntities",
                            this.client.endpoint(),
                            &this.term_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasRelatedObjectId> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod assign_term_to_entities {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
            pub(crate) related_object_ids: Vec<models::AtlasRelatedObjectId>,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/terms/{}/assignedEntities",
                            this.client.endpoint(),
                            &this.term_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.related_object_ids)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod remove_term_assignment_from_entities {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
            pub(crate) related_object_ids: Vec<models::AtlasRelatedObjectId>,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/terms/{}/assignedEntities",
                            this.client.endpoint(),
                            &this.term_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.related_object_ids)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_term_assignment_from_entities {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
            pub(crate) related_object_ids: Vec<models::AtlasRelatedObjectId>,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/terms/{}/assignedEntities",
                            this.client.endpoint(),
                            &this.term_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.related_object_ids)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_related_terms {
        use super::models;
        type Response = serde_json::Value;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) term_guid: String,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/terms/{}/related",
                            this.client.endpoint(),
                            &this.term_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: serde_json::Value = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_glossary {
        use super::models;
        type Response = models::AtlasGlossary;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary/{}", this.client.endpoint(), &this.glossary_guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossary = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update_glossary {
        use super::models;
        type Response = models::AtlasGlossary;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) updated_glossary: models::AtlasGlossary,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary/{}", this.client.endpoint(), &this.glossary_guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.updated_glossary)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossary = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_glossary {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/glossary/{}", this.client.endpoint(), &this.glossary_guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_glossary_categories {
        use super::models;
        type Response = Vec<models::AtlasGlossaryCategory>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/{}/categories",
                            this.client.endpoint(),
                            &this.glossary_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasGlossaryCategory> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_glossary_categories_headers {
        use super::models;
        type Response = Vec<models::AtlasRelatedCategoryHeader>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/{}/categories/headers",
                            this.client.endpoint(),
                            &this.glossary_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasRelatedCategoryHeader> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_detailed_glossary {
        use super::models;
        type Response = models::AtlasGlossaryExtInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/{}/detailed",
                            this.client.endpoint(),
                            &this.glossary_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossaryExtInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod partial_update_glossary {
        use super::models;
        type Response = models::AtlasGlossary;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) partial_updates: serde_json::Value,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/{}/partial",
                            this.client.endpoint(),
                            &this.glossary_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.partial_updates)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasGlossary = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_glossary_terms {
        use super::models;
        type Response = Vec<models::AtlasGlossaryTerm>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) include_term_hierarchy: Option<bool>,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/{}/terms",
                            this.client.endpoint(),
                            &this.glossary_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasGlossaryTerm> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_glossary_term_headers {
        use super::models;
        type Response = Vec<models::AtlasRelatedTermHeader>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) sort: Option<String>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn sort(mut self, sort: impl Into<String>) -> Self {
                self.sort = Some(sort.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/glossary/{}/terms/headers",
                            this.client.endpoint(),
                            &this.glossary_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(sort) = &this.sort {
                            req.url_mut().query_pairs_mut().append_pair("sort", sort);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasRelatedTermHeader> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod import_glossary_terms_via_csv {
        use super::models;
        type Response = models::ImportCsvOperation;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) file: bytes::Bytes,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            #[doc = "only the first response will be fetched as long running operations are not supported yet"]
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/glossary/{}/terms/import", this.client.endpoint(), &this.glossary_guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        unimplemented!("form data not yet supported");
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Accepted => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ImportCsvOperation = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod import_glossary_terms_via_csv_by_glossary_name {
        use super::models;
        type Response = models::ImportCsvOperation;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_name: String,
            pub(crate) file: bytes::Bytes,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            #[doc = "only the first response will be fetched as long running operations are not supported yet"]
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/glossary/name/{}/terms/import",
                            this.client.endpoint(),
                            &this.glossary_name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        unimplemented!("form data not yet supported");
                        let req_body = azure_core::EMPTY_BODY;
                        req.insert_header(azure_core::headers::CONTENT_LENGTH, "0");
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Accepted => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ImportCsvOperation = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_import_csv_operation_status {
        use super::models;
        type Response = models::ImportCsvOperation;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) operation_guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/glossary/terms/import/{}",
                            this.client.endpoint(),
                            &this.operation_guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::ImportCsvOperation = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod export_glossary_terms_as_csv {
        use super::models;
        type Response = bytes::Bytes;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_guid: String,
            pub(crate) term_guids: Vec<models::TermGuid>,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/glossary/{}/terms/export", this.client.endpoint(), &this.glossary_guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.term_guids)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value = rsp_body;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_terms_by_glossary_name {
        use super::models;
        type Response = Vec<models::AtlasGlossaryTerm>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) glossary_name: String,
            pub(crate) limit: Option<i32>,
            pub(crate) offset: Option<i32>,
            pub(crate) include_term_hierarchy: Option<bool>,
        }
        impl Builder {
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn include_term_hierarchy(mut self, include_term_hierarchy: bool) -> Self {
                self.include_term_hierarchy = Some(include_term_hierarchy);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/glossary/name/{}/terms", this.client.endpoint(), &this.glossary_name))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(include_term_hierarchy) = &this.include_term_hierarchy {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermHierarchy", &include_term_hierarchy.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasGlossaryTerm> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod discovery {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn query(&self, search_request: impl Into<models::SearchRequest>) -> query::Builder {
            query::Builder {
                client: self.0.clone(),
                search_request: search_request.into(),
            }
        }
        pub fn suggest(&self, suggest_request: impl Into<models::SuggestRequest>) -> suggest::Builder {
            suggest::Builder {
                client: self.0.clone(),
                suggest_request: suggest_request.into(),
            }
        }
        pub fn browse(&self, browse_request: impl Into<models::BrowseRequest>) -> browse::Builder {
            browse::Builder {
                client: self.0.clone(),
                browse_request: browse_request.into(),
            }
        }
        pub fn auto_complete(&self, auto_complete_request: impl Into<models::AutoCompleteRequest>) -> auto_complete::Builder {
            auto_complete::Builder {
                client: self.0.clone(),
                auto_complete_request: auto_complete_request.into(),
            }
        }
    }
    pub mod query {
        use super::models;
        type Response = models::SearchResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) search_request: models::SearchRequest,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/search/query", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.search_request)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::SearchResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod suggest {
        use super::models;
        type Response = models::SuggestResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) suggest_request: models::SuggestRequest,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/search/suggest", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.suggest_request)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::SuggestResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod browse {
        use super::models;
        type Response = models::BrowseResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) browse_request: models::BrowseRequest,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/browse", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.browse_request)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::BrowseResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod auto_complete {
        use super::models;
        type Response = models::AutoCompleteResult;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) auto_complete_request: models::AutoCompleteRequest,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/search/autocomplete", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.auto_complete_request)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AutoCompleteResult = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod lineage {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_lineage_graph(&self, guid: impl Into<String>, direction: impl Into<String>) -> get_lineage_graph::Builder {
            get_lineage_graph::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                direction: direction.into(),
                depth: None,
                width: None,
                include_parent: None,
                get_derived_lineage: None,
            }
        }
        pub fn next_page_lineage(&self, guid: impl Into<String>, direction: impl Into<String>) -> next_page_lineage::Builder {
            next_page_lineage::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                direction: direction.into(),
                get_derived_lineage: None,
                offset: None,
                limit: None,
            }
        }
    }
    pub mod get_lineage_graph {
        use super::models;
        type Response = models::AtlasLineageInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) direction: String,
            pub(crate) depth: Option<i32>,
            pub(crate) width: Option<i32>,
            pub(crate) include_parent: Option<bool>,
            pub(crate) get_derived_lineage: Option<bool>,
        }
        impl Builder {
            pub fn depth(mut self, depth: i32) -> Self {
                self.depth = Some(depth);
                self
            }
            pub fn width(mut self, width: i32) -> Self {
                self.width = Some(width);
                self
            }
            pub fn include_parent(mut self, include_parent: bool) -> Self {
                self.include_parent = Some(include_parent);
                self
            }
            pub fn get_derived_lineage(mut self, get_derived_lineage: bool) -> Self {
                self.get_derived_lineage = Some(get_derived_lineage);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/lineage/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(depth) = &this.depth {
                            req.url_mut().query_pairs_mut().append_pair("depth", &depth.to_string());
                        }
                        if let Some(width) = &this.width {
                            req.url_mut().query_pairs_mut().append_pair("width", &width.to_string());
                        }
                        let direction = &this.direction;
                        req.url_mut().query_pairs_mut().append_pair("direction", direction);
                        if let Some(include_parent) = &this.include_parent {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeParent", &include_parent.to_string());
                        }
                        if let Some(get_derived_lineage) = &this.get_derived_lineage {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("getDerivedLineage", &get_derived_lineage.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasLineageInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod next_page_lineage {
        use super::models;
        type Response = models::AtlasLineageInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) direction: String,
            pub(crate) get_derived_lineage: Option<bool>,
            pub(crate) offset: Option<i32>,
            pub(crate) limit: Option<i32>,
        }
        impl Builder {
            pub fn get_derived_lineage(mut self, get_derived_lineage: bool) -> Self {
                self.get_derived_lineage = Some(get_derived_lineage);
                self
            }
            pub fn offset(mut self, offset: i32) -> Self {
                self.offset = Some(offset);
                self
            }
            pub fn limit(mut self, limit: i32) -> Self {
                self.limit = Some(limit);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/lineage/{}/next/", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        let direction = &this.direction;
                        req.url_mut().query_pairs_mut().append_pair("direction", direction);
                        if let Some(get_derived_lineage) = &this.get_derived_lineage {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("getDerivedLineage", &get_derived_lineage.to_string());
                        }
                        if let Some(offset) = &this.offset {
                            req.url_mut().query_pairs_mut().append_pair("offset", &offset.to_string());
                        }
                        if let Some(limit) = &this.limit {
                            req.url_mut().query_pairs_mut().append_pair("limit", &limit.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasLineageInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod relationship {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn create(&self, relationship: impl Into<models::AtlasRelationship>) -> create::Builder {
            create::Builder {
                client: self.0.clone(),
                relationship: relationship.into(),
            }
        }
        pub fn update(&self, relationship: impl Into<models::AtlasRelationship>) -> update::Builder {
            update::Builder {
                client: self.0.clone(),
                relationship: relationship.into(),
            }
        }
        pub fn get(&self, guid: impl Into<String>) -> get::Builder {
            get::Builder {
                client: self.0.clone(),
                guid: guid.into(),
                extended_info: None,
            }
        }
        pub fn delete(&self, guid: impl Into<String>) -> delete::Builder {
            delete::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
    }
    pub mod create {
        use super::models;
        type Response = models::AtlasRelationship;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) relationship: models::AtlasRelationship,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/relationship", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.relationship)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasRelationship = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update {
        use super::models;
        type Response = models::AtlasRelationship;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) relationship: models::AtlasRelationship,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/relationship", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.relationship)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasRelationship = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get {
        use super::models;
        type Response = models::AtlasRelationshipWithExtInfo;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
            pub(crate) extended_info: Option<bool>,
        }
        impl Builder {
            pub fn extended_info(mut self, extended_info: bool) -> Self {
                self.extended_info = Some(extended_info);
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/relationship/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(extended_info) = &this.extended_info {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("extendedInfo", &extended_info.to_string());
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasRelationshipWithExtInfo = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/relationship/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod types {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn get_classification_def_by_guid(&self, guid: impl Into<String>) -> get_classification_def_by_guid::Builder {
            get_classification_def_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn get_classification_def_by_name(&self, name: impl Into<String>) -> get_classification_def_by_name::Builder {
            get_classification_def_by_name::Builder {
                client: self.0.clone(),
                name: name.into(),
            }
        }
        pub fn get_entity_definition_by_guid(&self, guid: impl Into<String>) -> get_entity_definition_by_guid::Builder {
            get_entity_definition_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn get_entity_definition_by_name(&self, name: impl Into<String>) -> get_entity_definition_by_name::Builder {
            get_entity_definition_by_name::Builder {
                client: self.0.clone(),
                name: name.into(),
            }
        }
        pub fn get_enum_def_by_guid(&self, guid: impl Into<String>) -> get_enum_def_by_guid::Builder {
            get_enum_def_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn get_enum_def_by_name(&self, name: impl Into<String>) -> get_enum_def_by_name::Builder {
            get_enum_def_by_name::Builder {
                client: self.0.clone(),
                name: name.into(),
            }
        }
        pub fn get_relationship_def_by_guid(&self, guid: impl Into<String>) -> get_relationship_def_by_guid::Builder {
            get_relationship_def_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn get_relationship_def_by_name(&self, name: impl Into<String>) -> get_relationship_def_by_name::Builder {
            get_relationship_def_by_name::Builder {
                client: self.0.clone(),
                name: name.into(),
            }
        }
        pub fn get_struct_def_by_guid(&self, guid: impl Into<String>) -> get_struct_def_by_guid::Builder {
            get_struct_def_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn get_struct_def_by_name(&self, name: impl Into<String>) -> get_struct_def_by_name::Builder {
            get_struct_def_by_name::Builder {
                client: self.0.clone(),
                name: name.into(),
            }
        }
        pub fn get_type_definition_by_guid(&self, guid: impl Into<String>) -> get_type_definition_by_guid::Builder {
            get_type_definition_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn get_type_definition_by_name(&self, name: impl Into<String>) -> get_type_definition_by_name::Builder {
            get_type_definition_by_name::Builder {
                client: self.0.clone(),
                name: name.into(),
            }
        }
        pub fn delete_type_by_name(&self, name: impl Into<String>) -> delete_type_by_name::Builder {
            delete_type_by_name::Builder {
                client: self.0.clone(),
                name: name.into(),
            }
        }
        pub fn get_all_type_definitions(&self) -> get_all_type_definitions::Builder {
            get_all_type_definitions::Builder {
                client: self.0.clone(),
                include_term_template: None,
                type_: None,
            }
        }
        pub fn create_type_definitions(&self, types_def: impl Into<models::AtlasTypesDef>) -> create_type_definitions::Builder {
            create_type_definitions::Builder {
                client: self.0.clone(),
                types_def: types_def.into(),
            }
        }
        pub fn update_atlas_type_definitions(&self, types_def: impl Into<models::AtlasTypesDef>) -> update_atlas_type_definitions::Builder {
            update_atlas_type_definitions::Builder {
                client: self.0.clone(),
                types_def: types_def.into(),
            }
        }
        pub fn delete_type_definitions(&self, types_def: impl Into<models::AtlasTypesDef>) -> delete_type_definitions::Builder {
            delete_type_definitions::Builder {
                client: self.0.clone(),
                types_def: types_def.into(),
            }
        }
        pub fn list_type_definition_headers(&self) -> list_type_definition_headers::Builder {
            list_type_definition_headers::Builder {
                client: self.0.clone(),
                include_term_template: None,
                type_: None,
            }
        }
        pub fn get_term_template_def_by_guid(&self, guid: impl Into<String>) -> get_term_template_def_by_guid::Builder {
            get_term_template_def_by_guid::Builder {
                client: self.0.clone(),
                guid: guid.into(),
            }
        }
        pub fn get_term_template_def_by_name(&self, name: impl Into<String>) -> get_term_template_def_by_name::Builder {
            get_term_template_def_by_name::Builder {
                client: self.0.clone(),
                name: name.into(),
            }
        }
    }
    pub mod get_classification_def_by_guid {
        use super::models;
        type Response = models::AtlasClassificationDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/types/classificationdef/guid/{}",
                            this.client.endpoint(),
                            &this.guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasClassificationDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_classification_def_by_name {
        use super::models;
        type Response = models::AtlasClassificationDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/types/classificationdef/name/{}",
                            this.client.endpoint(),
                            &this.name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasClassificationDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_entity_definition_by_guid {
        use super::models;
        type Response = models::AtlasEntityDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/entitydef/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEntityDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_entity_definition_by_name {
        use super::models;
        type Response = models::AtlasEntityDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/entitydef/name/{}", this.client.endpoint(), &this.name))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEntityDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_enum_def_by_guid {
        use super::models;
        type Response = models::AtlasEnumDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/enumdef/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEnumDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_enum_def_by_name {
        use super::models;
        type Response = models::AtlasEnumDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/enumdef/name/{}", this.client.endpoint(), &this.name))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasEnumDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_relationship_def_by_guid {
        use super::models;
        type Response = models::AtlasRelationshipDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/types/relationshipdef/guid/{}",
                            this.client.endpoint(),
                            &this.guid
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasRelationshipDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_relationship_def_by_name {
        use super::models;
        type Response = models::AtlasRelationshipDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/atlas/v2/types/relationshipdef/name/{}",
                            this.client.endpoint(),
                            &this.name
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasRelationshipDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_struct_def_by_guid {
        use super::models;
        type Response = models::AtlasStructDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/structdef/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasStructDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_struct_def_by_name {
        use super::models;
        type Response = models::AtlasStructDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/structdef/name/{}", this.client.endpoint(), &this.name))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasStructDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_type_definition_by_guid {
        use super::models;
        type Response = models::AtlasTypeDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/typedef/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasTypeDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_type_definition_by_name {
        use super::models;
        type Response = models::AtlasTypeDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/typedef/name/{}", this.client.endpoint(), &this.name))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasTypeDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_type_by_name {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/atlas/v2/types/typedef/name/{}", this.client.endpoint(), &this.name))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_all_type_definitions {
        use super::models;
        type Response = models::AtlasTypesDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) include_term_template: Option<bool>,
            pub(crate) type_: Option<String>,
        }
        impl Builder {
            pub fn include_term_template(mut self, include_term_template: bool) -> Self {
                self.include_term_template = Some(include_term_template);
                self
            }
            pub fn type_(mut self, type_: impl Into<String>) -> Self {
                self.type_ = Some(type_.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/types/typedefs", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(include_term_template) = &this.include_term_template {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermTemplate", &include_term_template.to_string());
                        }
                        if let Some(type_) = &this.type_ {
                            req.url_mut().query_pairs_mut().append_pair("type", type_);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasTypesDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_type_definitions {
        use super::models;
        type Response = models::AtlasTypesDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) types_def: models::AtlasTypesDef,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/types/typedefs", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.types_def)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasTypesDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod update_atlas_type_definitions {
        use super::models;
        type Response = models::AtlasTypesDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) types_def: models::AtlasTypesDef,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/types/typedefs", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Put);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.types_def)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::AtlasTypesDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod delete_type_definitions {
        use super::models;
        type Response = ();
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) types_def: models::AtlasTypesDef,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/types/typedefs", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Delete);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.types_def)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::NoContent => Ok(()),
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod list_type_definition_headers {
        use super::models;
        type Response = Vec<models::AtlasTypeDefHeader>;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) include_term_template: Option<bool>,
            pub(crate) type_: Option<String>,
        }
        impl Builder {
            pub fn include_term_template(mut self, include_term_template: bool) -> Self {
                self.include_term_template = Some(include_term_template);
                self
            }
            pub fn type_(mut self, type_: impl Into<String>) -> Self {
                self.type_ = Some(type_.into());
                self
            }
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/atlas/v2/types/typedefs/headers", this.client.endpoint(),))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        if let Some(include_term_template) = &this.include_term_template {
                            req.url_mut()
                                .query_pairs_mut()
                                .append_pair("includeTermTemplate", &include_term_template.to_string());
                        }
                        if let Some(type_) = &this.type_ {
                            req.url_mut().query_pairs_mut().append_pair("type", type_);
                        }
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: Vec<models::AtlasTypeDefHeader> = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_term_template_def_by_guid {
        use super::models;
        type Response = models::TermTemplateDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) guid: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/types/termtemplatedef/guid/{}", this.client.endpoint(), &this.guid))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::TermTemplateDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod get_term_template_def_by_name {
        use super::models;
        type Response = models::TermTemplateDef;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) name: String,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/types/termtemplatedef/name/{}", this.client.endpoint(), &this.name))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Get);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        let req_body = azure_core::EMPTY_BODY;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::TermTemplateDef = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
pub mod collection {
    use super::models;
    pub struct Client(pub(crate) super::Client);
    impl Client {
        pub fn create_or_update(
            &self,
            collection: impl Into<String>,
            entity: impl Into<models::AtlasEntityWithExtInfo>,
        ) -> create_or_update::Builder {
            create_or_update::Builder {
                client: self.0.clone(),
                collection: collection.into(),
                entity: entity.into(),
            }
        }
        pub fn create_or_update_bulk(
            &self,
            collection: impl Into<String>,
            entities: impl Into<models::AtlasEntitiesWithExtInfo>,
        ) -> create_or_update_bulk::Builder {
            create_or_update_bulk::Builder {
                client: self.0.clone(),
                collection: collection.into(),
                entities: entities.into(),
            }
        }
        pub fn move_entities_to_collection(
            &self,
            collection: impl Into<String>,
            move_entities_request: impl Into<models::MoveEntitiesRequest>,
        ) -> move_entities_to_collection::Builder {
            move_entities_to_collection::Builder {
                client: self.0.clone(),
                collection: collection.into(),
                move_entities_request: move_entities_request.into(),
            }
        }
    }
    pub mod create_or_update {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) collection: String,
            pub(crate) entity: models::AtlasEntityWithExtInfo,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!("{}/collections/{}/entity", this.client.endpoint(), &this.collection))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.entity)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod create_or_update_bulk {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) collection: String,
            pub(crate) entities: models::AtlasEntitiesWithExtInfo,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url =
                            azure_core::Url::parse(&format!("{}/collections/{}/entity/bulk", this.client.endpoint(), &this.collection))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.entities)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
    pub mod move_entities_to_collection {
        use super::models;
        type Response = models::EntityMutationResponse;
        #[derive(Clone)]
        pub struct Builder {
            pub(crate) client: super::super::Client,
            pub(crate) collection: String,
            pub(crate) move_entities_request: models::MoveEntitiesRequest,
        }
        impl Builder {
            pub fn into_future(self) -> futures::future::BoxFuture<'static, azure_core::Result<Response>> {
                Box::pin({
                    let this = self.clone();
                    async move {
                        let url = azure_core::Url::parse(&format!(
                            "{}/collections/{}/entity/moveHere",
                            this.client.endpoint(),
                            &this.collection
                        ))?;
                        let mut req = azure_core::Request::new(url, azure_core::Method::Post);
                        let credential = this.client.token_credential();
                        let token_response = credential.get_token(&this.client.scopes().join(" ")).await?;
                        req.insert_header(
                            azure_core::headers::AUTHORIZATION,
                            format!("Bearer {}", token_response.token.secret()),
                        );
                        req.url_mut()
                            .query_pairs_mut()
                            .append_pair(azure_core::query_param::API_VERSION, "2021-05-01-preview");
                        req.insert_header("content-type", "application/json");
                        let req_body = azure_core::to_json(&this.move_entities_request)?;
                        req.set_body(req_body);
                        let rsp = this.client.send(&mut req).await?;
                        let (rsp_status, rsp_headers, rsp_stream) = rsp.deconstruct();
                        match rsp_status {
                            azure_core::StatusCode::Ok => {
                                let rsp_body = azure_core::collect_pinned_stream(rsp_stream).await?;
                                let rsp_value: models::EntityMutationResponse = serde_json::from_slice(&rsp_body)?;
                                Ok(rsp_value)
                            }
                            status_code => Err(azure_core::error::Error::from(azure_core::error::ErrorKind::HttpResponse {
                                status: status_code,
                                error_code: None,
                            })),
                        }
                    }
                })
            }
        }
    }
}
