use std::{
    fs::File,
    io::{
        prelude::*,
        LineWriter,
    },
    path::Path,
};

pub type Result<T, E = Error> = std::result::Result<T, E>;
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("IoError")]
    IoError { source: std::io::Error },
}

pub fn create(crate_name: &str, feature_mod_names: &Vec<(String, String)>, path: &Path) -> Result<()> {
    let file = File::create(path).map_err(|source| Error::IoError { source })?;
    let mut file = LineWriter::new(file);
    let version = &env!("CARGO_PKG_VERSION");
    file.write_all(
        format!(
            r#"# generated by AutoRust {}
[package]
name = "{}"
version = "0.1.0"
edition = "2018"

[dependencies]
azure_core = {{ path = "../../../sdk/core", version = "0.1.0" }}
serde = {{ version = "1.0", features = ["derive"] }}
serde_json = "1.0"
reqwest = {{ version = "0.11", features = ["json"] }}
bytes = "1.0"
thiserror = "1.0"
http = "0.2"
url = "2.2"

[dev-dependencies]
azure_identity = {{ path = "../../../sdk/identity", version = "0.1.0" }}
tokio = {{ version = "1.0", features = ["macros"] }}

[features]
"#,
            version, crate_name
        )
        .as_bytes(),
    )
    .map_err(|source| Error::IoError { source })?;

    let default = get_default_feature(feature_mod_names);
    file.write_all(format!("default = [\"{}\"]\n", default).as_bytes())
        .map_err(|source| Error::IoError { source })?;

    for (feature_name, _mod_name) in feature_mod_names {
        file.write_all(format!("\"{}\" = []\n", feature_name).as_bytes())
            .map_err(|source| Error::IoError { source })?;
    }
    Ok(())
}

fn get_default_feature(feature_mod_names: &Vec<(String, String)>) -> String {
    let default = feature_mod_names
        .iter()
        .map(|(feature, _)| feature)
        .find(|feature| !feature.contains("preview"));
    match default {
        Some(default) => default.clone(),
        None => feature_mod_names[0].0.clone(),
    }
}
