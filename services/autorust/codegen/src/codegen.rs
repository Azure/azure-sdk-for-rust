use std::path::{
    Path,
    PathBuf,
};

use autorust_openapi::{
    DataType,
    ReferenceOr,
    Schema,
    SchemaCommon,
};
use heck::CamelCase;
use proc_macro2::TokenStream;
use quote::quote;
use serde_json::Value;

use crate::{
    identifier::ident,
    spec,
    Config,
    PropertyName,
    ResolvedSchema,
    Spec,
};

/// code generation context
pub struct CodeGen {
    config: Config,
    pub spec: Spec,
}

impl CodeGen {
    pub fn new(config: Config) -> Result<Self, Error> {
        let spec = Spec::read_files(&config.input_files).map_err(Error::Spec)?;
        Ok(Self { config, spec })
    }

    pub fn input_files(&self) -> &[PathBuf] {
        &self.config.input_files
    }

    pub fn output_folder(&self) -> &Path {
        &self.config.output_folder
    }

    pub fn api_version(&self) -> Option<&str> {
        self.config.api_version.as_deref()
    }

    pub fn should_box_property(&self, prop_nm: &PropertyName) -> bool {
        self.config.box_properties.contains(prop_nm)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("SpecError: {0}")]
    Spec(#[from] spec::Error),
    #[error("ArrayExpectedToHaveItems")]
    ArrayExpectedToHaveItems,
    #[error("NoNameForRef")]
    NoNameForRef,
    #[error("creating function name: {0}")]
    FunctionName(#[source] crate::identifier::Error),
    #[error("creating type name for schema ref: {0}")]
    TypeNameForSchemaRef(#[source] crate::identifier::Error),
    #[error("creating name for status code: {0}")]
    StatusCodeName(#[source] crate::identifier::Error),
    #[error("creating type name for response: {0}")]
    ResponseTypeName(#[source] crate::identifier::Error),
    #[error("creating name for param: {0}")]
    ParamName(#[source] crate::identifier::Error),
    #[error("creating name for property: {0}")]
    PropertyName(#[source] crate::identifier::Error),
    #[error("creating name for module: {0}")]
    ModuleName(#[source] crate::identifier::Error),
    #[error("creating name for enum: {0}")]
    EnumName(#[source] crate::identifier::Error),
    #[error("creating name for enum value: {0}")]
    EnumValueName(#[source] crate::identifier::Error),
    #[error("creating name for Vec alias: {0}")]
    VecAliasName(#[source] crate::identifier::Error),
    #[error("creating name for struct: {0}")]
    StructName(#[source] crate::identifier::Error),
    #[error("creating name for field in struct: {0}")]
    StructFieldName(#[source] crate::identifier::Error),
    #[error("api-version is missing")]
    MissingApiVersion,
}

/// Whether or not to pass a type is a reference.
#[derive(Copy, Clone)]
pub enum AsReference {
    True,
    False,
}

pub fn is_vec(ts: &TokenStream) -> bool {
    ts.to_string().starts_with("Vec <")
}

pub fn is_array(schema: &SchemaCommon) -> bool {
    matches!(schema.type_, Some(DataType::Array))
}

pub fn is_string(schema: &SchemaCommon) -> bool {
    matches!(schema.type_, Some(DataType::String))
}

pub fn get_schema_array_items(schema: &SchemaCommon) -> Result<&ReferenceOr<Schema>, Error> {
    Ok(schema.items.as_ref().as_ref().ok_or_else(|| Error::ArrayExpectedToHaveItems)?)
}

/// A header placed at the top the file to say that it is generated by AutoRust.
pub fn create_generated_by_header() -> TokenStream {
    let version = env!("CARGO_PKG_VERSION");
    let comment = format!("generated by AutoRust {}", &version);
    quote! { #![doc = #comment] }
}

pub fn is_local_enum(property: &ResolvedSchema) -> bool {
    property.schema.common.enum_.len() > 0
}

pub fn is_local_struct(property: &ResolvedSchema) -> bool {
    property.schema.properties.len() > 0
}

/// Wraps a type in an Option if is not required.
pub fn require(is_required: bool, tp: TokenStream) -> TokenStream {
    if is_required {
        tp
    } else {
        quote! { Option<#tp> }
    }
}

pub fn enum_values_as_strings(values: &Vec<Value>) -> Vec<&str> {
    values
        .iter()
        .filter_map(|v| match v {
            Value::String(s) => Some(s.as_str()),
            _ => None,
        })
        .collect()
}

pub fn get_type_name_for_schema(schema: &SchemaCommon, as_ref: AsReference) -> Result<TokenStream, Error> {
    if let Some(schema_type) = &schema.type_ {
        let format = schema.format.as_deref();
        let ts = match schema_type {
            DataType::Array => {
                let items = get_schema_array_items(&schema)?;
                let vec_items_typ = get_type_name_for_schema_ref(&items, as_ref)?;
                match as_ref {
                    AsReference::True => quote! { &Vec<#vec_items_typ> },
                    AsReference::False => quote! { Vec<#vec_items_typ> },
                }
            }
            DataType::Integer => {
                if format == Some("int32") {
                    quote! { i32 }
                } else {
                    quote! { i64 }
                }
            }
            DataType::Number => {
                if format == Some("float") {
                    quote! { f32 }
                } else {
                    quote! { f64 }
                }
            }
            DataType::String => match as_ref {
                AsReference::True => quote! { &str },
                AsReference::False => quote! { String },
            },
            DataType::Boolean => quote! { bool },
            DataType::Object => match as_ref {
                AsReference::True => quote! { &serde_json::Value },
                AsReference::False => quote! { serde_json::Value },
            },
            DataType::File => todo!("Handle DataType::File"),
        };
        Ok(ts)
    } else {
        // eprintln!(
        //     "WARN unknown type in get_type_name_for_schema, description {:?}",
        //     schema.description
        // );
        match as_ref {
            AsReference::True => Ok(quote! { &serde_json::Value }),
            AsReference::False => Ok(quote! { serde_json::Value }),
        }
    }
}

pub fn get_type_name_for_schema_ref(schema: &ReferenceOr<Schema>, as_ref: AsReference) -> Result<TokenStream, Error> {
    match schema {
        ReferenceOr::Reference { reference, .. } => {
            let name = &reference.name.as_ref().ok_or_else(|| Error::NoNameForRef)?;
            let idt = ident(&name.to_camel_case()).map_err(Error::TypeNameForSchemaRef)?;
            match as_ref {
                AsReference::True => Ok(quote! { &#idt }),
                AsReference::False => Ok(quote! { #idt }),
            }
        }
        ReferenceOr::Item(schema) => get_type_name_for_schema(&schema.common, as_ref),
    }
}

pub fn create_mod(api_version: &str) -> TokenStream {
    quote! {
        pub mod models;
        pub mod operations;
        pub const API_VERSION: &str = #api_version;
    }
}
